Changes since Pike 7.4:
----------------------------------------------------------------------

New/improved functionality:
---------------------------

o The automatic garbage collection strategy is configurable
    The garbage collector can be configured to take both the amount of
    garbage and the cpu time spent in the gc into account. Automatic
    gc runs can also be disabled in critical regions. See the function
    Pike.gc_parameters.

o sort() is stable
    Unlike previous releases, sort() will keep the original order
    between elements that are equal. This was not implemented as a
    separate function since it could be done with virtually no extra
    overhead.

o sort() is portable
    Sort is now locale and platform independent. In other words,
    strings are now compared only according to the unicode value of
    every character.

o Reworked codec
    The codec for serialization of Pike data types has been updated
    and has a significally improved successrate at encoding modules.

o Less magic hacks
    Several Pike modules have been cleaned up from old hacks and
    workarounds for problems which now have proper solutions. This
    should improve size, performance, dumpability and readability
    of the affected code. In addition lots of internal types in Pike
    have been tightened up and several more files now use the pragma
    strict_types, which has resulted in some additional bugfixes.

o INT64
    On 64 bit architechtures Pike will now use full 64 bits integer
    before resorting to Gmp.mpz objects for large numbers.

o IPv6
    Networking code in Pike has been updated to work with IPv6. This
    includes both low level fixes in the socket handling as well as
    high level changes such as IP parsing and protocol additions such
    as AAAA records in Protocol.DNS.

o mysqls
    The Mysql glue can operate over SSL. Use the "mysqls://" protocol
    in the Sql.Sql module to use this secuity feature.

o trace() can trace all threads
    The configure option --without-thread-trace has been removed, but
    instead the trace() function has been extended to make it possible
    to set the trace level in all threads simultaneously.

o --help
    The Pike --help message has been improved and it is possible to
    retrieve further information about options and environment
    variables. In addition most of the tools and build scripts now
    accepts --help and describes what they do and what options they
    take.

o unbug
    The Pike debugger unbug has been significtly optimized.

o Module system.
    Both dynamic and static modules appears as objects and they both
    support having an identifier _module_value, which will then be
    what is presented by the resolver as the module. _module_value can
    be a constant, thus preventing the program from being
    automatically cloned.


The Pike master:
----------------

o The new option --dumpversion prints out the Pike version in a more
  easily pared way than --version.

o The master now supplies argv to the started application, so it can
  use the create method for execution. Some people find it a more
  elegant solution than having a main function.

o The -e Pike environment has been improved with a lot of convenience
  wrappings. When compiling code with pike -e the macro NOT(X) will
  expand to !(X) and CHAR(X) to 'X', making it easier to solve quote
  problems from a shell. If the return from a pike -e statement is a
  positive integer it will be used as pikes exit code. If the return
  value is a string it will be outputed, with a "\n" added, if it
  lacked one. Finally there is a predefined variable env that contains
  the environment variables as a string:string mapping.


Building and installing pike:
-----------------------------

o To simplify the process of building Pike source distributions it is
  now possible to bundle less common libraries such as Nettle with
  Pike. The bundle, found in the bundle directory, will be compiled
  and statically linked if the no matching library is found on the
  system.

o The Pike build process no longer builds a bootstrap pike, used to
  run various small programs to generate source files. This means that
  in order to build Pike from CVS you need the latest major version of
  Pike installed on your system. Pike source distributions contains
  the generated files and is not affected (except it compiles in less
  time).

o By default pike want you to build a documentation source file, i.e.
  "make && make doc && make install". This makes it possible for third
  party modules to integrate its documentation into the system Pike
  documentation. If you do not want to build a documentation source
  file, use "make install_nodoc" instead of "make install".


Language additions:
-------------------

Changes and additions to -x utilities:
--------------------------------------

o rsif
    rsif can now work recursively in a file structure if given the
    flag -r or --recursive. Example:
      pike -x rsif -r 7.4 7.6

o benchmark
    A set of benchmarks is available in the benchmark tool. They are
    based on the Great Computer Language Shootout, but has been
    modified to make more sense in the context of Pike and to test
    various aspects of Pike we suspect (or at least at one time
    suspected) performs badly.

o cgrep
    Context sensitive grep is very helpful when you are looking for
    substrings that are common. The implemented search modes are:
      o Complete token
      o Part of a token
      o Complete string literal
      o Part of a string literal
      o Part of a comment

    Example:
      $ cd Pike/7.6/src
      $ grep or * | wc -l
      18907
      $ pike -x cgrep -T or * | wc -l
      14

o dump
    Dumps Pike .pike and .pmod module files to precompiled .o files
    for shorter load times. Previously available as
    src/dumpmodule.pike in the Pike source tree, but moved into the
    Pike builtin tools to facilitate dumping of external modules.

o extract_locale
    Locale extractor utility used to extract localizable strings from
    an application into an xml format, to later be used by the Locale
    module.

o monger
    A new utility to download, install and otherwise manage external
    modules from the Fresh Pike project.


New modules / classes / methods added:
--------------------------------------

o Regexp.PCRE added to give libpcre support.
    Are you a closet-perlet? For those who missed the richer flora of
    regexp syntax that Perl supports, the Perl Compatible Regular
    Expression module is the answer. If you compile libpcre with UTF-8
    support you will also get transparent wide string support. Several
    convenience functions are also added to the Regexp module to
    enable easier access to regular expressions.

o Crypto/Nettle
    The crypto module has been almost completely rewritten and now
    uses libnettle as backend instead of the built in crypto
    algorithms that Pike had before. This way Pike will benefit from
    the more active development and optimization work in the Nettle
    project. The most common hash and cipher methods are already
    written in assembler for several platforms. As an example SHA1 is
    about 40% faster than before on Intel platforms.

    With the new nettle support comes support for two new cipher
    algorithms, Blowfish and Serpent, and the new NIST hash algorithm
    SHA256. Note that the new Crypto module has renamed its
    identifiers to be consistent with the rest of Pike, and in some
    cases to clarify or correct bad names. The old names still work,
    but produce a warning unless Pike is run in compatibility mode.
    Compatibility outside compatibility mode will be removed in the
    future.

    The interfaces for the hash and cipher algorithms has been
    improved and they no longer only conform to predefined interfaces,
    but actually inherits Hash/HashState and Cipher/CipherState. Every
    algorithm is in itself a module in the Crypto module, and inherits
    the Hash/Cipher class. This module contains instance non-specific
    methods such as digest_size or key_size. By calling the `() method
    in the module a HashState/CipherState object is returned, which is
    a hash/cipher instance which can be used for streaming operations.

    Examples:

      Crypto.MD5.hash("Hash this string");

      Crypto.MD5()->update("Hash this ")->update("string")->digest();

    The confusing and hard to use Crypto.randomness has been obsoleted
    by the Nettle implementation of the Yarrow random generator. The
    Nettle implementation of Yarrow uses AES and SHA256. The
    Crypto.Random module acts as a frontend before system crypto
    sources and ensure that no matter how bad your OS is, you will
    still get cryptographically strong random data.


o Crypto.PGP
    The start of a PGP/GPG toolkit. It still cannot handle all types
    of signatures nor generate any, but it is useful to verify
    selfsigned code and data.


o ADT.Struct
    This module makes it possible to work with binary formats of the
    packed-struct-type. Simply create a class and specify the members
    in order, create an object with a file object as argument and then
    read the decoded values from the object as ordinary variables.

      class ID3 {
        inherit ADT.Struct;
        Item head = Chars(3);
        Item title = Chars(30);
        Item artist = Chars(30);
        Item album = Chars(30);
        Item year = Chars(4);
        Item comment = Chars(30);
        Item genre = Byte();
      }

      Stdio.File f = Stdio.File("foo.mp3");
      f->seek(-128);
      ADT.Struct tag = ID3(f);
      if(tag->head=="TAG") {
        write("Title: %s\n", tag->title);
        tag->title = "A new title" + "\0"*19;
        f->seek(-128);
        f->write( (string)tag );
      }


o ADT.BitBuffer
    When operating on data formats that are defined on bit level, the
    ADT.BitBuffer presents a convenient interface. It operates as a
    FIFO buffer on bit level, which allows you to read and write bits
    and bytes.

      > ADT.BitBuffer b=ADT.BitBuffer();
      > b->put1(2);
      (1) Result: ADT.BitBuffer(11)
      > b->put0(15);
      (2) Result: ADT.BitBuffer("À\0"0)
      > b->drain();
      (3) Result: "À\0"
      > sizeof(b);
      (4) Result: 1


o Debug.Wrapper
    A simple litte wrapper that can be placed around another object to
    get printouts about what is happening to it. Only a few LFUNs are
    currently supported.

      > object x=Debug.Wrapper(Crypto.MD5());
      Debug.Wrapper is proxying ___Nettle.MD5_State()
      > x->name();
      ___Nettle.MD5_State()->name
      (1) Result: "md5"
      > !x;
      !___Nettle.MD5_State()
      (2) Result: 0


o Image.NEO
    Support for one of the major image formats on Atari ST/STE,
    including decoding of color cycling. The C bitmap and palette
    handler can be used to implement other atari image formats.

o GLUE
    The GL Universal Environment is a GL toolkit that makes
    implementing GL applications in Pike really simple. GLUE has
    several orthogonal components like object orientation
    encapsulation of Gl, drawing primitives, texture handling and text
    generation. The most fundamental part is however an abstract
    interface to a GL area driver, like GTK or SDL.

      int main() {
        GLUE.init();
        draw_frame();
        return -1;
      }
      
      void draw_frame() {
        call_out(draw_frame, 0.02); // 1/(50 fps)
        do_gl_code();
        GLUE.swap_buffers();
      }


o _ADT
o Geography RT38

o Int
    The Int module contains a few functions and constants that deals
    specifically with the integer data type. Currently it contains
    parity and byte swapping functions and constants for the system
    maxint and minint.

o Pike.Security
    Functions and classes that deals with the Pike security system
    (requires Pike to be compiled with --with-security to be present)
    are stored in this module. Beware that the Pike security system is
    still very experimental.

o Protocols.HTTP.Session
    Handles an HTTP connection as a session, with cookies, redirects,
    HTTP keep-alive etc.

o Bz2
    Support for the compression format used by the bzip2 program. The
    module interface is almost identical with the Gz module, so
    changing between Bz2 and Gz is just a matter of a few characters
    difference.

o Process.Process
    The Process.Process class is extended to handle a time out
    callback and a read callback, to better manage processes in an
    asunchronous way.

o Error
    The beginning of the Pike exception hiearchy. Even though it is
    work in progress, it is already usable.

      > mixed err = catch( 1/0 );
      > err;
      (1) Result: Error.Math("Division by zero.\n")
      > object_program(err)==Error.Math;
      (2) Result: 1

o Float
    Here constants and functions that deals specifically with the
    float data type is stored. Currently contains only various
    constants that describe the precision and limitations of the float
    type Pike is compiled with.

o Protocols.Bittorrent

o Protocols.LMTP/Protocols.SMTP
    Protocols.LMTP Implements a server for the Local Mail Transfer
    Protocol, LMTP, as specified in RFC2033. This module has been well
    tested against Postfix clients. Protocols.LMTP is based on a new
    server implementation in Protocols.SMTP.

o Protocols.OBEX
    An implementation of the IrDA(R) Object Exchange Protocol. OBEX is
    a protocol for sending and receiving binary objects to mobile
    devices using transports such as IR and Bluetooth.

o Web.RDF/RDFS/OWL/RSS
    Pike now has support for the W3C semantic web formats OWL, RDF
    and RDFS, which are used for expressing structure and metadata
    information. There is also some support for the syndication
    format RSS (which happens to be a simple application of RDF).

    This sample program reads an OWL file, parses the dataset
    contained in it, and then lists the data classes in that
    dataset:

      int main(int argc, array argv)
      {
        object owlset = Web.OWL();
        string input = Stdio.read_file(argv[1]);
        owlset->parse_owl(input);

        write("Classes:\n");

        foreach(owlset->find_statements(0,
                                        owlset->rdf_type,
                                        owlset->owl_Class);
                               array statement)
          write("- %O\n", statement[0]);

       return 0;
     }  
 
o Array
    The Array module has been extended with Array.all and Array.any
    which determines if all or any of the elements in an array meets a
    given condition. Also the function Array.partition has been added,
    which divides the elements of an array into two arrays, selected
    by a given condition.

o Function
    The Function module has been extended with the fixpoint combinator
    "Y", useful when writing recursive lambdas, a curry function, to
    partially evaluate a function call, and a callback caller function
    that protects the caller from exceptions in the callback function.

o Thread
    Thread.Fifo and Thread.Queue has been extended with try_*
    varieties of all functions that can block and with functions that
    makes them both implement the same interface. Both also have
    fallbacks for running in nonthreaded mode.

o Filesystem.Traversion
    The Filesystem.Traversion iterator is a handy way to descend into
    a directory structure (depth first) and perform actions on all or
    some of the files.

    Example:

      foreach(Filesystem.Traversion("."); string dir; string file)
        if(file[-1]=='~' || file=="core") rm(dir+file);

o Calendar module
    The %S format is added to Calendar.parse() to parse seconds since
    the Epoch. The TimeRange class is extended with a format method
    format_commonlog(), a tzname_utc_offset (+HHMM) and
    tzname_location(), which, when available, returns zone names like
    "Europe/Stockholm". The database has been updated with Swedish
    pre-1901 namedays and Finnish namedays.

o SSL

o Sql.Provider

o EXIF
    The EXIF module is now much more robust than before and can handle
    some of the erroneous EXIF tags some cameras procduce. Extended
    support for Nikon cameras.

o Standards.IDNA
    This module implements various algorithms specified by the
    Internationalizing Domain Names in Applications (IDNA) memo by the
    Internet Engineering Task Force (IETF), RFC 3490.

Optimizations:
--------------

o Instantiation and destruction of pike-classes is now significantly faster.

o Handling of bignums has been optimized, especially conversion
  to/from normal integers.

o String case conversion is now five times faster than before on
  average.


Compatibility changes:
----------------------

Compatibility changes without backward compatibility:
-----------------------------------------------------

o Module ABI changed
  The pike_frame struct has a new member, which makes modules compiled
  with earlier versions of Pike incompatible.


C level/development changes:
----------------------------

o The security.h include file is renamed to pike_security.h
o cond_resolv, test_program_eq, test_program_equal, no warnings in testsuite,
o pmod: object(programname), void may be 0, typecheck of vararg/optional,
  inherit, PIKEVAR attributes, prototypes, program flags

Bugs fixed:
-----------


Uncategorized misc changes:
---------------------------

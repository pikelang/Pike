Changes since Pike 7.2:
----------------------------------------------------------------------

New/improved functionality:
---------------------------

o New Hilfe
    The interactive pike environment you get when running pike without
    giving a program name, has been thoroughly rewritten. Most notably
    it now supports more of the common pike constructs, and is more
    extendable and configurable. Start it and type help for more info.

o AutoDoc
    The major parts of Pike now has some sort of documentation on
    class and function level thanks to the AutoDoc system which has
    been deployed during the last year. Manual dumps are published on
    http://pike.ida.liu.se/docs/reference/.

o pike -x
    When starting pike with the -x parameter, the pike process will
    run the named script in Tools.Standalone, giving the rest of the
    arguments as command-line switches. This is a convenient way of
    running rsif (replace string in file) and pv (the image viewer
    you may be familiar with from Tools.PV).

o unbug
    Embryo of a Pike debugger. Not stable nor finished.

o Unicode 3.2.0
    All charts have been updated to Unicode 3.2.0. This applies both to
    the Unicode module as well as to Pike-global functionality such as
    upper_case/lower_case. unicode_to_string() also has support for
    surrogate and byteorder make handling.

o Extended random()
    random() now works on floats, arrays, multisets, mappings and
    objects in addition to integers.

o delay()/sleep()
    sleep() no longer busywaits, which it previously did for small
    values. The old behavior is available from the delay() function.

o search(string, int) / has_value(string, int)
    Both of these methods now handle both looking for strings and
    integers (the unicode number for a single character).
    Examples: search("hi, ho!", '!'), has_value("Nope.", ' ')

o Expanded Charset module
    The character set module now has support for the character sets
    Shift_JS, UTF-7.5, EUC, Big5, CP950, UTF-16, UTF-16BE, UTF-16LE.
    It is now also easier to get the right charset codec since the
    names are normalized internally.


Language additions:
-------------------

o foreach(X; Y; Z)
    The foreach statement has been extended to allow iterations over
    mappings, multisets and any object that implements the iterator
    interface (see below). To make it possible to use this
    conveniently, a new syntax has been added to get both the index
    and the value in each iteration:

        foreach (something; index-expr; value-expr) ...

    This iterates over something, assigning in turn each index to
    index-expr and each value to value-expr. The index and value
    expressions can be declarations or lvalues, and they can also be
    left out if the index and/or value part isn't interesting.

    Note that it depends on the data type whether the iteration order
    is well defined or not; arrays and multisets are iterated over
    starting with the first element while mappings are visited in some
    arbitrary order (each element is still visited only once, though).

o Iterators
    As noted above, an iterator interface has been added that is now
    used in various places to iterate over different data structures.
    Not only the built-in data types are supported, but actually any
    object that fulfills the interface for iterators:

    When iterating over an object o, o->_get_iterator() is called to
    get an iterator object. An iterator object should at least have
    two functions, index() and value(), to get the index and value
    at the current position, a function `+=(int steps) to advance the
    current position the specified number of steps, and a `!() that
    returns zero if the end of the data set hasn't been reached yet.

    Also, if the object o lacks a _get_iterator function, it's assumed
    to be an iterator itself. This makes it possible to pass an
    iterator explicitly to e.g. the foreach statement.

    The built-in data types also have iterator classes with this
    interface. They are found as Array.Iterator, Mapping.Iterator, etc
    and can be used to iterate over these data types in some custom
    fashion. This is especially useful for mappings and multisets,
    which cannot be iterated over directly in any other way. For
    example, to get some arbitrary index in a mapping m:

        mixed any_index = Mapping.Iterator(m)->index();

o Automap
    To perform per-element operations on arrays, there is now a convenience
    syntax for map(), that can make code more readable in some situations.
    Summing up two arrays element by element using automap looks like this:

        a[*] + b[*]; // the result has as many elements as the shortest array.

    Multiplying all elements in a by a constant:

        a[*] * 4711;

    Make an array of what sprintf("%O", a[n]) returns for all elements in a:

        sprintf("%O", a[*]);

o Implicit lambda
    A convenient way to embed code that needs pre- and/or post-
    initialization. If a statement starts with a function call
    followed directly by a brace block, then the block is transformed
    to a lambda function which is passed as the last argument to the
    function being called.

    The following example embeds OpenGL calls that modifies the matrix
    in an implicit lambda that will save the matrix before execution
    and restore it afterwards:

       void PushPop( function f )
       {
         glPushMatrix();
         mixed err = catch(f());
         glPopMatrix();
         if (err) throw(err);
       }

       void do_something()
       {
         PushPop() {
           glTranslate( ((1.0-0.08))/2, 0.0, 0.0 );
           draw_stuff();
         };
       }

    Note that although useful, this feature has important
    disadvantages and will probably be obsoleted by a better
    alternative in the future. The problem is that the inner brace
    block become a completely separate function instead of remaining a
    block. The difference (apart from being slower) is shown by this
    example:

       void do_something()
       {
         PushPop() {
           if (glError()) return;
           glTranslate( (1.0-0.08)/2, 0.0, 0.0 );
           draw_stuff();
         };
         draw_more_stuff();
       }

    Since the inner block is a separate function, the return statement
    doesn't exit do_something() as one might expect, causing
    draw_more_stuff() to be called even when there's a GL error.
    Another effect is that break and continue can't be associated with
    statements outside the implicit lambda block.

    Another method that overcomes these problems will likely be
    implemented. The problem is that it can give compatibility
    problems to change old code that uses implicit lambdas to that
    one, since e.g. return will work differently without giving any
    sort of error.

o Access to hidden variables in surrounding scopes
    Include the names of the surrounding classes themselves in the lookup for
    Foo::, to make it possible to address hidden variables in the scopes of
    surrounding classes, e.g:

       class Foo {
         int i;
         void create (int i) {Foo::i = i;}
       }

o global::
    Added new keyword global to be able to access identifiers on the
    top level of the compilation unit using global::foo.

o global.
    All top level modules (and other identifiers in that scope) can now
    be accessed with a "global." prefix. This is useful in cases where
    local identifiers overshadow the top level, for instance in the Image
    module, where the Image.Image class would occasionally block your view.

o this
    Added a magic identifier "this" that can be used instead of
    this_object(). Like this_program, it only exists when there's no
    other identifier with that name. The primary reason for adding
    this magic identifier is to make it possible to address the object
    of a surrounding class with Foo::this.

o The Local module
    All Pike modules and classes found in the directory hierarchies
    /usr/local/pike_modules, /opt/pike_modules, /opt/share/pike_modules,
    /usr/local/share/pike_modules, $HOME/pike_modules, and
    $PIKE_LOCAL_PATH (a :-separated list of directories) are available
    with the prefix "Local.". Local.add_path() and Local.remove_path()
    respectively adds and removes entries from the list of paths to
    inspect when resolving Local.* symbols.

o The program type can be specialized
    It's possible to specialize a program variable by adding a program
    identifier, much like an object variable can be specialized. E.g:

       program(Stdio.File) fd = Stdio.File;

o ::_indices(), ::_values().
    There are now two "magic" functions ::_indices() and ::_values()
    that can be used by an object to list all identifiers and their
    values in itself. They are primarily intended when the _indices()
    and _values() lfuns have been defined, to get the default
    implementations. This is to complement the "magic" ::`->() and
    ::`->=() functions that exist in earlier releases.

o UNDEFINED
    To generate a 0 (zero) with a zero_type(var) == 1, you previously
    had to use constructs like ([])[0]. This is now available as the
    globally available symbol UNDEFINED.

o _m_delete
    A class can now define a function mixed _m_delete(mixed index) to
    make the objects work like mappings with m_delete(). (This feature
    has been added to later 7.2 releases too.)

o sprintf("%O", foo) is more descriptive
    If foo is a program or an object then Pike will try to find the
    resolved name instead of returning just "program" or "object".
    However, if an object contains an _sprintf function it will still
    be called in this case.


New modules / classes / methods / functionality added:
------------------------------------------------------

o ADT.History
    ADT implementation of a "leaking stack". Hilfe example:
      > object h=ADT.History(3);
      > for(int i=17; i<22; i++) h->push(i);
      Ok.
      > h->get_first_entry_num();
      (1) Result: 3
      > h[3];
      (2) Result: 19

o ADT.Relation.Binary
    Handles binary relations. Hilfe example:
      > object r=ADT.Relation.Binary("test");
      > r->add(1,2)->add(2,3)->add(3,5)->add(1,4)->add(4,5);
      (1) Result: ADT.Relation.Binary("test")
      > r->find_shortest_path(1,5);
      (2) Result: ({ /* 3 elements */
                      1,
                      4,
                      5
                  })
      > r->remove(1,4);
      (3) Result: ADT.Relation.Binary("test")
      > r->add(5,1);
      (4) Result: ADT.Relation.Binary("test")
      > r->find_shortest_path(1,5);
      (5) Result: ({ /* 4 elements */
                      1,
                      2,
                      3,
                      5
                  })

o Audio.Codec and Audio.Codec
    Contains decoders and encoders for audio. Currently WAV and MP3.
    Note: The API remains marked "unstable".


o Crypto.md4
    Hash used for NT Lanmanager passwords.

o Crypto.crypt_md5
    Convenience function to produce crypted $1$ style crypted
    passwords (commonly called MD5 passwords).

o Debug.Tracer
o Debug.Subject
    Helper classes that helps in understanding what Pike is doing.

o Locale.Language
    FIXME: nilsson?

o Math.Matrix
    Methods sum(), max(), min(), convolve() and dot_product() added.
    
o Math.Transforms
    Glue for supporting FFT and iFFT via libfftw and librfftw.

o Math
    Added inf and nan constants.

o MIME.Message
    Guess mode added. *FIXME: expand on this*

o Parser.Python
    Splits Python source code into text tokens.

o Parser.RCS
    Extracts data from RCS or CVS repositories.

o HTTP.Server
    A simple HTTP Server.

o Protocols.X.KeySyms
o Standards.CIFF
o Standards.FIPS10_4
    FIXME: remove?

o Standards.ID3
    ID3 tags decoder/encoder. Supports versions: 1.0, 1.1,
    2.2-2.4. Frequently used in MP3 files for encapsulating metadata.

o Standards.RDF
    FIXME: nilsson?

o System.Time
    Used to get the current time with sub second precision.

o System.Timer
    Measures the time between two calls.

o System.Memory 
   Handles read/write from mmap'ed or allocated memory.

system.normalize_path
system.gettimeofday
system.get_netinfo_property (Max OS X)
system.usleep/nanosleep
   FIXME: per?

o Stdio.FakeFile
    Wraps a string and exports a Stdio.File interface.

o Stdio.File->grantpt()
    can now allocate a VTY on systems with /dev/ptmx support.

    Minimal example:
      fd = Stdio.File("/dev/ptmx", "rw" );
      Stdio.File fd2 = Stdio.File( fd->grantpt(), "rw" );
      Process.create_process( ({ "/bin/bash" }), ([
        "stdin":fd2,  "stdout":fd2, "stderr":fd2, "setsid":fd2, 
      ]) );

o Stdio
    Moved get_all_active_fd() from spider to Stdio.
    Added methods to Stdio.File: sync(), line_iterator()

o Gz.File
    Pike can now compress and decompress the Gzip format. This is
    still a bit experimental but the basic functions should work 
    just fine.

o Stdio.expand_symlinks(string path)
    Expands all symlinks along a path (returns 0 for broken links).
    (Only available on systems with readlink.)

o Tools.PV
    Convenience tool that sets up a canvas with GTK, presents a
    picture on it and delivers a number of image inspection and
    manipulation options. This is a great tool for image work in
    Hilfe.

      > object i=Image.Image(32,32)->random();
      > Tools.PV(i);

    The Pike Viewer tool is also accessible via "pike -x pv".

o Image.Dims
    Can extract the dimensions of an image with a minimal amount of
    data loading. Currently handles JPEG, GIF and PNG images. Hilfe
    example:
      > Image.Dims.get(Stdio.File("test.gif"));
      (1) Result: ({ /* 2 elements */
                      1412,
                      1120
                  })

o Image.Fonts
    High level API for font handling. Should be used instead of
    accessing the FreeType, TTF and Image.Font modules directly.

o Image.DWG
    Decodes AutoCAD thumbnail images.

o Image.JPEG
    Support for lossless transforms and handling of metadata.

o Image.SVG
    Support for Structured Vector Graphics through the Gnome SVG
    library. Requires Gnome 2.

o Image.Image 
    Added two new methods: blur() and grey_blur().

o Image.PVR
    VQ compression/decompression added.

o Shuffler

o Gmp.mpq and Gmp.mpf
    Multi precision fractions.

o String.SplitIterator
    FIXME: grubba

o String.Replace, String.SingleReplace
    FIXME

o SDL
    Wrapper for a subset of Simple DirectMedia Layer
    functionality. Useful for writing games, movie players and other
    graphically intensive applications.

o XML.NSTree
    FIXME: Nilsson?

o Oracle
     CLOB and BLOB support.

o Return value from catch blocks.
    The return value from catch blocks that exit normally has been
    changed from a normal zero (i.e. zero_type 0) to UNDEFINED (i.e.
    zero_type 1).


Optimizations:
--------------

o Machine code used on some architectures.

o Computed goto

o Better module dumping

o Overall speed improvements.
    Function calls (new opcodes)
    sprintf
    arrays
    replace

o Deferred backtraces.

o Saved 8 bytes per object for objects not using their parent scope

o Improvement and bug tickets closed: 1499


Compatibility changes:
----------------------

The following changes are known to break compatibility. The old
behavior is emulated in the compatibility layer that is activated by
adding the preprocessor directive "#pike 7.2" to your program or by
giving the argument "-V7.2" to the pike executable.

o "global" has become a reserved keyword.

o Changed lookup rule for ::.
    Previously the identifier in front of :: was only looked up among
    the preceding inherits. Now the lookup additionally includes the
    names of the surrounding classes. The inherits inside a class
    still take precedence over the name of the class, though.

o Using local:: on variables is an error.
    Previously the construct local::foo could be used to access the
    identifier "foo" in the class scope if it had been overridden by
    an argument or function variable. That is however only a
    side-effect of the real use for local::, namely to bind the
    identifier statically at that point only, to avoid getting an
    overridden version. In the case of variables this leads to
    questionable semantics, which is the reason it's been made an
    error in this version. Pike 7.2 didn't implement it correctly;
    there local:: on variables had only the effect to access the class
    scope. Now a proper way to access hidden identifiers has been
    added, so all such uses of local:: should be replaced with
    this_program::.

o Identifier lookup
    The search algorithm for finding identifiers from inherited classes
    has been changed to look for the most recent definition in the most
    recent inherit. In Pike 7.2 and prior, it looked up the last
    definition regardless of inherit depth, unless there was a
    definition in the current program. (This actually changed more than
    once during 7.3 - between 7.3.23 and 7.3.32, it looked up the most
    recent definition with the least inherit depth.) This example shows
    what the lookup strategies would find:

    class A {
      int foo() {}
    }

    class B {
      int foo() {}
      inherit A;
    }

    class C {
      inherit B;
    }

    class D {
      inherit B;
      inherit C;
    }

    Lookup of identifier "foo" in D():

    D-+-B-+-foo          (Pike 7.3.23 --- Pike 7.3.32)
      |   |
      |   +-A---foo
      |
      +-C---B-+-foo      Pike 7.3.33 --- (present day)
              |
              +-A---foo              --- Pike 7.3.22

    Lookup of identifier "foo" in C():

    C---B-+-foo          Pike 7.3.23 --- (present day)
          |
          +-A---foo                  --- Pike 7.3.22

    Lookup of identifier "foo" in B():

    B-+-foo              All versions of Pike
      |
      +-A---foo

o Thread.Condition()->wait

o Protocols.HTTP
    All methods in Protocols.HTTP that take a header mapping can now
    handle array values (signifying multiple headers of that type).

o Protocols.LDAP.client
    The return code from all methods was changed to follow Pike's
    logic better. 0 is now a failure. The old behavior is emulated in
    a compatibility layer.

o dirname
    Now correctly returns a directory instead of just stripping the
    part after the nearest directory separator.

o LR
    LR has been moved to Parser.LR and the API has been changed.
    FIXME: More about this?

o wmml documentation removed
    Use the documentation in the refdoc directory instead.

o .build_lobotomize_crypto removed
    Use the Makefile target lobotomize_crypto to lobotomize Pike.
    Should preferably be executed in an unused tree straight from CVS.


Compatibility changes without backward compatibility:
-----------------------------------------------------

The folloing changes were considered bugs and have no backwards
compatibility layer.


o enum and typedef have implicit local binding
    enums and typedefs now always have static binding. In 7.2 they
    could sometimes be dynamically bound.

o Image.Layer modes modified.
    Alpha channel handling for modes add, subtract, multiply, divide,
    modulo, invsubtract, invdivide, invmodulo, difference, max, min,
    bitwise_and, bitwise_or, bitwise_xor, screen and overlay modified so
    that the source layer alpha channel copied to the destination layer
    alpha channel rather then mixed with the current layer alpha channel:

    aD=aS

    rather then the behavior before:

    aD=(aL+(1-aL)*aS)

    (which is the behavior of the 'normal' mode.)

    Bug fixes in the above modes so that alpha r,g,b channels
    are handled properly (separately).

    Bug fixes in equal, not_equal, less, more, less_or_equal, and
    more_or_equal modes so that the alpha channel is handled as
    documented (which is, in fact, as above; aD=aS).

    Bug fix in divide and invdivide to actually do what the modes are
    supposed to do (rather then just black the layer).

    And while on it, adding some modes:

    'imultiply'  - D=(1-L)*S
    'idivide'    - D=S/(1-L)
    'invidivide' - D=L/(1-S)

    'value_mul' - multiplying the source layer value
    (as in h,s,v) with the current layer value to the destination
    layer ("true burn").


C level/development changes:
----------------------------

o Some global symbols have been renamed to avoid name clashes.
    sp -> Pike_sp
    fp -> Pike_fp
    fatal -> Pike_fatal
    empty_string -> empty_pike_string

o --with-internal-profiling

o Module symbols not available from other modules.


Bugs fixed:
-----------

o Reworked trampolines to cause less circular references. (solves 1937)

o Works with Autoconf 2.50

(To browse bug tickets, either visit
http://community.roxen.com/crunch/ - or append the ticket id to
"http://bugs.roxen.com/" for an address directly to the ticket
itself.)



Uncategorized misc changes:
---------------------------

o constant objects (Gmp.Bignum, Math.Matrix, Image.Color)
o basetype()
o it is possible to change predefines without forking a new pike
o #pragma save_parent
o #pragma dont_save_parent (overrides constant __pragma_save_parent__)
o dont_dump_module *FIXME: grubba*
o C modules can no longer call functions in other dynamic C modules directly
  FIXME: mast, grubba?
o It is possible to inherit pike programs from C programs.
o Separate weak flags for indices and values in mappings
o Added low lowel glue for the Ffmpeg library.


o Calendar.verify  *FIXME: remove?*

Nilsson does lib:

master.pike
- Better %O print outs for objects and programs.
- pike -x
- add_predefine/remove_predefine
- argc, argv and env are available when using pike -e
- getenv/putenv is now case insensitive on NT.
- Improved handling of module cross dependencies.

Array.common_prefix
Array.count
Array.greedy_diff
Array.oid_sort_func
Array.arrayify
Array.uniq2
Array.sum

Local

Multiset

Pike.Backend
Pike.Security
Pike.BacktraceFrame
Pike.WEAK_INDICES, WEAK_VALUES, WEAK

Image.DWG

String.Elite
String.SingleReplace
String.Replace
String.SplitIterator
String.soundex
String.Buffer

ADT.History
ADT.Relation.Binary

Audio

Debug.Subject
Debug.Tracer

Locale.Language

MIME.ext_to_media_type

Parser.Python
Parser.RCS
Parser.decode_numeric_xml_entity
Parser.get_xml_parser
Parser.parse_html_entities
Parser.LR
Parser.XML.NSTree

Protocols.HTTP.Query supports https

Protocols.LDP supports ldaps

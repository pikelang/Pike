Changes since Pike 7.4:
----------------------------------------------------------------------

New/improved functionality:
---------------------------

o The automatic garbage collection strategy is configurable
    The garbage collector can be configured to take both the amount of
    garbage and the cpu time spent in the gc into account. Automatic
    gc runs can also be disabled in critical regions. See the function
    Pike.gc_parameters.

o sort() is stable
    Unlike previous releases, sort() will keep the original order
    between elements that are equal. This was not implemented as a
    separate function since it could be done with virtually no extra
    overhead.

o sort() is portable
    Sort is now locale and platform independent. In other words,
    strings are now compared only according to the unicode value of
    every character.

o Reworked codec
    The codec for serialization of Pike data types has been updated
    and has a significally improved successrate at encoding modules.

o Less magic hacks
    Several Pike modules have been cleaned up from old hacks and
    workarounds for problems which now have proper solutions. This
    should improve size, performance, dumpability and readability
    of the affected code. In addition lots of internal types in Pike
    have been tightened up and several more files now use the pragma
    strict_types, which has resulted in some additional bugfixes.

o INT64
    On 64 bit architechtures Pike will now use full 64 bits integer
    before resorting to Gmp.mpz objects for large numbers.

o IPv6

o mysqls
    The Mysql glue can operate over SSL. Use the "mysqls://" protocol
    in the Sql.Sql module to use this secuity feature.

o trace() can trace all threads
    The configure option --without-thread-trace has been removed, but
    instead the trace() function has been extended to make it possible
    to set the trace level in all threads simultaneously.


Build baluns:
-------------
bundles


Language additions:
-------------------

Changes and additions to -x utilities:
--------------------------------------

o rsif
    rsif can now work recursively in a file structure if given the
    flag -r or --recursive. Example:
      pike -x rsif -r 7.4 7.6

o benchmark
    A set of benchmarks is available in the benchmark tool. They are
    based on the Great Computer Language Shootout, but has been
    modified to make more sense in the context of Pike and to test
    various aspects of Pike we suspect (or at least at one time
    suspected) performs badly.

o cgrep
    Context sensitive grep is very helpful when you are looking for
    substrings that are common. The implemented search modes are:
      o Complete token
      o Part of a token
      o Complete string literal
      o Part of a string literal
      o Part of a comment

    Example:
      $ cd Pike/7.6/src
      $ grep or * | wc -l
      18907
      $ pike -x cgrep -T or * | wc -l
      14

o dump
    Dumps Pike .pike and .pmod module files to precompiled .o files
    for shorter load times. Previously available as
    src/dumpmodule.pike in the Pike source tree, but moved into the
    Pike builtin tools to facilitate dumping of external modules.

o extract_locale
    Locale extractor utility used to extract localizable strings from
    an application into an xml format, to later be used by the Locale
    module.

o monger
    A new utility to download, install and otherwise manage external
    modules from the Fresh Pike project.


New modules / classes / methods added:
--------------------------------------

o Regexp.PCRE added to give libpcre support.
    Are you a closet-perlet? For those who missed the richer flora of
    regexp syntax that Perl supports, the Perl Compatible Regular
    Expression module is the answer. If you compile libpcre with UTF-8
    support you will also get transparent wide string support. Several
    convenience functions are also added to the Regexp module to
    enable easier access to regular expressions.

o Crypto/Nettle
    The crypto module has been almost completely rewritten and now
    uses libnettle as backend instead of the built in crypto
    algorithms that Pike had before. This way Pike will benefit from
    the more active development and optimization work in the Nettle
    project. The most common hash and cipher methods are already
    written in assembler for several platforms. As an example SHA1 is
    about 40% faster than before on Intel platforms.

    With the new nettle support comes support for two new cipher
    algorithms, Blowfish and Serpent, and the new NIST hash algorithm
    SHA256. Note that the new Crypto module has renamed its
    identifiers to be consistent with the rest of Pike, and in some
    cases to clarify or correct bad names. The old names still work,
    but produce a warning unless Pike is run in compatibility mode.
    Compatibility outside compatibility mode will be removed in the
    future.

    The interfaces for the hash and cipher algorithms has been
    improved and they no longer only conform to predefined interfaces,
    but actually inherits Hash/HashState and Cipher/CipherState. Every
    algorithm is in itself a module in the Crypto module, and inherits
    the Hash/Cipher class. This module contains instance non-specific
    methods such as digest_size or key_size. By calling the `() method
    in the module a HashState/CipherState object is returned, which is
    a hash/cipher instance which can be used for streaming operations.

    Examples:

      Crypto.MD5.hash("Hash this string");

      Crypto.MD5()->update("Hash this ")->update("string")->digest();

    The confusing and hard to use Crypto.randomness has been obsoleted
    by the Nettle implementation of the Yarrow random generator. The
    Nettle implementation of Yarrow uses AES and SHA256. The
    Crypto.Random module acts as a frontend before system crypto
    sources and ensure that no matter how bad your OS is, you will
    still get cryptographically strong random data.


o Crypto.PGP
    The start of a PGP/GPG toolkit. It still cannot handle all types
    of signatures nor generate any, but it is useful to verify
    selfsigned code and data.


o ADT.Struct
    This module makes it possible to work with binary formats of the
    packed-struct-type. Simply create a class and specify the members
    in order, create an object with a file object as argument and then
    read the decoded values from the object as ordinary variables.

      class ID3 {
        inherit ADT.Struct;
        Item head = Chars(3);
        Item title = Chars(30);
        Item artist = Chars(30);
        Item album = Chars(30);
        Item year = Chars(4);
        Item comment = Chars(30);
        Item genre = Byte();
      }

      Stdio.File f = Stdio.File("foo.mp3");
      f->seek(-128);
      ADT.Struct tag = ID3(f);
      if(tag->head=="TAG") {
        write("Title: %s\n", tag->title);
        tag->title = "A new title" + "\0"*19;
        f->seek(-128);
        f->write( (string)tag );
      }


o ADT.BitBuffer
    When operating on data formats that are defined on bit level, the
    ADT.BitBuffer presents a convenient interface. It operates as a
    FIFO buffer on bit level, which allows you to read and write bits
    and bytes.

      > ADT.BitBuffer b=ADT.BitBuffer();
      > b->put1(2);
      (1) Result: ADT.BitBuffer(11)
      > b->put0(15);
      (2) Result: ADT.BitBuffer("À\0"0)
      > b->drain();
      (3) Result: "À\0"
      > sizeof(b);
      (4) Result: 1


o Debug.Wrapper
    A simple litte wrapper that can be placed around another object to
    get printouts about what is happening to it. Only a few LFUNs are
    currently supported.

      > object x=Debug.Wrapper(Crypto.MD5());
      Debug.Wrapper is proxying ___Nettle.MD5_State()
      > x->name();
      ___Nettle.MD5_State()->name
      (1) Result: "md5"
      > !x;
      !___Nettle.MD5_State()
      (2) Result: 0


o Image.NEO
    Support for one of the major image formats on Atari ST/STE,
    including decoding of color cycling. The C bitmap and palette
    handler can be used to implement other atari image formats.

o GLUE

    The GL Universal Environment is a GL toolkit that makes
    implementing GL applications in Pike really simple. GLUE has
    several orthogonal components like object orientation
    encapsulation of Gl, drawing primitives, texture handling and text
    generation. The most fundamental part is however an abstract
    interface to a GL area driver, like GTK or SDL.

      int main() {
        GLUE.init();
        draw_frame();
        return -1;
      }
      
      void draw_frame() {
        call_out(draw_frame, 0.02); // 1/(50 fps)
        do_gl_code();
        GLUE.swap_buffers();
      }


o _ADT
o Geography RT38
o Int
o Pike.Security
o Protocols.HTTP.Session

    Handles an HTTP connection as a session, with cookies and stuff.

o Bz2

    Support for the compression format used by the bzip2 program.

o Process.Process
o Error
o Float
o Protocols.Bittorrent
o Protocols.LMTP
o Web.RDF/RDFS/OWL/RSS

    Pike now has support for the W3C semantic web formats OWL, RDF
    and RDFS, which are used for expressing structure and metadata
    information. There is also some support for the syndication
    format RSS (which happens to be a simple application of RDF).

    This sample program reads an OWL file, parses the dataset
    contained in it, and then lists the data classes in that
    dataset:

      int main(int argc, array argv)
      {
        object owlset = Web.OWL();
        string input = Stdio.read_file(argv[1]);
        owlset->parse_owl(input);

        write("Classes:\n");

        foreach(owlset->find_statements(0,
                                        owlset->rdf_type,
                                        owlset->owl_Class);
                               array statement)
          write("- %O\n", statement[0]);

       return 0;
     }  
 

o Parser.RCS

Optimizations:
--------------

o Instantiation and destruction of pike-classes is now significantly faster.

o Handling of bignums has been optimized, especially conversion
  to/from normal integers.

o String case conversion is now five times faster than before on
  average.


Compatibility changes:
----------------------

Compatibility changes without backward compatibility:
-----------------------------------------------------

o Module ABI changed
  The pike_frame struct has a new member, which makes modules compiled
  with earlier versions of Pike incompatible.


C level/development changes:
----------------------------

o The security.h include file is renamed to pike_security.h

Bugs fixed:
-----------


Uncategorized misc changes:
---------------------------

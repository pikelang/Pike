// -*- Pike -*-
//
// Master Control Program for Pike.
//
// This file is part of Pike. For copyright information see COPYRIGHT.
// Pike is distributed under GPL, LGPL and MPL. See the file COPYING
// for more information.
//
// $Id: master.pike.in,v 1.247 2003/05/17 10:52:47 grubba Exp $

#pike __REAL_VERSION__

// Some programs destroys character pairs beginning with the currency
// symbol when running in chinese locale.
#if "¤/" != "\244/"
#error "master.pike.in is corrupted."
#endif

// --- Some configurable parameters

#define PIKE_AUTORELOAD
#define GETCWD_CACHE
#define FILE_STAT_CACHE

// This define is searched and replaced by bin/install.pike.
#undef PIKE_MODULE_RELOC

#ifndef PIKE_WARNINGS
#define PIKE_WARNINGS 1
#endif /* PIKE_WARNINGS */


// --- Global constants and variables

// Used by describe_backtrace() et al.
#if !defined(BT_MAX_STRING_LEN) || (BT_MAX_STRING_LEN <= 0)
#undef BT_MAX_STRING_LEN
#define BT_MAX_STRING_LEN	200
#endif /* !defined(BT_MAX_STRING_LEN) || (BT_MAX_STRING_LEN <= 0) */
constant bt_max_string_len = BT_MAX_STRING_LEN;

//! @decl constant bt_max_string_len = 200
//! This constant contains the maximum length of a function entry in a
//! backtrace. Defaults to 200 if no BT_MAX_STRING_LEN define has been
//! given.

// Enables the out of date warning in low_findprog().
#ifndef OUT_OF_DATE_WARNING
#define OUT_OF_DATE_WARNING 1
#endif /* OUT_OF_DATE_WARNING */
constant out_of_date_warning = OUT_OF_DATE_WARNING;

//! @decl constant out_of_date_warning = 1
//! Should Pike complain about out of date compiled files.
//! 1 means yes and 0 means no. Controlled by the OUT_OF_DATE_WARNING
//! define.

//! If not zero compilation warnings will be written out on stderr.
int want_warnings = PIKE_WARNINGS;

//!
int compat_major=-1;

//!
int compat_minor=-1;


// ---  Functions begin here.

#define Stat _static_modules.files.Stat
#define capitalize(X) (upper_case((X)[..0])+(X)[1..])

//! @appears error
//! Throws an error. A more readable version of the code
//! @tt{throw( ({ sprintf(f, @@args), backtrace() }) )@}.
void error(string f, mixed ... args) {
  array b = backtrace();
  if (sizeof(args)) f = sprintf(f, @args);
  throw( ({ f, b[..sizeof(b)-2] }) );
}

// FIXME: Should the pikeroot-things be private?
#ifdef PIKE_FAKEROOT
object o;
string fakeroot(string s)
{
  string tmp1=combine_path_with_cwd(s);
#ifdef PIKE_FAKEROOT_OMIT
  foreach(PIKE_FAKEROOT_OMIT/":", string x)
    if(glob(x,tmp1))
      return s;
#endif
  return PIKE_FAKEROOT+tmp1;
}
#else
#define fakeroot(X) X
#endif // PIKE_FAKEROOT

#ifdef PIKE_MODULE_RELOC
string relocate_module(string s)
{
  if(s[..1]=="/$" && (s+"/")[..20] == "/${PIKE_MODULE_PATH}/") {
    string tmp = s[21..];
    foreach(pike_module_path, string path) {
      string s2 = fakeroot(sizeof(tmp)? combine_path(path, tmp) : path);
      if(master_file_stat(s2))
	return s2;
    }
  }
  return fakeroot(s);
}

string unrelocate_module(string s)
{
  if(s[..1]=="/$" && (s+"/")[..20] == "/${PIKE_MODULE_PATH}/")
    return s;

  foreach(pike_module_path, string path)
    if(s == path)
      return "/${PIKE_MODULE_PATH}";
    else {
      string s2 = combine_path(path, "");
      if(s[..sizeof(s2)-1] == s2)
	return "/${PIKE_MODULE_PATH}/"+s[sizeof(s2)..];
    }
  return s;
}
#ifdef fakeroot
#undef fakeroot
#endif
#define fakeroot relocate_module
#endif // PIKE_MODULE_RELOC


//! @appears is_absolute_path
//! Check if a path @[p] is fully qualified (ie not relative).
//!
//! @returns
//! Returns 1 if the path is absolute, 0 otherwise.
int is_absolute_path(string p)
{
#ifdef __NT__
  p=replace(p,"\\","/");
  if(sscanf(p,"%[a-zA-Z]:%*c",string s)==2 && sizeof(s)==1)
    return 1;
#define IS_ABSOLUTE_PATH is_absolute_path
#else
#define IS_ABSOLUTE_PATH(X) has_prefix((X),"/")
#endif
  return has_prefix(p,"/");
}

#ifdef __NT__
#define EXPLODE_PATH(X) (replace((X),"\\","/")/"/")
#else
#define EXPLODE_PATH(X) ((X)/"/")
#endif

//! @appears explode_path
//! Split a path @[p] into its components.
//!
//! This function divides a path into its components. This might seem like
//! it could be done by dividing the string on <tt>"/"</tt>, but that will
//! not work on some operating systems.
//!
array(string) explode_path(string p)
{
  return EXPLODE_PATH(p);
}

//! @appears dirname
//! Returns all but the last segment of a path. Some example inputs and
//! outputs:
//!
//! @xml{<matrix>
//! <r><c><b>Expression</b></c><c><b>Value</b></c></r>
//! <r><c>dirname("/a/b")</c><c>"/a/"</c></r>
//! <r><c>dirname("/a/")</c><c>"/a/"</c></r>
//! <r><c>dirname("/a")</c><c>"/"</c></r>
//! <r><c>dirname("/")</c><c>"/"</c></r>
//! <r><c>dirname("")</c><c>""</c></r>
//! </matrix>@}
//!
//! @seealso
//! @[basename()], @[explode_path()]
string dirname(string x)
{
  if(x=="") return "";
  array(string) tmp=EXPLODE_PATH(x);
  if(x[0]=='/' && sizeof(tmp)<3) return "/";
  return tmp[..sizeof(tmp)-2]*"/";
}

//! @appears basename
//! Returns the last segment of a path.
//!
//! @seealso
//! @[dirname()], @[explode_path()]
string basename(string x)
{
  array(string) tmp=EXPLODE_PATH(x);
  return tmp[-1];
}
#define BASENAME(X) (EXPLODE_PATH(X)[-1])

#ifdef PIKE_AUTORELOAD

int autoreload_on;
int newest;

#define AUTORELOAD_CHECK_FILE(X) \
   if(autoreload_on) if(Stat s=master_file_stat(X)) if(s->mtime>newest) newest=[int]s->mtime;

#define AUTORELOAD_BEGIN() \
    int ___newest=newest;  \
    newest=0
    

#define AUTORELOAD_FINISH(VAR, CACHE, FILE)		\
   if(autoreload_on) {                                  \
     if(CACHE [ FILE ] && newest <= load_time[FILE]) {	\
        VAR = CACHE [ FILE ]; 				\
      }                                                 \
    }                                                   \
    load_time[FILE]=time();				\
    if(___newest > newest) newest=___newest;


mapping(string:int) load_time=([]);
#else

#define AUTORELOAD_CHECK_FILE(X)
#define AUTORELOAD_BEGIN()
#define AUTORELOAD_FINISH(VAR,CACHE,FILE)

#endif // PIKE_AUTORELOAD

//! @appears compile_string
//! Compile the Pike code in the string @[source] into a program.
//! If @[filename] is not specified, it will default to @tt{"-"@}.
//!
//! Functionally equal to @code{@[compile](@[cpp](@[source], @[filename]))@}.
//!
//! @seealso
//! @[compile()], @[cpp()], @[compile_file()]
//!
program compile_string(string source, void|string filename,
		       object|void handler)
{
  return compile(cpp(source, filename||"-", 1, handler,
		     compat_major, compat_minor),
		 handler,
		 compat_major,
		 compat_minor);
}

//!
string master_read_file(string file)
{
  object o=_static_modules.files()->Fd();
  if( ([function(string, string : int)]o->open)(fakeroot(file),"r") )
    return ([function(void : string)]o->read)();
  return 0;
}

#ifdef GETCWD_CACHE
string current_path;
int cd(string s)
{
  current_path=0;
  return predef::cd(s);
}

string getcwd()
{
  return current_path || (current_path=predef::getcwd());
}
#endif // GETCWD_CACHE

string combine_path_with_cwd(string path)
{
  return combine_path(IS_ABSOLUTE_PATH(path)?"/":getcwd(),path);
}

#ifdef FILE_STAT_CACHE

#define FILE_STAT_CACHE_TIME 20

int invalidate_time;
mapping(string:multiset(string)) dir_cache = ([]);

Stat master_file_stat(string x)
{
  string dir = combine_path_with_cwd(x);
  string file = BASENAME(dir);
  dir = dirname(dir);

  if(time() > invalidate_time)
  {
    dir_cache = ([]);
    invalidate_time = time()+FILE_STAT_CACHE_TIME;
  }

  multiset(string) d = dir_cache[dir];
  if( zero_type(d) )
  {
    array(string) tmp = get_dir(dir);
    if(tmp)
    {
#ifdef __NT__
      tmp = map(tmp, lower_case);
#endif
      d = dir_cache[dir] = aggregate_multiset(@tmp);
    }
    else
      dir_cache[dir]=0;
  }
  
#ifdef __NT__
  file = lower_case(file);
#endif
  if(d && !d[file]) return 0;

  return predef::file_stat(x);
}
#else
#define master_file_stat file_stat
#endif // FILE_STAT_CACHE

mapping (string:array(string)) environment=([]);


//! @decl string getenv(string varname)
//! @decl mapping(string:string) getenv()
//! @appears getenv
//!
//! When called with no arguments, a mapping with all current environment
//! variables will be returned. Destructive opreations on the mapping
//! will not affect the internal environment representation.
//!
//! If the @[varname] argument has been given, the value of the environment
//! variable with the name @[varname] will be returned. If no such
//! environment variable exists, @tt{0@} (zero) will be returned.
//!
//! On NT the environment variable name is case insensitive.
//!
string|mapping(string:string) getenv(string|void s)
{
  if(!s) return [mapping(string:string)]aggregate_mapping( @(values(environment)*({}) ) );
#ifdef __NT__
  s = lower_case(s);
#endif
  return environment[s] && environment[s][1];
}


//! @appears compile_file
//! Compile the Pike code contained in the file @[filename] into a program.
//!
//! This function will compile the file @[filename] to a Pike program that can
//! later be instantiated. It is the same as doing
//! @code{@[compile_string](@[Stdio.read_file](@[filename]), @[filename])@}.
//!
//! @seealso
//! @[compile()], @[compile_string()], @[cpp()]
//!
program compile_file(string filename,
		     object|void handler,
		     void|program p,
		     void|object o)
{
  AUTORELOAD_CHECK_FILE(filename);
  return compile(cpp(master_read_file(filename),
		     filename,
		     1,
		     handler,
		     compat_major,
		     compat_minor),
		 handler,
		 compat_major,
		 compat_minor,
		 p,
		 o);
}



#if 0
variant mapping(string:string) getenv()
{
  return environment + ([]);
}

variant string getenv(string s)
{
  return environment[s];
}

function(:mapping(string:string))|function(string:string) getenv(s)
{
  if(!s) return environment + ([]);
  return environment[s];
}

// mapping(string:string) getenv() |
string getenv(string s)
{
  if(!s) return environment + ([]);
  return environment[s];
}
#endif /* 0 */

//! @appears putenv
//! Sets the environment variable @[varname] to @[value].
//!
//! On NT the environment variable name is case insensitive.
//!
//! @seealso
//! @[getenv()]
//!
void putenv(string varname, string value)
{
  string index = varname;
#ifdef __NT__
  index = lower_case(varname);
  if (environment[index] && environment[index][0])
    varname = environment[index][0];
#endif
  environment[index] = ({ varname, value });
}

//! @appears normalize_path
//! Replaces "\" with "/" if runing on MS Windows. It is
//! adviced to use @[System.normalize_path] instead.
string normalize_path( string path )
{
#ifndef __NT__
  return path;
#else
  return replace(path,"\\","/");
#endif
}

mapping (string:program) programs=(["/master":object_program(this_object())]);

array(string) query_precompiled_names(string fname)
{
  // Filenames of potential precompiled files in priority order.
#ifdef PRECOMPILED_SEARCH_MORE
  // Search for precompiled files in all module directories, not just
  // in the one where the source file is. This is useful when running
  // pike directly from the build directory.
  fname = fakeroot (fname);
  // FIXME: Not sure if this works correctly with the fakeroot and
  // module relocation stuff.
  foreach (pike_module_path, string path)
    if (has_prefix (fname, path))
      return map (pike_module_path, `+, "/", fname[sizeof (path)..], ".o");
#endif
  return ({ fname + ".o" });
}

#if constant(_static_modules.Builtin.mutex)
#define THREADED
_static_modules.Builtin.mutex compilation_mutex = _static_modules.Builtin()->mutex();
#endif

static program low_findprog(string pname,
			    string ext,
			    object|void handler,
			    void|int mkobj)
{
  program ret;
  Stat s;
  string fname=pname+ext;

#ifdef THREADED
  object key;
  // FIXME: The catch is needed, since we might be called in
  // a context when threads are disabled.
  // (compile() disables threads).
  mixed err = catch {
    key=compilation_mutex->lock(2);
  };
  if (err) {
    werror( "low_findprog: Caught spurious error:\n"
	    "%s\n", describe_backtrace(err) );
  }
#endif

#ifdef PIKE_MODULE_RELOC
  fname = unrelocate_module(fname);
#endif

#ifdef PIKE_AUTORELOAD
  if(!autoreload_on || load_time[fname]>=time())
#endif
  {
    if(!zero_type (ret=programs[fname])) {
#ifdef RESOLV_DEBUG
      werror ("low_findprog: %s returning cached (no autoreload)\n", fname);
#endif
      return ret;
    }
  }

#ifdef __NT__
  // Ugly kluge to work better with cygwin32
  if(getenv("OSTYPE")=="cygwin32")
  {
    string tmp=fname[..1];
    if((tmp=="//" || tmp=="\\\\") && (fname[3]=='/' || fname[3]=='\\'))
    {
      if(!master_file_stat(fname))
      {
	fname=fname[2..2]+":"+fname[3..];
      }
    }
  }
#endif

  if( (s=master_file_stat(fakeroot(fname)))  && s[1]>=0 )
  {
    AUTORELOAD_BEGIN();

#ifdef PIKE_AUTORELOAD
    if (load_time[fname] > s[3])
      if (!zero_type (ret=programs[fname])) {
#ifdef RESOLV_DEBUG
	werror ("low_findprog: %s returning cached (autoreload)\n", fname);
#endif
	return ret;
      }
#endif

    switch(ext)
    {
    case "":
    case ".pike":
      foreach(query_precompiled_names(fname), string oname) {
	if(Stat s2=master_file_stat(fakeroot(oname)))
	{	
	  if(s2[1]>=0 && s2[3]>=s[3])
	  {
	    mixed err=catch {
	      AUTORELOAD_CHECK_FILE(oname);
	      ret = decode_value(master_read_file(oname),
				 Codec(fname, mkobj));
#ifdef RESOLV_DEBUG
	      werror ("low_findprog: %s returning decoded dump\n", fname);
#endif
	      return programs[fname] = ret;

	    };
	    m_delete(programs, fname);
	    if (handler && handler->compile_warning) {
	      handler->compile_warning(oname, 0,
				       sprintf("Decode failed:\n"
					       "\t%s", describe_error(err)));
	    } else {
	      compile_warning(oname, 0,
			      sprintf("Decode failed:\n"
				      "\t%s", describe_error(err)));
	    }
	  } else if (out_of_date_warning) {
	    if (handler && handler->compile_warning) {
	      handler->compile_warning(oname, 0,
				       "Compiled file is out of date\n");
	    } else {
	      compile_warning(oname, 0, "Compiled file is out of date\n");
	    }
	  }
	}
      }
      
#ifdef RESOLV_DEBUG
      werror ("low_findprog: %s compiling\n", fname);
#endif
      programs[fname]=ret=__empty_program(0, fname);
      if ( mixed e=catch {
	ret=compile_file(fname,
			 handler,
			 ret,
			 mkobj? (objects[ret]=__null_program()) : 0);
      } )
      {
	ret=programs[fname]=0;
        throw(e);
      }
      break;
#if constant(load_module)
    case ".so":
      if (fname == "") {
	werror( "low_findprog(\"%s\", \"%s\") => load_module(\"\")\n"
		"%s\n", pname, ext, describe_backtrace(backtrace()) );
      }

      ret=load_module(fakeroot(fname));
#ifdef RESOLV_DEBUG
      werror ("low_findprog: %s loaded binary\n", fname);
#endif
#endif /* load_module */
    }

    AUTORELOAD_FINISH(ret,programs,fname);

    return programs[fname]=ret;
  }
#ifdef RESOLV_DEBUG
  werror ("low_findprog: %s file not found\n", fname);
#endif
  return 0;
}

//
// This function is called by the compiler when a delayed compilation
// error occurs in the given program. It should remove all references
// to the program so that it can be freed.
//
void unregister(program p)
{
  if(string fname=search(programs,p)) {
    m_delete(programs, fname);
    // FIXME: The following assumes that programs are always stored
    // with '/' as path separators, even on NT. Haven't checked if
    // that always is the case.
    fname = dirname (fname);
    object n;
    if ( fname!="" && (n = fc[fname]) )
      if (n->is_resolv_dirnode || n->is_resolv_joinnode)
	n->delete_value (p);
  }
  m_delete(objects, p);
  foreach (fc; string name; mixed mod)
    if (objectp(mod) && object_program(mod) == p)
      m_delete(fc, name);
}

static program findprog(string pname,
			string ext,
			object|void handler,
			void|int mkobj)
{
  switch(ext)
  {
  case ".pike":
  case ".so":
    return low_findprog(pname,ext,handler, mkobj);

  default:
    pname+=ext;
    return
      low_findprog(pname,"", handler, mkobj) ||
      low_findprog(pname,".pike", handler, mkobj) ||
      low_findprog(pname,".so", handler, mkobj);
  }
}

program low_cast_to_program(string pname,
			    string current_file,
			    object|void handler,
			    void|int mkobj)
{
  string ext;
  string nname;
  array(string) tmp=EXPLODE_PATH(pname);

  // werror("low_cast_to_program(%O, %O, %O, %O)\n",
  // pname, current_file, handler, mkobj);

  if(sscanf(reverse(tmp[-1]),"%s.%s",ext, nname))
  {
    ext="."+reverse(ext);
    tmp[-1]=reverse(nname);
    pname=tmp*"/";
  }
  else {
    ext="";
  }

  if(IS_ABSOLUTE_PATH(pname))
  {
    if (programs[pname])
      return programs[pname];
    pname=combine_path("/",pname);
    return findprog(pname,ext,handler,mkobj);
  }
  else {
    string cwd;
    if(current_file)
    {
      cwd=dirname(current_file);
    }
    else {
      cwd=getcwd();
    }

    if(program ret=findprog(combine_path(cwd,pname),ext,handler,mkobj))
      return ret;

    foreach(pike_program_path, string path)
      if(program ret=findprog(combine_path(path,pname),ext,handler,mkobj))
	return ret;

    return 0;
  }
}


//! This function is called when the driver wants to cast a string
//! to a program, this might be because of an explicit cast, an inherit
//! or a implict cast. In the future it might receive more arguments,
//! to aid the master finding the right program.
program cast_to_program(string pname,
			string current_file, 
			object|void handler)
{
  return low_cast_to_program(pname, current_file, handler);
}


//! This function is called when an error occurs that is not caught
//! with catch().
void handle_error(array(mixed)|object trace)
{
  if(mixed x=catch {
    werror(describe_backtrace(trace));
  }) {
    // One reason for this might be too little stack space, which
    // easily can occur for "out of stack" errors. It should help to
    // tune up the STACK_MARGIN values in interpret.c then.
    werror("Error in handle_error in master object:\n");
    if(catch {
      catch {
	if (catch {
	  string msg = [string]x[0];
	  array bt = [array]x[1];
	  werror("%s%O\n", msg, bt);
	}) {
	  werror("%O\n", x);
	}
      };
      werror("Original error:\n"
	     "%O\n", trace);
    }) {
      werror("sprintf() failed to write error.\n");
    }
  }
}

/* This array contains the names of the functions
 * that a replacing master-object may want to override.
 */
constant master_efuns = ({
  "error",
  "basename",
  "dirname",
  "is_absolute_path",
  "explode_path",

  "compile_string",
  "compile_file",
  "add_include_path",
  "remove_include_path",
  "add_module_path",
  "remove_module_path",
  "add_program_path",
  "remove_program_path",
  "describe_backtrace",
  "describe_error",
  "normalize_path",
  "getenv",
  "putenv",

#ifdef GETCWD_CACHE
  "cd",
  "getcwd",
#endif
});

string include_prefix;

/* Note that create is called before add_precompiled_program
 */
void create()
{
  object o = this_object();

  foreach(master_efuns, string e)
    if (o[e])
      add_constant(e, o[e]);
    else
      error("Function %O is missing from master.pike.\n", e);

  add_constant("strlen", sizeof);
  add_constant("write", _static_modules.files()->_stdout->write);

#define CO(X)  add_constant(#X,_static_modules.Builtin.__backend->X)
  CO(call_out);
  CO(_do_call_outs);
  CO(find_call_out);
  CO(remove_call_out);
  CO(call_out_info);

#if "¤share_prefix¤"[0]!='¤'
  // add path for architecture-dependant files
  add_include_path("¤share_prefix¤/include");
  add_module_path("¤share_prefix¤/modules");
#endif

#if "¤lib_prefix¤"[0]!='¤'
  // add path for architecture-dependant files
  add_include_path("¤lib_prefix¤/include");
  add_module_path("¤lib_prefix¤/modules");
#endif

#if "¤include_prefix¤"[0]!='¤'
  include_prefix = "¤include_prefix¤";
#endif
}


//! This function is called whenever a inherit is called for.
//! It is supposed to return the program to inherit.
//! The first argument is the argument given to inherit, and the second
//! is the file name of the program currently compiling. Note that the
//! file name can be changed with #line, or set by compile_string, so
//! it can not be 100% trusted to be a filename.
//! previous_object(), can be virtually anything in this function, as it
//! is called from the compiler.
program handle_inherit(string pname, string current_file, object|void handler)
{
  return cast_to_program(pname, current_file, handler);
}

mapping (program:object) objects=([object_program(this_object()):this_object()]);

object low_cast_to_object(string oname, string current_file,
			  object|void current_handler)
{
  program p;
  object o;

  p = low_cast_to_program(oname, current_file, current_handler, 1);
  if(!p) return 0;
  if(!objectp (o=objects[p])) o=objects[p]=p();
  return o;
}

//! This function is called when the drivers wants to cast a string
//! to an object because of an implict or explicit cast. This function
//! may also receive more arguments in the future.
object cast_to_object(string oname, string current_file)
{
  object o = low_cast_to_object(oname, current_file);
  if (objectp (o)) return o;
  error("Cast '"+oname+"' to object failed"+
	((current_file && current_file!="-")?sprintf(" for '%s'",current_file):"")+".\n");
  return 0;
}

class dirnode
{
  string dirname;
  object|void handler;
  constant is_resolv_dirnode = 1;
  // objectp() is intentionally not used on the module object, to
  // allow a module to deny its own existence with `!.
  mixed module=module_checker();
  mapping(string:mixed) cache=([]);
  array(string) files;

  void create(string d, object|void h)
    {
#ifdef MODULE_TRACE
      werror("%*ndirnode(%O,%O);\n",sizeof(backtrace())-1,d,h);
//      werror(describe_backtrace( ({"HERE\n",backtrace()})));
#endif
      dirname=d;
      handler=h;
      fc[dirname]=this_object();
      if(has_suffix(dirname,".pmod"))
	fc[dirname[..sizeof(dirname)-6]]=this_object();
    }

  class module_checker
  {
    int `!()
    {
#ifdef MODULE_TRACE
      werror("%*ndirnode(%O)->module_checker()->`!()\n",sizeof(backtrace()),dirname);
#endif
      if(module=findmodule(dirname+"/module", handler))
      {
	if(mixed tmp=module->_module_value)
	  module=tmp;

	/* This allows for `[] to have side effects first time
	 * it is called. (Specifically, the Calendar module uses
	 * this
	 */
	cache=([]);
	_cache_full=0;
      }

      return !module;
    }

    mixed `[](string index)
      {
#ifdef MODULE_TRACE
	werror("%*ndirnode(%O)->module_checker()[%O]\n",sizeof(backtrace()),dirname,index);
#endif
	if(module) return module[index];
      }
    array(string) _indices() { if(module) return indices(module); }
    array _values() { if(module) return values(module); }
  }

  static mixed ind(string index)
  {
#ifdef MODULE_TRACE
    werror("%*nDirnode(%O) ind[%O] -> ???\n",sizeof(backtrace()),dirname,index);
#endif
    if(module) 
    {
#ifdef MODULE_TRACE
      werror("%*nDirnode(%O) module[%O] -> ???\n",sizeof(backtrace()),dirname,index);
#endif
      mixed o;
//      _describe(module);
      if(!zero_type(o=module[index]))
      {
#ifdef MODULE_TRACE
	werror("%*nDirnode(%O) module[%O] -> %O\n",sizeof(backtrace()),dirname,index, o);
#endif
	return o;
      }
    }

    if( !files )
      if (!(files = get_dir(fakeroot(dirname)))) {
	werror ("Error listing module directory %O: %s\n",
		dirname, strerror (errno()));
	files = ({});
      }

    int ret;
    foreach( files, string s )
    {
      if( has_value(s, index) || has_value(index,s) )
      {
        ret=1;
        break;
      }
    }
    if(!ret)
      return UNDEFINED;
    index = dirname+"/"+index;
#ifdef MODULE_TRACE
    werror("%*nDirnode(%O) findmodule(%O)\n",
	   sizeof(backtrace()), dirname, dirname+"/"+index);
#endif
    if(object o=findmodule(index, handler))
    {
      if(mixed tmp=o->_module_value) o=tmp;
      return o;
    }
    if (program p=cast_to_program( index, 0, handler ))
    {
//      werror("dirnode(%O)[%O] -> %O\n",dirname,index,p);
      return p;
    }
//    werror("Returning UNDEFINED for %s\n",ind);
    return UNDEFINED;
  }

  mixed `[](string index)
  {
    mixed ret;
#ifdef MODULE_TRACE
    werror("%*nDirnode(%O) cache[%O] ?????\n",sizeof(backtrace()),dirname,index);
#endif
    if(!zero_type(ret=cache[index]))
    {
#ifdef MODULE_TRACE
      werror("%*nDirnode(%O) cache[%O] -> %O\n",sizeof(backtrace()),dirname,index, ret);
#endif
      if (ret != ZERO_TYPE) return ret;
      return UNDEFINED;
    }
    ret=ind(index);

    // We might have gotten placeholder objects in the first pass
    // which must not be cached to the second.
    if(ret == predef::__placeholder_object) return ret;

    cache[index] = zero_type(ret) ? ZERO_TYPE : ret;
    return ret;
  }

  static int _cache_full;
  void fill_cache()
  {
#ifdef RESOLV_DEBUG
    werror(describe_backtrace(({ sprintf("Filling cache in dirnode %O\n",
					 dirname),
				 backtrace() })));
#endif /* RESOLV_DEBUG */
    if (_cache_full) {
      return;
    }

    if (module) {
      foreach(indices(module), string index) {
	cache[index] = module[index];
      }
    }

    if( !files )
      if (!(files = get_dir(fakeroot(dirname)))) {
	werror ("Error listing module directory %O: %s\n",
		dirname, strerror (errno()));
	files = ({});
      }

    foreach(files, string fname) {
      mixed err = catch {
	if (((< ".pike", ".pmod" >)[fname[sizeof(fname)-5..]]) &&
	    !zero_type(`[](fname[..sizeof(fname)-6]))) {
	  continue;
	} else if ((fname[sizeof(fname)-3..] == ".so") &&
	    !zero_type(`[](fname[..sizeof(fname)-4]))) {
	  continue;
	}
      };
      if (err) {
	compile_warning(dirname+"."+fname, 0,
			sprintf("Compilation failed:\n"
				"%s\n",
				describe_backtrace(err)));
      }
    }
    _cache_full = 1;
  }
  array(string) _indices()
  {
    // werror("indices(%O) called\n", dirname);
    fill_cache();
    return indices(filter(cache, lambda(mixed x) {return x != ZERO_TYPE;}));
  }
  array(mixed) _values()
  {
    // werror("values(%O) called\n", dirname);
    fill_cache();
    return values(cache) - ({ZERO_TYPE});
  }

  void delete_value (mixed val)
  {
    if (string name = search (cache, val))
      m_delete (cache, name);
  }

  string _sprintf(int as)
    {
      return as=='O' && sprintf("master()->dirnode(%O)",dirname);
    }
  
};

static class ZERO_TYPE {};

class joinnode
{
  constant is_resolv_joinnode = 1;
  array(object|mapping) joined_modules;
  mapping(string:mixed) cache=([]);

  string _sprintf(int as)
    {
      return as=='O' && sprintf("master()->joinnode(%O)",joined_modules);
    }

  void create(array(object|mapping) _joined_modules)
  {
    joined_modules = _joined_modules;
  }

  static mixed ind(string index)
  {
    array(mixed) res = ({});
    foreach(joined_modules, object|mapping o) 
    {
      mixed ret;
      if (!zero_type(ret = o[index])) 
      {
	if (objectp(ret = o[index]) &&
	    (ret->is_resolv_dirnode || ret->is_resolv_joinnode))
        {
	  // Only join directorynodes (or joinnodes).
	  res += ({ ret });
	} else if ( !zero_type(ret) ) {
	  return (ret);
	} else {
	  // Ignore
	  continue;
	}
      }
    }
    if (sizeof(res) > 1)
      return joinnode(res); 
    else if (sizeof(res))
      return res[0];
    return UNDEFINED;
  }

  mixed `[](string index)
  {
    mixed ret;
    if (!zero_type(ret = cache[index])) {
      if (ret != ZERO_TYPE) {
	return ret;
      }
      return UNDEFINED;
    }
    ret = ind(index);

    // We might have gotten placeholder objects in the first pass
    // which must not be cached to the second.
    if(ret == predef::__placeholder_object) return ret;

    if (zero_type(ret)) {
      cache[index] = ZERO_TYPE;
    } else {
      cache[index] = ret;
    }
    return ret;
  }
  static int _cache_full;
  void fill_cache()
  {
#ifdef RESOLV_DEBUG
    werror(describe_backtrace(({ "Filling cache in joinnode\n",
				 backtrace() })));
#endif /* RESOLV_DEBUG */
    if (_cache_full) {
      return;
    }
    foreach(joined_modules, object|mapping|program o) {
      foreach(indices(o), string index) {
	if (zero_type(cache[index])) {
	  `[](index);
	}
      }
    }
    _cache_full = 1;
  }
  array(string) _indices()
  {
    fill_cache();
    return indices(filter(cache, lambda(mixed x){ return x != ZERO_TYPE; }));
  }
  array(mixed) _values()
  {
    fill_cache();
    return values(cache) - ({ZERO_TYPE});
  }

  void delete_value (mixed val)
  {
    if (string name = search (cache, val))
      m_delete (cache, name);
    for (int i = 0; i < sizeof (joined_modules); i++) {
      object|mapping|program o = joined_modules[i];
      if (o == val) {
	joined_modules = joined_modules[..i - 1] + joined_modules[i + 1..];
	i--;
      }
      else if (objectp (o) && (o->is_resolv_dirnode || o->is_resolv_joinnode))
	o->delete_value (val);
      else if (string name = mappingp (o) && search (o, val))
	m_delete (o, name);
    }
  }
};

// Variables mustn't be static to allow for replace_master().
//	/grubba 1998-04-10
mapping(string:mixed) fc=([]);

object findmodule(string fullname, object|void handler)
{
  object o;
#ifdef MODULE_TRACE
  werror("%*nfindmodule(%O)\n",sizeof(backtrace()),fullname);
#endif
  if(!zero_type(o=fc[fullname]))
  {
//    werror("fc[%O] -> %O\n",fullname, o);
    if (o == 0) return UNDEFINED;
    return o;
  }

  if(Stat stat=master_file_stat(fakeroot(fullname+".pmod")))
  {
    if(stat[1]==-2)
      return dirnode(fullname+".pmod", handler);
  }

  if(objectp (o = low_cast_to_object(fullname+".pmod", "/.", handler)))
    return fc[fullname]=o;
    
#if constant(load_module)
  if(master_file_stat(fakeroot(fullname+".so")))
    return fc[fullname] = low_cast_to_object(fullname, "/.", handler);
#endif

  return fc[fullname] = 0;
}

mixed handle_import(string what, string|void current_file, object|void handler)
{
  array(string) tmp;
  string path;
  if(current_file)
  {
    tmp=EXPLODE_PATH(current_file);
    tmp[-1]=what;
    path=combine_path_with_cwd( tmp*"/");
  } else {
    path = combine_path_with_cwd(what);
  }
#ifdef MODULE_TRACE
  werror("%*nhandle_import(%O, %O, %O)\n",
	 sizeof(backtrace()), what, current_file, handler);
#endif /* MODULE_TRACE */
  if (handler) {
    return dirnode(path, handler);
  }
  if(fc[path]) return fc[path];
  return dirnode(path);
}



multiset no_resolv = (<>);

//!
class CompatResolver
{
  array(string) pike_include_path=({});
  array(string) pike_module_path=({});
  array(string) pike_program_path=({});
  mapping(string:string) predefines = ([]);
  string ver;

  //! The CompatResolver is initialized with a value that can be
  //! casted into a "%d.%d" string, e.g. a version object.
  void create(mixed version)
    {
      ver=(string)version;
    }

  //! Add a directory to search for include files.
  //!
  //! This is the same as the command line option @tt{-I@}.
  //!
  //! @note
  //! Note that the added directory will only be searched when using
  //! < > to quote the included file.
  //!
  //! @seealso
  //! @[remove_include_path()]
  //!
  void add_include_path(string tmp)
    {
      tmp=normalize_path(combine_path_with_cwd(tmp));
      pike_include_path-=({tmp});
      pike_include_path=({tmp})+pike_include_path;
    }

  //! Remove a directory to search for include files.
  //!
  //! This function performs the reverse operation of @[add_include_path()].
  //!
  //! @seealso
  //! @[add_include_path()]
  //!
  void remove_include_path(string tmp)
    {
      tmp=normalize_path(combine_path_with_cwd(tmp));
      pike_include_path-=({tmp});
    }
  
  //! Add a directory to search for modules.
  //!
  //! This is the same as the command line option @tt{-M@}.
  //!
  //! @seealso
  //! @[remove_module_path()]
  //!
  void add_module_path(string tmp)
    {
      tmp=normalize_path(combine_path_with_cwd(tmp));
      pike_module_path-=({tmp});
      pike_module_path=({tmp})+pike_module_path;
    }
  
  //! Remove a directory to search for modules.
  //!
  //! This function performs the reverse operation of @[add_module_path()].
  //!
  //! @seealso
  //! @[add_module_path()]
  //!
  void remove_module_path(string tmp)
    {
      tmp=normalize_path(combine_path_with_cwd(tmp));
      pike_module_path-=({tmp});
    }
  
  //! Add a directory to search for programs.
  //!
  //! This is the same as the command line option @tt{-P@}.
  //!
  //! @seealso
  //! @[remove_program_path()]
  //!
  void add_program_path(string tmp)
    {
      tmp=normalize_path(combine_path_with_cwd(tmp));
      pike_program_path-=({tmp});
      pike_program_path=({tmp})+pike_program_path;
    }
  
  //! Remove a directory to search for programs.
  //!
  //! This function performs the reverse operation of @[add_program_path()].
  //!
  //! @seealso
  //! @[add_program_path()]
  //!
  void remove_program_path(string tmp)
    {
      tmp=normalize_path(combine_path_with_cwd(tmp));
      pike_program_path-=({tmp});
    }

  //! Add a define (without arguments) which will be implicitly
  //! defined in @[cpp] calls.
  void add_predefine (string name, string value)
  {
    predefines[name] = value;
  }

  //! Remove a define from the set that are implicitly defined in
  //! @[cpp] calls.
  void remove_predefine (string name)
  {
    m_delete (predefines, name);
  }

  //! Returns a mapping with the current predefines.
  mapping get_predefines()
  {
    return predefines;
  }

  //!
  mapping get_default_module()
    {
      /* This is an ugly kluge to avoid an infinite recursion.
       * The infinite recursion occurs because this function is
       * called for every file when the compat_major/minor is set.
       * This kluge could cause problems with threads if the
       * compiler was threaded. -Hubbe
       */
      int saved_compat_minor=compat_minor;
      int saved_compat_major=compat_major;
      compat_minor=-1;
      compat_major=-1;

      mixed x;
      mixed err =catch {
	if(resolv("__default") && (x=resolv("__default.all_constants")))
	  x=x();
      };

      compat_major=saved_compat_major;
      compat_minor=saved_compat_minor;
      if(err) throw(err);
      return x;
    }

  //!
  mixed resolv_base(string identifier, string|void current_file,
		    object|void current_handler)
    {
//      werror("Resolv_base(%O)\n",identifier);
      array(mixed) tmp = ({});
      string dir=current_file ? dirname(current_file) : "/";

      foreach(pike_module_path, string path)
	{
	  string file=combine_path(dir, path, identifier);
	  mixed ret = findmodule(file, current_handler);
	  if(objectp (ret)) {	// ret is either zero or an object here.
	    if (ret->is_resolv_dirnode || ret->is_resolv_joinnode) {
	      if (mixed new_ret = ret->_module_value) {
		ret = new_ret;
	      }
	      tmp += ({ ret });
	    } else {
	      if (mixed new_ret = ret->_module_value) {
		ret = new_ret;
	      }
	      if (!sizeof(tmp)) {
		return ret;
	      } else {
		// Ignore
		werror( "Ignoring file %O: %t for identifier %O\n",
			file, ret, identifier );
		continue;
	      }
	    }
	  }
	}
      if (sizeof(tmp)) {
	if (sizeof(tmp) == 1) {
	  return(tmp[0]);
	}
	return joinnode(tmp);
      }
      return UNDEFINED;
    }
  
  mapping resolv_cache = set_weak_flag( ([]), 1 );

  //!
  mixed resolv(string identifier, string|void current_file,
	       object|void current_handler)
    {
#ifdef RESOLV_DEBUG
      werror("Resolv(%O, %O)\n",identifier, current_file);
#endif /* RESOLV_DEBUG */

      // FIXME: Support having the cache in the handler?
      if( no_resolv[ identifier ] ) {
#ifdef RESOLV_DEBUG
	werror("Resolv(%O, %O) => excluded\n",identifier, current_file);
#endif /* RESOLV_DEBUG */
	return UNDEFINED;
      }

      if (current_file && !stringp(current_file)) {
	error( "resolv(%O, %O, %O): current_file is not a string!\n",
	       identifier, current_file, current_handler,
	       backtrace() );
      }

      mixed ret;
      string id=identifier+":"+(current_file ? dirname(current_file) : "-");
      if( zero_type (ret = resolv_cache[id]) != 1 )
      {
//	werror("Resolv cached(%O) => %O (%d)\n",id,resolv_cache[id],zero_type(resolv_cache[id]));
#ifdef RESOLV_DEBUG
	if (ret == ZERO_TYPE)
	  werror("Resolv(%O, %O) => not found (cached)\n",identifier, current_file);
	else
	  werror("Resolv(%O, %O) => found %O (cached)\n",identifier, current_file, ret);
#endif /* RESOLV_DEBUG */
	return ret == ZERO_TYPE ? UNDEFINED : ret;
      }

      array(string) tmp=identifier/".";
      ret=resolv_base(tmp[0], current_file, current_handler);
      foreach(tmp[1..],string index) {
	if (zero_type(ret)) break;
	ret=ret[index];
      }
      resolv_cache[id] = zero_type (ret) ? ZERO_TYPE : ret;
#ifdef RESOLV_DEBUG
      if (zero_type (ret))
	  werror("Resolv(%O, %O) => not found\n",identifier, current_file);
	else
	  werror("Resolv(%O, %O) => found %O\n",identifier, current_file, ret);
#endif /* RESOLV_DEBUG */
      return ret;
    }

  //! This function is called whenever an #include directive is encountered
  //! it receives the argument for #include and should return the file name
  //! of the file to include
  string handle_include(string f,
			string current_file,
			int local_include)
    {
      array(string) tmp;
      string path;
      
      if(local_include)
      {
	tmp=EXPLODE_PATH(current_file);
	tmp[-1]=f;
	path=combine_path_with_cwd(tmp*"/");
      }
      else
      {
	foreach(pike_include_path, path)
	  {
	    path=combine_path(path,f);
	    if(master_file_stat(fakeroot(path)))
	      break;
	    else
	      path=0;
	  }
	
      }
      
      return path;
    }

  //!
  string read_include(string f)
    {
      AUTORELOAD_CHECK_FILE(f)
	return master_read_file(f);
    }

  string _sprintf(int t)
    {
      return t=='O' && sprintf("CompatResolver(%O)",ver);
    }
}

inherit CompatResolver;

//! These are useful if you want to start other Pike processes
//! with the same options as this one was started with.
string _pike_file_name;
string _master_file_name;

// Gets set to 1 if we're in async-mode (script->main() returned <0)
private int(0..1) _async=0;

//! Returns 1 if we´re in async-mode, e.g. if the main method has
//! returned a negative number.
int(0..1) asyncp() {
  return _async;
}

#if constant(thread_create)
// this must be done in __init if someone inherits the master
static object _backend_thread=this_thread();

//! The backend_thread() function is useful to determine if you are
//! the backend thread - important when doing async/sync protocols.
//! This method is only available if thread_create is present.
object backend_thread()
{
   return _backend_thread;
}
#endif

//! This function is called when all the driver is done with all setup
//! of modules, efuns, tables etc. etc. and is ready to start executing
//! _real_ programs. It receives the arguments not meant for the driver
//! and an array containing the environment variables on the same form as
//! a C program receives them.
void _main(array(string) orig_argv, array(string) env)
{
  array(string) argv=copy_value(orig_argv);
  int i,debug,trace,run_tool;
  object tmp;
  string a,b;
  array q;
  string postparseaction=0;
  mixed v;

  predefines = _static_modules.Builtin()->_take_over_initial_predefines();
  _pike_file_name = orig_argv[0];
#if constant(thread_create)
  _backend_thread = this_thread();
#endif

  foreach(env,a)
    {
      if(sscanf(a,"%s=%s",a,b))
      {
	if(a=="") // Special hack for NT
	{
	  sscanf(b,"%s=%s",a,b);
	  a="="+a;
	}
	putenv(a, b);
      }else{
	werror("Broken environment var %s\n",a);
      } 
    }

  void _error(string a, mixed ... b) {
    werror(a, @b);
    exit(1);
  };

#ifndef NOT_INSTALLED
  q=(getenv("PIKE_INCLUDE_PATH")||"")/":"-({""});
  for(i=sizeof(q)-1;i>=0;i--) add_include_path(q[i]);

  q=(getenv("PIKE_PROGRAM_PATH")||"")/":"-({""});
  for(i=sizeof(q)-1;i>=0;i--) add_program_path(q[i]);

  q=(getenv("PIKE_MODULE_PATH")||"")/":"-({""});
  for(i=sizeof(q)-1;i>=0;i--) add_module_path(q[i]);
#endif

  // Some configure scripts depends on this format.
  string format_paths() {
    return  ("master.pike...: " + (_master_file_name || __FILE__) + "\n"
	     "Module path...: " + pike_module_path*"\n"
	     "                " + "\n"
	     "Include path..: " + pike_include_path*"\n"
	     "                " + "\n"
	     "Program path..: " + pike_program_path*"\n"
	     "                " + "\n");
  };

  mixed main_resolv(string ... syms) {
    mixed v = resolv(syms[0]);
    foreach(syms[1..], string sym)
      if(v) v = v[sym];
    if(!v)
      _error("Could not resolv %s\n", syms*".");
    return v;
  };

  if(sizeof(argv)>1 && sizeof(argv[1]) && argv[1][0]=='-')
  {
    tmp = main_resolv("Getopt");
    if (!tmp)
      _error("master.pike: Couldn't resolv Getopt module.\n"
	     "Is your PIKE_MODULE_PATH environment variable set correctly?\n");

    int NO_ARG = tmp->NO_ARG;
    int MAY_HAVE_ARG = tmp->MAY_HAVE_ARG;
    int HAS_ARG = tmp->HAS_ARG;

    q=tmp->find_all_options(argv,({
      ({"compat_version", HAS_ARG, ({"-V", "--compat"}), 0, 0}),
      ({"version",        NO_ARG,  ({"-v", "--version"}), 0, 0}),
      ({"help",           NO_ARG,  ({"-h", "--help"}), 0, 0}),
      ({"features",       NO_ARG,  ({"--features"}), 0, 0}),
      ({"info",           NO_ARG,  ({"--info"}), 0, 0}),
      ({"execute",        HAS_ARG, ({"-e", "--execute"}), 0, 0}),
      ({"debug_without",  HAS_ARG, ({"--debug-without"}), 0, 0}),
      ({"preprocess",     HAS_ARG, ({"-E", "--preprocess"}), 0, 0}),
      ({"modpath",        HAS_ARG, ({"-M", "--module-path"}), 0, 0}),
      ({"ipath",          HAS_ARG, ({"-I", "--include-path"}), 0, 0}),
      ({"ppath",          HAS_ARG, ({"-P", "--program-path"}), 0, 0}),
      ({"showpaths",      NO_ARG,  ({"--show-paths"}), 0, 0}),
      ({"warnings",       NO_ARG,  ({"-w", "--warnings"}), 0, 0}),
      ({"nowarnings",     NO_ARG,  ({"-W", "--woff", "--no-warnings"}), 0, 0}),
      ({"autoreload",     NO_ARG,  ({"--autoreload"}), 0, 0}),
      ({"master",         HAS_ARG, ({"-m"}), 0, 0}),
      ({"compiler_trace", NO_ARG,  ({"--compiler-trace"}), 0, 0}),
      ({"assembler_debug",MAY_HAVE_ARG, ({"--assembler-debug"}), 0, 0}),
      ({"optimizer_debug",MAY_HAVE_ARG, ({"--optimizer-debug"}), 0, 0}),
      ({"debug",          MAY_HAVE_ARG, ({"--debug"}), 0, 1}),
      ({"trace",          MAY_HAVE_ARG, ({"--trace"}), 0, 1}),
      ({"ignore",         MAY_HAVE_ARG, ({"-Dqdatplr"}), 0, 1}),
      ({"ignore",         HAS_ARG, ({"-s"}), 0, 0}),
      ({"run_tool",       NO_ARG,  ({"-x"}), 0, 0}),
    }), 1);

    /* Parse -M and -I backwards */
    for(i=sizeof(q)-1; i>=0; i--)
    {
      switch(q[i][0])
      {
	case "compat_version":
	  sscanf(q[i][1],"%d.%d",compat_major,compat_minor);
	  break;

#ifdef PIKE_AUTORELOAD
      case "autoreload":
	autoreload_on++;
#endif

      case "debug_without":
        foreach( q[i][1]/",", string feature )
        {
          switch( feature )
          {
           case "ttf":
             no_resolv[ "_Image_TTF" ] = 1;
             break;
           case "zlib":
             no_resolv[ "Gz" ] = 1;
             break;
           case "unisys":
             no_resolv[ "_Image_GIF" ] = 1;
             no_resolv[ "_Image_TIFF" ] = 1;
             break;
           case "threads":
             // not really 100% correct, but good enough for most things.
             no_resolv[ "Thread" ] = 1;
             add_constant( "thread_create" );
             break;
           default:
             no_resolv[ feature ] = 1;
             break;
          }
        }
        break;

      case "debug":
	debug+=(int)q[i][1];
	break;

#if constant(_compiler_trace)
      case "compiler_trace":
	_compiler_trace(1);
	break;
#endif /* constant(_compiler_trace) */

#if constant(_assembler_debug)
      case "assembler_debug":
	_assembler_debug((int)q[i][1]);
	break;
#endif /* constant(_assembler_debug) */

#if constant(_optimizer_debug)
      case "optimizer_debug":
	_optimizer_debug((int)q[i][1]);
	break;
#endif /* constant(_optimizer_debug) */

      case "trace":
	trace+=(int)q[i][1];
	break;

      case "modpath":
	add_module_path(q[i][1]);
	break;
	
      case "ipath":
	add_include_path(q[i][1]);
	break;
	
      case "ppath":
	add_program_path(q[i][1]);
	break;

      case "warnings":
	want_warnings++;
	break;

      case "nowarnings":
	want_warnings--;
	break;

      case "master":
	_master_file_name = q[i][1];
	break;

      case "run_tool":
	run_tool = 1;
	break;
      }
    }
    
    foreach(q, array opts)
    {
      switch(opts[0])
      {
      case "version":
	werror(version() + " Copyright © 1994-2003 Linköping University\n"
	       "Pike comes with ABSOLUTELY NO WARRANTY; This is free software and you are\n"
	       "welcome to redistribute it under certain conditions; Read the files\n"
	       "COPYING and COPYRIGHT in the Pike distribution for more details.\n");
	exit(0);
	
      case "help":
	werror("Usage: pike [-driver options] script [script arguments]\n"
	       "Driver options include:\n"
	       " -I --include-path=<p>: Add <p> to the include path\n"
	       " -M --module-path=<p> : Add <p> to the module path\n"
	       " -P --program-path=<p>: Add <p> to the program path\n"
	       " -e --execute=<cmd>   : Run the given command instead of a script.\n"
	       " -h --help            : see this message\n"
	       " -v --version         : See what version of pike you have.\n"
	       " --features           : List Pike features.\n"
	       " --info               : List information about the Pike build and setup.\n"
	       " --show-paths         : See the paths and master that pike uses.\n"
	       " -s#                  : Set stack size\n"
	       " -m <file>            : Use <file> as master object.\n"
	       " -d -d#               : Increase debug (# is how much)\n"
	       " -t -t#               : Increase trace level\n"
	  );
	exit(0);
	
      case "features":
	postparseaction="features";
	break;

      case "info":
	postparseaction="info";
	break;

      case "showpaths":
	werror(format_paths());
	exit(0);
	
      case "execute":
#ifdef __AUTO_BIGNUM__
	main_resolv( "Gmp", "bignum" );
#endif /* __AUTO_BIGNUM__ */

	random_seed(time() ^ (getpid()<<8));
	argv = tmp->get_args(argv,1);

	program prog =
	  compile_string("mixed create(int argc, array(string) argv,array(string) env){"+
			 opts[1]+";}");

#if constant(_debug)
	if(debug) _debug(debug);
#endif
	if(trace) predef::trace(trace);
	mixed err = catch {
	    // One reason for this catch is to get a new call to
	    // eval_instruction in interpret.c so that the debug and
	    // trace levels set above take effect in the bytecode
	    // evaluator.
	    prog(sizeof(argv),argv,env);
	  };
	if(trace) predef::trace(0);
	if (err) {
	  handle_error (err);
	  exit (10);
	}
	exit(0);

      case "preprocess":
#ifdef __AUTO_BIGNUM__
	main_resolv( "Gmp", "bignum" );
#endif /* __AUTO_BIGNUM__ */
	_static_modules.files()->_stdout->write(cpp(master_read_file(opts[1]),
						    opts[1]));
	exit(0);
      }
    }

    argv = tmp->get_args(argv,1);
  }

#ifdef __AUTO_BIGNUM__
  main_resolv( "Gmp", "bignum" );
#endif /* __AUTO_BIGNUM__ */

  switch (postparseaction)
  {
     case "features":
	_static_modules.files()->_stdout->
	  write( main_resolv("Tools", "Install", "features")()*"\n"+"\n" );
	exit(0);

     case "info":
	function w=_static_modules.files()->_stdout->write;
	w("Software......Pike\n"
	  "Version......."+version()+"\n"
	  "WWW...........http://pike.ida.liu.se/\n"
	  "\n");

	w("pike binary..."+_pike_file_name+"\n");
	w( format_paths() + "\n");

	w("Features......"+
	  main_resolv("Tools", "Install", "features")()*"\n              "+
	  "\n");
	exit(0);
  }

  random_seed(time() ^ (getpid()<<8));

  if(sizeof(argv)==1)
  {
    if(run_tool)
      _error( "Pike: -x specified without tool name.\n");
    main_resolv("Tools", "Hilfe")->StdinHilfe();
    exit(0);
  }
  else
    argv=argv[1..];

  program prog;

  if(run_tool) {
    mixed err = catch {
      prog=main_resolv("Tools", "Standalone", argv[0]);
    };

    if (err)
      _error( "Pike: Failed to load tool %s:\n"
	      "%s\n", argv[0],
	      stringp(err[0])?err[0]:describe_backtrace(err) );

    argv[0] = search(master()->programs, prog) || argv[0];
  } else {
    argv[0]=combine_path_with_cwd(argv[0]);

    mixed err = catch {
      prog=(program)argv[0];
    };

    if (err)
      _error( "Pike: Failed to compile script:\n"
	      "%s\n", stringp(err[0])?err[0]:describe_backtrace(err) );
  }

  if(!prog)
    _error("Pike: Couldn't find script to execute\n(%O)\n", argv[0]);

#if constant(_debug)
  if(debug) _debug(debug);
#endif
  if(trace) predef::trace(trace);

  mixed err = catch {
      // The main reason for this catch is actually to get a new call
      // to eval_instruction in interpret.c so that the debug and
      // trace levels set above take effect in the bytecode evaluator.
      object script=prog();
      if(!script->main)
	_error("Error: %s has no main().\n", argv[0]);
      i=script->main(sizeof(argv),argv,env);
    };
  if(trace) predef::trace(0);
  if (err) {
    handle_error (err);
    i = 10;
  }
  if(i >=0) exit(i);
  _async=1;
  
  while(1)
  {
    mixed err=catch 
    {
      while(1)
	_static_modules.Builtin.__backend(3600.0);
    };
    master()->handle_error(err);
  }
}

#if constant(thread_local)
object inhibit_compile_errors = thread_local();

void set_inhibit_compile_errors(mixed f)
{
  inhibit_compile_errors->set(f);
}

mixed get_inhibit_compile_errors()
{
  return inhibit_compile_errors->get();
}
#else /* !constant(thread_local) */
mixed inhibit_compile_errors;

void set_inhibit_compile_errors(mixed f)
{
  inhibit_compile_errors=f;
}

mixed get_inhibit_compile_errors()
{
  return inhibit_compile_errors;
}
#endif /* constant(thread_local) */

static private function(string:string) _trim_file_name_cb=0;
string trim_file_name(string s)
{
#ifdef PIKE_MODULE_RELOC
  s = relocate_module(s);
#endif
  if(getenv("LONG_PIKE_ERRORS")) return s;
  if(getenv("SHORT_PIKE_ERRORS")) return BASENAME(s);

  if (_trim_file_name_cb) return _trim_file_name_cb(s);

  /* getcwd() can fail, but since this is called from handle_error(),
   * we don't want to fail, so we don't care about that.
   */
  catch {
    string cwd=getcwd();
    if (sizeof(cwd) && (cwd[-1] != '/')) {
      cwd += "/";
    }
    if(s[..sizeof(cwd)-1]==cwd) return s[sizeof(cwd)..];
  };
  return s;
}

function(string:string) set_trim_file_name_callback(function(string:string) s)
{
   function(string:string) f=_trim_file_name_cb;
   _trim_file_name_cb=s;
   return f;
}


//! This function is called whenever a compiling error occurs.
//! Nothing strange about it.
//! Note that previous_object cannot be trusted in ths function, because
//! the compiler calls this function.
void compile_error(string file,int line,string err)
{
  mixed val;
  if(! (val = get_inhibit_compile_errors() ))
  {
    werror( "%s:%s:%s\n",trim_file_name(file),
	    line?(string)line:"-",err );
  }
  else if(objectp(val) ||
	  programp(val) ||
	  functionp(val))
  {
    if (objectp(val) && val->compile_error) {
      val->compile_error(file, line, err);
    } else {
      val(file, line, err);
    }
  }
}


//! This function is called whenever a compiling warning occurs.
//! Nothing strange about it.
//! Note that previous_object cannot be trusted in ths function, because
//! the compiler calls this function.
void compile_warning(string file,int line,string err)
{
  mixed val;

  if(!(val = get_inhibit_compile_errors() ))
  {
    if(want_warnings)
      werror( "%s:%s: Warning: %s\n",trim_file_name(file),
	      line?(string)line:"-",err );
  }
  else if (objectp(val) && val->compile_warning) {
    val->compile_warning(file, line, err);
  }
}


//! This function is called when an exception is catched during
//! compilation. Its message is also reported to @[compile_error] if
//! this function returns zero.
int compile_exception (array|object trace)
{
  if (objectp (trace) &&
      (trace->is_cpp_error || trace->is_compilation_error))
    // Errors thrown directly by cpp() and compile() are normally not
    // interesting; they've already been reported to compile_error.
    return 1;
  if (mixed val = get_inhibit_compile_errors()) {
    if (objectp (val) && val->compile_exception)
      return val->compile_exception (trace);
  }
  else {
    handle_error (trace);
    return 1;
  }
  return 0;
}


//! Called for every runtime warning. The first argument identifies
//! where the warning comes from, the second identifies the specific
//! message, and the rest depends on that. See code below for currently
//! implemented warnings.
void runtime_warning (string where, string what, mixed... args)
{
  if (want_warnings)
    switch (where + "." + what) {
      case "gc.bad_cycle":
	// args[0] is an array containing the objects in the cycle
	// which aren't destructed and have destroy() functions.
#if 0
	// Ignore this warning for now since we do not yet have a weak
	// modifier, so it can't be avoided in a reasonable way.
	werror ("GC warning: Garbing cycle where destroy() will be called "
		"in arbitrary order:\n%{            %s\n%}",
		sprintf("%O", args[0][*]));
#endif
	break;

      default:
	werror ("%s warning: %s %O\n", capitalize (where), what, args);
    }
}


static mixed _charset_mod;

//! This function is called by cpp() when it wants to do
//! character code conversion.
string decode_charset(string data, string charset)
{
  // werror(sprintf("decode_charset(%O, %O)\n", data, charset));

  if (!_charset_mod) {
    mixed mod = resolv("Locale");

    _charset_mod = mod && mod["Charset"];
    if (!_charset_mod) {
      compile_warning("-", 0, "No Locale.Charset module!");
      return 0;
    }
  }

  object decoder;

  catch {
    decoder = _charset_mod->decoder(charset);
  };

  if (!decoder) {
    compile_warning("-", 0, sprintf("Unknown charset %O!", charset));
    return 0;
  }
  return decoder->feed(data)->drain();
}



class Describer
{
  int clipped=0;
  int canclip=0;
  mapping(mixed:int|string) ident = ([]);
  int identcount = 0;

  void identify_parts (mixed stuff)
  {
    // Use an array as stack here instead of recursing directly; we
    // might be pressed for stack space if the backtrace being
    // described is a stack overflow.
    array identify_stack = ({stuff});
    while (sizeof (identify_stack)) {
      stuff = identify_stack[-1];
      identify_stack = identify_stack[..sizeof (identify_stack) - 2];
      if (objectp (stuff) || functionp (stuff) || programp (stuff))
	ident[stuff]++;
      else if (arrayp (stuff)) {
	if (!ident[stuff]++)
	  identify_stack += stuff;
      }
      else if (multisetp (stuff)) {
	if (!ident[stuff]++)
	  identify_stack += indices (stuff);
      }
      else if (mappingp (stuff)) {
	if (!ident[stuff]++)
	  identify_stack += indices (stuff) + values (stuff);
      }
      
    }
  }

  string describe_string (string m, int maxlen)
  {
    canclip++;
    if(sizeof(m) < maxlen)
    {
      string t = sprintf("%O", m);
      if (sizeof(t) < (maxlen + 2)) {
	return t;
      }
      t = 0;
    }
    clipped++;
    if(maxlen>10)
    {
      return sprintf("%O+[%d]",m[..maxlen-5],sizeof(m)-(maxlen-5));
    }else{
      return "string["+sizeof(m)+"]";
    }
  }

  string describe_array (array m, int maxlen)
  {
    if(!sizeof(m)) return "({})";
    else {
      if(maxlen<5)
      {
	clipped++;
	return "array["+sizeof(m)+"]";
      }
      else {
	canclip++;
	return "({" + describe_comma_list(m,maxlen-2) +"})";
      }
    }
  }

  string describe_mapping (mapping m, int maxlen)
  {
    if(!sizeof(m)) return "([])";
    else return "mapping["+sizeof(m)+"]";
  }

  string describe_multiset (multiset m, int maxlen)
  {
    if(!sizeof(m)) return "(<>)";
    else return "multiset["+sizeof(m)+"]";
  }

  string describe (mixed m, int maxlen)
  {
    if (stringp (ident[m])) return ident[m];
    else if (intp (ident[m]) && ident[m] > 1)
      ident[m] = "@" + identcount++;

    string res;
    if (catch (res=sprintf("%t",m)))
      res = "object";		// Object with a broken _sprintf(), probably.
    switch(res)
    {
    case "int":
    case "float":
      return (string)m;
    case "string":
      return describe_string (m, maxlen);
    case "array":
      res = describe_array (m, maxlen);
      break;
    case "mapping":
      res = describe_mapping (m, maxlen);
      break;
    case "multiset":
      res = describe_multiset (m, maxlen);
      break;
    case "function":
      if (string tmp=describe_function(m)) res = tmp;
      break;
    case "program":
      if(string tmp=describe_program(m)) res = tmp;
      break;
    default:
      /* object or type. */
      if (catch {
	if(string tmp=sprintf("%O", m)) res = tmp;
      }) {
	// Extra paranoia case.
	res = sprintf("Instance of %O", _typeof(m));
      }
      break;
    }
    if (stringp(ident[m]))
      return ident[m] + "=" + res;
    return res;
  }

  string describe_comma_list(array x, int maxlen)
  {
    string ret="";

    if(!sizeof(x)) return "";
    if(maxlen<0) return ",,,"+sizeof(x);

    int clip=min(maxlen/2,sizeof(x));
    int len=maxlen;
    int done=0;

    //  int loopcount=0;

    while(1)
    {
      //    if(loopcount>10000) werror("len=%d\n",len);
      array(string) z=allocate(clip);
      array(int) isclipped=allocate(clip);
      array(int) clippable=allocate(clip);
      for(int e=0;e<clip;e++)
      {
	clipped=0;
	canclip=0;
	z[e]=describe(x[e],len);
	isclipped[e]=clipped;
	clippable[e]=canclip;
      }

      while(1)
      {
	//      if(loopcount>10000)  werror("clip=%d maxlen=%d\n",clip,maxlen);
	string ret = z[..clip-1]*",";
	//      if(loopcount>10000)  werror("sizeof(ret)=%d z=%O isclipped=%O done=%d\n",sizeof(ret),z[..clip-1],isclipped[..clip-1],done);
	if(done || sizeof(ret)<=maxlen+1)
	{
	  int tmp=sizeof(x)-clip-1;
	  //	if(loopcount>10000) werror("CLIPPED::::: %O\n",isclipped);
	  clipped=`+(0,@isclipped);
	  if(tmp>=0)
	  {
	    clipped++;
	    ret+=",,,"+tmp;
	  }
	  canclip++;
	  return ret;
	}

	int last_newlen=len;
	int newlen;
	int clipsuggest;
	while(1)
	{
	  //	if(loopcount++ > 20000) return "";
	  //	if(!(loopcount & 0xfff)) werror("GNORK\n");
	  int smallsize=0;
	  int num_large=0;
	  clipsuggest=0;

	  for(int e=0;e<clip;e++)
	  {
	    //	    if(loopcount>10000) werror("sizeof(z[%d])=%d  len=%d\n",e,sizeof(z[e]),len);

	    if((sizeof(z[e])>=last_newlen || isclipped[e]) && clippable[e])
	      num_large++;
	    else
	      smallsize+=sizeof(z[e]);

	    if(num_large * 15 + smallsize < maxlen) clipsuggest=e+1;
	  }
	
	  //	if(loopcount>10000) werror("num_large=%d  maxlen=%d  smallsize=%d clippsuggest=%d\n",num_large,maxlen,smallsize,clipsuggest);
	  newlen=num_large ? (maxlen-smallsize)/num_large : 0;
	
	  //	if(loopcount>10000) werror("newlen=%d\n",newlen);

	  if(newlen<8 || newlen >= last_newlen) break;
	  last_newlen=newlen;
	  //	if(loopcount>10000) werror("len decreased, retrying.\n");
	}

	if(newlen < 8 && clip)
	{
	  clip-= (clip/4) || 1;
	  if(clip > clipsuggest) clip=clipsuggest;
	  //	if(loopcount>10000) werror("clip decreased, retrying.\n");
	}else{
	  len=newlen;
	  done++;
	  break;
	}
      }
    }

    return ret;
  }
}


static string get_clean_program_path ( program p, string pref1,
				       string suff1, string suff2 )
{
  array(string) sort_paths_by_length(array(string) paths)
  {
    sort(map(paths, sizeof), paths);
    return reverse(paths);
  };
  string path = search(programs, p);
  if (path) {
    if (path == "/master") return "master"+suff2;
    foreach(sort_paths_by_length(map(pike_module_path - ({""}),
				     lambda(string s) {
				       if (s[-1] == '/') return s;
				       return s+"/";
				     })),
	    string prefix) {
      if (has_prefix(path, prefix)) {
	path = path[sizeof(prefix)..];
	break;
      }
    }
    path = trim_file_name(path);
    string modname = replace(path, ".pmod/", ".");
    if(search(modname, "/")<0) path=modname;
    if (has_suffix(path, ".module.pmod")) {
      return pref1+path[..sizeof(path)-13]+suff1;
    }
    if (has_suffix(path, ".pmod")) {
      return pref1+path[..sizeof(path)-6]+suff1;
    }
    if (has_suffix(path, ".so")) {
      return pref1+path[..sizeof(path)-4]+suff1;
    }
    if (has_suffix(path, ".pike")) {
      return path[..sizeof(path)-6]+suff2;
    }
    return path + suff2;
  }
  return 0;
}


//! Describe the path to the module @[mod].
//!
//! @param mod
//!   If @[mod] is a program, attempt to describe the path
//!   to a clone of @[mod].
//!
//! @param ret_obj
//!   If an instance of @[mod] is found, it will be returned
//!   by changing element @tt{0@} of @[ret_obj].
//!
//! @returns
//!   The a description of the path.
//!
//! @note
//!   The returned description will end with a proper indexing method
//!   currently either @tt{"."@} or @tt{"->"@}.
string describe_module(object|program mod, array(object)|void ret_obj)
{
  if (!mod) return "";
  program parent_fun;
  if (objectp(mod)) {
    parent_fun = object_program(mod);
    if (ret_obj) ret_obj[0] = mod;
  } else {
    parent_fun = mod;
    if (objectp (mod = objects[parent_fun]) && ret_obj) ret_obj[0] = mod;
  }
  if (mod) {
    catch {
      string res = sprintf("%O", mod);
      if (res != "object" && res != "")
	return (objectp (objects[parent_fun]) && programs["/master"] != parent_fun?
		res+".":res+"->");
    };
  }
  if (!object_program(parent_fun)) {
    // We might be a top-level entity.
    string path = get_clean_program_path(parent_fun, "", ".", "()->");
    if(path) return path;
  }
  // Begin by describing our parent.
  array(object) parent_obj = ({ 0 });
  string res = describe_module(function_object(parent_fun)||
			       function_program(parent_fun)||
			       object_program(parent_fun),
			       parent_obj);
  // werror("So far: %O parent_obj:%O\n", res, parent_obj);
  object|program parent =
    objectp (parent_obj[0]) ? parent_obj[0] : object_program(parent_fun);
  if (mod && (objectp (parent) || parent)) {
    // Object identified.
    catch {
      // Check if we're an object in parent.
      int i = search(values(parent), mod);
      if (i >= 0) {
	return res + indices(parent)[i] + ".";
      }
    };
  }

  // We're cloned from something in parent.
  if (string fun_name = function_name(parent_fun)) {
    return res + fun_name + "()->";
  }

  // No such luck.
  // Try identifying a clone of ourselves.
  if (!mod && (objectp (parent) || parent)) {
    catch {
      // Check if there's a clone of parent_fun in parent_obj.
      int i;
      array(mixed) val = values(parent);
      array(string) ind = indices(parent);
      for (i=0; i < sizeof(val); i++) {
	if (objectp(val[i]) && object_program(val[i]) == parent_fun) {
	  return res + ind[i] + ".";
	}
      }
    };
  }

  // We're really out of luck here...
  return res + (describe_program(parent_fun)||"unknown_program") + "()->";
}

//!
string describe_object(object|program o)
{
  string s;
  if(!o) return 0;

  function parent_fun = object_program(o);

  /* Constant object? */
  catch {
    object|program parent_obj =
      (function_object(parent_fun) || function_program(parent_fun));

    if (objectp (parent_obj) || parent_obj) {
      /* Check if we have a constant object. */
      object tmp = objects[parent_obj];
      if (objectp (tmp)) parent_obj = tmp;

      /* Try finding ourselves in parent_obj. */
      int i;
      if (objectp(o)) {
	i = search(values(parent_obj), o);
      } else {
	i = search(map(values(parent_obj),
		       lambda(mixed x) {
			 if (objectp(x)) return object_program(x);
			 return 0;
		       }), o);
      }
      if (i >= 0) {
	s = indices(parent_obj)[i];
	return describe_module(parent_obj) + s;
      }
    }
  };
  if(objectp (objects[parent_fun]))
    if(s=get_clean_program_path(parent_fun, "", "", "()"))
      return s;
  /* Try identifying the program. */
  if(( s=describe_program(parent_fun) ))
    return s+"()";

  return 0;
}

//!
string describe_program(program p)
{
  string s;
  if(!p) return 0;

  if(s=get_clean_program_path(p, "object_program(", ")", ""))
    return s;

  if(mixed tmp=(function_object(p) || function_program(p)))
    if(s = function_name(p))
      {
	return describe_module(tmp) + s;
      }

  if(s=_static_modules.Builtin()->program_defined(p))
    return EXPLODE_PATH(s)[-1];

  return 0;
}

//!
string describe_function (function f)
{
  if (!f) return 0;

  string name;

  if(string s=search(programs,f))
  {
    if(has_suffix(s, ".pmod"))
      name = EXPLODE_PATH(s[..sizeof(s)-6])[-1];
    else
      name = trim_file_name(s);
  }
  else
    if (catch (name = function_name (f))) name = "function";

  object o = function_object(f);
  if(objectp (o)) { // Check if it's an object in a way that (hopefully) doesn't
		    // call any functions in it (neither `== nor `!).
    string s;
    if (!catch (s = sprintf("%O",o)) && s != "object")
      return s+"->"+name;
  }
  return name;
}

/* It is possible that this should be a real efun,
 * it is currently used by handle_error to convert a backtrace to a
 * readable message.
 */

//! @appears describe_backtrace
//! Returns a string containing a readable message that describes where
//! the backtrace was made.
//!
//! The argument @[trace] should normally be the return value from a call
//! to @[backtrace()], or a caught error.
//!
//! @seealso
//! @[backtrace()], @[describe_error()], @[catch()], @[throw()]
//!
string describe_backtrace(mixed trace, void|int linewidth)
{
  int e;
  string ret = "";
  int backtrace_len=((int)getenv("PIKE_BACKTRACE_LEN")) || bt_max_string_len;

  if(!linewidth)
  {
    linewidth=99999;
    catch 
    {
      linewidth=_static_modules.files()->_stdin->tcgetattr()->columns;
    };
    if(linewidth<10) linewidth=99999;
  }

  if((arrayp(trace) && sizeof(trace)==2 && stringp(trace[0])) ||
     (objectp(trace) && trace->is_generic_error))
  {
    if (catch {
      ret = trace[0] || "No error message!\n";
      trace = trace[1];
    }) {
      return "Error indexing backtrace!\n";
    }
    if(!arrayp(trace))
      return ret + "No backtrace.\n";
  }else
    if (!arrayp (trace))
      return sprintf ("Unrecognized backtrace format: %O\n", trace);

  {
    Describer desc = Describer();
    desc->identify_parts (trace);

    int end = 0;
    if( (sizeof(trace)>1) &&
	arrayp(trace[0]) &&
	(sizeof(trace[0]) > 2) &&
	(trace[0][2] == _main))
      end = 1;

    mapping(string:int) prev_pos = ([]);
    array(string) frames = ({});
    int loop_start = 0, loop_next, loops;

    for(e = sizeof(trace)-1; e>=end; e--)
    {
      mixed tmp;
      string row;
      if (mixed err=catch {
	tmp = trace[e];
	if(stringp(tmp))
	{
	  row=tmp;
	}
	else if(arrayp(tmp))
	{
	  string pos;
	  if(sizeof(tmp)>=2 && stringp(tmp[0])) {
	    if (intp(tmp[1])) {

	      string exact_pos = tmp[0] + ":" + tmp[1];

	      pos=trim_file_name(tmp[0])+":"+tmp[1];
	    } else {
	      pos = sprintf("%s:Bad line %t", trim_file_name(tmp[0]), tmp[1]);
	    }
	  }else{
	    mixed desc="Unknown program";
	    if(sizeof(tmp)>=3 && functionp(tmp[2]))
	    {
	      catch 
              {
		if(mixed tmp=function_object(tmp[2]))
		  if(tmp=object_program(tmp))
		    if(tmp=describe_program(tmp))
		      desc=tmp;
	      };
	    }
	    pos=desc;
	  }

	  string data;
	  
	  if(sizeof(tmp)>=3)
	  {
	    if(functionp(tmp[2])) {
	      data = describe_function (tmp[2]);
	    }
	    else if (stringp(tmp[2])) {
	      data= tmp[2];
	    } else
	      data ="unknown function";
	    
	    data+="("+
	      desc->describe_comma_list(tmp[3..], backtrace_len)+
	    ")";

	    if(sizeof(pos)+sizeof(data) < linewidth-4)
	    {
	      row=sprintf("%s: %s",pos,data);
	    }else{
	      row=sprintf("%s:\n%s",pos,sprintf("    %*-/s",linewidth-6,data));
	    }
	  } else {
	    row = pos;
	  }
	}
	else
	{
	  if (tmp) {
	    if (catch (row = sprintf("%O", tmp)))
	      row = describe_program(object_program(tmp)) + " with broken _sprintf()";
	  } else {
	    row = "Destructed object";
	  }
	}
      }) {
  	row = sprintf("Error indexing backtrace line %d: %s (%O)!", e, err[0], err[1]);
      }

      int dup_frame;
      if (!zero_type(dup_frame = prev_pos[row])) {
	dup_frame -= sizeof(frames);
	if (!loop_start) {
	  loop_start = dup_frame;
	  loop_next = dup_frame + 1;
	  loops = 0;
	  continue;
	} else {
	  int new_loop = 0;
	  if (!loop_next) loop_next = loop_start, new_loop = 1;
	  if (dup_frame == loop_next++) {
	    loops += new_loop;
	    continue;
	  }
	}
      }
      prev_pos[row] = sizeof(frames);

      if (loop_start) {
	array(string) tail;
	if (!loop_next) tail = ({}), loops++;
	else tail = frames[loop_start + sizeof(frames) ..
			  loop_next - 1 + sizeof(frames)];
	if (loops)
	  frames += ({sprintf ("... last %d frames above repeated %d times ...\n",
			       -loop_start, loops)});
	frames += tail;
	prev_pos = ([]);
	loop_start = 0;
      }

      frames += ({row + "\n"});
    }

    if (loop_start) {
      // Want tail to contain a full loop rather than being empty; it
      // looks odd when the repeat message ends the backtrace.
      array(string) tail = frames[loop_start + sizeof(frames) ..
				  loop_next - 1 + sizeof(frames)];
      if (loops)
	frames += ({sprintf("... last %d frames above repeated %d times ...\n",
			     -loop_start, loops)});
      frames += tail;
    }

    ret += frames * "";
  }

  return ret;
}

//! @appears describe_error
//! Returns only the error message from a backtrace.
//!
//! If there is no error message in the backtrace, a fallback message
//! will be returned.
//!
//! @seealso
//! @[backtrace()], @[describe_backtrace()]
//!
string describe_error (mixed trace)
{
  if((arrayp(trace) && sizeof(trace)==2 && stringp(trace[0])) ||
     (objectp(trace) && trace->is_generic_error))
  {
    if (catch {
      return trace[0] || "No error message.\n";
    }) {
      return "Error indexing backtrace!\n";
    }
  }
  return sprintf ("Backtrace is of unknown type %t!\n", trace);
}


class Codec (void|string fname, void|int mkobj)
{
  program prog_to_mkobj;

  object __register_new_program(program p)
    {
      if(fname)
      {
	programs[fname]=prog_to_mkobj=p;
	fname=0;
	if (mkobj)
	  return objectp (objects[p]) ? objects[p] : (objects[p]=__null_program());
      }
      return 0;
    }

  mapping f=all_constants();

  string nameof(mixed x)
    {
      if(mixed tmp=search(f,x))
	return "efun:"+tmp;
      
      if (programp(x)) {
	if(mixed tmp=search(programs,x))
	  return tmp;

	if(mixed tmp=search(values(_static_modules), x))
	  return "_static_modules."+(indices(_static_modules)[tmp]);
      }
      else if (objectp(x))
	if(mixed tmp=search(objects,x))
	  if(tmp=search(programs,tmp))
	    return tmp;
      return UNDEFINED;
    } 
  
  function functionof(string x)
    {
      if(sscanf(x,"efun:%s",x)) return f[x];
      if(sscanf(x,"resolv:%s",x)) return resolv(x);
      return 0;
    }
  
  object objectof(string x)
    {
      if(sscanf(x,"efun:%s",x)) return f[x];
      if(sscanf(x,"resolv:%s",x)) return resolv(x);
      if(sscanf(x,"mpath:%s",x))
	foreach(pike_module_path, string path) {
	  object ret = low_cast_to_object(combine_path(path,x),0);
	  if (objectp (ret)) return ret;
	}
      return cast_to_object(x,0);
    }
  
  program programof(string x)
    {
      if(sscanf(x,"efun:%s",x)) return f[x];
      if(sscanf(x,"resolv:%s",x)) return resolv(x);
      if(sscanf(x,"mpath:%s",x))
	foreach(pike_module_path, string path)
	  if(program ret=cast_to_program(combine_path(path,x),0))
	    return ret;
      return cast_to_program(x,0);
    }
  
  mixed encode_object(object x)
    {
      if(x->_encode) return x->_encode();
      error("Cannot encode objects yet.\n");
    }
  
  
  void decode_object(object o, mixed data)
  {
    o->_decode(data);
  }
}


//! Contains version information about a Pike version.
class Version
{

  //! The major and minor parts of the version.
  int major;
  int minor;

  //! @decl void create(int major, int minor)
  //! Set the version in the object.
  void create(int maj, int min)
  {
    major = maj;
    minor = min;
  }

#define CMP(X)  ((major - (X)->major) || (minor - (X)->minor))
  
  //! Methods define so that version objects
  //! can be compared and ordered.
  int `<(Version v) { return CMP(v) < 0; }
  int `>(Version v) { return CMP(v) > 0; }
  int `==(Version v) { return CMP(v)== 0; }
  int _hash() { return major * 4711 + minor ; }

  string _sprintf(int t) {
    switch(t) {
    case 's': return sprintf("%d.%d",major,minor);
    case 'O': return sprintf("%O(%s)", this_program, this_object());
    }
  }

  //! The version object can be casted into a string.
  mixed cast(string type)
    {
      switch(type)
      {
	case "string":
	  return sprintf("%d.%d",major,minor);
      }
    }
}

//! Version information about the current Pike version.
Version currentversion=Version(__MAJOR__,__MINOR__);

mapping(Version:CompatResolver) compat_handler_cache=set_weak_flag( ([]), 1);

CompatResolver get_compilation_handler(int major, int minor)
{
  CompatResolver ret;
  
  Version v=Version(major,minor);

  if(v > currentversion)
  {
    /* do we want to make an error if major.minor > __MAJOR__.__MINOR ? */
    return 0;
  }
  
  if(!zero_type(ret=compat_handler_cache[v])) return ret;

  array files;
  array(Version) available=({});

#if "¤share_prefix¤"[0]!='¤'
  if (!(files = get_dir("¤share_prefix¤"))) {
    werror ("Error listing directory %O: %s\n",
	    "¤share_prefix¤", strerror (errno()));
    files = ({});
  }
  foreach(files, string ver)
    {
      if(sscanf(ver,"%d.%d",int maj, int min))
      {
	Version x=Version(maj, min) ;
	if(x >= v)
	  available|=({ x });
      }
    }
#endif

#if "¤lib_prefix¤"[0]!='¤'
  if (!(files = get_dir("¤lib_prefix¤"))) {
    werror ("Error listing directory %O: %s\n",
	    "¤lib_prefix¤", strerror (errno()));
    files = ({});
  }
  foreach(files, string ver)
    {
      if(sscanf(ver,"%d.%d",int maj, int min))
      {
	Version x=Version(maj, min) ;
	if(x >= v)
	  available|=({ x });
      }
    }
#endif

  sort(available);

#ifndef RESOLVER_HACK
  /* We need to define RESOLVER_HACK when we add
   * version-specific stuff in the CompatResolver.
   * As long as all the compatibility is done in the
   * module dierctories, RESOLVER_HACK can be undefined
   */

  /* No compat needed */
  if(!sizeof(available))
  {
    compat_handler_cache[v]=0;
    return 0;
  }

  /* Same as available[0] */
  if(ret=compat_handler_cache[available[0]])
    return compat_handler_cache[v]=ret;
#endif

  ret=CompatResolver(v);
  /* Add default paths */
  ret->pike_module_path=pike_module_path;
  ret->pike_include_path=pike_include_path;

  foreach(reverse(available), Version tmp)
    {
      string base;
#if "¤lib_prefix¤"[0]!='¤'
      base=combine_path("¤lib_prefix¤",sprintf("%s",tmp));
      ret->add_module_path(combine_path(base,"modules"));
      ret->add_include_path(combine_path(base,"include"));
#endif

#if "¤share_prefix¤"[0]!='¤'
      base=combine_path("¤share_prefix¤",sprintf("%s",tmp));
      ret->add_module_path(combine_path(base,"modules"));
      ret->add_include_path(combine_path(base,"include"));
#endif
    }

  if( v <= Version(0,6))
    ret->pike_module_path+=({"."});

  compat_handler_cache[v] = ret;

#ifndef RESOLVER_HACK
  compat_handler_cache[available[0]] = ret; /* may be equal to 'v' */
#endif

  return ret;
}

string _sprintf(int t)
{
  switch(t) {
  case 't': return "master";
  case 'O': return "master()";
  }
}

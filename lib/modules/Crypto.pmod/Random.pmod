#pike __REAL_VERSION__
// $Id: Random.pmod,v 1.9 2004/03/10 00:38:50 nilsson Exp $

//! This module contains stuff to that tries to give you the
//! best possible random generation.

#if constant(Nettle.Yarrow)

#if !constant(Crypto.NT)
static string dev_urandom;
static string dev_random;

void create() {
  if(file_stat("/dev/urandom")) dev_urandom = "/dev/urandom";
  if(file_stat("/dev/random")) dev_random = "/dev/random";
  if(dev_random && !dev_urandom) dev_urandom=dev_random;
  if(!dev_random && dev_urandom) dev_random=dev_urandom;
}
#endif

static class RND {
  inherit Nettle.Yarrow;
  static int bytes_left = 32;

#if constant(Crypto.NT)
  static Crypto.NT.CryptContext ctx;
#else
  static Stdio.File f;
#endif

  static int last_tick;
  static function ticker;

  static void create(int(0..1) no_block) {
    // Source 0: /dev/random or CryptGenRandom
    // Source 1: ticker
    // Source 2: external
    ::create(3);
    int entropy_needed = min_seed_size()*2;

#if constant(Crypto.NT)
    ctx = Crypto.NT.CryptContext(0, 0, Crypto.NT.PROV_RSA_FULL,
				 Crypto.NT.CRYPT_VERIFYCONTEXT );
    seed( ctx->read(entropy_needed) );
#else
    if (dev_random) {
      if(no_block)
	f = Stdio.File(dev_urandom, "r");
      else
	f = Stdio.File(dev_random, "r");
    } else {
      // No entropy device.
      f = Stdio.File();
      Stdio.File child_pipe = f->pipe();
      if (!child_pipe) {
	f = 0;
      } else {
	// Attempt to generate some entropy by running some
	// statistical commands.
	mapping(string:string) env = getenv() + ([
	  "PATH":"/usr/sbin:/usr/etc:/usr/bin/:/sbin/:/etc:/bin",
	]);
	mapping(string:mixed) modifiers = ([
	  "stdin":Stdio.File("/dev/null", "rw"),
	  "stdout":child_pipe,
	  "stderr":child_pipe,
	  "env":env,
	]);
	foreach(({ ({ "last", "-256" }),
		   ({ "arp", "-a" }), 
		   ({ "netstat", "-anv" }), ({ "netstat", "-mv" }),
		   ({ "netstat", "-sv" }), 
		   ({ "uptime" }),
		   ({ "ps", "-fel" }), ({ "ps", "aux" }),
		   ({ "vmstat", "-f" }), ({ "vmstat", "-s" }),
		   ({ "vmstat", "-M" }),
		   ({ "iostat" }), ({ "iostat", "-t" }),
		   ({ "iostat", "-cdDItx" }),
		   ({ "ipcs", "-a" }),
		   ({ "pipcs", "-a" }),
		   }), array(string) cmd) {
	  catch {
	    Process.create_process(cmd, modifiers);
	  };
	}
	child_pipe->close();
	destruct(child_pipe);
	// We need as much as we can get.
	entropy_needed = 0x7fffffff;
      }
    }
    if (!f) {
      error("Failed to open entropy source.\n");
    }
    seed( f->read(entropy_needed) );
#endif

#if constant(System.rdtsc)
    ticker = System.rdtsc;
#elif constant(gethrtime)
    ticker = gethrtime;
#else
    ticker = time;
#endif
  }

  string random_string(int len) {
    String.Buffer buf = String.Buffer(len);
    int new_tick = ticker();
    update( (string)(new_tick-last_tick), 1, 1 );
    last_tick = new_tick;

    while(len) {
      int pass = min(len, bytes_left);
      buf->add( ::random_string(pass) );
      bytes_left -= pass;
      len -= pass;
      if(!bytes_left) {
#if constant(Crypto.NT)
	// CryptGenRandom claims to be cryptographically strong.
	update( ctx->read(32), 0, 256 );
#else
	// Only trust 50% randomness.
	update( f->read(64), 0, 256 );
#endif
	bytes_left = 32;
      }
    }
    return (string)buf;
  }
}

static string rnd_bootstrap(int len) {
  rnd_obj = RND(1);
  rnd_func = rnd_obj->random_string;
  return rnd_func(len);
}

static RND rnd_obj;
static function(int:string) rnd_func = rnd_bootstrap;

static string rnd_block_bootstrap(int len) {
  rnd_block_obj = RND(0);
  rnd_block_func = rnd_block_obj->random_string;
  return rnd_block_func(len);
}

static RND rnd_block_obj;
static function(int:string) rnd_block_func = rnd_block_bootstrap;


//! Returns a string of length @[len] with random content. The
//! content is generated by a Yarrow random generator that is
//! constantly updated with output from /dev/random on UNIX and
//! CryptGenRandom on NT. The Yarrow random generator is fed
//! at least the amount of random data from its sources as it
//! outputs, thus doing its best to give at least good pseudo-
//! random data on operating systems with bad /dev/random.
string random_string(int len) {
  return rnd_func(len);
}

//! Returns a @[Gmp.mpz] object with a random value between @expr{0@}
//! and @[top]. Uses @[random_string].
Gmp.mpz random(int top) {
  return Gmp.mpz(rnd_func( (int)ceil( log((float)top)/log(2.0) ) ),
		 256) % top;
}

//! Works as @[random_string], but may block in order to gather
//! enough entropy to make a truely random output.
string blocking_random_string(int len) {
  return rnd_block_func(len);
}

//! Inject additional entropy into the random generator.
//! @param data
//!   The random string.
//! @param entropy
//!   The number of bits in the random string that is
//!   truely random.
void add_entropy(string data, int entropy) {
  if(rnd_obj)
    rnd_obj->update(data, 2, entropy);
  if(rnd_block_obj)
    rnd_block_obj->update(data, 2, entropy);
}

#endif

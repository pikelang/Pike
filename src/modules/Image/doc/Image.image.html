<title>Pike documentation: Image.image</title>
<h2>Image.image</h2>

<hr>
   <i><tt><tt><a href=#>`&</a></tt></tt></i><br>
   <i><tt><tt><a href=#>`*</a></tt></tt></i><br>
   <i><tt><tt><a href=#>`+</a></tt></tt></i><br>
   <i><tt><tt><a href=#>`-</a></tt></tt></i><br>
   <i><tt><tt><a href=#>`|</a></tt></tt></i><br>
   <i><tt><tt><a href=#>add_layers</a></tt></tt></i><br>
   <i><tt><tt><a href=#>apply_matrix</a></tt></tt></i><br>
   <i><tt><tt><a href=#>autocrop</a></tt></tt></i><br>
   <i><tt><tt><a href=#>box</a></tt></tt></i><br>
   <i><tt><tt><a href=#>cast</a></tt></tt></i><br>
   <i><tt><tt><a href=#>ccw</a></tt></tt></i><br>
   <i><tt><tt><a href=#>change_color</a></tt></tt></i><br>
   <i><tt><tt><a href=#>circle</a></tt></tt></i><br>
   <i><tt><tt><a href=#>clear</a></tt></tt></i><br>
   <i><tt><tt><a href=#>clone</a></tt></tt></i><br>
   <i><tt><tt><a href=#>color</a></tt></tt></i><br>
   <i><tt><tt><a href=#>copy</a></tt></tt></i><br>
   <i><tt><tt><a href=#>create</a></tt></tt></i><br>
   <i><tt><tt><a href=#>cw</a></tt></tt></i><br>
   <i><tt><tt><a href=#>dct</a></tt></tt></i><br>
   <i><tt><tt><a href=#>distancesq</a></tt></tt></i><br>
   <i><tt><tt><a href=#>fromgif</a></tt></tt></i><br>
   <i><tt><tt><a href=#>frompnm</a></tt></tt></i><br>
   <i><tt><tt><a href=#>fromppm</a></tt></tt></i><br>
   <i><tt><tt><a href=#>getpixel</a></tt></tt></i><br>
   <i><tt><tt><a href=#>gif_add</a></tt></tt></i><br>
   <i><tt><tt><a href=#>gif_add_fs</a></tt></tt></i><br>
   <i><tt><tt><a href=#>gif_add_fs_nomap</a></tt></tt></i><br>
   <i><tt><tt><a href=#>gif_add_nomap</a></tt></tt></i><br>
   <i><tt><tt><a href=#>gif_begin</a></tt></tt></i><br>
   <i><tt><tt><a href=#>gif_end</a></tt></tt></i><br>
   <i><tt><tt><a href=#>gif_netscape_loop</a></tt></tt></i><br>
   <i><tt><tt><a href=#>grey</a></tt></tt></i><br>
   <i><tt><tt><a href=#>invert</a></tt></tt></i><br>
   <i><tt><tt><a href=#>line</a></tt></tt></i><br>
   <i><tt><tt><a href=#>map_closest</a></tt></tt></i><br>
   <i><tt><tt><a href=#>map_fast</a></tt></tt></i><br>
   <i><tt><tt><a href=#>mirrorx</a></tt></tt></i><br>
   <i><tt><tt><a href=#>modify_by_intensity</a></tt></tt></i><br>
   <i><tt><tt><a href=#>paste</a></tt></tt></i><br>
   <i><tt><tt><a href=#>paste_alpha</a></tt></tt></i><br>
   <i><tt><tt><a href=#>paste_alpha_color</a></tt></tt></i><br>
   <i><tt><tt><a href=#>paste_mask</a></tt></tt></i><br>
   <i><tt><tt><a href=#>rotate</a></tt></tt></i><br>
   <i><tt><tt><a href=#>rotate_expand</a></tt></tt></i><br>
   <i><tt><tt><a href=#>scale</a></tt></tt></i><br>
   <i><tt><tt><a href=#>select_from</a></tt></tt></i><br>
   <i><tt><tt><a href=#>setcolor</a></tt></tt></i><br>
   <i><tt><tt><a href=#>setpixel</a></tt></tt></i><br>
   <i><tt><tt><a href=#>skewx</a></tt></tt></i><br>
   <i><tt><tt><a href=#>skewx_expand</a></tt></tt></i><br>
   <i><tt><tt><a href=#>skewy</a></tt></tt></i><br>
   <i><tt><tt><a href=#>skewy_expand</a></tt></tt></i><br>
   <i><tt><tt><a href=#>to8bit</a></tt></tt></i><br>
   <i><tt><tt><a href=#>to8bit_closest</a></tt></tt></i><br>
   <i><tt><tt><a href=#>to8bit_fs</a></tt></tt></i><br>
   <i><tt><tt><a href=#>to8bit_rgbcube</a></tt></tt></i><br>
   <i><tt><tt><a href=#>to8bit_rgbcube_rdither</a></tt></tt></i><br>
   <i><tt><tt><a href=#>tobitmap</a></tt></tt></i><br>
   <i><tt><tt><a href=#>togif</a></tt></tt></i><br>
   <i><tt><tt><a href=#>togif_fs</a></tt></tt></i><br>
   <i><tt><tt><a href=#>toppm</a></tt></tt></i><br>
   <i><tt><tt><a href=#>tozbgr</a></tt></tt></i><br>
   <i><tt><tt><a href=#>treshold</a></tt></tt></i><br>
   <i><tt><tt><a href=#>tuned_box</a></tt></tt></i><br>
   <i><tt><tt><a href=#>xsize</a></tt></tt></i><br>
   <i><tt><tt><a href=#>ysize</a></tt></tt></i><br>


<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`&</b>(object&nbspoperand)<br>
object <b>`&</b>(array(int)&nbspcolor)<br>
object <b>`&</b>(int&nbspvalue)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
makes a new image out of the minimum pixels values
     

<p> object operand
     the other image to compare with;
     the images must have the same size.
 array(int) color
     an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.
 int value
     equal to ({value,value,value}).
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>`-</a></tt>,
     <tt><a href=#>`+</a></tt>,
     <tt><a href=#>`|</a></tt>,
     <tt><a href=#>`*</a></tt>,
     <tt><a href=#>add_layers</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`*</b>(object&nbspoperand)<br>
object <b>`*</b>(array(int)&nbspcolor)<br>
object <b>`*</b>(int&nbspvalue)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Multiplies pixel values and creates a new image.

<p>     This can be useful to lower the values of an image,
     making it greyer, for instance:

<p>     <pre>image=image*128+64;</pre>

<p> object operand
     the other image to multiply with;
     the images must have the same size.
 array(int) color
     an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.
 int value
     equal to ({value,value,value}).
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>`-</a></tt>,
     <tt><a href=#>`+</a></tt>,
     <tt><a href=#>`|</a></tt>,
     <tt><a href=#>`&</a></tt>,
     <tt><a href=#>add_layers</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`+</b>(object&nbspoperand)<br>
object <b>`+</b>(array(int)&nbspcolor)<br>
object <b>`+</b>(int&nbspvalue)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
adds two images; values are truncated at 255.

<p> object operand
     the image which to add.
 array(int) color
     an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.
 int value
     equal to ({value,value,value}).
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>`-</a></tt>,
     <tt><a href=#>`|</a></tt>,
     <tt><a href=#>`&</a></tt>,
     <tt><a href=#>`*</a></tt>,
     <tt><a href=#>add_layers</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`-</b>(object&nbspoperand)<br>
object <b>`-</b>(array(int)&nbspcolor)<br>
object <b>`-</b>(int&nbspvalue)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
makes a new image out of the difference

<p> object operand
     the other image to compare with;
     the images must have the same size.
 array(int) color
     an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.
 int value
     equal to ({value,value,value}).
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>`+</a></tt>,
     <tt><a href=#>`|</a></tt>,
     <tt><a href=#>`&</a></tt>,
     <tt><a href=#>`*</a></tt>,
     <tt><a href=#>add_layers</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`|</b>(object&nbspoperand)<br>
object <b>`|</b>(array(int)&nbspcolor)<br>
object <b>`|</b>(int&nbspvalue)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
makes a new image out of the maximum pixels values
     

<p> object operand
     the other image to compare with;
     the images must have the same size.
 array(int) color
     an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.
 int value
     equal to ({value,value,value}).
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>`-</a></tt>,
     <tt><a href=#>`+</a></tt>,
     <tt><a href=#>`&</a></tt>,
     <tt><a href=#>`*</a></tt>,
     <tt><a href=#>add_layers</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>add_layers</b>(array(int|object))&nbsplayer0, ...)<br>
object <b>add_layers</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2, array(int|object))&nbsplayer0, ...)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Using the called object as base, adds layers using masks,
     opaque channel values and special methods.

<p>     The destination image can also be cropped, thus
     speeding up the process.

<p>     Each array in the layers array is one of:
     <pre>
     ({object image,object|int mask})
     ({object image,object|int mask,int opaque_value})
     ({object image,object|int mask,int opaque_value,int method})
     </pre>
     Given 0 as mask means the image is totally opaque.

<p>     Default opaque value is 255, only using the mask.

<p>     Methods for now are:
     <pre>
     0  no operation (just paste with mask, default)
     1  maximum  (`|)
     2  minimum  (`&)
     3  multiply (`*)
     4  add      (`+)
     5  diff     (`-)
     </pre>
     The layer image and the current source are calculated
     through the given method and then pasted using the mask
     and the opaque channel value. 

<p>     All given images must be the same size.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(int|object) layer0</tt>
  <dd>image to paste
<dt><tt>int x1</tt>
<dt><tt>int y1</tt>
<dt><tt>int x2</tt>
<dt><tt>int y2</tt>
  <dd>rectangle for cropping
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
a new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>paste_mask</a></tt>,
     <tt><a href=#>paste_alpha</a></tt>,
     <tt><a href=#>paste_alpha_color</a></tt>,
     <tt><a href=#>`|</a></tt>,
     <tt><a href=#>`&</a></tt>,
     <tt><a href=#>`*</a></tt>,
     <tt><a href=#>`+</a></tt>,
     <tt><a href=#>`-</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>apply_matrix</b>(array(array(int|array(int)))&nbspmatrix)<br>
object <b>apply_matrix</b>(array(array(int|array(int)))&nbspmatrix, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>apply_matrix</b>(array(array(int|array(int)))&nbspmatrix, int&nbspr, int&nbspg, int&nbspb, int|float&nbspdiv)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Applies a pixel-transform matrix, or filter, to the image.
    
     <pre>
                            2   2
     pixel(x,y)= base+ k ( sum sum pixel(x+k-1,y+l-1)*matrix(k,l) ) 
                           k=0 l=0 
     </pre>
     
     1/k is sum of matrix, or sum of matrix multiplied with div.
     base is given by r,g,b and is normally black.

<p>     blur (ie a 2d gauss function):
     <pre>
     ({({1,2,1}),
       ({2,5,2}),
       ({1,2,1})})
     </pre>
     
     sharpen (k>8, preferably 12 or 16):
     <pre>
     ({({-1,-1,-1}),
       ({-1, k,-1}),
       ({-1,-1,-1})})
     </pre>

<p>     edge detect:
     <pre>
     ({({1, 1,1}),
       ({1,-8,1}),
       ({1, 1,1})})
     </pre>

<p>     horisontal edge detect (get the idea):
     <pre>
     ({({0, 0,0})
       ({1,-8,1}),
       ({0, 0,0})})
     </pre>

<p>     emboss (might prefer to begin with a <tt><a href=#>grey</a></tt> image):
     <pre>
     ({({2, 1, 0})
       ({1, 0,-1}),
       ({0,-1, 2})}), 128,128,128, 5
     </pre>

<p>     This function is not very fast, and it's hard to 
     optimize it more, not using assembler.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(array(int|array(int)))</tt>
  <dd>the matrix; innermost is a value or an array with red, green, blue
     values for red, green, blue separation.
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>base level of result, default is zero
<dt><tt>int|float div</tt>
  <dd>division factor, default is 1.0.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>autocrop</b>()<br>
object <b>autocrop</b>(int&nbspborder)<br>
object <b>autocrop</b>(int&nbspborder, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>autocrop</b>(int&nbspborder, int&nbspleft, int&nbspright, int&nbsptop, int&nbspbottom)<br>
object <b>autocrop</b>(int&nbspborder, int&nbspleft, int&nbspright, int&nbsptop, int&nbspbottom, int&nbspr, int&nbspg, int&nbspb)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Removes "unneccesary" borders around the image, adds one of
     its own if wanted to, in selected directions.

<p>     "Unneccesary" is all pixels that are equal -- ie if all the same pixels
     to the left are the same color, that column of pixels are removed.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int border</tt>
  <dd>added border size in pixels
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color of the new border
<dt><tt>int left</tt>
<dt><tt>int right</tt>
<dt><tt>int top</tt>
<dt><tt>int bottom</tt>
  <dd>which borders to scan and cut the image; 
     a typical example is removing the top and bottom unneccesary
     pixels:
     <pre>img=img->autocrop(0, 0,0,1,1);</pre>
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>copy</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>box</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2)<br>
object <b>box</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>box</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2, int&nbspr, int&nbspg, int&nbspb, int&nbspalpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Draws a filled rectangle on the image.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x1</tt>
<dt><tt>int y1</tt>
<dt><tt>int x2</tt>
<dt><tt>int y2</tt>
  <dd>box corners
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color of the box
<dt><tt>int alpha</tt>
  <dd>alpha value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>cast</b>(string&nbsptype)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
known bugs: always casts to string...
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the image data as a string ("rgbrgbrgb...")
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>toppm</a></tt>,
     <tt><a href=#>togif</a></tt>,
     <tt><a href=#>tozbgr</a></tt>,
     <tt><a href=#>to8bit</a></tt>,
     <tt><a href=#>to8bit_rgbcube</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>ccw</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
rotates an image counter-clockwise, 90 degrees.
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>change_color</b>(int&nbsptor, int&nbsptog, int&nbsptob)<br>
object <b>change_color</b>(int&nbspfromr, int&nbspfromg, int&nbspfromb, &nbspint&nbsptor, int&nbsptog, int&nbsptob)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Changes one color (exakt match) to another.
     If non-exakt-match is preferred, check <tt><a href=#>distancesq</a></tt>
     and <tt><a href=#>paste_alpha_color</a></tt>.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int tor</tt>
<dt><tt>int tog</tt>
<dt><tt>int tob</tt>
  <dd>destination color and next current color
<dt><tt>int fromr</tt>
<dt><tt>int fromg</tt>
<dt><tt>int fromb</tt>
  <dd>source color, default is current color
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
a new (the destination) image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>circle</b>(int&nbspx, int&nbspy, int&nbsprx, int&nbspry)<br>
object <b>circle</b>(int&nbspx, int&nbspy, int&nbsprx, int&nbspry, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>circle</b>(int&nbspx, int&nbspy, int&nbsprx, int&nbspry, int&nbspr, int&nbspg, int&nbspb, int&nbspalpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Draws a line on the image. The line is <i>not</i> antialiased.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>circle center
<dt><tt>int rx</tt>
<dt><tt>int ry</tt>
  <dd>circle radius in pixels
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color
<dt><tt>int alpha</tt>
  <dd>alpha value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>void <b>clear</b>()<br>
void <b>clear</b>(int&nbspr, int&nbspg, int&nbspb)<br>
void <b>clear</b>(int&nbspr, int&nbspg, int&nbspb, int&nbspalpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
gives a new, cleared image with the same size of drawing area
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color of the new image
<dt><tt>int alpha</tt>
  <dd>new default alpha channel value
</dl></blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>copy</a></tt>,
     <tt><a href=#>clone</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>clone</b>()<br>
object <b>clone</b>(int&nbspxsize, int&nbspysize)<br>
object <b>clone</b>(int&nbspxsize, int&nbspysize, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>clone</b>(int&nbspxsize, int&nbspysize, int&nbspr, int&nbspg, int&nbspb, int&nbspalpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Copies to or initialize a new image object.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int xsize</tt>
<dt><tt>int ysize</tt>
  <dd>size of (new) image in pixels, called image
     is cropped to that size
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>current color of the new image, 
     default is black. 
     Will also be the background color if the cloned image
     is empty (no drawing area made).
<dt><tt>int alpha</tt>
  <dd>new default alpha channel value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>copy</a></tt>,
     <tt><a href=#>create</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>color</b>()<br>
object <b>color</b>(int&nbspvalue)<br>
object <b>color</b>(int&nbspr, int&nbspg, int&nbspb)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Colorize an image. 

<p>    The red, green and blue values of the pixels are multiplied
    with the given value(s). This works best on a grey image...

<p>    The result is divided by 255, giving correct pixel values.

<p>    If no arguments are given, the current color is used as factors.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>red, green, blue factors
<dt><tt>int value</tt>
  <dd>factor
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>grey</a></tt>,
     <tt><a href=#>`*</a></tt>,
     <tt><a href=#>modify_by_intensity</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>copy</b>()<br>
object <b>copy</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2)<br>
object <b>copy</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>copy</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2, int&nbspr, int&nbspg, int&nbspb, int&nbspalpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Copies this part of the image. The requested area can
     be smaller, giving a cropped image, or bigger - 
     the new area will be filled with the given or current color.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x1</tt>
<dt><tt>int y1</tt>
<dt><tt>int x2</tt>
<dt><tt>int y2</tt>
  <dd>The requested new area. Default is the old image size.
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color of the new image
<dt><tt>int alpha</tt>
  <dd>new default alpha channel value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
a new image object
</blockquote>


<h4>NOTE</h4>
<blockquote>
     Copies this part of the image. The requested area can
     be smaller, giving a cropped image, or bigger - 
     the new area will be filled with the given or current color.


</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>clone</a></tt>,
     <tt><a href=#>autocrop</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>void <b>create</b>()<br>
void <b>create</b>(int&nbspxsize, int&nbspysize)<br>
void <b>create</b>(int&nbspxsize, int&nbspysize, int&nbspr, int&nbspg, int&nbspb)<br>
void <b>create</b>(int&nbspxsize, int&nbspysize, int&nbspr, int&nbspg, int&nbspb, int&nbspalpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Initializes a new image object.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int xsize</tt>
<dt><tt>int ysize</tt>
  <dd>size of (new) image in pixels
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>background color (will also be current color),
     default color is black
<dt><tt>int alpha</tt>
  <dd>default alpha channel value
</dl></blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>copy</a></tt>,
     <tt><a href=#>clone</a></tt>,
     <tt><a href=#>Image.image</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>cw</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
rotates an image clockwise, 90 degrees.
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>dct</b>(int&nbspnewx, int&nbspnewy)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Scales the image to a new size.
     
     Method for scaling is rather complex;
     the image is transformed via a cosine transform,
     and then resampled back.

<p>     This gives a quality-conserving upscale,
     but the algorithm used is n*n+n*m, where n
     and m is pixels in the original and new image.

<p>     Recommended wrapping algorithm is to scale
     overlapping parts of the image-to-be-scaled.

<p>     This functionality is actually added as an
     true experiment, but works...
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int newx</tt>
<dt><tt>int newy</tt>
  <dd>new image size in pixels
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>distancesq</b>()<br>
object <b>distancesq</b>(int&nbspr, int&nbspg, int&nbspb)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes an grey-scale image, for alpha-channel use.
    
    The given value (or current color) are used for coordinates
    in the color cube. Each resulting pixel is the 
    distance from this point to the source pixel color,
    in the color cube, squared, rightshifted 8 steps:

<p>    <pre>
    p = pixel color
    o = given color
    d = destination pixel
    d.red=d.blue=d.green=
        ((o.red-p.red)²+(o.green-p.green)²+(o.blue-p.blue)²)>>8
    </pre>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>red, green, blue coordinates
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>select_from</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>fromgif</b>(string&nbspgif)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Reads GIF data to the called image object.

<p>     GIF animation delay or loops are ignored,
     and the resulting image is the written result.
 known bugs: yes, it does -- it may even do segment overrides...
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>string pnm</tt>
  <dd>pnm data, as a string
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>togif</a></tt>,
     <tt><a href=#>frompnm</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object|string <b>frompnm</b>(string&nbsppnm)<br>
object|string <b>fromppm</b>(string&nbsppnm)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Reads a PNM (PBM, PGM or PPM in ascii or binary)
     to the called image object.

<p>     The method accepts P1 through P6 type of PNM data.

<p>     "fromppm" is an alias for "frompnm".
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>string pnm</tt>
  <dd>pnm data, as a string
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object or a hint of what wronged.
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>toppm</a></tt>,
     <tt><a href=#>fromgif</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>array(int) <b>getpixel</b>(int&nbspx, int&nbspy)</tt>
</blockquote>

<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>position of the pixel
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
color of the requested pixel -- ({int red,int green,int blue})
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>gif_add</b>()<br>
string <b>gif_add</b>(int&nbspx, int&nbspy)<br>
string <b>gif_add</b>(int&nbspx, int&nbspy, int&nbspdelay_cs)<br>
string <b>gif_add</b>(int&nbspx, int&nbspy, float&nbspdelay_s)<br>
string <b>gif_add</b>(int&nbspx, int&nbspy, int&nbspnum_colors, int&nbspdelay_cs)<br>
string <b>gif_add</b>(int&nbspx, int&nbspy, int&nbspnum_colors, float&nbspdelay_s)<br>
string <b>gif_add</b>(int&nbspx, int&nbspy, array(array(int))&nbspcolors, int&nbspdelay_cs)<br>
string <b>gif_add</b>(int&nbspx, int&nbspy, array(array(int))&nbspcolors, float&nbspdelay_s)<br>
string <b>gif_add_fs</b>()<br>
string <b>gif_add_fs</b>(int&nbspx, int&nbspy)<br>
string <b>gif_add_fs</b>(int&nbspx, int&nbspy, int&nbspdelay_cs)<br>
string <b>gif_add_fs</b>(int&nbspx, int&nbspy, float&nbspdelay_s)<br>
string <b>gif_add_fs</b>(int&nbspx, int&nbspy, int&nbspnum_colors, int&nbspdelay_cs)<br>
string <b>gif_add_fs</b>(int&nbspx, int&nbspy, int&nbspnum_colors, float&nbspdelay_s)<br>
string <b>gif_add_fs</b>(int&nbspx, int&nbspy, array(array(int))&nbspcolors, int&nbspdelay_cs)<br>
string <b>gif_add_fs</b>(int&nbspx, int&nbspy, array(array(int))&nbspcolors, float&nbspdelay_s)<br>
string <b>gif_add_nomap</b>()<br>
string <b>gif_add_nomap</b>(int&nbspx, int&nbspy)<br>
string <b>gif_add_nomap</b>(int&nbspx, int&nbspy, int&nbspdelay_cs)<br>
string <b>gif_add_nomap</b>(int&nbspx, int&nbspy, float&nbspdelay_s)<br>
string <b>gif_add_nomap</b>(int&nbspx, int&nbspy, int&nbspnum_colors, int&nbspdelay_cs)<br>
string <b>gif_add_nomap</b>(int&nbspx, int&nbspy, int&nbspnum_colors, float&nbspdelay_s)<br>
string <b>gif_add_nomap</b>(int&nbspx, int&nbspy, array(array(int))&nbspcolors, int&nbspdelay_cs)<br>
string <b>gif_add_nomap</b>(int&nbspx, int&nbspy, array(array(int))&nbspcolors, float&nbspdelay_s)<br>
string <b>gif_add_fs_nomap</b>()<br>
string <b>gif_add_fs_nomap</b>(int&nbspx, int&nbspy)<br>
string <b>gif_add_fs_nomap</b>(int&nbspx, int&nbspy, int&nbspdelay_cs)<br>
string <b>gif_add_fs_nomap</b>(int&nbspx, int&nbspy, float&nbspdelay_s)<br>
string <b>gif_add_fs_nomap</b>(int&nbspx, int&nbspy, int&nbspnum_colors, int&nbspdelay_cs)<br>
string <b>gif_add_fs_nomap</b>(int&nbspx, int&nbspy, int&nbspnum_colors, float&nbspdelay_s)<br>
string <b>gif_add_fs_nomap</b>(int&nbspx, int&nbspy, array(array(int))&nbspcolors, int&nbspdelay_cs)<br>
string <b>gif_add_fs_nomap</b>(int&nbspx, int&nbspy, array(array(int))&nbspcolors, float&nbspdelay_s)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes a GIF (sub)image data chunk, to be placed 
     at the given position. The "fs" versions uses
     floyd-steinberg dithering, and the "nomap" versions
     have no local colormap.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>the location of this subimage
<dt><tt>int delay_cs</tt>
  <dd>frame delay in centiseconds
<dt><tt>float delay_s</tt>
  <dd>frame delay in seconds
<dt><tt>int num_colors</tt>
  <dd>number of colors to quantize to (default is 256)
<dt><tt>array array(array(int)) colors</tt>
  <dd>colors to map to, format is ({({r,g,b}),({r,g,b}),...}).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the GIF data
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>gif_add</a></tt>,
     <tt><a href=#>gif_end</a></tt>,
     <tt><a href=#>gif_netscape_loop</a></tt>,
     <tt><a href=#>togif</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>gif_begin</b>()<br>
string <b>gif_begin</b>(int&nbspnum_colors)<br>
string <b>gif_begin</b>(array(array(int))&nbspcolors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes GIF header. With no argument, there is no
     global colortable (palette).
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int num_colors</tt>
  <dd>number of colors to quantize to (default is 256) 
 array array(array(int)) colors
     colors to map to, format is ({({r,g,b}),({r,g,b}),...}).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the GIF data
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>gif_add</a></tt>,
     <tt><a href=#>gif_end</a></tt>,
     <tt><a href=#>togif</a></tt>,
     <tt><a href=#>gif_netscape_loop</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>gif_end</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Ends GIF data.
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the GIF data.
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>gif_begin</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>gif_netscape_loop</b>()<br>
string <b>gif_netscape_loop</b>(int&nbsploops)</tt>
</blockquote>

<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int loops</tt>
  <dd>number of loops, default is 65535.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
a gif chunk that defines that the GIF animation should loop
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>gif_add</a></tt>,
     <tt><a href=#>gif_begin</a></tt>,
     <tt><a href=#>gif_end</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>int <b>xsize</b>()<br>
int <b>ysize</b>()<br>
object <b>grey</b>()<br>
object <b>grey</b>(int&nbspr, int&nbspg, int&nbspb)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes a grey-scale image (with weighted values).
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>weight of color, default is r=87,g=127,b=41,
     which should be pretty accurate of what the eyes see...
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>color</a></tt>,
     <tt><a href=#>`*</a></tt>,
     <tt><a href=#>modify_by_intensity</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>invert</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Invert an image. Each pixel value gets to be 255-x, where x 
    is the old value.
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>line</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2)<br>
object <b>line</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>line</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2, int&nbspr, int&nbspg, int&nbspb, int&nbspalpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Draws a line on the image. The line is <i>not</i> antialiased.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x1</tt>
<dt><tt>int y1</tt>
<dt><tt>int x2</tt>
<dt><tt>int y2</tt>
  <dd>line endpoints
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color
<dt><tt>int alpha</tt>
  <dd>alpha value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>map_closest</b>(array(array(int))&nbspcolors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps all pixel colors to the colors given.

<p>    Method to find the correct color is linear search
    over the colors given, selecting the nearest in the
    color cube. Slow...
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(array(int)) color</tt>
  <dd>list of destination (available) colors
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>map_fast</a></tt>,
     <tt><a href=#>select_colors</a></tt>,
     <tt><a href=#>map_fs</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>map_closest</b>(array(array(int))&nbspcolors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps all pixel colors to the colors given.

<p>    Method to find the correct color is linear search
    over the colors given, selecting the nearest in the
    color cube. Slow...

<p>    Floyd-steinberg error correction is added to create
    a better-looking image, in many cases, anyway.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(array(int)) color</tt>
  <dd>list of destination (available) colors
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>map_fast</a></tt>,
     <tt><a href=#>select_colors</a></tt>,
     <tt><a href=#>map_closest</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>array(array(int)) <b>map_closest</b>(int&nbspnum_colors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Selects the best colors to represent the image.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int num_colors</tt>
  <dd>number of colors to return
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
an array of colors
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>map_fast</a></tt>,
     <tt><a href=#>select_colors</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>map_fast</b>(array(array(int))&nbspcolors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps all pixel colors to the colors given.

<p>    Method to find the correct color is to branch
    in a binary space partitioning tree in the 
    colorcube. This is fast, but in some cases
    it gives the wrong color (mostly when few colors
    are available).
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(array(int)) color</tt>
  <dd>list of destination (available) colors
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>map_fast</a></tt>,
     <tt><a href=#>select_colors</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>mirrorx</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
mirrors an image:
     <pre>
     +--+     +--+
     |x | <-> | x|
     | .|     |. |
     +--+     +--+
     </pre>
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>mirrorx</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
mirrors an image:
     <pre>
     +--+     +--+
     |x | <-> | .|
     | .|     |x |
     +--+     +--+
     </pre>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>modify_by_intensity</b>(int&nbspr, int&nbspg, int&nbspb, int|array(int)&nbspv1, ..., int|array(int)&nbspvn)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Recolor an image from intensity values.

<p>    For each color an intensity is calculated, from r, g and b factors
    (see <tt><a href=#>grey</a></tt>), this gives a value between 0 and max.

<p>    The color is then calculated from the values given, v1 representing
    the intensity value of 0, vn representing max, and colors between
    representing intensity values between, linear.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>red, green, blue intensity factors
<dt><tt>int|array(int) v1</tt>
<dt><tt>int|array(int) vn</tt>
  <dd>destination color
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>grey</a></tt>,
     <tt><a href=#>`*</a></tt>,
     <tt><a href=#>color</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>paste</b>(object&nbspimage)<br>
object <b>paste</b>(object&nbspimage, int&nbspx, int&nbspy)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Pastes a given image over the current image.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object image</tt>
  <dd>image to paste
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>where to paste the image; default is 0,0
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>paste_mask</a></tt>,
     <tt><a href=#>paste_alpha</a></tt>,
     <tt><a href=#>paste_alpha_color</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>paste_alpha</b>(object&nbspimage, int&nbspalpha)<br>
object <b>paste_alpha</b>(object&nbspimage, int&nbspalpha, int&nbspx, int&nbspy)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Pastes a given image over the current image, with
     the specified alpha channel value.
     
     An alpha channel value of 0 leaves nothing of the original 
     image in the paste area, 255 is meaningless and makes the
     given image invisible.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object image</tt>
  <dd>image to paste
<dt><tt>int alpha</tt>
  <dd>alpha channel value
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>where to paste the image; default is 0,0
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>paste_mask</a></tt>,
     <tt><a href=#>paste</a></tt>,
     <tt><a href=#>paste_alpha_color</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>paste_alpha_color</b>(object&nbspmask)<br>
object <b>paste_alpha_color</b>(object&nbspmask, int&nbspx, int&nbspy)<br>
object <b>paste_alpha_color</b>(object&nbspmask, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>paste_alpha_color</b>(object&nbspmask, int&nbspr, int&nbspg, int&nbspb, int&nbspx, int&nbspy)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Pastes a given color over the current image,
    using the given mask as opaque channel.  
    
    A pixel value of 255 makes the result become the color given,
    0 doesn't change anything.
    
    The masks red, green and blue values are used separately.
    If no color are given, the current is used.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object mask</tt>
  <dd>mask image
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>what color to paint with; default is current
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>where to paste the image; default is 0,0
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>paste_mask</a></tt>,
     <tt><a href=#>paste_alpha</a></tt>,
     <tt><a href=#>paste_alpha_color</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>paste_mask</b>(object&nbspimage, object&nbspmask)<br>
object <b>paste_mask</b>(object&nbspimage, object&nbspmask, int&nbspx, int&nbspy)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Pastes a given image over the current image,
    using the given mask as opaque channel.  
    
    A pixel value of 255 makes the result become a pixel
    from the given image, 0 doesn't change anything.

<p>    The masks red, green and blue values are used separately.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object image</tt>
  <dd>image to paste
<dt><tt>object mask</tt>
  <dd>mask image
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>where to paste the image; default is 0,0
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>paste</a></tt>,
     <tt><a href=#>paste_alpha</a></tt>,
     <tt><a href=#>paste_alpha_color</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>rotate</b>(int|float&nbspangle)<br>
object <b>rotate</b>(int|float&nbspangle, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>rotate_expand</b>(int|float&nbspangle)<br>
object <b>rotate_expand</b>(int|float&nbspangle, int&nbspr, int&nbspg, int&nbspb)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Rotates an image a certain amount of degrees (360° is 
     a complete rotation) counter-clockwise:
     <pre>
                 x
     +--+       / \
     |  |  <-> x   x
     |  |       \ /
     +--+        x
     </pre>
     The "expand" variant of functions stretches the 
     image border pixels rather then filling with 
     the given or current color.

<p>     This rotate uses the skewx() and skewy() functions.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int|float angle</tt>
  <dd>the number of degrees to rotate
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color to fill with; default is current
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>scale</b>(float&nbspfactor)<br>
object <b>scale</b>(0.5)<br>
object <b>scale</b>(float&nbspxfactor, float&nbspyfactor)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
scales the image with a factor,
     0.5 is an optimized case.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>float factor</tt>
  <dd>factor to use for both x and y
<dt><tt>float xfactor</tt>
<dt><tt>float yfactor</tt>
  <dd>separate factors for x and y
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>scale</b>(int&nbspnewxsize, int&nbspnewysize)<br>
object <b>scale</b>(0, int&nbspnewysize)<br>
object <b>scale</b>(int&nbspnewxsize, 0)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
scales the image to a specified new size,
     if one of newxsize or newysize is 0,
     the image aspect ratio is preserved.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int newxsize</tt>
<dt><tt>int newysize</tt>
  <dd>new image size in pixels
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>select_from</b>(int&nbspx, int&nbspy)<br>
object <b>select_from</b>(int&nbspx, int&nbspy, int&nbspedge_value)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes an grey-scale image, for alpha-channel use.
    
    This is very close to a floodfill.
    
    The image is scanned from the given pixel,
    filled with 255 if the color is the same,
    or 255 minus distance in the colorcube, squared, rightshifted
    8 steps (see <tt><a href=#>distancesq</a></tt>).

<p>    When the edge distance is reached, the scan is stopped.
    Default edge value is 30.
    This value is squared and compared with the square of the 
    distance above.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>originating pixel in the image
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>distancesq</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>setcolor</b>(int&nbspr, int&nbspg, int&nbspb)<br>
object <b>setcolor</b>(int&nbspr, int&nbspg, int&nbspb, int&nbspalpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
set the current color
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>new color
<dt><tt>int alpha</tt>
  <dd>new alpha value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>setpixel</b>(int&nbspx, int&nbspy)<br>
object <b>setpixel</b>(int&nbspx, int&nbspy, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>setpixel</b>(int&nbspx, int&nbspy, int&nbspr, int&nbspg, int&nbspb, int&nbspalpha)</tt>
</blockquote>

<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>position of the pixel
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color
<dt><tt>int alpha</tt>
  <dd>alpha value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>skewx</b>(int&nbspx)<br>
object <b>skewx</b>(int&nbspyfactor)<br>
object <b>skewx</b>(int&nbspx, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>skewx</b>(int&nbspyfactor, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>skewx_expand</b>(int&nbspx)<br>
object <b>skewx_expand</b>(int&nbspyfactor)<br>
object <b>skewx_expand</b>(int&nbspx, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>skewx_expand</b>(int&nbspyfactor, int&nbspr, int&nbspg, int&nbspb)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Skews an image an amount of pixels or a factor;
     a skew-x is a transformation:
     <pre>
     +--+         +--+
     |  |  <->   /  /
     |  |       /  /
     +--+      +--+
     </pre>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
  <dd>the number of pixels
     The "expand" variant of functions stretches the 
     image border pixels rather then filling with 
     the given or current color.
<dt><tt>float yfactor</tt>
  <dd>best described as: x=yfactor*this->ysize()
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color to fill with; default is current
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>skewy</b>(int&nbspy)<br>
object <b>skewy</b>(int&nbspxfactor)<br>
object <b>skewy</b>(int&nbspy, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>skewy</b>(int&nbspxfactor, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>skewy_expand</b>(int&nbspy)<br>
object <b>skewy_expand</b>(int&nbspxfactor)<br>
object <b>skewy_expand</b>(int&nbspy, int&nbspr, int&nbspg, int&nbspb)<br>
object <b>skewy_expand</b>(int&nbspxfactor, int&nbspr, int&nbspg, int&nbspb)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Skews an image an amount of pixels or a factor;
     a skew-y is a transformation:
     <pre>
                  +
                 /|
     +--+       / |
     |  |  <-> +  +
     |  |      | /
     +--+      |/
               +
     </pre>
     The "expand" variant of functions stretches the 
     image border pixels rather then filling with 
     the given or current color.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int y</tt>
  <dd>the number of pixels
<dt><tt>float xfactor</tt>
  <dd>best described as: t=xfactor*this->xsize()
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color to fill with; default is current
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>to8bit</b>(array(array(int))&nbspcolors)<br>
string <b>to8bit_fs</b>(array(array(int))&nbspcolors)<br>
string <b>to8bit_closest</b>(array(array(int))&nbspcolors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps the image to the given colors and returns 
     the 8 bit data.

<p>     to8bit_fs uses floyd-steinberg dithering
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the calculated string
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>to8bit_rgbcube</a></tt>,
     <tt><a href=#>tozbgr</a></tt>,
     <tt><a href=#>map_fast</a></tt>,
     <tt><a href=#>map_closest</a></tt>,
     <tt><a href=#>select_colors</a></tt>,
     <tt><a href=#>tobitmap</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>tozbgr</b>(array(array(int))&nbspcolors)<br>
string <b>to8bit_rgbcube</b>(int&nbspred, int&nbspgreen, int&nbspblue)<br>
string <b>to8bit_rgbcube</b>(int&nbspred, int&nbspgreen, int&nbspblue, string&nbspmap)<br>
string <b>to8bit_rgbcube_rdither</b>(int&nbspred, int&nbspgreen, int&nbspblue)<br>
string <b>to8bit_rgbcube_rdither</b>(int&nbspred, int&nbspgreen, int&nbspblue, string&nbspmap)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps the image into a colorcube with the given 
     dimensions. Red is least significant, blue is most.

<p>     The "rdither" type of method uses a random dither algoritm.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int red</tt>
<dt><tt>int green</tt>
<dt><tt>int blue</tt>
  <dd>The sides of the colorcube. Not the number of bits!
<dt><tt>string map</tt>
  <dd>Map this position in the colorcube to another value,
     ie: say we have position red=1,green=2,blue=3 in a colorcube of
     6×6×6, we have the index 1+2*6+3*6*6=121. If the 
     map-string contains 'å' in position 121, the resulting
     byte is 'å' or 229.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the calculated string
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>tozbgr</a></tt>,
     <tt><a href=#>to8bit</a></tt>,
     <tt><a href=#>tobitmap</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>tobitmap</b>();</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps the image to a bitmap.

<p>     Bit 0 is the leftmost pixel, and the rows are aligned to 
     bytes.

<p>     Any pixel value other then black results in a set bit.
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the calculated string
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>tozbgr</a></tt>,
     <tt><a href=#>to8bit</a></tt>,
     <tt><a href=#>to8bit_rgbcube</a></tt>,
     <tt><a href=#>cast</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>togif</b>()<br>
string <b>togif</b>(int&nbspnum_colors)<br>
string <b>togif</b>(array(array(int))&nbspcolors)<br>
string <b>togif</b>(int&nbsptrans_r, int&nbsptrans_g, int&nbsptrans_b)<br>
string <b>togif</b>(int&nbspnum_colors, int&nbsptrans_r, int&nbsptrans_g, int&nbsptrans_b)<br>
string <b>togif</b>(array(array(int))&nbspcolors, int&nbsptrans_r, int&nbsptrans_g, int&nbsptrans_b)<br>
string <b>togif_fs</b>()<br>
string <b>togif_fs</b>(int&nbspnum_colors)<br>
string <b>togif_fs</b>(array(array(int))&nbspcolors)<br>
string <b>togif_fs</b>(int&nbsptrans_r, int&nbsptrans_g, int&nbsptrans_b)<br>
string <b>togif_fs</b>(int&nbspnum_colors, int&nbsptrans_r, int&nbsptrans_g, int&nbsptrans_b)<br>
string <b>togif_fs</b>(array(array(int))&nbspcolors, int&nbsptrans_r, int&nbsptrans_g, int&nbsptrans_b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes GIF data. The togif_fs variant uses floyd-steinberg 
     dithereing.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int num_colors</tt>
  <dd>number of colors to quantize to (default is 256) 
 array array(array(int)) colors
     colors to map to (default is to quantize to 256), format is ({({r,g,b}),({r,g,b}),...}).
<dt><tt>int trans_r</tt>
<dt><tt>int trans_g</tt>
<dt><tt>int trans_b</tt>
  <dd>one color, that is to be transparent.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the GIF data
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>togif_begin</a></tt>,
     <tt><a href=#>togif_add</a></tt>,
     <tt><a href=#>togif_end</a></tt>,
     <tt><a href=#>toppm</a></tt>,
     <tt><a href=#>fromgif</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>toppm</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Returns PPM (P6, binary pixmap) data from the
     current image object.
</blockquote>
<h4>RETURNS</h4>


<blockquote>
PPM data
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>frompnm</a></tt>,
     <tt><a href=#>fromgif</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>treshold</b>()<br>
object <b>treshold</b>(int&nbspr, int&nbspg, int&nbspb)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes a black-white image. 

<p>     If all red, green, blue parts of a pixel
     is larger or equal then the given value, the pixel will become
     white, else black.

<p>     This method works fine with the grey method.

<p>     If no arguments are given, the current color is used 
     for treshold values.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>red, green, blue threshold values
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=#>grey</a></tt>
</blockquote>

<hr>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>tuned_box</b>(int&nbspx1, int&nbspy1, int&nbspx2, int&nbspy2, array(array(int))&nbspcorner_color)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Draws a filled rectangle with colors (and alpha values) tuned
     between the corners.

<p>     Tuning function is (1.0-x/xw)*(1.0-y/yw) where x and y is
     the distance to the corner and xw and yw are the sides of the
     rectangle.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x1</tt>
<dt><tt>int y1</tt>
<dt><tt>int x2</tt>
<dt><tt>int y2</tt>
  <dd>rectangle corners
<dt><tt>array(array(int)) corner_color</tt>
  <dd>colors of the corners:

<p>     ({x1y1,x2y1,x1y2,x2y2})

<p>     each of these is an array of integeres:

<p>     ({r,g,b}) or ({r,g,b,alpha})

<p>     Default alpha channel value is 0 (opaque).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

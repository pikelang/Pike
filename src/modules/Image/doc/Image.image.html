<title>Pike documentation: Image.image</title>
<h2>Image.image</h2>


<blockquote>
The main object of the <tt><a href=Image.html>Image</a></tt> module, this object
     is used as drawing area, mask or result of operations.

<p>     init: <tt><a href=Image.html>clear</a></tt>,
     <tt><a href=Image.html>clone</a></tt>,
     <tt><a href=Image.html>create</a></tt>, 
     <tt><a href=Image.html>xsize</a></tt>,
     <tt><a href=Image.html>ysize</a></tt>

<p>     plain drawing: <tt><a href=Image.html>box</a></tt>,
     <tt><a href=Image.html>circle</a></tt>,
     <tt><a href=Image.html>getpixel</a></tt>, 
     <tt><a href=Image.html>line</a></tt>,
     <tt><a href=Image.html>setcolor</a></tt>,
     <tt><a href=Image.html>setpixel</a></tt>, 
     <tt><a href=Image.html>treshold</a></tt>,
     <tt><a href=Image.html>tuned_box</a></tt>,
     <tt><a href=Image.html>polygone</a></tt>

<p>     operators: <tt><a href=Image.html>`&amp;</a></tt>,
     <tt><a href=Image.html>`*</a></tt>,
     <tt><a href=Image.html>`+</a></tt>,
     <tt><a href=Image.html>`-</a></tt>,
     <tt><a href=Image.html>`|</a></tt>

<p>     pasting images, layers: <tt><a href=Image.html>add_layers</a></tt>, 
     <tt><a href=Image.html>paste</a></tt>,
     <tt><a href=Image.html>paste_alpha</a></tt>,
     <tt><a href=Image.html>paste_alpha_color</a></tt>,
     <tt><a href=Image.html>paste_mask</a></tt>

<p>     getting subimages, scaling, rotating: <tt><a href=Image.html>autocrop</a></tt>, 
     <tt><a href=Image.html>clone</a></tt>,
     <tt><a href=Image.html>copy</a></tt>, 
     <tt><a href=Image.html>dct</a></tt>,
     <tt><a href=Image.html>mirrorx</a></tt>, 
     <tt><a href=Image.html>rotate</a></tt>,
     <tt><a href=Image.html>rotate_expand</a></tt>, 
     <tt><a href=Image.html>rotate_ccw</a></tt>,
     <tt><a href=Image.html>rotate_cw</a></tt>,
     <tt><a href=Image.html>scale</a></tt>, 
     <tt><a href=Image.html>skewx</a></tt>,
     <tt><a href=Image.html>skewx_expand</a></tt>,
     <tt><a href=Image.html>skewy</a></tt>,
     <tt><a href=Image.html>skewy_expand</a></tt>

<p>     calculation by pixels: <tt><a href=Image.html>apply_matrix</a></tt>, 
     <tt><a href=Image.html>change_color</a></tt>,
     <tt><a href=Image.html>color</a></tt>,
     <tt><a href=Image.html>distancesq</a></tt>, 
     <tt><a href=Image.html>grey</a></tt>,
     <tt><a href=Image.html>invert</a></tt>, 
     <tt><a href=Image.html>map_closest</a></tt>,
     <tt><a href=Image.html>map_fast</a></tt>, 
     <tt><a href=Image.html>select_colors</a></tt>,
     <tt><a href=Image.html>modify_by_intensity</a></tt>,
     <tt><a href=Image.html>select_from</a></tt>, 
     <tt><a href=Image.html>rgb_to_hsv</a></tt>,
     <tt><a href=Image.html>hsv_to_rgb</a></tt>

<p>     converting to other datatypes: <tt><a href=Image.html>cast</a></tt>,
     <tt><a href=Image.html>fromgif</a></tt>, 
     <tt><a href=Image.html>frompnm</a></tt>/<tt><a href=Image.html>fromppm</a></tt>, 
     <tt><a href=Image.html>gif_add</a></tt>,
     <tt><a href=Image.html>gif_add_fs</a></tt>,
     <tt><a href=Image.html>gif_add_fs_nomap</a></tt>,
     <tt><a href=Image.html>gif_add_nomap</a></tt>,
     <tt><a href=Image.html>gif_begin</a></tt>,
     <tt><a href=Image.html>gif_end</a></tt>,
     <tt><a href=Image.html>gif_netscape_loop</a></tt>,
     <tt><a href=Image.html>gif_transparency</a></tt>,
     <tt><a href=Image.html>to8bit</a></tt>,
     <tt><a href=Image.html>to8bit_closest</a></tt>, 
     <tt><a href=Image.html>to8bit_fs</a></tt>,
     <tt><a href=Image.html>to8bit_rgbcube</a></tt>, 
     <tt><a href=Image.html>to8bit_rgbcube_rdither</a></tt>,
     <tt><a href=Image.html>tobitmap</a></tt>, 
     <tt><a href=Image.html>togif</a></tt>,
     <tt><a href=Image.html>togif_fs</a></tt>, 
     <tt><a href=Image.html>toppm</a></tt>,
     <tt><a href=Image.html>tozbgr</a></tt>

<p>     special pattern drawing:
     <tt><a href=Image.html>noise</a></tt>,
     <tt><a href=Image.html>turbulence</a></tt>
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>Image</a></tt>,
     <tt><a href=Image.html>Image.font</a></tt>
</blockquote>

<hr>
<a name=%60%26> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`&amp;</b>(object&nbsp;operand)<br>
object <b>`&amp;</b>(array(int)&nbsp;color)<br>
object <b>`&amp;</b>(int&nbsp;value)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
makes a new image out of the minimum pixels values
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object operand</tt>
  <dd>the other image to compare with;
     the images must have the same size.
<dt><tt>array(int) color</tt>
  <dd>an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.
<dt><tt>int value</tt>
  <dd>equal to ({value,value,value}).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>`-</a></tt>,
     <tt><a href=Image.html>`+</a></tt>,
     <tt><a href=Image.html>`|</a></tt>,
     <tt><a href=Image.html>`*</a></tt>,
     <tt><a href=Image.html>add_layers</a></tt>
</blockquote>

<hr>
<a name=%60*> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`*</b>(object&nbsp;operand)<br>
object <b>`*</b>(array(int)&nbsp;color)<br>
object <b>`*</b>(int&nbsp;value)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Multiplies pixel values and creates a new image.

<p>     This can be useful to lower the values of an image,
     making it greyer, for instance:

<p>     <pre>image=image*128+64;</pre>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object operand</tt>
  <dd>the other image to multiply with;
     the images must have the same size.
<dt><tt>array(int) color</tt>
  <dd>an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.
<dt><tt>int value</tt>
  <dd>equal to ({value,value,value}).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>`-</a></tt>,
     <tt><a href=Image.html>`+</a></tt>,
     <tt><a href=Image.html>`|</a></tt>,
     <tt><a href=Image.html>`&</a></tt>,
     <tt><a href=Image.html>add_layers</a></tt>
</blockquote>

<hr>
<a name=%60+> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`+</b>(object&nbsp;operand)<br>
object <b>`+</b>(array(int)&nbsp;color)<br>
object <b>`+</b>(int&nbsp;value)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
adds two images; values are truncated at 255.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object operand</tt>
  <dd>the image which to add.
<dt><tt>array(int) color</tt>
  <dd>an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.
<dt><tt>int value</tt>
  <dd>equal to ({value,value,value}).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>`-</a></tt>,
     <tt><a href=Image.html>`|</a></tt>,
     <tt><a href=Image.html>`&</a></tt>,
     <tt><a href=Image.html>`*</a></tt>,
     <tt><a href=Image.html>add_layers</a></tt>
</blockquote>

<hr>
<a name=%60-> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`-</b>(object&nbsp;operand)<br>
object <b>`-</b>(array(int)&nbsp;color)<br>
object <b>`-</b>(int&nbsp;value)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
makes a new image out of the difference
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object operand</tt>
  <dd>the other image to compare with;
     the images must have the same size.
<dt><tt>array(int) color</tt>
  <dd>an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.
<dt><tt>int value</tt>
  <dd>equal to ({value,value,value}).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>`+</a></tt>,
     <tt><a href=Image.html>`|</a></tt>,
     <tt><a href=Image.html>`&</a></tt>,
     <tt><a href=Image.html>`*</a></tt>,
     <tt><a href=Image.html>add_layers</a></tt>
</blockquote>

<hr>
<a name=%60|> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>`|</b>(object&nbsp;operand)<br>
object <b>`|</b>(array(int)&nbsp;color)<br>
object <b>`|</b>(int&nbsp;value)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
makes a new image out of the maximum pixels values
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object operand</tt>
  <dd>the other image to compare with;
     the images must have the same size.
<dt><tt>array(int) color</tt>
  <dd>an array in format ({r,g,b}), this is equal
     to using an uniform-colored image.
<dt><tt>int value</tt>
  <dd>equal to ({value,value,value}).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>`-</a></tt>,
     <tt><a href=Image.html>`+</a></tt>,
     <tt><a href=Image.html>`&</a></tt>,
     <tt><a href=Image.html>`*</a></tt>,
     <tt><a href=Image.html>add_layers</a></tt>
</blockquote>

<hr>
<a name=add_layers> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>add_layers</b>(array(int|object))&nbsp;layer0, ...)<br>
object <b>add_layers</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, array(int|object))&nbsp;layer0, ...)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Using the called object as base, adds layers using masks,
     opaque channel values and special methods.

<p>     The destination image can also be cropped, thus
     speeding up the process.

<p>     Each array in the layers array is one of:
     <pre>
     ({object image,object|int mask})
     ({object image,object|int mask,int opaque_value})
     ({object image,object|int mask,int opaque_value,int method})
     </pre>
     Given 0 as mask means the image is totally opaque.

<p>     Default opaque value is 255, only using the mask.

<p>     Methods for now are:
     <pre>
     0  no operation (just paste with mask, default)
     1  maximum  (`|)
     2  minimum  (`&amp;)
     3  multiply (`*)
     4  add      (`+)
     5  diff     (`-)
     </pre>
     The layer image and the current source are calculated
     through the given method and then pasted using the mask
     and the opaque channel value. 

<p>     All given images must be the same size.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(int|object) layer0</tt>
  <dd>image to paste
<dt><tt>int x1</tt>
<dt><tt>int y1</tt>
<dt><tt>int x2</tt>
<dt><tt>int y2</tt>
  <dd>rectangle for cropping
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
a new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>paste_mask</a></tt>,
     <tt><a href=Image.html>paste_alpha</a></tt>,
     <tt><a href=Image.html>paste_alpha_color</a></tt>,
     <tt><a href=Image.html>`|</a></tt>,
     <tt><a href=Image.html>`&</a></tt>,
     <tt><a href=Image.html>`*</a></tt>,
     <tt><a href=Image.html>`+</a></tt>,
     <tt><a href=Image.html>`-</a></tt>
</blockquote>

<hr>
<a name=apply_matrix> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>apply_matrix</b>(array(array(int|array(int)))&nbsp;matrix)<br>
object <b>apply_matrix</b>(array(array(int|array(int)))&nbsp;matrix, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>apply_matrix</b>(array(array(int|array(int)))&nbsp;matrix, int&nbsp;r, int&nbsp;g, int&nbsp;b, int|float&nbsp;div)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Applies a pixel-transform matrix, or filter, to the image.
    
     <pre>
                            2   2
     pixel(x,y)= base+ k ( sum sum pixel(x+k-1,y+l-1)*matrix(k,l) ) 
                           k=0 l=0 
     </pre>
     
     1/k is sum of matrix, or sum of matrix multiplied with div.
     base is given by r,g,b and is normally black.

<p>     <table><tr><td rowspan=2>
     blur (ie a 2d gauss function):
     <pre>
     ({({1,2,1}),
       ({2,5,2}),
       ({1,2,1})})
     </pre>
     </td><td>
     <a href=illustrations.html#illustration_41.gif><img border=0 src=illustration_41.gif width=67 height=67></a>
     </td><td>
     <img src=lena.gif width=67 height=67>
     </td>
     <tr><td></td><td>original</td>
     
     <tr><td>
     sharpen (k>8, preferably 12 or 16):
     <pre>
     ({({-1,-1,-1}),
       ({-1, k,-1}),
       ({-1,-1,-1})})
     </pre>
     </td><td>
     <a href=illustrations.html#illustration_43.gif><img border=0 src=illustration_43.gif width=67 height=67></a>
     </td>

<p>     <tr><td>
     edge detect:
     <pre>
     ({({1, 1,1}),
       ({1,-8,1}),
       ({1, 1,1})})
     </pre>
     </td><td>
     <a href=illustrations.html#illustration_44.gif><img border=0 src=illustration_44.gif width=67 height=67></a>
     </td>

<p>     <tr><td>
     horisontal edge detect (get the idea):
     <pre>
     ({({0, 0,0}),
       ({1,-2,1}),
       ({0, 0,0})})
     </pre>
     </td><td>
     <a href=illustrations.html#illustration_45.gif><img border=0 src=illustration_45.gif width=67 height=67></a>
     </td>

<p>     <tr><td rowspan=2>
     emboss (might prefer to begin with a <tt><a href=Image.html>grey</a></tt> image):
     <pre>
     ({({2, 1, 0}),
       ({1, 0,-1}),
       ({0,-1,-2})}), 128,128,128, 3
     </pre>
     </td><td>
     <a href=illustrations.html#illustration_46.gif><img border=0 src=illustration_46.gif width=67 height=67></a>
     </td><td>
     <a href=illustrations.html#illustration_47.gif><img border=0 src=illustration_47.gif width=67 height=67></a>
     </td>
     <tr><td></td><td>greyed</td></table>

<p>     This function is not very fast -- and it's hard to 
     optimize it more, not using assembler.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(array(int|array(int)))</tt>
  <dd>the matrix; innermost is a value or an array with red, green, blue
     values for red, green, blue separation.
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>base level of result, default is zero
<dt><tt>int|float div</tt>
  <dd>division factor, default is 1.0.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=autocrop> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>autocrop</b>()<br>
object <b>autocrop</b>(int&nbsp;border)<br>
object <b>autocrop</b>(int&nbsp;border, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>autocrop</b>(int&nbsp;border, int&nbsp;left, int&nbsp;right, int&nbsp;top, int&nbsp;bottom)<br>
object <b>autocrop</b>(int&nbsp;border, int&nbsp;left, int&nbsp;right, int&nbsp;top, int&nbsp;bottom, int&nbsp;r, int&nbsp;g, int&nbsp;b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Removes "unneccesary" borders around the image, adds one of
     its own if wanted to, in selected directions.

<p>     "Unneccesary" is all pixels that are equal -- ie if all the same pixels
     to the left are the same color, that column of pixels are removed.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int border</tt>
  <dd>added border size in pixels
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color of the new border
<dt><tt>int left</tt>
<dt><tt>int right</tt>
<dt><tt>int top</tt>
<dt><tt>int bottom</tt>
  <dd>which borders to scan and cut the image; 
     a typical example is removing the top and bottom unneccesary
     pixels:
     <pre>img=img->autocrop(0, 0,0,1,1);</pre>
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>copy</a></tt>
</blockquote>

<hr>
<a name=box> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>box</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2)<br>
object <b>box</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>box</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Draws a filled rectangle on the image.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x1</tt>
<dt><tt>int y1</tt>
<dt><tt>int x2</tt>
<dt><tt>int y2</tt>
  <dd>box corners
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color of the box
<dt><tt>int alpha</tt>
  <dd>alpha value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<a name=cast> </a>
<a name=to8bit> </a>
<a name=to8bit_closest> </a>
<a name=to8bit_fs> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>cast</b>(string&nbsp;type)<br>
string <b>to8bit</b>(array(array(int))&nbsp;colors)<br>
string <b>to8bit_fs</b>(array(array(int))&nbsp;colors)<br>
string <b>to8bit_closest</b>(array(array(int))&nbsp;colors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps the image to the given colors and returns 
     the 8 bit data.

<p>     to8bit_fs uses floyd-steinberg dithering
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the calculated string
</blockquote>


<h4>KNOWN BUGS</h4>
<blockquote>
always casts to string...
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>to8bit_rgbcube</a></tt>,
     <tt><a href=Image.html>tozbgr</a></tt>,
     <tt><a href=Image.html>map_fast</a></tt>,
     <tt><a href=Image.html>map_closest</a></tt>,
     <tt><a href=Image.html>select_colors</a></tt>,
     <tt><a href=Image.html>tobitmap</a></tt>
</blockquote>

<hr>
<a name=change_color> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>change_color</b>(int&nbsp;tor, int&nbsp;tog, int&nbsp;tob)<br>
object <b>change_color</b>(int&nbsp;fromr, int&nbsp;fromg, int&nbsp;fromb, &nbsp;int&nbsp;tor, int&nbsp;tog, int&nbsp;tob)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Changes one color (exakt match) to another.
     If non-exakt-match is preferred, check <tt><a href=Image.html>distancesq</a></tt>
     and <tt><a href=Image.html>paste_alpha_color</a></tt>.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int tor</tt>
<dt><tt>int tog</tt>
<dt><tt>int tob</tt>
  <dd>destination color and next current color
<dt><tt>int fromr</tt>
<dt><tt>int fromg</tt>
<dt><tt>int fromb</tt>
  <dd>source color, default is current color
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
a new (the destination) image object
</blockquote>

<hr>
<a name=circle> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>circle</b>(int&nbsp;x, int&nbsp;y, int&nbsp;rx, int&nbsp;ry)<br>
object <b>circle</b>(int&nbsp;x, int&nbsp;y, int&nbsp;rx, int&nbsp;ry, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>circle</b>(int&nbsp;x, int&nbsp;y, int&nbsp;rx, int&nbsp;ry, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Draws a line on the image. The line is <i>not</i> antialiased.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>circle center
<dt><tt>int rx</tt>
<dt><tt>int ry</tt>
  <dd>circle radius in pixels
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color
<dt><tt>int alpha</tt>
  <dd>alpha value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<a name=clear> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>void <b>clear</b>()<br>
void <b>clear</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
void <b>clear</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
gives a new, cleared image with the same size of drawing area
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color of the new image
<dt><tt>int alpha</tt>
  <dd>new default alpha channel value
</dl></blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>copy</a></tt>,
     <tt><a href=Image.html>clone</a></tt>
</blockquote>

<hr>
<a name=clone> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>clone</b>()<br>
object <b>clone</b>(int&nbsp;xsize, int&nbsp;ysize)<br>
object <b>clone</b>(int&nbsp;xsize, int&nbsp;ysize, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>clone</b>(int&nbsp;xsize, int&nbsp;ysize, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Copies to or initialize a new image object.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int xsize</tt>
<dt><tt>int ysize</tt>
  <dd>size of (new) image in pixels, called image
     is cropped to that size
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>current color of the new image, 
     default is black. 
     Will also be the background color if the cloned image
     is empty (no drawing area made).
<dt><tt>int alpha</tt>
  <dd>new default alpha channel value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>copy</a></tt>,
     <tt><a href=Image.html>create</a></tt>
</blockquote>

<hr>
<a name=color> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>color</b>()<br>
object <b>color</b>(int&nbsp;value)<br>
object <b>color</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Colorize an image. 

<p>    The red, green and blue values of the pixels are multiplied
    with the given value(s). This works best on a grey image...

<p>    The result is divided by 255, giving correct pixel values.

<p>    If no arguments are given, the current color is used as factors.

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_49.gif><img border=0 src=illustration_49.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->color(128,128,255);</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>red, green, blue factors
<dt><tt>int value</tt>
  <dd>factor
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>grey</a></tt>,
     <tt><a href=Image.html>`*</a></tt>,
     <tt><a href=Image.html>modify_by_intensity</a></tt>
</blockquote>

<hr>
<a name=copy> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>copy</b>()<br>
object <b>copy</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2)<br>
object <b>copy</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>copy</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Copies this part of the image. The requested area can
     be smaller, giving a cropped image, or bigger - 
     the new area will be filled with the given or current color.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x1</tt>
<dt><tt>int y1</tt>
<dt><tt>int x2</tt>
<dt><tt>int y2</tt>
  <dd>The requested new area. Default is the old image size.
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color of the new image
<dt><tt>int alpha</tt>
  <dd>new default alpha channel value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
a new image object
</blockquote>


<h4>NOTE</h4>
<blockquote>
<tt><a href=Image.html>clone</a></tt>(void) and <tt><a href=Image.html>copy</a></tt>(void) does the same 
     operation
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>clone</a></tt>,
     <tt><a href=Image.html>autocrop</a></tt>
</blockquote>

<hr>
<a name=create> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>void <b>create</b>()<br>
void <b>create</b>(int&nbsp;xsize, int&nbsp;ysize)<br>
void <b>create</b>(int&nbsp;xsize, int&nbsp;ysize, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
void <b>create</b>(int&nbsp;xsize, int&nbsp;ysize, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Initializes a new image object.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int xsize</tt>
<dt><tt>int ysize</tt>
  <dd>size of (new) image in pixels
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>background color (will also be current color),
     default color is black
<dt><tt>int alpha</tt>
  <dd>default alpha channel value
</dl></blockquote>


<h4>KNOWN BUGS</h4>
<blockquote>
SIGSEGS can be caused if the size is too big, due
     to unchecked overflow - 
     (xsize*ysize)&amp;MAXINT is small enough to allocate.
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>copy</a></tt>,
     <tt><a href=Image.html>clone</a></tt>,
     <tt><a href=Image.html>Image.image</a></tt>
</blockquote>

<hr>
<a name=dct> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>dct</b>(int&nbsp;newx, int&nbsp;newy)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Scales the image to a new size.
     
     Method for scaling is rather complex;
     the image is transformed via a cosine transform,
     and then resampled back.

<p>     This gives a quality-conserving upscale,
     but the algorithm used is n*n+n*m, where n
     and m is pixels in the original and new image.

<p>     Recommended wrapping algorithm is to scale
     overlapping parts of the image-to-be-scaled.

<p>     This functionality is actually added as an
     true experiment, but works...
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int newx</tt>
<dt><tt>int newy</tt>
  <dd>new image size in pixels
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>NOTE</h4>
<blockquote>
Do NOT use this function if you don't know what 
     you're dealing with! Read some signal theory first...
</blockquote>

<hr>
<a name=distancesq> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>distancesq</b>()<br>
object <b>distancesq</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes an grey-scale image, for alpha-channel use.
    
    The given value (or current color) are used for coordinates
    in the color cube. Each resulting pixel is the 
    distance from this point to the source pixel color,
    in the color cube, squared, rightshifted 8 steps:

<p>    <pre>
    p = pixel color
    o = given color
    d = destination pixel
    d.red=d.blue=d.green=
        ((o.red-p.red)²+(o.green-p.green)²+(o.blue-p.blue)²)>>8
    </pre>

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_51.gif><img border=0 src=illustration_51.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->distancesq(255,0,128);</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>red, green, blue coordinates
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>select_from</a></tt>
</blockquote>

<hr>
<a name=fromgif> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>fromgif</b>(string&nbsp;gif)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Reads GIF data to the called image object.

<p>     GIF animation delay or loops are ignored,
     and the resulting image is the written result.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>string pnm</tt>
  <dd>pnm data, as a string
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object
</blockquote>


<h4>KNOWN BUGS</h4>
<blockquote>
yes, it does -- it may even do segment overrides...
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>togif</a></tt>,
     <tt><a href=Image.html>frompnm</a></tt>
</blockquote>

<hr>
<a name=frompnm> </a>
<a name=fromppm> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object|string <b>frompnm</b>(string&nbsp;pnm)<br>
object|string <b>fromppm</b>(string&nbsp;pnm)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
<b>compability method</b> - do not use in new programs.
     
     See <tt><a href=Image.PNM.html#decode>Image.PNM.decode</a></tt>().
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>string pnm</tt>
  <dd>pnm data, as a string
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the called object or a hint of what wronged.
</blockquote>

<hr>
<a name=getpixel> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>array(int) <b>getpixel</b>(int&nbsp;x, int&nbsp;y)</tt>
</blockquote>

<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>position of the pixel
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
color of the requested pixel -- ({int red,int green,int blue})
</blockquote>

<hr>
<a name=gif_add> </a>
<a name=gif_add_fs> </a>
<a name=gif_add_fs_nomap> </a>
<a name=gif_add_nomap> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>gif_add</b>()<br>
string <b>gif_add</b>(int&nbsp;x, int&nbsp;y)<br>
string <b>gif_add</b>(int&nbsp;x, int&nbsp;y, int&nbsp;delay_cs)<br>
string <b>gif_add</b>(int&nbsp;x, int&nbsp;y, float&nbsp;delay_s)<br>
string <b>gif_add</b>(int&nbsp;x, int&nbsp;y, int&nbsp;num_colors, int&nbsp;delay_cs)<br>
string <b>gif_add</b>(int&nbsp;x, int&nbsp;y, int&nbsp;num_colors, float&nbsp;delay_s)<br>
string <b>gif_add</b>(int&nbsp;x, int&nbsp;y, array(array(int))&nbsp;colors, int&nbsp;delay_cs)<br>
string <b>gif_add</b>(int&nbsp;x, int&nbsp;y, array(array(int))&nbsp;colors, float&nbsp;delay_s)<br>
string <b>gif_add_fs</b>()<br>
string <b>gif_add_fs</b>(int&nbsp;x, int&nbsp;y)<br>
string <b>gif_add_fs</b>(int&nbsp;x, int&nbsp;y, int&nbsp;delay_cs)<br>
string <b>gif_add_fs</b>(int&nbsp;x, int&nbsp;y, float&nbsp;delay_s)<br>
string <b>gif_add_fs</b>(int&nbsp;x, int&nbsp;y, int&nbsp;num_colors, int&nbsp;delay_cs)<br>
string <b>gif_add_fs</b>(int&nbsp;x, int&nbsp;y, int&nbsp;num_colors, float&nbsp;delay_s)<br>
string <b>gif_add_fs</b>(int&nbsp;x, int&nbsp;y, array(array(int))&nbsp;colors, int&nbsp;delay_cs)<br>
string <b>gif_add_fs</b>(int&nbsp;x, int&nbsp;y, array(array(int))&nbsp;colors, float&nbsp;delay_s)<br>
string <b>gif_add_nomap</b>()<br>
string <b>gif_add_nomap</b>(int&nbsp;x, int&nbsp;y)<br>
string <b>gif_add_nomap</b>(int&nbsp;x, int&nbsp;y, int&nbsp;delay_cs)<br>
string <b>gif_add_nomap</b>(int&nbsp;x, int&nbsp;y, float&nbsp;delay_s)<br>
string <b>gif_add_nomap</b>(int&nbsp;x, int&nbsp;y, int&nbsp;num_colors, int&nbsp;delay_cs)<br>
string <b>gif_add_nomap</b>(int&nbsp;x, int&nbsp;y, int&nbsp;num_colors, float&nbsp;delay_s)<br>
string <b>gif_add_nomap</b>(int&nbsp;x, int&nbsp;y, array(array(int))&nbsp;colors, int&nbsp;delay_cs)<br>
string <b>gif_add_nomap</b>(int&nbsp;x, int&nbsp;y, array(array(int))&nbsp;colors, float&nbsp;delay_s)<br>
string <b>gif_add_fs_nomap</b>()<br>
string <b>gif_add_fs_nomap</b>(int&nbsp;x, int&nbsp;y)<br>
string <b>gif_add_fs_nomap</b>(int&nbsp;x, int&nbsp;y, int&nbsp;delay_cs)<br>
string <b>gif_add_fs_nomap</b>(int&nbsp;x, int&nbsp;y, float&nbsp;delay_s)<br>
string <b>gif_add_fs_nomap</b>(int&nbsp;x, int&nbsp;y, int&nbsp;num_colors, int&nbsp;delay_cs)<br>
string <b>gif_add_fs_nomap</b>(int&nbsp;x, int&nbsp;y, int&nbsp;num_colors, float&nbsp;delay_s)<br>
string <b>gif_add_fs_nomap</b>(int&nbsp;x, int&nbsp;y, array(array(int))&nbsp;colors, int&nbsp;delay_cs)<br>
string <b>gif_add_fs_nomap</b>(int&nbsp;x, int&nbsp;y, array(array(int))&nbsp;colors, float&nbsp;delay_s)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes a GIF (sub)image data chunk, to be placed 
     at the given position. 

<p>     The "fs" versions uses floyd-steinberg dithering, and the "nomap"
     versions have no local colormap.

<p>     Example: 
     <pre>
     object img1 = Image(200,200); 
     object img2 = Image(200,200); 
     // load img1 and img2 with stuff
     write(img1->gif_begin()+
           img1->gif_netscape_loop()+
           img1->gif_add(0,0,100)+
           img2->gif_add(0,0,100)+
           img1->gif_end());
     // voila, a gif animation...
     </pre>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>the location of this subimage
<dt><tt>int delay_cs</tt>
  <dd>frame delay in centiseconds
<dt><tt>float delay_s</tt>
  <dd>frame delay in seconds
<dt><tt>int num_colors</tt>
  <dd>number of colors to quantize to (default is 256)
<dt><tt>array array(array(int)) colors</tt>
  <dd>colors to map to, format is ({({r,g,b}),({r,g,b}),...}).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the GIF data chunk as a string
</blockquote>


<h4>NOTE</h4>
<blockquote>
I (Mirar) recommend reading about the GIF file format before 
     experementing with these.
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>gif_add</a></tt>,
     <tt><a href=Image.html>gif_end</a></tt>,
     <tt><a href=Image.html>gif_netscape_loop</a></tt>,
     <tt><a href=Image.html>togif */</a></tt>
</blockquote>

<hr>
<a name=gif_begin> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>gif_begin</b>()<br>
string <b>gif_begin</b>(int&nbsp;num_colors)<br>
string <b>gif_begin</b>(array(array(int))&nbsp;colors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes GIF header. With no argument, there is no
     global colortable (palette).
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int num_colors</tt>
  <dd>number of colors to quantize to (default is 256) 
 array array(array(int)) colors
     colors to map to, format is ({({r,g,b}),({r,g,b}),...}).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the GIF data
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>gif_add</a></tt>,
     <tt><a href=Image.html>gif_end</a></tt>,
     <tt><a href=Image.html>togif</a></tt>,
     <tt><a href=Image.html>gif_netscape_loop</a></tt>
</blockquote>

<hr>
<a name=gif_end> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>gif_end</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Ends GIF data.
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the GIF data.
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>gif_begin</a></tt>
</blockquote>

<hr>
<a name=gif_netscape_loop> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>gif_netscape_loop</b>()<br>
string <b>gif_netscape_loop</b>(int&nbsp;loops)</tt>
</blockquote>

<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int loops</tt>
  <dd>number of loops, default is 65535.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
a gif chunk that defines that the GIF animation should loop
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>gif_add</a></tt>,
     <tt><a href=Image.html>gif_begin</a></tt>,
     <tt><a href=Image.html>gif_end</a></tt>
</blockquote>

<hr>
<a name=gif_transparency> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>gif_transparency</b>(int&nbsp;color)</tt>
</blockquote>

<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int color</tt>
  <dd>index of color in the palette
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
a gif chunk that transparent a color in the next image chunk
</blockquote>


<h4>NOTE</h4>
<blockquote>
Yes - i know this function is too hard to use. :/
     The palette _is_ unknown mostly...
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>gif_add</a></tt>,
     <tt><a href=Image.html>gif_begin</a></tt>,
     <tt><a href=Image.html>gif_end</a></tt>
</blockquote>

<hr>
<a name=grey> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>grey</b>()<br>
object <b>grey</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes a grey-scale image (with weighted values).

<p>
     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_53.gif><img border=0 src=illustration_53.gif width=67 height=67></a></td>
     <td><a href=illustrations.html#illustration_54.gif><img border=0 src=illustration_54.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->grey();</td>
     <td>->grey(0,0,255);</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>weight of color, default is r=87,g=127,b=41,
     which should be pretty accurate of what the eyes see...
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>color</a></tt>,
     <tt><a href=Image.html>`*</a></tt>,
     <tt><a href=Image.html>modify_by_intensity</a></tt>
</blockquote>

<hr>
<a name=hsv_to_rgb> </a>
<a name=rgb_to_hsv> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>rgb_to_hsv</b>()<br>
object <b>hsv_to_rgb</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Converts RGB data to HSV data, or the other way around.
    When converting to HSV, the resulting data is stored like this:
     pixel.r = h; pixel.g = s; pixel.b = v;

<p>    When converting to RGB, the input data is asumed to be placed in
    the pixels as above.

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_56.gif><img border=0 src=illustration_56.gif width=67 height=67></a></td>
     <td><a href=illustrations.html#illustration_57.gif><img border=0 src=illustration_57.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->hsv_to_rgb();</td>
     <td>->rgb_to_hsv();</td>
     </tr><tr valign=center>
     <td><a href=illustrations.html#illustration_58.gif><img border=0 src=illustration_58.gif width=67 height=67></a></td>
     <td><a href=illustrations.html#illustration_59.gif><img border=0 src=illustration_59.gif width=67 height=67></a></td>
     <td><a href=illustrations.html#illustration_60.gif><img border=0 src=illustration_60.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>tuned box (below)</td>
     <td>the rainbow (below)</td>
     <td>same, but rgb_to_hsv()</td>
     </tr></table>

<p>
    HSV to RGB calculation:
    <pre>
    in = input pixel
    out = destination pixel
    h=-pos*c_angle*3.1415/(float)NUM_SQUARES;
    out.r=(in.b+in.g*cos(in.r));
    out.g=(in.b+in.g*cos(in.r + pi*2/3));
    out.b=(in.b+in.g*cos(in.r + pi*4/3));
    </pre>

<p>    RGB to HSV calculation: Hmm.
    <pre>
    </pre>

<p>     Example: Nice rainbow.
     <pre>
     object i = Image.image(200,200);
     i = i->tuned_box(0,0, 200,200,
                      ({ ({ 255,255,128 }), ({ 0,255,128 }),
                         ({ 255,255,255 }), ({ 0,255,255 })}))
          ->hsv_to_rgb();
     </pre>
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=invert> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>invert</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Invert an image. Each pixel value gets to be 255-x, where x 
    is the old value.

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_62.gif><img border=0 src=illustration_62.gif width=67 height=67></a></td>
     <td><a href=illustrations.html#illustration_63.gif><img border=0 src=illustration_63.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->invert();</td>
     <td>->rgb_to_hsv()->invert()->hsv_to_rgb();</td>
     </tr></table>
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=line> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>line</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2)<br>
object <b>line</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>line</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Draws a line on the image. The line is <i>not</i> antialiased.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x1</tt>
<dt><tt>int y1</tt>
<dt><tt>int x2</tt>
<dt><tt>int y2</tt>
  <dd>line endpoints
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color
<dt><tt>int alpha</tt>
  <dd>alpha value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<a name=map_closest> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>map_closest</b>(array(array(int))&nbsp;colors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps all pixel colors to the colors given.

<p>    Method to find the correct color is linear search
    over the colors given, selecting the nearest in the
    color cube. Slow...

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_65.gif><img border=0 src=illustration_65.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->map_closest(({({255,0,0}),({255,255,255}),({0,0,0})}));</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(array(int)) color</tt>
  <dd>list of destination (available) colors
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>NOTE</h4>
<blockquote>
this function may change slightly when <tt><a href=Image.html>Image::colortable</a></tt> 
     is implemented (pike 0.6, probably)
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>map_fast</a></tt>,
     <tt><a href=Image.html>select_colors</a></tt>,
     <tt><a href=Image.html>map_fs</a></tt>
</blockquote>

<hr>
<a name=map_fast> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>map_fast</b>(array(array(int))&nbsp;colors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps all pixel colors to the colors given.

<p>    Method to find the correct color is to branch
    in a binary space partitioning tree in the 
    colorcube. This is fast, but in some cases
    it gives the wrong color (mostly when few colors
    are available).
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(array(int)) color</tt>
  <dd>list of destination (available) colors
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>NOTE</h4>
<blockquote>
this function may change slightly when <tt><a href=Image.html>Image::colortable</a></tt> 
     is implemented (pike 0.6, probably)
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>map_fast</a></tt>,
     <tt><a href=Image.html>select_colors</a></tt>
</blockquote>

<hr>
<a name=map_fs> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>map_fs</b>(array(array(int))&nbsp;colors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps all pixel colors to the colors given.

<p>    Method to find the correct color is linear search
    over the colors given, selecting the nearest in the
    color cube. Slow...

<p>    Floyd-steinberg error correction is added to create
    a better-looking image, in many cases, anyway.

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_67.gif><img border=0 src=illustration_67.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->map_fs(({({255,0,0}),({255,255,255}),({0,0,0})}));</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(array(int)) color</tt>
  <dd>list of destination (available) colors
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>NOTE</h4>
<blockquote>
this function may change slightly when <tt><a href=Image.html>Image::colortable</a></tt> 
     is implemented (pike 0.6, probably)
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>map_fast</a></tt>,
     <tt><a href=Image.html>select_colors</a></tt>,
     <tt><a href=Image.html>map_closest</a></tt>
</blockquote>

<hr>
<a name=mirrorx> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>mirrorx</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
mirrors an image:
     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_69.gif><img border=0 src=illustration_69.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->mirrorx();</td>
     </tr></table>
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=mirrory> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>mirrory</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
mirrors an image:
     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_71.gif><img border=0 src=illustration_71.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->mirrory();</td>
     </tr></table>
</blockquote>

<hr>
<a name=modify_by_intensity> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>modify_by_intensity</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int|array(int)&nbsp;v1, ..., int|array(int)&nbsp;vn)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Recolor an image from intensity values.

<p>    For each color an intensity is calculated, from r, g and b factors
    (see <tt><a href=Image.html>grey</a></tt>), this gives a value between 0 and max.

<p>    The color is then calculated from the values given, v1 representing
    the intensity value of 0, vn representing max, and colors between
    representing intensity values between, linear.

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_73.gif><img border=0 src=illustration_73.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->grey()->modify_by_intensity(1,0,0, 0,({255,0,0}),({0,255,0}));</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>red, green, blue intensity factors
<dt><tt>int|array(int) v1</tt>
<dt><tt>int|array(int) vn</tt>
  <dd>destination color
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>grey</a></tt>,
     <tt><a href=Image.html>`*</a></tt>,
     <tt><a href=Image.html>color</a></tt>
</blockquote>

<hr>
<a name=noise> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>void <b>noise</b>(array(float|int|array(int))&nbsp;colorrange)<br>
void <b>noise</b>(array(float|int|array(int))&nbsp;colorrange, float&nbsp;scale, float&nbsp;xdiff, float&nbsp;ydiff, float&nbsp;cscale)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Gives a new image with the old image's size,
     filled width a 'noise' pattern.

<p>     The random seed may be different with each instance of pike.

<p>     Example: 
     <tt>->noise( ({0,({255,0,0}), 0.3,({0,255,0}), 0.6,({0,0,255}), 0.8,({255,255,0})}), 0.005,0,0,0.5 );</tt>
     <br><a href=illustrations.html#illustration_74.gif><img border=0 src=illustration_74.gif width=200 height=100></a>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(float|int|array(int)) colorrange</tt>
  <dd>colorrange table
<dt><tt>float scale</tt>
  <dd>default value is 0.1
<dt><tt>float xdiff</tt>
<dt><tt>float ydiff</tt>
  <dd>default value is 0,0
<dt><tt>float cscale</tt>
  <dd>default value is 1
</dl></blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>turbulence</a></tt>
</blockquote>

<hr>
<a name=paste> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>paste</b>(object&nbsp;image)<br>
object <b>paste</b>(object&nbsp;image, int&nbsp;x, int&nbsp;y)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Pastes a given image over the current image.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object image</tt>
  <dd>image to paste
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>where to paste the image; default is 0,0
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>paste_mask</a></tt>,
     <tt><a href=Image.html>paste_alpha</a></tt>,
     <tt><a href=Image.html>paste_alpha_color</a></tt>
</blockquote>

<hr>
<a name=paste_alpha> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>paste_alpha</b>(object&nbsp;image, int&nbsp;alpha)<br>
object <b>paste_alpha</b>(object&nbsp;image, int&nbsp;alpha, int&nbsp;x, int&nbsp;y)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Pastes a given image over the current image, with
     the specified alpha channel value.
     
     An alpha channel value of 0 leaves nothing of the original 
     image in the paste area, 255 is meaningless and makes the
     given image invisible.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object image</tt>
  <dd>image to paste
<dt><tt>int alpha</tt>
  <dd>alpha channel value
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>where to paste the image; default is 0,0
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>paste_mask</a></tt>,
     <tt><a href=Image.html>paste</a></tt>,
     <tt><a href=Image.html>paste_alpha_color</a></tt>
</blockquote>

<hr>
<a name=paste_alpha_color> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>paste_alpha_color</b>(object&nbsp;mask)<br>
object <b>paste_alpha_color</b>(object&nbsp;mask, int&nbsp;x, int&nbsp;y)<br>
object <b>paste_alpha_color</b>(object&nbsp;mask, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>paste_alpha_color</b>(object&nbsp;mask, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;x, int&nbsp;y)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Pastes a given color over the current image,
    using the given mask as opaque channel.  
    
    A pixel value of 255 makes the result become the color given,
    0 doesn't change anything.
    
    The masks red, green and blue values are used separately.
    If no color are given, the current is used.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object mask</tt>
  <dd>mask image
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>what color to paint with; default is current
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>where to paste the image; default is 0,0
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>paste_mask</a></tt>,
     <tt><a href=Image.html>paste_alpha</a></tt>,
     <tt><a href=Image.html>paste_alpha_color</a></tt>
</blockquote>

<hr>
<a name=paste_mask> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>paste_mask</b>(object&nbsp;image, object&nbsp;mask)<br>
object <b>paste_mask</b>(object&nbsp;image, object&nbsp;mask, int&nbsp;x, int&nbsp;y)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Pastes a given image over the current image,
    using the given mask as opaque channel.  
    
    A pixel value of 255 makes the result become a pixel
    from the given image, 0 doesn't change anything.

<p>    The masks red, green and blue values are used separately.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>object image</tt>
  <dd>image to paste
<dt><tt>object mask</tt>
  <dd>mask image
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>where to paste the image; default is 0,0
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>paste</a></tt>,
     <tt><a href=Image.html>paste_alpha</a></tt>,
     <tt><a href=Image.html>paste_alpha_color</a></tt>
</blockquote>

<hr>
<a name=polygone> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>polygone</b>(array(int|float)&nbsp;...&nbsp;curve)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
fills an area with the current color
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(int|float) curve</tt>
  <dd>curve(s), <tt>({x1,y1,x2,y2,...,xn,yn})</tt>,
     automatically closed.

<p>     If any given curve is inside another, it
     will make a hole.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the current object
</blockquote>


<h4>NOTE</h4>
<blockquote>
This function is new (april-97) and rather untested.
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>box</a></tt>,
     <tt><a href=Image.html>setcolor</a></tt>
</blockquote>

<hr>
<a name=read_lsb_grey> </a>
<a name=read_lsb_rgb> </a>
<a name=write_lsb_grey> </a>
<a name=write_lsb_rgb> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>write_lsb_rgb</b>(string&nbsp;what)<br>
object <b>write_lsb_grey</b>(string&nbsp;what)<br>
string <b>read_lsb_rgb</b>()<br>
string <b>read_lsb_grey</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
These functions read/write in the least significant bit
     of the image pixel values. The _rgb() functions
     read/write on each of the red, green and blue values,
     and the grey keeps the same lsb on all three.

<p>     The string is nullpadded or cut to fit.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>string what</tt>
  <dd>the hidden message
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the current object or the read string
</blockquote>

<hr>
<a name=rotate> </a>
<a name=rotate_expand> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>rotate</b>(int|float&nbsp;angle)<br>
object <b>rotate</b>(int|float&nbsp;angle, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>rotate_expand</b>(int|float&nbsp;angle)<br>
object <b>rotate_expand</b>(int|float&nbsp;angle, int&nbsp;r, int&nbsp;g, int&nbsp;b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Rotates an image a certain amount of degrees (360° is 
     a complete rotation) counter-clockwise:

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_76.gif><img border=0 src=illustration_76.gif width=87 height=88></a></td>
     <td><a href=illustrations.html#illustration_77.gif><img border=0 src=illustration_77.gif width=87 height=88></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->rotate(15,255,0,0);</td>
     <td>->rotate_expand(15);</td>
     </tr></table>

<p>     The "expand" variant of functions stretches the 
     image border pixels rather then filling with 
     the given or current color.

<p>     This rotate uses the <tt><a href=Image.html>skewx</a></tt>() and <tt><a href=Image.html>skewy</a></tt>() functions.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int|float angle</tt>
  <dd>the number of degrees to rotate
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color to fill with; default is current
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=rotate_ccw> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>rotate_ccw</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
rotates an image counter-clockwise, 90 degrees.

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_79.gif><img border=0 src=illustration_79.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->rotate_ccw();</td>
     </tr></table>
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=rotate_cw> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>rotate_cw</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
rotates an image clockwise, 90 degrees.

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_81.gif><img border=0 src=illustration_81.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->rotate_cw();</td>
     </tr></table>
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=scale> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>scale</b>(float&nbsp;factor)<br>
object <b>scale</b>(0.5)<br>
object <b>scale</b>(float&nbsp;xfactor, float&nbsp;yfactor)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
scales the image with a factor,
     0.5 is an optimized case.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>float factor</tt>
  <dd>factor to use for both x and y
<dt><tt>float xfactor</tt>
<dt><tt>float yfactor</tt>
  <dd>separate factors for x and y
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=scale> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>scale</b>(int&nbsp;newxsize, int&nbsp;newysize)<br>
object <b>scale</b>(0, int&nbsp;newysize)<br>
object <b>scale</b>(int&nbsp;newxsize, 0)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
scales the image to a specified new size,
     if one of newxsize or newysize is 0,
     the image aspect ratio is preserved.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int newxsize</tt>
<dt><tt>int newysize</tt>
  <dd>new image size in pixels
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=select_colors> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>array(array(int)) <b>select_colors</b>(int&nbsp;num_colors)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Selects the best colors to represent the image.

<p>
     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_83.gif><img border=0 src=illustration_83.gif width=67 height=67></a></td>
     <td><a href=illustrations.html#illustration_84.gif><img border=0 src=illustration_84.gif width=67 height=67></a></td>
     <td><a href=illustrations.html#illustration_85.gif><img border=0 src=illustration_85.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>2</td>
     <td>8</td>
     <td>32</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int num_colors</tt>
  <dd>number of colors to return
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
an array of colors
</blockquote>


<h4>NOTE</h4>
<blockquote>
this function may change somewhat when <tt><a href=Image.html>Image::colortable</a></tt>
     is implemented (pike 0.6, probably)
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>map_fast</a></tt>,
     <tt><a href=Image.html>select_colors</a></tt>
</blockquote>

<hr>
<a name=select_from> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>select_from</b>(int&nbsp;x, int&nbsp;y)<br>
object <b>select_from</b>(int&nbsp;x, int&nbsp;y, int&nbsp;edge_value)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes an grey-scale image, for alpha-channel use.
    
    This is very close to a floodfill.
    
    The image is scanned from the given pixel,
    filled with 255 if the color is the same,
    or 255 minus distance in the colorcube, squared, rightshifted
    8 steps (see <tt><a href=Image.html>distancesq</a></tt>).

<p>    When the edge distance is reached, the scan is stopped.
    Default edge value is 30.
    This value is squared and compared with the square of the 
    distance above.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>originating pixel in the image
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>distancesq</a></tt>
</blockquote>

<hr>
<a name=setcolor> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>setcolor</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>setcolor</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
set the current color
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>new color
<dt><tt>int alpha</tt>
  <dd>new alpha value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<a name=setpixel> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>setpixel</b>(int&nbsp;x, int&nbsp;y)<br>
object <b>setpixel</b>(int&nbsp;x, int&nbsp;y, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>setpixel</b>(int&nbsp;x, int&nbsp;y, int&nbsp;r, int&nbsp;g, int&nbsp;b, int&nbsp;alpha)</tt>
</blockquote>

<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
<dt><tt>int y</tt>
  <dd>position of the pixel
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color
<dt><tt>int alpha</tt>
  <dd>alpha value
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<a name=skewx> </a>
<a name=skewx_expand> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>skewx</b>(int&nbsp;x)<br>
object <b>skewx</b>(int&nbsp;yfactor)<br>
object <b>skewx</b>(int&nbsp;x, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>skewx</b>(int&nbsp;yfactor, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>skewx_expand</b>(int&nbsp;x)<br>
object <b>skewx_expand</b>(int&nbsp;yfactor)<br>
object <b>skewx_expand</b>(int&nbsp;x, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>skewx_expand</b>(int&nbsp;yfactor, int&nbsp;r, int&nbsp;g, int&nbsp;b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Skews an image an amount of pixels or a factor;
     a skew-x is a transformation:

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_87.gif><img border=0 src=illustration_87.gif width=82 height=67></a></td>
     <td><a href=illustrations.html#illustration_88.gif><img border=0 src=illustration_88.gif width=82 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->skewx(15,255,0,0);</td>
     <td>->skewx_expand(15);</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x</tt>
  <dd>the number of pixels
     The "expand" variant of functions stretches the 
     image border pixels rather then filling with 
     the given or current color.
<dt><tt>float yfactor</tt>
  <dd>best described as: x=yfactor*this->ysize()
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color to fill with; default is current
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=skewy> </a>
<a name=skewy_expand> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>skewy</b>(int&nbsp;y)<br>
object <b>skewy</b>(int&nbsp;xfactor)<br>
object <b>skewy</b>(int&nbsp;y, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>skewy</b>(int&nbsp;xfactor, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>skewy_expand</b>(int&nbsp;y)<br>
object <b>skewy_expand</b>(int&nbsp;xfactor)<br>
object <b>skewy_expand</b>(int&nbsp;y, int&nbsp;r, int&nbsp;g, int&nbsp;b)<br>
object <b>skewy_expand</b>(int&nbsp;xfactor, int&nbsp;r, int&nbsp;g, int&nbsp;b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Skews an image an amount of pixels or a factor;
     a skew-y is a transformation:

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_90.gif><img border=0 src=illustration_90.gif width=67 height=82></a></td>
     <td><a href=illustrations.html#illustration_91.gif><img border=0 src=illustration_91.gif width=67 height=82></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->skewy(15,255,0,0);</td>
     <td>->skewy_expand(15);</td>
     </tr></table>

<p>     The "expand" variant of functions stretches the 
     image border pixels rather then filling with 
     the given or current color.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int y</tt>
  <dd>the number of pixels
<dt><tt>float xfactor</tt>
  <dd>best described as: t=xfactor*this->xsize()
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>color to fill with; default is current
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>

<hr>
<a name=threshold> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>threshold</b>()<br>
object <b>threshold</b>(int&nbsp;r, int&nbsp;g, int&nbsp;b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes a black-white image. 

<p>     If all red, green, blue parts of a pixel
     is larger or equal then the given value, the pixel will become
     white, else black.

<p>     This method works fine with the grey method.

<p>     If no arguments are given, the current color is used 
     for threshold values.

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_93.gif><img border=0 src=illustration_93.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>->threshold(90,100,110);</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int r</tt>
<dt><tt>int g</tt>
<dt><tt>int b</tt>
  <dd>red, green, blue threshold values
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the new image object
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>grey</a></tt>
</blockquote>

<hr>
<a name=to8bit_rgbcube> </a>
<a name=to8bit_rgbcube_rdither> </a>
<a name=tozbgr> </a>
<a name=tozrgb> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>tozbgr</b>(array(array(int))&nbsp;colors)<br>
string <b>tozrgb</b>(array(array(int))&nbsp;colors)<br>
string <b>to8bit_rgbcube</b>(int&nbsp;red, int&nbsp;green, int&nbsp;blue)<br>
string <b>to8bit_rgbcube</b>(int&nbsp;red, int&nbsp;green, int&nbsp;blue, string&nbsp;map)<br>
string <b>to8bit_rgbcube_rdither</b>(int&nbsp;red, int&nbsp;green, int&nbsp;blue)<br>
string <b>to8bit_rgbcube_rdither</b>(int&nbsp;red, int&nbsp;green, int&nbsp;blue, string&nbsp;map)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps the image into a colorcube with the given 
     dimensions. Red is least significant, blue is most.

<p>     The "rdither" type of method uses a random dither algoritm.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int red</tt>
<dt><tt>int green</tt>
<dt><tt>int blue</tt>
  <dd>The sides of the colorcube. Not the number of bits!
<dt><tt>string map</tt>
  <dd>Map this position in the colorcube to another value,
     ie: say we have position red=1,green=2,blue=3 in a colorcube of
     6×6×6, we have the index 1+2*6+3*6*6=121. If the 
     map-string contains 'å' in position 121, the resulting
     byte is 'å' or 229.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the calculated string
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>tozbgr</a></tt>,
     <tt><a href=Image.html>to8bit</a></tt>,
     <tt><a href=Image.html>tobitmap</a></tt>
</blockquote>

<hr>
<a name=tobitmap> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>tobitmap</b>();</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Maps the image to a bitmap.

<p>     Bit 0 is the leftmost pixel, and the rows are aligned to 
     bytes.

<p>     Any pixel value other then black results in a set bit.
</blockquote>
<h4>RETURNS</h4>


<blockquote>
the calculated string
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>tozbgr</a></tt>,
     <tt><a href=Image.html>to8bit</a></tt>,
     <tt><a href=Image.html>to8bit_rgbcube</a></tt>,
     <tt><a href=Image.html>cast</a></tt>
</blockquote>

<hr>
<a name=togif> </a>
<a name=togif_fs> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>togif</b>()<br>
string <b>togif</b>(int&nbsp;num_colors)<br>
string <b>togif</b>(array(array(int))&nbsp;colors)<br>
string <b>togif</b>(int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
string <b>togif</b>(int&nbsp;num_colors, int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
string <b>togif</b>(array(array(int))&nbsp;colors, int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
string <b>togif_fs</b>()<br>
string <b>togif_fs</b>(int&nbsp;num_colors)<br>
string <b>togif_fs</b>(array(array(int))&nbsp;colors)<br>
string <b>togif_fs</b>(int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
string <b>togif_fs</b>(int&nbsp;num_colors, int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)<br>
string <b>togif_fs</b>(array(array(int))&nbsp;colors, int&nbsp;trans_r, int&nbsp;trans_g, int&nbsp;trans_b)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Makes GIF data. The togif_fs variant uses floyd-steinberg 
     dithereing.
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int num_colors</tt>
  <dd>number of colors to quantize to (default is 256) 
 array array(array(int)) colors
     colors to map to (default is to quantize to 256), format is ({({r,g,b}),({r,g,b}),...}).
<dt><tt>int trans_r</tt>
<dt><tt>int trans_g</tt>
<dt><tt>int trans_b</tt>
  <dd>one color, that is to be transparent.
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the GIF data
</blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>gif_begin</a></tt>,
     <tt><a href=Image.html>gif_add</a></tt>,
     <tt><a href=Image.html>gif_end</a></tt>,
     <tt><a href=Image.html>toppm</a></tt>,
     <tt><a href=Image.html>fromgif</a></tt>
</blockquote>

<hr>
<a name=toppm> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>string <b>toppm</b>()</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
<b>compability method</b> - do not use in new programs.
     
     See <tt><a href=Image.PNM.html#encode>Image.PNM.encode</a></tt>().
</blockquote>
<h4>RETURNS</h4>


<blockquote>
PPM data
</blockquote>

<hr>
<a name=tuned_box> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>object <b>tuned_box</b>(int&nbsp;x1, int&nbsp;y1, int&nbsp;x2, int&nbsp;y2, array(array(int))&nbsp;corner_color)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
Draws a filled rectangle with colors (and alpha values) tuned
     between the corners.

<p>     Tuning function is (1.0-x/xw)*(1.0-y/yw) where x and y is
     the distance to the corner and xw and yw are the sides of the
     rectangle.

<p>     <table><tr valign=center>
     <td><img src=lena.gif width=67 height=67></td>
     <td><a href=illustrations.html#illustration_95.gif><img border=0 src=illustration_95.gif width=67 height=67></a></td>
     <td><a href=illustrations.html#illustration_96.gif><img border=0 src=illustration_96.gif width=67 height=67></a></td>
     </tr><tr valign=center>
     <td>original</td>
     <td>solid tuning<br>(blue,red,green,yellow)</td>
     <td>tuning transparency<br>(as left + 255,128,128,0)</td>
     </tr></table>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>int x1</tt>
<dt><tt>int y1</tt>
<dt><tt>int x2</tt>
<dt><tt>int y2</tt>
  <dd>rectangle corners
<dt><tt>array(array(int)) corner_color</tt>
  <dd>colors of the corners:
     <pre>
     ({x1y1,x2y1,x1y2,x2y2})
     </pre>
     each of these is an array of integeres:
     <pre>
     ({r,g,b}) or ({r,g,b,alpha})
     </pre>
     Default alpha channel value is 0 (opaque).
</dl></blockquote>
<h4>RETURNS</h4>


<blockquote>
the object called
</blockquote>

<hr>
<a name=turbulence> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>void <b>turbulence</b>(array(float|int|array(int))&nbsp;colorrange)<br>
void <b>turbulence</b>(array(float|int|array(int))&nbsp;colorrange, int&nbsp;octaves, float&nbsp;scale, float&nbsp;xdiff, float&nbsp;ydiff, float&nbsp;cscale)</tt>
</blockquote>

<h4>DESCRIPTION</h4>


<blockquote>
gives a new image with the old image's size,
     filled width a 'turbulence' pattern

<p>     The random seed may be different with each instance of pike.

<p>     Example: <br>
     <tt>->turbulence( ({0,({229,204,204}), 0.9,({229,20,20}), 0.9,0}) );</tt>
     <br><a href=illustrations.html#illustration_97.gif><img border=0 src=illustration_97.gif width=200 height=100></a>
</blockquote>
<h4>ARGUMENTS</h4>
<blockquote><dl>
<dt><tt>array(float|int|array(int)) colorrange</tt>
  <dd>colorrange table
<dt><tt>int octaves</tt>
  <dd>default value is 3
<dt><tt>float scale</tt>
  <dd>default value is 0.1
<dt><tt>float xdiff</tt>
<dt><tt>float ydiff</tt>
  <dd>default value is 0,0
<dt><tt>float cscale</tt>
  <dd>default value is 1
</dl></blockquote>


<h4>SEE ALSO</h4>
<blockquote>     <tt><a href=Image.html>noise</a></tt>
</blockquote>

<hr>
<a name=xsize> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>int <b>xsize</b>()</tt>
</blockquote>

<h4>RETURNS</h4>


<blockquote>
the width of the image
</blockquote>

<hr>
<a name=ysize> </a>
<h4>SYNOPSIS</h4>
<blockquote>
<tt>int <b>ysize</b>()</tt>
</blockquote>

<h4>RETURNS</h4>


<blockquote>
the height of the image
</blockquote>

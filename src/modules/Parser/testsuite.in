START_MARKER

dnl - Parser.HTML

define(test_parser, [[
  define([[WIDENER]], "\0")
  test_any_equal($1,$2)
  define([[WIDENER]], "\400")
  test_any_equal($1,$2)
  define([[WIDENER]], "\200000")
  test_any_equal($1,$2)
  undefine([[WIDENER]])
]])

// Callback arguments and return values
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return "<t2>";});
  p->add_tag ("t2", "a");
  return p->finish("<t>" WIDENER)->read();
]], "a" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({"<t>"});});
  return p->finish("<t>" WIDENER)->read();
]], "<t>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return "<t>";});
  if (catch {
    return p->finish("<t>" WIDENER)->read();
  }) return 1;
]], 1);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", "<t>");
  if (catch {
    return p->finish("<t>" WIDENER)->read();
  }) return 1;
]], "<t>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", "t");
  return p->finish("<t a=b c>" WIDENER)->read();
]], "t" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a>" WIDENER)->read();
]], "a" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(indices(a))*","});});
  return p->finish("<t a=b 1=2>" WIDENER)->read();
]], ("1,a" WIDENER));
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(values(a))*","});});
  return p->finish("<t a=b 1=2>" WIDENER)->read();
]], ("2,b" WIDENER));
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return p;});
  if (catch {
    return p->finish("<t>" WIDENER)->read();
  }) return 1;
]], 1);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "<t>";});
  p->add_tag ("t", "a");
  return p->finish("&e;<x x =  &e;'&e;' &e;>&e;" WIDENER)->read();
]], "a<x x =  <t>'<t>' &e;>a" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->splice_arg ("::");
  p->add_entity ("e", lambda (object p) {return "<t>";});
  p->add_tag ("t", "a");
  return p->finish("&e;<x x =  &e;'&e;' &e;>&e;" WIDENER)->read();
]], "a<x x =  <t>'<t>' &e;>a" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return ({"&e;"});});
  return p->finish("&e;<x x=&e;>" WIDENER)->read();
]], "&e;<x x=&e;>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "&e;";});
  if (catch {
    return p->finish("&e;" WIDENER)->read();
  }) return 1;
]], 1);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "&e;";});
  if (catch {
    return p->finish("<x x=&e;>" WIDENER)->read();
  }) return 1;
]], 1);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "e");
  return p->finish("&e;<x x=&e;>" WIDENER)->read();
]], "e<x x=e>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", "&e;");
  p->add_entity ("e", "<t>");
  if (catch {
    return p->finish("<t>&e;<x x  = &e;>" WIDENER)->read();
  }) return 1;
]], "&e;<t><x x  = <t>>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", ({lambda (object p, mixed... e) {return e;}, 17, (<>)}));
  p->add_container ("c", ({lambda (object p, mixed... e) {return e;}, ({}), 0, 0}));
  p->add_entity ("e", ({lambda (object p, mixed... e) {return e;}, "f"}));
  p->set_extra (4711);
  return p->finish("<t a><c>x</c>&e;<x x=&e;>" WIDENER)->read();
]], ({(["a": "a"]), 17, (<>), 4711,
      ([]), "x", ({}), 0, 0, 4711,
      "f", 4711, "<x x=", "f", 4711, ">", WIDENER}));
test_parser([[
  object p = Parser.HTML();
  p->_set_tag_callback (
    lambda (object p, string str) {
      p->add_container (p->tag_name(),
			lambda (object p, mapping a, string c) {
			  return ({"C(", p->tag_name(), "|", c, ")"});
			});
      return 1;
    });
  return p->finish ("<t>x</t>" WIDENER)->read();
]], "C(t|x)" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", "x");
  p->add_quote_tag ("!--",
		    lambda (object p, string s) {
		      return ({"[", s, "]"});
		    },
		    "--");
  p->add_quote_tag ("!-",
		    lambda (object p, string s) {
		      return ({"{", s, "}"});
		    },
		    "\'");
  return p->finish ("<t> <!-- <t a='> -- --> <!-<t a='> -->" WIDENER)->read();
]], "x [ <t a='> -- ] {<t a=} -->" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->write_out ("[" + a->x + "]"); return 0;});
  return p->finish ("&e; <t x='&e;' &e;=&e;>" WIDENER)->read();
}]], "x [&e;]<t x='x' &e;=x>" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->splice_arg ("&e;");
  p->add_entity ("e", "x");
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->write_out ("[" + a["&e;"] + "]"); return 0;});
  return p->finish ("&e; <t x='&e;' &e;=&e;>" WIDENER)->read();
}]], "x [&e;]<t x='x' x>" WIDENER);

// Current context functions
test_parser([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->splice_arg ("::");
  p->add_tag (
    "t", lambda (object p, mapping a) {
	   return ({"T(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), "|", p->context(), ")"});
	 });
  p->add_container (
    "c", lambda (object p, mapping a, string c) {
	   return ({"C(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), "|", p->context(), ")"});
	 });
  p->add_entity (
    "e", lambda (object p) {
	   return ({"E(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), "|", p->context(), ")"});
	 });
  p->add_quote_tag (
    "q", lambda (object p, string c) {
	   return ({"Q(", p->current(), "|", p->tag_name(), "|",
		    (string) p->tag_content(), "|", p->context(), ")"});
	 }, "p");
  return p->finish ("<t a=&e; <t>> <q <\"' &e; p> "
		    "&e<c x=y -- >x</c> &e; "
		    "<x &e; q=&e;> <x q='&e;'> <x ::='&e;'>"
		    WIDENER)->read();
}]], ("T(<t a=&e; <t>>|t|0|data) Q(<q <\"' &e; p>|q| <\"' &e; |data) "
      "&eC(<c x=y -- >x</c>|c|x|data) E(&e;|e|0|data) "
      "<x &e; q=E(&e;|e|0|arg)> <x q='E(&e;|e|0|')'> <x E(&e;|e|0|splice_arg)>"
      WIDENER));
test_parser([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->splice_arg ("::");
  p->_set_tag_callback (
    lambda (object p, string s) {
      return ({"T(", p->current(), "|", p->tag_name(), "|",
	       (string) p->tag_content(), "|", p->context(), ")"});
    });
  return p->finish ("<x &e; q=&f;> &g; "
		    "<x q='&h;'/> <x ::='&i;'>"
		    WIDENER)->read();
}]], ("T(<x &e; q=&f;>|x|0|data) &g; "
      "T(<x q='&h;'/>|x|0|data) T(<x ::='&i;'>|x|0|data)"
      WIDENER));
test_parser([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->splice_arg ("::");
  p->_set_entity_callback (
    lambda (object p, string s) {
      return ({"E(", p->current(), "|", p->tag_name(), "|",
	       (string) p->tag_content(), "|", p->context(), ")"});
    });
  return p->finish ("<x &e; q=&f;> &g; "
		    "<x q='&h;'/> <x ::='&i;'>"
		    WIDENER)->read();
}]], ("<x &e; q=E(&f;|f|0|arg)> E(&g;|g|0|data) "
      "<x q='E(&h;|h|0|')'/> <x E(&i;|i|0|splice_arg)>"
      WIDENER));
test_parser([[
  object p = Parser.HTML();
  array a = ({ });
  p->_set_tag_callback (
    lambda (object p, string str) {
      a += ({ p->tag_name() });
      return 0;
    });
  p->finish("<t>x</t>" WIDENER);
  return a;
]], ({ "t", "/t" }));

// Argument quoting
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
 return p->finish("<t a=\"f'o\">" WIDENER)->read();
]], "f'o" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f\"o'>" WIDENER)->read();
]], "f\"o" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"\\\">" WIDENER)->read();
]], "\\" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f'\"'\"'o'>" WIDENER)->read();
]], "f" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f\"'\"'\"o\">" WIDENER)->read();
]], "f" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({"(", a->a, ")"});});
  return p->finish("<t a=f>oo>" WIDENER)->read();
]], "(f)oo>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=\"f'o><t>" WIDENER)->read();
]], "f'o><t>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a=b=\"c=d\"='e'=f=g>" WIDENER)->read();
]], "b=c=d" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a + " " + a[""]});});
  return p->finish("<t a=b =\"c=d\"='e'=f=g>" WIDENER)->read();
]], "b f=g" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {return ({a["b/a"]+"|"+a["/a"]+"|"+a["a/"]+"|"+a["a"]});});
  return p->finish("<t b/a> <t b /a> <t b a/> "
		   "<t b /a=fo> <t b a/=fo> <t b a=/fo> "
		   "<t b a=f/o> <t b a=fo/> <t b a='fo/'>"
		   WIDENER)->read();
}]], ("b/a|0|0|0 0|/a|0|0 0|0|0|a "
      "0|fo|0|0 0|0|fo|0 0|0|0|/fo "
      "0|0|0|f/o 0|0|0|fo 0|0|0|fo/"
      WIDENER));
test_parser([[{
  object p = Parser.HTML();
  p->xml_tag_syntax (0);
  p->add_tag ("t", lambda (object p, mapping a)
		     {return ({a["b/a"]+"|"+a["/a"]+"|"+a["a/"]+"|"+a["a"]});});
  return p->finish("<t b/a> <t b /a> <t b a/> "
		   "<t b /a=fo> <t b a/=fo> <t b a=/fo> "
		   "<t b a=f/o> <t b a=fo/> <t b a='fo/'>"
		   WIDENER)->read();
}]], ("b/a|0|0|0 0|/a|0|0 0|0|a/|0 "
      "0|fo|0|0 0|0|fo|0 0|0|0|/fo "
      "0|0|0|f/o 0|0|0|fo/ 0|0|0|fo/"
      WIDENER));

// Result reparsing
test_parser([[{
  object p = Parser.HTML();
  p->_set_data_callback (lambda (object p, string s) {return ({"[", s, "]"});});
  p->add_tag ("t", "T");
  p->add_container ("c", "C");
  p->add_entity ("e", "E");
  p->add_quote_tag ("q", "Q", "q");
  return p->finish ("a<t>b<c>c</c>d&e;e<qfq>" WIDENER)->read();
}]], "[a]T[b]C[d]E[e]Q[" WIDENER "]");
test_parser([[{
  object p = Parser.HTML();
  p->_set_data_callback (lambda (object p, string s) {return ({"[", s, "]"});});
  p->reparse_strings (1);
  p->add_tag ("t", "T");
  p->add_container ("c", "C");
  p->add_entity ("e", "E");
  p->add_quote_tag ("q", "Q", "q");
  return p->finish ("a<t>b<c>c</c>d&e;e<qfq>" WIDENER)->read();
}]], "[aTbCdEeQ" WIDENER "]");
test_parser([[{
  object p = Parser.HTML();
  p->_set_data_callback (lambda (object p, string s) {return ({"[", s, "]"});});
  p->add_tag ("t", lambda () {return "T";});
  p->add_container ("c", lambda () {return "C";});
  p->add_entity ("e", lambda () {return "E";});
  p->add_quote_tag ("q", lambda () {return "Q";}, "q");
  return p->finish ("a<t>b<c>c</c>d&e;e<qfq>" WIDENER)->read();
}]], "[a][Tb][Cd][Ee][Q" WIDENER "]");
test_parser([[{
  object p = Parser.HTML();
  p->_set_data_callback (lambda (object p, string s) {return ({"[", s, "]"});});
  p->add_tag ("t", lambda () {return ({"T"});});
  p->add_container ("c", lambda () {return ({"C"});});
  p->add_entity ("e", lambda () {return ({"E"});});
  p->add_quote_tag ("q", lambda () {return ({"Q"});}, "q");
  return p->finish ("a<t>b<c>c</c>d&e;e<qfq>" WIDENER)->read();
}]], "[a]T[b]C[d]E[e]Q[" WIDENER "]");
test_parser([[{
  object p = Parser.HTML();
  p->_set_data_callback (lambda (object p, string s) {return ({"[", s, "]"});});
  p->add_tag ("t", lambda () {return 0;});
  p->add_container ("c", lambda () {return 0;});
  p->add_entity ("e", lambda () {return 0;});
  p->add_quote_tag ("q", lambda () {return 0;}, "q");
  return p->finish ("a<t>b<c>c</c>d&e;e<qfq>" WIDENER)->read();
}]], "[a]<t>[b]<c>[c]</c>[d]&e;[e]<qfq>[" WIDENER "]");

// Local feeds
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return ({"<t3>"});});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t>c" WIDENER)->read();
]], "a<t3>2b<t3>2c" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return "<t3>";});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t>c" WIDENER)->read();
]], "a32b32c" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return "<t3>";});
  p->add_tag ("t2", lambda (object p, mapping a)
		      {p->feed_insert("A<t3>B"); return "2";});
  p->add_tag ("t3", "3");
  return p->finish("a<t>b<t>c" WIDENER)->read();
]], "a32A3Bb32A3Bc" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->feed_insert("<t2>"); return s;});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t3>c</t>d" WIDENER)->read();
]], "ab3c2d" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->_set_data_callback (lambda (object p, string s) {return ({"[", s, "]"});});
  p->reparse_strings (1);
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return ({"<t3>"});});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t>c" WIDENER)->read();
]], "[a]<t3>[2b]<t3>[2c" WIDENER "]");
test_parser([[
  object p = Parser.HTML();
  p->_set_data_callback (lambda (object p, string s) {return ({"[", s, "]"});});
  p->reparse_strings (1);
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return "<t3>";});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t>c" WIDENER)->read();
]], "[a][32b][32c" WIDENER "]");
test_parser([[
  object p = Parser.HTML();
  p->_set_data_callback (lambda (object p, string s) {return ({"[", s, "]"});});
  p->reparse_strings (1);
  p->add_tag ("t", lambda (object p, mapping a)
		     {p->feed_insert("<t2>"); return "<t3>";});
  p->add_tag ("t2", lambda (object p, mapping a)
		      {p->feed_insert("A<t3>B"); return "2";});
  p->add_tag ("t3", "3");
  return p->finish("a<t>b<t>c" WIDENER)->read();
]], "[a][3][2A3Bb][3][2A3Bc" WIDENER "]");
test_parser([[
  object p = Parser.HTML();
  p->_set_data_callback (lambda (object p, string s) {return ({"[", s, "]"});});
  p->reparse_strings (1);
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->feed_insert("<t2>"); return s;});
  p->add_tags ((["t2": "2", "t3": "3"]));
  return p->finish("a<t>b<t3>c</t>d" WIDENER)->read();
]], "[a][b3c2d" WIDENER "]");

// Streaming
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a=1>2")->feed("<t a=3>" WIDENER)->read();
]], "123" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a=1>2")->read() + " " + p->feed("<t a=3>" WIDENER)->read();
]], "12 3" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({"{", a->a, "}"});});
  return p->feed("<t a='f")->feed("oo'>" WIDENER)->read();
]], "{foo}" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({"{", a->a, "}"});});
  return p->feed("<t a='")->feed("foo'>" WIDENER)->read();
]], "{foo}" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f")->read() + " " + p->feed("oo'>" WIDENER)->read();
]], " foo" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->feed("<t a='f>" WIDENER)->read();
]], "");
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return p->finish("<t a='f>" WIDENER)->read();
]], "f>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({a->a});});
  return (p->feed("<")->feed("t")->feed(" ")->feed("a")->feed("=")->feed("'")->
	  feed("f")->feed("o")->feed("o")->feed("'")->feed(">")->
	  feed(WIDENER)->read());
]], "foo" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("c", lambda (object p, mapping a, string c)
			   {return ({"[", a->a, "|", c, "]"});});
  return (p->feed("<")->feed("c")->feed(" ")->feed("a")->feed("=")->feed("'")->
	  feed("f")->feed("o")->feed("o")->feed("'")->feed(">")->feed("x")->
	  feed("y")->feed("<")->feed("c")->feed(">")->feed("z")->feed("<")->
	  feed("t")->feed(">")->feed("<")->feed("/")->feed("c")->feed(">")->
	  feed("q")->feed("<")->feed("/")->feed("c")->feed(">")->feed(".")->
	  feed(WIDENER)->read());
}]], "[foo|xy<c>z<t></c>q]." WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "e";});
  return p->feed("&e")->read() + " " + p->feed(";" WIDENER)->read();
]], " e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_entity ("e", lambda (object p) {return "e";});
  return (p->feed("<x x=&e")->read() + " " +
	  p->feed(";")->read() + " " +
	  p->feed(">" WIDENER)->read());
}]], "<x x= e >" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({s});}, "]--");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({s});}, "]");
  return (p->feed("<!")->read() + " " +
	  p->feed("--")->read() + " " +
	  p->feed("x-->" WIDENER)->read());
]], "  x" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({s});}, "]--");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({s});}, "]");
  return (p->feed("<!")->read() + " " +
	  p->feed("--")->read() + " " +
	  p->feed("x--")->read() + " " +
	  p->feed("->" WIDENER)->read());
]], "   x-" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_quote_tag ("!--", lambda (object p, string s) {return ({"1",s});}, "--");
  p->add_quote_tag ("!--[", lambda (object p, string s) {return ({"2",s});}, "]-");
  p->add_quote_tag ("![", lambda (object p, string s) {return ({"3",s});}, "]");
  return (p->feed("<")->read() + "a" + p->feed("!")->read() + "b" +
	  p->feed("-")->read() + "c" + p->feed("-")->read() + "d" +
	  p->feed("X")->read() + "e" + p->feed("Y")->read() + "f" +
	  p->feed("]")->read() + "g" + p->feed(">")->read() + "h" +
	  p->feed("]")->read() + "i" + p->feed("-")->read() + "j" +
	  p->feed(">")->read() + "k" + p->feed("-")->read() + "l" +
	  p->feed("-")->read() + "m" + p->feed("-")->read() + "n" +
	  p->feed(">" WIDENER)->read());
}]], "abcdefghijklmn1XY]>]->-" WIDENER);

// Exception handling
test_parser([[{
  object p = Parser.HTML();
  int t[[,]] c[[,]] e[[,]] q;
  p->splice_arg ("::");
  p->add_tag ("t", lambda (object p, mapping a) {
		     if (t++ < 3) {p->write_out ((string) t); throw (t);}
		     return ({"|", (string) t});
		   });
  p->add_container ("c", lambda (object p, mapping a, string s) {
			   if (c++ < 3) {p->write_out ((string) c); throw (c);}
			   return ({"|", (string) c});
			 });
  p->add_entity ("e", lambda (object p) {
			if (e++ < 3) {p->write_out ((string) e); throw (e);}
			array res = ({"|", (string) e});
			e = 0;
			return res;
		      });
  p->add_quote_tag ("q", lambda (object p, string s) {
			   if (q++ < 3) {p->write_out ((string) q); throw (q);}
			   return ({"|", (string) q});
			 },
		    "q");
  if (catch (p->finish ("<t> <c> <t> &e; </c> &e; <q &e; q> "
			"<x a=&e; &e; b='<t>&e;' ::='abc&e;def'>" WIDENER)))
    for (int i; i < 50; i++)
      if (!catch (p->finish())) break;
  return p->read();
}]], ("123|4 123|4 123|4 123|4 "
      "<x a=123|4 &e; b='<t>123|4' abc123|4def>" WIDENER))

// Mixed mode
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {return ({1});});
  return !!catch (p->finish("a<t>b" WIDENER)) + p->read();
]], "1a");
test_parser([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {p->write_out(1); return ({2});});
  return p->finish("a<t>b" WIDENER)->read();
]], ({"a",1,2,"b" WIDENER}));
test_parser([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return ({a});});
  return p->finish("<t a=b>" WIDENER)->read();
]], ({(["a": "b"]), WIDENER}));
test_parser([[{
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return ({1});});
  p->feed ("a<t>b" WIDENER);
  return ({!!catch (p->mixed_mode (0))}) + p->read();
}]], ({1, "a", 1, "b" WIDENER}));
test_parser([[{
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return ({"x"});});
  p->feed ("a<")->feed ("t>")->feed ("b")->feed (WIDENER);
  return !!catch (p->mixed_mode (0)) + p->read();
}]], "0axb" WIDENER);
test_parser([[{
    object p = Parser.HTML();
    p->mixed_mode (1);
    p->add_tag ("t", lambda (object p, mapping a) {return ({1});});
    return p->clone()->finish("<t>" WIDENER)->read();
  }]], ({1, WIDENER}));
test_parser([[{
    object p = Parser.HTML();
    p->mixed_mode (1);
    p->feed ("foo" WIDENER)->feed ("bar");
    p->mixed_mode (0);
    p->finish ("gnu");
    return p->read();
  }]], "foo" WIDENER "bargnu");
test_parser(
  [[
    object p = Parser.HTML();
    p->mixed_mode (1);
    p->add_container ("c", lambda (object p, mapping a, string s) {return ({s});});
    return p->finish("<c>x</c>" * 31 + WIDENER)->read();
  ]], ({"x"}) * 31 + ({WIDENER}));
test_parser(
  [[
    object p = Parser.HTML();
    p->mixed_mode (1);
    p->add_container ("c", lambda (object p, mapping a, string s) {return ({s});});
    return p->finish("<c>x</c>" * 32 + WIDENER)->read();
  ]], ({"x"}) * 32 + ({WIDENER}));
test_parser(
  [[
    object p = Parser.HTML();
    p->mixed_mode (1);
    p->add_container ("c", lambda (object p, mapping a, string s) {return ({s});});
    return p->finish("<c>x</c>" * 33 + WIDENER)->read();
  ]], ({"x"}) * 33 + ({WIDENER}));

// Matching tags and quotes
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->add_tag ("t>", "c");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  return p->finish(WIDENER "<a href=\"<t\">")->read();
]], WIDENER "<a href=\"c");
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a)
		     {return ({"[",a->test,"]"});});
  return p->finish(WIDENER "<t test=\">")->read();
]], WIDENER "[>]");
test_parser([[
  object p = Parser.HTML();
  p->add_container ("c", lambda (object p, mapping a, string s)
			   {return ({"[",a->test,"|",s,"]"});});
  return p->finish(WIDENER "<c test=\">")->read();
]], WIDENER "[>|]");
test_parser([[
  object p = Parser.HTML();
  p->match_tag (0);
  p->add_container ("c", lambda (object p, mapping a, string s)
			   {return ({"[",s,"]"});});
  return p->finish(WIDENER "<c></c </c>>")->read();
]], WIDENER "[</c ]>");
test_parser([[
  object p = Parser.HTML();
  p->match_tag (0);
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({s});});
  return p->finish(WIDENER "<c><</c>")->read();
]], WIDENER "<");
test_parser([[
  object p = Parser.HTML();
  p->add_container ("c", "C");
  return p->finish(WIDENER "<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], WIDENER "C ");
test_parser([[
  object p = Parser.HTML();
  p->ignore_unknown (1);
  p->add_container ("c", "C");
  return p->finish(WIDENER "<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], WIDENER "C --> </c> C ");
test_parser([[
  object p = Parser.HTML();
  p->add_quote_tag ("!--", ".", "--");
  p->add_container ("c", "C");
  return p->finish(WIDENER "<c> <!-- \" </c> --> </c> <c> <!-- \" --> </c> ")->read();
]], WIDENER "C C ");
test_parser([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return p->tag();});
  return p->finish(WIDENER "<t a b='b>")->read();
]], ({WIDENER, "t", (["a": "a", "b": "b>"]), 0}));
test_parser([[
  object p = Parser.HTML();
  p->mixed_mode (1);
  p->add_tag ("t", lambda (object p, mapping a) {return p->tag((<>));});
  return p->finish(WIDENER "<t a b='b>")->read();
]], ({WIDENER, "t", (["a": (<>), "b": "b>"]), 0}));
test_parser([[{
  object p = Parser.HTML();
  p->_set_tag_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  return p->finish (WIDENER "<t <bar // > >xab")->read();
}]], WIDENER "[<t <bar // > >]xab");
test_parser([[{
  object p = Parser.HTML();
  p->_set_tag_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  return p->finish (WIDENER "<t <bar/>>xab")->read();
}]], WIDENER "[<t <bar/>>]xab");
test_parser([[{
  object p = Parser.HTML();
  p->_set_tag_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  return p->finish (WIDENER "<t </bar>/>xab")->read();
}]], WIDENER "[<t </bar>/>]xab");
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish (WIDENER "a<t>b<t/>c</t>d</t>e")->read();
}]], WIDENER "a[b<t/>c</t>d]e");
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish (WIDENER "a<t>b<t>c</t>d</t>e")->read();
}]], WIDENER "a[b<t>c</t>d]e");
test_parser([[{
  object p = Parser.HTML();
  p->ignore_unknown (1);
  p->match_tag (0);
  p->add_container ("c", "");
  p->add_tag ("X", "");
  p->add_container ("Y", "");
  p->add_tag ("/x", "");
  p->add_container ("/y", "");
  return p->finish (WIDENER
		    "1<c>-<a </c>-</c>-"
		    "2<c>-<X </c>-</c>-"
		    "3<c>-</X </c>-</c>-"
		    "4<c>-<//X </c>-</c>-"
		    "5<c>-<Y </c>-</c>-"
		    "6<c>-</Y </c>-</c>-"
		    "7<c>-<//Y </c>-</c>-"
		    "8<c>-<x </c>-</c>-"
		    "9<c>-</x </c>-</c>-"
		    "10<c>-<//x </c>-</c>-"
		    "11<c>-<y </c>-</c>-"
		    "12<c>-</y </c>-</c>-"
		    "13<c>-<//y </c>-</c>-"
		    "14<c>-<c </c>-</c>-</c>-")->read();
}]],               (WIDENER
		    "1-</c>-"
		    "2-"
		    "3-</c>-"
		    "4-</c>-"
		    "5-"
		    "6-"
		    "7-</c>-"
		    "8-</c>-"
		    "9-"
		    "10-</c>-"
		    "11-</c>-"
		    "12-"
		    "13-"
		    "14-"));
test_parser([[{
  object p = Parser.HTML();
  p->match_tag (0);
  p->add_container ("foo", "");
  return p->finish (WIDENER "<foo></foobar</foo>")->read();
}]], WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("foo", lambda (object p, mapping a, string s)
			     {return ({"[",s,"]"});});
  p->add_quote_tag ("?", "y", "?");
  return p->finish (WIDENER "<foo><? sadf </foo>z")->read();
}]], WIDENER "[<? sadf </foo>z]");
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("foo", lambda (object p, mapping a, string s)
			     {return ({"[",s,"]"});});
  p->add_quote_tag ("?", "y", "?");
  return p->finish (WIDENER "<t><foo><? sadf </foo>z")->read();
}]], WIDENER "<t>[<? sadf </foo>z]");

// Redefinition during parsing
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("a", lambda (object p, mapping a)
		     {p->add_tag ("b", "B"); return ({"A"});});
  return p->finish("<b><a><b>" WIDENER)->read();
]], "<b>AB" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("a", lambda (object p, mapping a)
		     {p->add_tag ("b", 0); return ({"A"});});
  p->add_tag ("b", "B");
  return p->finish("<b><a><b>" WIDENER)->read();
]], "BA<b>" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->ignore_unknown (1);
  p->add_tag ("a", lambda (object p) {return ({"A"});});
  p->_set_data_callback (lambda (object p, string s) {
			   p->add_tag ("a", 0);
			   return ({"[", s, "]"});
			 });
  return p->finish ("x<a>" WIDENER)->read();
}]], "[x][<a>" WIDENER "]");
test_parser([[{
  object p = Parser.HTML();
  p->ignore_unknown (1);
  p->_set_tag_callback (lambda (object p) {return ({"A"});});
  p->_set_data_callback (lambda (object p, string s) {
			   p->_set_tag_callback (0);
			   return ({"[", s, "]"});
			 });
  return p->finish ("x<a>" WIDENER)->read();
}]], "[x][<a>" WIDENER "]");

// Delimiters
test_parser([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("&e; &e<t> &e <t> a='&e;&e' &e=f; b=\"&e\" &e>" WIDENER)->read();
]], "x &e<t> &e <t> a='x&e' &e=f; b=\"&e\" &e>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;&e' \"&e;'&e; >\" &e; >" WIDENER)->read();
]], "<t a='x&e' \"&e;'&e; >\" x >" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;&e' \"&e;'&e; >\" &e; >" WIDENER)->read();
]], "<t a='x&e' \"&e;'&e; >\" &e; >" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;&e' \"&e;'&e; >\" &e; " WIDENER)->read();
]], "<t a='x&e' \"&e;'&e; >\" x " WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;&e' \"&e;'&e; >\" &e; " WIDENER)->read();
]], "<t a='x&e' \"&e;'&e; >\" &e; " WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->_set_entity_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  return p->finish ("&abc|&abc<>&abc;<x x='&abc|&abc<>&abc;'>" WIDENER)->read();
]], "&abc|&abc<>[&abc;]<x x='&abc|&abc<>[&abc;]'>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->_set_entity_callback (lambda (object p, string s) {return ({"[",s,"]"});});
  p->_set_data_callback (lambda (object p, string s) {return ({"{",s,"}"});});
  return p->finish ("&abc|&abc<>&abc;" WIDENER)->read();
]], "{&abc|&abc}<>[&abc;]{" WIDENER "}");
test_parser([[{
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish(WIDENER "&e")->read();
}]], WIDENER "&e");
test_parser([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish(WIDENER "&e")->read();
}]], WIDENER "&e");
test_parser([[{
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish(WIDENER "<x x=&e")->read();
}]], WIDENER "<x x=&e");
test_parser([[{
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish(WIDENER "<x x=&e")->read();
}]], WIDENER "<x x=&e");
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t &e; a=\"&f&e;'&e&e;o\">" WIDENER)->read();
]], "<t &e; a=\"&f&e;'&e&e;o\">" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->lazy_entity_end (1);
  p->add_entity ("e", "x");
  return p->finish("<t &e; a=\"&f&e;'&e&e;o\">" WIDENER)->read();
]], "<t &e; a=\"&fx'&exo\">" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a=&e;'f\"o' &e>" WIDENER)->read();
]], "<t a=x'f\"o' &e>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='f\"o'&e/>" WIDENER)->read();
]], "<t a='f\"o'&e/>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t 'a=f\"o'=&e;>" WIDENER)->read();
]], "<t 'a=f\"o'=x>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='f\"o'&e;'/>" WIDENER)->read();
]], "<t a='f\"o'&e;'/>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a=&e;'f\"o' &e>" WIDENER)->read();
]], "<t a=x'f\"o' &e>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;&e;&e;'>" WIDENER)->read();
]], "<t a='xxx'>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;'\" &e;=\"&e;>" WIDENER)->read();
]], "<t a='x'\" &e;=\"&e;>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;'\"&e;\"=&e;>" WIDENER)->read();
]], "<t a='x'\"&e;\"=x>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "x");
  return p->finish("<t a='&e;'\"&e ;\"=&e;>" WIDENER)->read();
]], "<t a='x'\"&e ;\"=x>" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_entity ("e", lambda (object p, string c) {return "'> &f; <t y='";});
  p->add_entity ("f", "foo");
  return p->finish("<x a='&e;'>" WIDENER)->read();
]], "<x a=''> foo <t y=''>" WIDENER);

// Splice argument
test_parser([[{
  object p = Parser.HTML();
  p->splice_arg ("::");
  p->add_entity ("e", "x");
  return p->finish ("<x ::  = \"foo bar='gnu' &e;\"&e; a='&e;' &e;:: "
		    "::=&e; :::=\"&e;y\" ::  ::  =  ''&e;\"\" :/: ::/>"
		    WIDENER)->read();
}]], "<x foo bar='gnu' x&e; a='x' &e;:: x :::=\"xy\"   &e;\"\" :/: />" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->xml_tag_syntax (0);
  p->splice_arg ("::");
  p->add_entity ("e", "x");
  return p->finish ("<x ::  = \"foo bar='gnu' &e;\" &e; a='&e;' &e;:: "
		    "::=&e; :::=\"&e;y\" ::  ::  =  '&e;\"\"' :/: ::/>"
		    WIDENER)->read();
}]], "<x foo bar='gnu' x &e; a='x' &e;:: x :::=\"xy\"   x\"\" :/: ::/>" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->splice_arg (":/:");
  p->add_entity ("e", "x");
  return p->finish ("<x/x /::  = &e; :/: =&e; ::/= &e;>" WIDENER)->read();
}]], "<x/x /::  = x x ::/= x>" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->splice_arg ("::");
  p->add_entity ("e", "x");
  return p->finish ("<x/x /::  = &e; :/: =&e; ::/= &e;>" WIDENER)->read();
}]], "<x/x /::  = x :/: =x ::/= x>" WIDENER);

// Recursive parsing in tags
test_parser([[
  object p = Parser.HTML();
  p->add_entity ("e", "e");
  p->add_tag ("t", lambda (object p, mapping a) {return ({sort(values(a))*","});});
  return p->finish("<t a=\"&e;\">" WIDENER)->read();
]], "&e;" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  return p->finish("<!-- <t> -->" WIDENER)->read();
]], "<!-- <t> -->" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->ignore_unknown (1);
  return p->finish("<!-- <t> -->" WIDENER)->read();
]], "<!-- b -->" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  return p->finish("<a href=\"<t>\">" WIDENER)->read();
]], "<a href=\"<t>\">" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", "b");
  p->ignore_unknown (1);
  return p->finish("<a href=\"<t>\">" WIDENER)->read();
]], "<a href=\"b\">" WIDENER);

// XML syntax
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b</t>c<c>d</c>e<t/>f</t>g<c/>h</c>i" WIDENER)->read();
}]], "a()b</t>c[d]e()f</t>g[h]i" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<c>d</c>e<t/>f</t>g<c/>h</c>i" WIDENER)->read();
}]], "a()b</t>c[d]e()f</t>g[]h</c>i" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("c", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<c>d</c>e<t/>f</t>g<c/>h</c>i" WIDENER)->read();
}]], "a()c[d]e()f</t>g[]h</c>i" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  return p->finish ("a<t>b</t>c<t/>d</t>e" WIDENER)->read();
}]], "a()b</t>c()d</t>e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b</t>c<t/>d</t>e" WIDENER)->read();
}]], "a[b]c[d]e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  return p->finish ("a<t>b</t>c<t/>d</t>e" WIDENER)->read();
}]], "a()b</t>c()d</t>e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<t/>d</t>e" WIDENER)->read();
}]], "a()b</t>c()d</t>e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<t/>d</t>e" WIDENER)->read();
}]], "a[b]c[]d</t>e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (2);
  return p->finish ("a<t>b</t>c<t/>d</t>e" WIDENER)->read();
}]], "a[b]c()d</t>e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<t/>d</t>e" WIDENER)->read();
}]], "a()c()d</t>e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<t/>d</t>e" WIDENER)->read();
}]], "a[b]c[]d</t>e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "()");
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b</t>c<t/>d</t>e" WIDENER)->read();
}]], "a[b]c()d</t>e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b<t/>c</t>d</t>e" WIDENER)->read();
}]], "a[b<t/>c]d</t>e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b<t>c</t>d</t>e" WIDENER)->read();
}]], "a[b<t>c</t>d]e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b<x/>c</t>d</t>e" WIDENER)->read();
}]], "a[b<x/>c]d</t>e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b<x>c</x>d</t>e" WIDENER)->read();
}]], "a[b<x>c</x>d]e" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s) {return ({"[",s,"]"});});
  p->xml_tag_syntax (3);
  return p->finish ("a<t>b<x>c</t>d</t>e" WIDENER)->read();
}]], "a[b<x>c]d</t>e" WIDENER);

// Positions
test_parser([[{
  object p = Parser.HTML();
  p->_set_data_callback (lambda (object p) {
			   p->write_out ("[" + p->at_char() + "]");
			   return 0;
			 });
  p->add_tag ("t", "x");
  p->reparse_strings (1);
  p->add_tag ("q", lambda (object p) {
		     p->write_out ("{" + p->at_char() + "}");
		     return 0;
		   });
  return p->finish("aa<t>bb<q>cc" WIDENER)->read();
}]], "[0]aaxbb{7}<q>[10]cc" WIDENER);

// parse_tag_args
test_equal(Parser.HTML()->parse_tag_args("<"), ([]));
test_equal(Parser.HTML()->parse_tag_args(">"), ([]));
test_parser(return Parser.HTML()->parse_tag_args("br" WIDENER),
	    (["br" WIDENER: "br" WIDENER]));
test_parser(return Parser.HTML()->parse_tag_args("<br" WIDENER ">"),
	    (["br" WIDENER: "br" WIDENER]));
test_parser(return Parser.HTML()->parse_tag_args("<br" WIDENER "/>"),
	    (["br" WIDENER "/": "br" WIDENER "/"]));

// Misc
test_parser([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->ignore_unknown (1);
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<f <t2>=<t2>><t><t2><a<t2>></t><o>" WIDENER)->read();
]], "[<f ]2[=]2[>]|2[<a]2[><o>" WIDENER "]");
test_parser([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("<f <t2>=<t2>><t><t2><a<t2>></t><o>" WIDENER)->read();
]], "<[f ]2[=]2[>]|2<[a]2[>]<[o>" WIDENER "]");
test_parser([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->ignore_unknown (1);
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("x<f x<t2>=<t2>x>x<t>x<t2>x<a<t2>x>x</t>x<o>x" WIDENER)->read();
]], "[x<f x]2[=]2[x>x]|[x]2[x<a]2[x>xx<o>x" WIDENER "]");
test_parser([[
  object p = Parser.HTML();
  p->add_container ("t", lambda (object p, mapping a, string s)
			   {p->write_out("|"); return s;});
  p->add_tag ("t2", "2");
  p->_set_tag_callback (lambda (object p, string s)
			  {p->feed_insert(s[1..]); return ({s[..0]});});
  p->_set_data_callback (lambda (object p, string s)
			   {return ({"[",s,"]"});});
  return p->finish("x<f x<t2>=<t2>x>x<t>x<t2>x<a<t2>x>x</t>x<o>x" WIDENER)->read();
]], "[x]<[f x]2[=]2[x>x]|[x]2[x]<[a]2[x>xx]<[o>x" WIDENER "]");
test_parser([[
  object p = Parser.HTML();
  p->case_insensitive_tag (1);
  p->add_tag ("aA","[a]");
  p->add_container ("Bb","[b]");
  p->add_entity ("cC","[c]");
  return p->finish("<aa><AA><bb></Bb><BB></bB>&cc;&CC;" WIDENER)->read();
]], "[a][a][b][b]&cc;&CC;" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("aA","[a]");
  p->add_container ("Bb","[b]");
  p->add_entity ("cC","[c]");
  return p->finish("<aa><AA><bb></Bb><BB></bB>&cc;&CC;" WIDENER)->read();
]], "<aa><AA><bb></Bb><BB></bB>&cc;&CC;" WIDENER);
test_parser([[
  object p = Parser.HTML();
  p->add_tag ("t", lambda (object p, mapping a) {
		     return ({"[",p->current(),"|",sort(indices(a))*",","]"});
		   });
  p->match_tag (0);
  return p->finish("<t bar <foo>>" WIDENER)->read();
  //                       ^ bogus char that we should jump over.
]], ("[<t bar <foo>|bar,foo]>" WIDENER));
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_tag ("", "E");
  return p->finish("< t>" WIDENER)->read();
}]], "E" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_tag ("", "E");
  p->ws_before_tag_name (1);
  return p->finish("< t>" WIDENER)->read();
}]], "T" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("/t", "T");
  return p->finish("</t>" WIDENER)->read();
}]], "T" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_container ("c", "C");
  p->add_entity ("e", "E");
  p->ignore_tags (1);
  return p->finish("<t &e;><&e;><c>&e;</c><t>" WIDENER)->read();
}]], "<t E><E><c>E</c><t>" WIDENER);
test_parser([[{
  object p = Parser.HTML();
  p->add_tag ("t", "T");
  p->add_container ("c", "C");
  p->add_entity ("e", "E");
  p->ignore_tags (1);
  return p->clone()->finish("<t &e;><&e;><c>&e;</c><t>" WIDENER)->read();
}]], "<t E><E><c>E</c><t>" WIDENER);
test_parser([[{
  return
    Parser.HTML()->
    add_quote_tag("?", lambda() {}, "?")->
    feed(WIDENER "<? ? >")->
    finish()->read();
}]], WIDENER "<? ? >");
test_parser([[{
  object p = Parser.HTML();
  p->_set_tag_callback (lambda () {return "T";});
  p->add_quote_tag ("?", "X", "?");
  return p->finish (WIDENER "<")->read();
}]], WIDENER "T");
test_parser([[{
  object p = Parser.HTML();
  p->_set_data_callback (lambda () {});
  return p->finish (WIDENER "<x>")->read();
}]], WIDENER "<x>");
test_parser([[{
  object p = Parser.HTML();
  p->feed("fo" WIDENER);
  return p->read(0) + " " + p->read(1) + " " + p->read(2) + " " + p->read(3);
}]], " f o" WIDENER " ");
test_parser([[{
  object p = Parser.HTML();
  p->feed("f")->feed("o")->feed("")->feed(WIDENER);
  return p->read(0) + " " + p->read(1) + " " + p->read(2) + " " + p->read(3);
}]], " f o" WIDENER " ");
test_any([[{
   string decode_config_region(Parser.HTML p, mapping mr, string s)
   {
      return "";
   };
   string s=#" <region name='Variables'> </region> ";
   object p = Parser.HTML();
   p->add_container ("region", decode_config_region);
   p->finish (s);
   return p->read();
}]],"  ");
test_parser([[{
  object p = Parser.HTML();
  return p->finish (WIDENER "<x y=")->read();
}]], WIDENER "<x y=");
test_program([[{
  int i;
  class X
  {
    inherit Parser.HTML;
    protected void create() {i++;}
  }
  int a()
  {
    return !!X()->clone();
  }
}]]);
test_any(
[[
  object p = Parser.HTML();
  p->add_container ("foo", lambda () {return "";});
  p->_set_data_callback (lambda () {});
  return p->finish ("<foo>")->read();
]], "");
test_any(
  [[
    Parser.HTML p1 = Parser.HTML();
    p1->add_quote_tag ("?", lambda () {return ({"p1"});}, "?");
    Parser.HTML p2 = p1->clone();
    p2->add_quote_tag ("?", lambda () {return ({"p2"});}, "?");
    return p1->finish("<??>")->read();
  ]], "p1")

test_any([[
  int|string entity_callback(object parser, string entity, object id, mixed ... extra)
  {
    if(entity=="&foobar;")
    {
      // return string ending with XML entity will crash:
      // "&nbsp;" will crash
      // "&nbsp; " won't crash
      return "&nbsp;";
    }
    return 0;
  };
  object my_parser = Parser.HTML();
  my_parser->_set_entity_callback(entity_callback);
  return my_parser->finish("<a href=\"mailto:&foobar;\"></a>")->read();
]], "<a href=\"mailto:&nbsp;\"></a>")

dnl - Parser.RCS

test_do(add_constant("rcsraw", Stdio.read_file("SRCDIR/testdata/COPYRIGHT,v")))
test_do(add_constant("rcsobj", Parser.RCS("SRCDIR/testdata/COPYRIGHT,v", 0)))
test_do(add_constant("rcsarr", rcsobj->parse_admin_section(rcsraw)))
test_eq(sizeof(rcsarr), 66);
test_do(add_constant("rcsarr", rcsobj->parse_delta_sections(rcsarr)))
test_eq(sizeof(rcsarr), 65);
test_do([[
  mapping rcsrevs = ([]);
  foreach(rcsobj->DeltatextIterator(rcsarr); int n; Parser.RCS.Revision rev) {
    rcsrevs[rev->revision] = rev;
  }
  // werror("rcsrevs: %O\n", rcsrevs);
  add_constant("rcsrevs", rcsrevs);
]])
test_eq(sizeof(rcsrevs), 13)

test_do(add_constant("rcsrevs"))
test_do(add_constant("rcsarr"))
test_do(add_constant("rcsobj"))
test_do(add_constant("rcsraw"))

END_MARKER

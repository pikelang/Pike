// -*- Pike -*-

#pike __REAL_VERSION__
//! @ignore
static private inherit @module@;
//! @endignore

//! @appears Locale.Charset
//! The Charset module supports a wide variety of different character sets, and
//! it is flexible in regard of the names of character sets it accepts. The
//! character case is ignored, as are the most common non-alaphanumeric
//! characters appearing in character set names. E.g. @tt{"iso-8859-1"@} works
//! just as well as @tt{"ISO_8859_1"@}. All encodings specified in RFC 1345 are
//! supported4
//!
//! First of all the Charset module is capable of handling the following
//! encodings of Unicode:
//!
//! @ul
//!   @item utf7
//!   @item utf8
//!   @item utf16
//!   @item utf16be
//!   @item utf16le
//!   @item utf75
//!   @item utf7½
//!     UTF encodings
//!   @item shifjis
//!   @item euc-kr
//!   @item euc-cn
//!   @item euc-jp
//! @endul
//!
//! Most, if not all, of the relevant code pages are represented, as the
//! following list shows. Prefix the numbers as noted in the list to get
//! the wanted codec:
//!
//! @ul
//!   @item 037
//!   @item 038
//!   @item 273
//!   @item 274
//!   @item 275
//!   @item 277
//!   @item 278
//!   @item 280
//!   @item 281
//!   @item 284
//!   @item 285
//!   @item 290
//!   @item 297
//!   @item 367
//!   @item 420
//!   @item 423
//!   @item 424
//!   @item 437
//!   @item 500
//!   @item 819
//!   @item 850
//!   @item 851
//!   @item 852
//!   @item 855
//!   @item 857
//!   @item 860
//!   @item 861
//!   @item 862
//!   @item 863
//!   @item 864
//!   @item 865
//!   @item 866
//!   @item 868
//!   @item 869
//!   @item 870
//!   @item 871
//!   @item 880
//!   @item 891
//!   @item 903
//!   @item 904
//!   @item 905
//!   @item 918
//!   @item 950
//!   @item 1026
//!     These may be prefixed with @tt{"cp"@} or @tt{"ibm"@}.
//!   @item 1250
//!   @item 1251
//!   @item 1252
//!   @item 1253
//!   @item 1254
//!   @item 1255
//!   @item 1256
//!   @item 1257
//!   @item 1258
//!     These may be prefixed with @tt{"cp"@}, @tt{"ibm"@} or @tt{"windows"@}.
//! @endul
//!
//! +359 more.

class ascii {
  static private string s = "";
  object(this_program) feed(string ss)
  {
    s += ss;
    return this_object();
  }
  string drain()
  {
    string ss = s;
    s = "";
    return ss;
  }
  object(this_program) clear()
  {
    s = "";
    return this_object();
  }
}

private class UTF16dec {
  inherit ascii;
  static int check_bom=1, le=0;
  string drain() {
    string s = ::drain();
    if(sizeof(s)&1) {
      feed(s[sizeof(s)-1..]);
      s = s[..sizeof(s)-2];
    }
    if(check_bom && sizeof(s))
      switch(s[..1]) {
       case "\xfe\xff":
       case "\xff\xfe":
	 le=(s[0]==0xff);
	 s=s[2..];
       default:
	 check_bom=0;
      }
    if(le)
      s = map(s/2, reverse)*"";
    return unicode_to_string(s);
  }
}

private class UTF16LEdec {
  inherit UTF16dec;
  static void create() { le=1; }
}

private string normalize(string in) {
  if(!in) return 0;
  string out = replace(lower_case(in),
		      ({ "_",".",":","-","(",")" }),
		      ({ "","","","","","" }));

  if( (out=="isoir91" || out=="isoir92") && in[-2]!='9')
    out = sprintf("%s-%c", out[..sizeof(out)-2], out[-1]);

  if(sscanf(out, "cp%*d")) out = out[2..];
  if(sscanf(out, "ibm%*d")) out = out[3..];
  return out;
}

//! Returns a charset decoder object.
//! @param name
//!   The name of the character set to decode from. Supported charsets
//!   include (not all supported charsets are enumerable):
//!   "iso_8859-1:1987", "iso_8859-1:1998", "iso-8859-1", "iso-ir-100",
//!   "latin1", "l1", "ansi_x3.4-1968", "iso_646.irv:1991", "iso646-us",
//!   "iso-ir-6", "us", "us-ascii", "ascii", "cp367", "ibm367", "cp819",
//!   "ibm819", "iso-2022" (of various kinds), "utf-7", "utf-8" and
//!   various encodings as described by RFC1345.
//! @throws
//!   If the asked-for @[name] was not supported, an error is thrown.
object(ascii) decoder(string name)
{
  name = normalize(name);
  if(!name || (<
    "iso885911987", "iso885911998", "iso88591", "isoir100",
    "latin1", "l1", "ansix341968", "iso646irv1991", "iso646us",
    "isoir6", "us", "usascii", "ascii", "367", "819">)[name])
    return ascii();

  if(has_prefix(name, "iso2022"))
    return ISO2022Dec();

  program p = ([
    "utf7": UTF7dec,
    "utf8": UTF8dec,
    "utf16": UTF16dec,
    "utf16be": UTF16dec,
    "utf16le": UTF16LEdec,
    "utf75": UTF7_5dec,
    "utf7½": UTF7_5dec,
    "shiftjis": ShiftJisDec,
  ])[name];

  if(p)
    return p();

  if(has_prefix(name, "euc")) {
    string sub = ([
      "kr":"korean",
      "jp":"x0208",
      "cn":"chinese",
    ])[name[3..]];

    if(sub)
      return EUCDec(sub);
  }

  object o = rfc1345(name);

  if(o)
    return o;

  throw(({"Unknown character encoding "+name+"\n", backtrace()}));
}

class _encoder
{
  static string s = "";
  static string|void replacement;
  static function(string:string)|void repcb;
  static string low_convert(string s, string|void r,
			     function(string:string)|void rc)
  {
    int i = strlen(s);
    string rr;
    while(--i>=0)
      if(s[i]>255)
	if(rc && (rr = rc(s[i..i])))
	  s=s[..i-1]+low_convert(rr,r)+s[i+1..];
	else if(r)
	  s=s[..i-1]+low_convert(r)+s[i+1..];
	else
	  throw(({"Character unsupported by encoding.\n", backtrace()}));
    return s;
  }
  object(this_program) feed(string ss)
  {
    s += low_convert(ss, replacement, repcb);
    return this_object();
  }
  string drain()
  {
    string ss = s;
    s = "";
    return ss;
  }
  object(this_program) clear()
  {
    s = "";
    return this_object();
  }
  void set_replacement_callback(function(string:string) rc)
  {
    repcb = rc;
  }
  static void create(string|void r, string|void rc)
  {
    replacement = r;
    repcb = rc;
  }
}

private class UTF16enc {
  inherit _encoder;
  static private string low_convert(string s, string|void r,
				    function(string:string)|void rc)
  {
    int i = strlen(s);
    string rr;
    while(--i>=0)
      if(s[i]>0x10ffff)
	if(rc && (rr = rc(s[i..i])))
	  s=s[..i-1]+low_convert(rr,r)+s[i+1..];
	else if(r)
	  s=s[..i-1]+low_convert(r)+s[i+1..];
	else
	  throw(({"Character unsupported by encoding.\n", backtrace()}));
    return s;
  }
  object(this_program) feed(string ss) {
    s += ss;
    return this_object();
  }
  string drain() {
    string ss = s;
    s = "";
    catch {
      return string_to_unicode(ss);
    };
    ss = low_convert(ss, replacement, repcb);
    return string_to_unicode(ss);
  }
}

private class UTF16LEenc {
  inherit UTF16enc;
  string drain() {
    return map(::drain()/2, reverse)*"";
  }
}

//! Returns a charset encoder object.
//! @param name
//!   The name of the character set to decode from. Supported charsets
//!   include (not all supported charsets are enumerable):
//!   "iso_8859-1:1987", "iso_8859-1:1998", "iso-8859-1", "iso-ir-100",
//!   "latin1", "l1", "ansi_x3.4-1968", "iso_646.irv:1991", "iso646-us",
//!   "iso-ir-6", "us", "us-ascii", "ascii", "cp367", "ibm367", "cp819",
//!   "ibm819", "iso-2022" (of various kinds), "utf-7", "utf-8" and
//!   various encodings as described by RFC1345.
//! @throws
//!   If the asked-for @[name] was not supported, an error is thrown.
object(_encoder) encoder(string name, string|void replacement,
			 function(string:string)|void repcb)
{
  name = normalize(name);
  if(!name || (<
    "iso885911987", "iso885911998", "iso88591", "isoir100",
    "latin1", "l1", "ansix341968", "iso646irv1991", "iso646us",
    "isoir6", "us", "usascii", "ascii", "367", "819">)[name])
    return _encoder(replacement, repcb);

  if(has_prefix(name, "iso2022"))
    return ISO2022Enc(replacement, repcb);

  program p = ([
    "utf7": UTF7enc,
    "utf8": UTF8enc,
    "utf16": UTF16enc,
    "utf16be": UTF16enc,
    "utf16le": UTF16LEenc,
    "utf75": UTF7_5enc,
    "utf7½": UTF7_5enc,
    "shiftjis": ShiftJisEnc,
  ])[name];

  if(p)
    return p(replacement, repcb);

  if(has_prefix(name, "euc")) {
    string sub = ([
      "kr":"korean",
      "jp":"x0208",
      "cn":"chinese",
    ])[name[3..]];

    if(sub)
      return EUCEnc(sub, replacement, repcb);
  }

  object o = rfc1345(name, 1, replacement, repcb);

  if(o)
    return o;

  error("Unknown character encoding "+name+"\n");
}

#!/bin/sh

#set -x

exec 5>&1 1>&2

if [ x"$1" = x--cache ]; then
  CACHE_OUTPUT=yes
  shift 1
else
  CACHE_OUTPUT=no
fi

SCRIPT="$1"
shift 1

if [ $CACHE_OUTPUT = yes ]; then
  for arg
  do
    INPUT="$arg"
  done
  TMPOUTPUT="${INPUT}.compiled"

  if [ -f "$TMPOUTPUT" ]; then
    if [ "`ls -1t $TMPOUTPUT $INPUT $SCRIPT 2>/dev/null | head -1`" = "`ls -1t $TMPOUTPUT`" ]; then
      cat "$TMPOUTPUT" >&5
      exit 0
    fi
  fi
fi

TMP_BUILDDIR="@BUILDDIR@"
TMP_BINDIR="@BINDIR@"
LIBDIR_SRC="@LIBDIR@"
SRCDIR="@srcdir@"

export TMP_BUILDDIR
export LIBDIR_SRC
export TMP_BUILDDIR
export SRCDIR

retries=.

if test "@CROSS@" = "yes"; then
  method="QQQQ"
  retries="....."
else :; fi

if test -f "$TMP_BUILDDIR/precompile-method" ; then
  . "$TMP_BUILDDIR/precompile-method"
else
  :
fi

old_method="${method-}"

OLD_RUNPIKE="$RUNPIKE"

case "$SCRIPT" in
  /*|./*)
    if test -f "$SCRIPT"; then :; else
      echo "Script $SCRIPT not found."
      exit 1
    fi
  ;;
  *)
    if test -f ./$SCRIPT ; then
      OLD="-DOLD=\"`/bin/pwd|sed 's@/[^/]*@../@g'`$SRCDIR\""
    elif test -f "$TMP_BINDIR/$SCRIPT"; then
      SCRIPT="$TMP_BINDIR/$SCRIPT"
      OLD="-DOLD=\"`( cd $TMP_BINDIR; /bin/pwd; )|sed 's@/[^/]*@../@g'`$SRCDIR\""
    else
      echo "Script $SCRIPT neither found in the current directory nor in $TMP_BINDIR."
      exit 1
    fi
  ;;
esac

test $CACHE_OUTPUT = yes && trap 'rm -rf "$TMPOUTPUT" ; exit 1' 1 2 15

while test "$retries" != .............. ; do

RUNPIKE=
case $method in
  Q)
    RUNPIKE="$TMP_BUILDDIR/pike -DNOT_INSTALLED -m$TMP_BUILDDIR/master.pike $PIKEOPTS"
  ;;
  QQ)
    RUNPIKE="$TMP_BUILDDIR/tpike -DNOT_INSTALLED -m$TMP_BUILDDIR/master.pike $PIKEOPTS"
  ;;
  QQQ)
    RUNPIKE=$TMP_BUILDDIR/test-pike
  ;;
  QQQQ)
    if test x"$OLD_RUNPIKE" != x; then
      LAST_PIKE="$OLD_RUNPIKE"
      method=QQQQQ
      RUNPIKE="$OLD_RUNPIKE"
    else
      RUNPIKE=""
    fi
  ;;
  QQQQQ)
    LAST_PIKE=pike
    method=QQQQQQ
    RUNPIKE="$LAST_PIKE $OLD"
  ;;
  QQQQQQ)
    RUNPIKE="$LAST_PIKE $OLD"
  ;;
  QQQQQQQ)
    ifs_save="${IFS- 	}"
    IFS=" :"
    for dir in $PATH
    do
      for p in pike pike7 pike70 pike71 pike07 pike06 pike-mirar
      do
        if [ -x $dir/$p ]; then
          if [ "x$LAST_PIKE" = xpike ] ; then
            LAST_PIKE=$dir/$p
            RUNPIKE="$dir/$p $OLD"
            break
          fi

          if [ "x$LAST_PIKE" = "x$dir/$p" ]; then
            LAST_PIKE=pike
          fi
        fi
      done
      if [ "x$RUNPIKE" != x ]; then
        method=QQQQQQ
        break
      fi
    done
    IFS="${ifs_save}"
  ;;
  QQQQQQQQ)
    method=
  ;;
esac

#
# By linking these two files to the current directory I can make
# $SCRIPT work with older versions of Pike - Hubbe
#

if test -f $SRCDIR/C.pmod ; then
  :
else
  rm $SRCDIR/C.pmod 2>/dev/null
  if ln -s "$LIBDIR_SRC/modules/Parser.pmod/C.pmod" $SRCDIR/C.pmod; then :; else
    # We might be on a filesystem that doesn't support symlinks (eg FAT).
    echo "Trying copying instead..."
    cp "$LIBDIR_SRC/modules/Parser.pmod/C.pmod" $SRCDIR/C.pmod
  fi
fi

if test -f $SRCDIR/Pike.pmod ; then
  :
else
  rm $SRCDIR/Pike.pmod 2>/dev/null
  if ln -s "$LIBDIR_SRC/modules/Parser.pmod/Pike.pmod" $SRCDIR/Pike.pmod; then :; else
    # We might be on a filesystem that doesn't support symlinks (eg FAT).
    echo "Trying copying instead..."
    cp "$LIBDIR_SRC/modules/Parser.pmod/Pike.pmod" $SRCDIR/Pike.pmod
  fi
fi

if test "x${RUNPIKE-}" != x ; then
echo "precompile: $RUNPIKE $SCRIPT $@ (method=$method)"

if [ $CACHE_OUTPUT = yes ]; then
  $RUNPIKE $SCRIPT "$@" >"$TMPOUTPUT"
else
  $RUNPIKE $SCRIPT "$@"
fi

if [ $? = 0 ]; then

cat > "$TMP_BUILDDIR/precompile-method.$$" <<EOF && \
  mv "$TMP_BUILDDIR/precompile-method.$$" "$TMP_BUILDDIR/precompile-method"
LAST_PIKE="$LAST_PIKE"
method="$method"
#retries="$retries"
EOF

  test $CACHE_OUTPUT = yes && cat "$TMPOUTPUT" >&5
exit 0
else
  test $CACHE_OUTPUT = yes && rm "$TMPOUTPUT"
fi
fi

method="Q$method"
retries=".$retries"

done # retry
# Total failure

echo "Failed to find a Pike executable that could run $SCRIPT."

exit 1

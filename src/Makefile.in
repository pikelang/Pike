#
# $Id: Makefile.in,v 1.251 2001/03/12 10:51:28 hubbe Exp $
#

# This line is needed on some machines.
@SET_MAKE@

# Don't change this line.  Define EXTRALIBS before this line if you
# wish to add any libraries.
LIBS=@LIBS@ $(EXTRALIBS)

# This is normall the install program in the source directory
INSTALL=@INSTALL@

SRCDIR=@srcdir@
VPATH=@srcdir@

# These are used while compiling
LIBDIR_SRC = @LIBDIR@
MANDIR_SRC = $(SRCDIR)/../man
TMP_BINDIR = @BINDIR@
TMP_BUILDDIR = @BUILDDIR@
TMP_DOCDIR = @DOCDIR@
TMP_LIBDIR = $(TMP_BUILDDIR)/lib

#
# RPM and package builders, listen up, because this is your only
# documentation! This variable is prepended to the install path.
# Please note that Pike will not work until moved into the proper
# place.  -Hubbe
# 
buildroot=

prefix = @prefix@
exec_prefix = $(prefix)/bin
lib_prefix = $(prefix)/lib/pike
data_prefix = @datadir@
share_prefix = $(data_prefix)/pike
man_prefix = $(prefix)/man

# Arguments for test_pike.pike used by the verify targets.
# TESTARGS = -a

# Arguments for install.pike used by the install targets.
INSTALLARGS = --new-style

#
# use bison please, yacc isn't good enough.
#
YACC=@YACC@
YFLAGS=-d -v

#
# This may be -pg
#
PROFIL=@PROFIL@

#
# OS dependant flags
#
OSFLAGS=

#
#Enable warnings from the compiler, if wanted.
#
WARN=@WARN@

#add extra defines here
# Be sure to use -g  when looking for bugs
DEFINES=@CPPFLAGS@

# -O should work with all compilers
OPTIMIZE=@OPTIMIZE@

# Set to a flag for parallelizing make, e.g. -j2. It's given to make
# at the level where it's most effective.
MAKE_PARALLEL=

# Preprocessor flags.
PREFLAGS=-I. -I$(SRCDIR) $(DEFINES)
OTHERFLAGS=@CFLAGS@ $(OSFLAGS) $(OPTIMIZE) $(WARN) $(PROFIL)
NOOPTFLAGS=@CFLAGS@ @CPPFLAGS@ $(OSFLAGS) $(WARN) $(PROFIL)
CFLAGS=$(PREFLAGS) $(OTHERFLAGS)

SMARTLINK=@SMARTLINK@
REALCC=@REALCC@
CC=@CC@
CPP=@CPP@

FALLBACK_CC=@FALLBACK_CC@

AR=@AR@

LD=@LD@
LDFLAGS=@LDFLAGS@ @LINKFORSHARED@ $(EXTRALDFLAGS)

DEFAULT_RUNPIKE=$(TMP_BUILDDIR)/pike -DNOT_INSTALLED -m$(TMP_BUILDDIR)/master.pike $(PIKEOPTS)
RUNPIKE=$(DEFAULT_RUNPIKE)
USE_TPIKE=$(TMP_BUILDDIR)/precompile.sh
USE_PIKE=@PIKE@ $(PIKEOPTS)
RUNTPIKE=$(@RUNTPIKE@)

MAKE_FLAGS=

# Add alloca.o if you don't have alloca() on your machine.
#
OBJ= \
 language.o \
 security.o \
 bignum.o \
 interpret.o \
 constants.o \
 cpp.o \
 fdlib.o \
 cyclic.o \
 array.o \
 backend.o \
 callback.o \
 encode.o \
 docode.o \
 dynamic_buffer.o \
 dynamic_load.o \
 error.o \
 fd_control.o \
 fsort.o \
 gc.o \
 hashtable.o \
 lex.o \
 multiset.o \
 signal_handler.o \
 pike_search.o \
 pike_types.o \
 main.o \
 mapping.o \
 pike_memory.o \
 module_support.o \
 object.o \
 opcodes.o \
 operators.o \
 port.o \
 program.o \
 rusage.o \
 stralloc.o \
 stuff.o \
 threads.o \
 version.o \
 queue.o \
 builtin.o \
 iterators.o \
 svalue.o @EXTRA_OBJS@

MODULE_REQUIREMENTS= \
  machine.h \
  global.h \
  modules/static_module_makefile \
  modules/dynamic_module_makefile \
  $(SRCDIR)/language.h \
  $(SRCDIR)/interpret_protos.h \
  lib @EXTRA_MODULE_REQUIREMENTS@


DEPEND= \
 $(SRCDIR)/language.c \
 $(SRCDIR)/builtin.c

#
# The following objectfiles differ between tpike & pike:
#

TOBJ = las_t.o builtin_functions_t.o peep_t.o  module_t.o
POBJ = las.o builtin_functions.o peep.o module.o


#
# User callable targets
#

# Since post_modules might be static, we must remake pike after them
# to make sure they are linked in.
all: module_objects hilfe
	$(MAKE) $(MAKE_FLAGS) $(MAKE_PARALLEL) post_modules
	$(MAKE) $(MAKE_FLAGS) $(MAKE_PARALLEL) pike

post_modules: pike
	@( cd post_modules ; rm remake >/dev/null 2>&1 || : ; \
	   $(MAKE) $(MAKE_PARALLEL) $(MAKE_FLAGS) || \
	     ( test -f remake && $(MAKE) $(MAKE_PARALLEL) $(MAKE_FLAGS) ) ) || exit $$?

post_modules/modlist_headers.h:
	@test -f post_modules/modlist_headers.h || touch post_modules/modlist_headers.h

post_modules/modlist.h:
	@test -f post_modules/modlist.h || touch post_modules/modlist.h

post_modules/linker_options:
	@test -f post_modules/linker_options || touch post_modules/linker_options

compiler-warnings : clean
	@echo Summarizing compiler warnings.
	@echo
	@if $(MAKE) $(MAKE_FLAGS) all 2>compiler-warnings ; then \
	  echo; \
	  echo 'Compilation warning summary:'; \
	  echo '----------------------------'; \
	else \
	  echo; \
	  echo 'Compilation warning and error summary:'; \
	  echo '--------------------------------------'; \
	fi
	@echo
	@cat compiler-warnings
	@echo
	@echo 'End of summary'
	@echo '--------------'

tpike-real: $(OBJ) $(TOBJ) modules/linker_options
	-@rm -f tpike || :
	$(LD) $(LDFLAGS) $(OBJ) $(TOBJ) `cat modules/linker_options` $(LIBS) -o tpike

# Only want tpike to exist when using $(RUNTPIKE); we don't want to
# require it actually being up-to-date.
#
# If RUNPIKE has been overridden we don't bother to build tpike. The
# precompile.sh script will then fall back to use RUNPIKE when it
# doesn't find tpike, and we assume that RUNPIKE doesn't point to a
# pike from the stone age.
$(TMP_BUILDDIR)/tpike: precompile.sh-stamp
	@if test "x$(RUNPIKE)" = "x$(DEFAULT_RUNPIKE)"; then \
	  $(MAKE) $(MAKE_FLAGS) $(MAKE_PARALLEL) tpike-real; \
	else :; fi

# Make $(POBJ)s with a recursive make instead of depending on them.
# This way, we make sure that all other objects shared with tpike are
# up-to-date first. So if the $(POBJ)s, which depend on tpike, trigs
# the recursive make of tpike-real above, that one will never start to
# make the $(OBJ)s concurrently with this one. stamp-tpike-predep
# records the $(POBJ) dependencies without tpike.
pike: $(OBJ) master.pike modules/linker_options stamp-tpike-predep post_modules/linker_options
	$(MAKE) $(MAKE_FLAGS) $(MAKE_PARALLEL) $(POBJ)
	-@if [ -f pike.old ] ; then rm -f pike.old || : ; else : ; fi
	-@if [ -f pike.old.exe ] ; then rm -f pike.old.exe || : ; else : ; fi
	-@if [ -f pike ] ; then mv pike pike.old || : ; else : ; fi
	$(LD) $(LDFLAGS) $(OBJ) $(POBJ) `cat modules/linker_options post_modules/linker_options` $(LIBS) -o pike

# purify
pure: $(OBJ) $(POBJ) master.pike module_objects
	-@mv pike pike.old 2>/dev/null || true
	$(SMARTLINK) purify -max-threads=128 -thread_stack_change=8192 -free-queue-length=500 -inuse-at-exit=yes -chain-length=12 $(REALCC) $(LDFLAGS) $(OBJ) $(POBJ) `cat modules/linker_options  post_modules/linker_options` $(LIBS) -o pike

# purecov
cover: $(OBJ) $(POBJ) master.pike module_objects
	-@mv pike pike.old 2>/dev/null || true
	$(SMARTLINK) purecov purify -max-threads=128 -thread_stack_change=8192 -free-queue-length=500 -inuse-at-exit=yes -chain-length=12 $(REALCC) $(LDFLAGS) $(OBJ) $(POBJ) `cat modules/linker_options  post_modules/linker_options` $(LIBS) -o pike

# quantify
quant: $(OBJ) $(POBJ) master.pike module_objects
	-@mv pike pike.old 2>/dev/null || true
	$(SMARTLINK) quantify $(REALCC) $(LDFLAGS) $(OBJ) $(POBJ) `cat modules/linker_options  post_modules/linker_options` $(LIBS) -o pike

atom: pike
	atom pike -tool atom -env threads -g -v `find lib/modules -type f -name '*.so' -print | sed -e 's/^/-incobj /g'`
	mv pike pike.pre-atom
	mv pike.third.threads pike
	@echo Make sure you have '.' in your LD_LIBRARY_PATH.

pixie: pike
	atom pike -tool pixie -env threads -g -v `find lib/modules -type f -name '*.so' -print | sed -e 's/^/-incobj /g'`
	mv pike pike.pre-pixie
	mv pike.pixie.threads pixie
	@echo Make sure you have '.' in your LD_LIBRARY_PATH.

hilfe: $(TMP_BINDIR)/hilfe Makefile
	@echo "Creating ./hilfe..."; \
	if [ "$(exec_prefix)" != "/usr/local/bin" -a \
	      "$(exec_prefix)" != "/usr/local/bin/" ]; then \
	  ( sed -e 's!/usr/local/bin!$(exec_prefix)!' <$(TMP_BINDIR)/hilfe \
	    >./hilfe && chmod 755 ./hilfe) || exit 1 ; \
	else \
	  $(INSTALL) $(TMP_BINDIR)/hilfe `pwd`/hilfe || exit 1; \
	fi
	@echo "Done."


.SUFFIXES: .c .h .o .cmod .pp .pph .protos .xml .h_src

.c.xml: pike $(TMP_BINDIR)/autodoc.pike
	@$(RUNPIKE) $(TMP_BINDIR)/autodoc.pike "$<" >"$@"

.c.pp:
	$(CPP) $(PREFLAGS) -DPMOD_EXPORT=PMOD_EXPORT \
	  -DPMOD_PROTO=PMOD_PROTO "$<" >"$@"

.c.protos:
	./precompile.sh fake_dynamic_load.pike >"$@" --cpp --protos \
	  $(CPP) $(PREFLAGS) -DPMOD_EXPORT=PMOD_EXPORT \
	    -DPMOD_PROTO=PMOD_PROTO -DPIKE_PRECOMPILER=1 "$<" || \
	  { rm "$@"; exit 1; }

.h.pph:
	$(CPP) $(PREFLAGS) -DPMOD_EXPORT=PMOD_EXPORT \
	  -DPMOD_PROTO=PMOD_PROTO "$<" >"$@"


# Several optimizers have problems with interpret.c
# First try compiling with optimization and if that doesn't work, without.
# GCC dumps core on some files @ OSF1
# This kluge should work around that...
# FIXME: Make this a configure option
.c.o:
	@echo "Compiling $<" ;\
	if $(CC) $(CFLAGS) -c $< -o $@ ; then : ; else \
	  echo "WARNING: Compiler failure! Trying without optimization!" >&2;\
	  echo "echo $(CC) $(PREFLAGS) $(NOOPTFLAGS) -c $< -o $@" >&2 ;\
	  NO_ULIMIT=yes; \
	  export NO_ULIMIT; \
	  if $(CC) $(PREFLAGS) $(NOOPTFLAGS) -c $< -o $@ ; then : ; else \
	    err=$$?; \
	    if test "x$(FALLBACK_CC)" = "x"; then \
	      exit $$err; \
	    else \
	      echo "WARNING: Compiler failure! Trying fallback compiler!" >&2;\
	      echo "echo $(FALLBACK_CC) $(PREFLAGS) $(NOOPTFLAGS) -c $< -o $@" >&2 ;\
	      $(FALLBACK_CC) $(PREFLAGS) $(NOOPTFLAGS) -c $< -o $@ ;\
	    fi; \
	  fi; \
	fi

#
# Please note that this must be accompanied by a dependency rule as
# The .c file will not be created in the SOURCE directory otherwise.
# -Hubbe
#
.cmod.c:
	./precompile.sh precompile.pike >"$@" "$<" || { rm "$@"; exit 1; }

# This rule is used for some header files that are generated from the
# source, to avoid excessive rebuilding when the source change in ways
# that doesn't affect the header.
#
# It can cause a .h target to be out-of-date repeatedly, but since it
# runs fast that's not an issue. This technique only works well in
# make's that stat the target again after the rule has run and
# recalculate the dependencies from that. Most make's seems to behave
# like that.
.h_src.h:
	@if test -f "$@"; then \
	  cmp -s "$<" "$@"; \
	else \
	  false; \
	fi || ( \
	  echo "cp $< $@"; \
	  cp "$<" "$@"; \
	)

force :
	@:

# install
install: pike hilfe pike-module aclocal
	@$(RUNPIKE) $(TMP_BINDIR)/install.pike $(INSTALLARGS) \
	exec_prefix="$(exec_prefix)" lib_prefix="$(lib_prefix)" \
	TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	SRCDIR="$(SRCDIR)" prefix="$(prefix)" MANDIR_SRC="$(MANDIR_SRC)" \
	man_prefix="$(man_prefix)" pike_name=$(pike_name) \
	fakeroot="$(buildroot)"

install_interactive: pike hilfe pike-module aclocal
	@$(RUNPIKE) $(TMP_BINDIR)/install.pike --interactive \
	exec_prefix="$(exec_prefix)"  prefix=$(prefix) \
	TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	SRCDIR="$(SRCDIR)" MANDIR_SRC="$(MANDIR_SRC)" \
	fakeroot="$(buildroot)"

# tidy up a bit
tidy:
	-rm -f *.o *.obj *.pp *.protos core y.output y.tab.c y.tab.h
	-rm -f $(TMP_BINDIR)/core *.o *.i *.i~ testsuite

# make clean
clean: tidy
	-( cd modules; $(MAKE) $(MAKE_FLAGS) clean )
	-( cd post_modules; $(MAKE) $(MAKE_FLAGS) clean )
	-rm -rf test-install test-pike
	-rm -f TAGS tags yacc.acts yacc.debug yacc.tmp *.debug.log a.out
	-rm -f hilfe master.pike compiler-warnings
	-rm -f tpike stamp-tpike-predep import-stamp modules-stamp
	-rm -rf lib/modules/*
#	-rm -f lib/master.pike

# make _really_ clean
spotless: clean
	-(cd $(SRCDIR); find . -type f -name '*.h.in' -print) | \
	  sed -e 's/\.in$$//' | xargs rm -f
	find . -type f '(' -name 'Makefile' -o -name '*~' -o -name '.*~' -o \
	  -name core -o -name '.nfs*' -name '#*#' -o -name '.pure' -o \
	  -name 'conftest.*' -o -name 'stamp-h' ')' -exec rm -f \{\} \;
	-rm -f lexical.c mon.out *.ln config.status
	-rm -f $(TMP_BINDIR)/*~ $(TMP_BINDIR)/\#*\#
	-rm -f pike pike.old l.outa*
	-rm -f modules/*/testsuite
	-rm -f modules/static_module_makefile modules/dynamic_module_makefile
	-rm -f precompile.sh precompile.sh-stamp
	-rm -rf lib

distclean: spotless
	find . -type f '(' -name 'config.log' -o -name 'config.status' -o \
	  -name 'config.cache' ')' -exec rm -f \{\} \;

cvsclean: distclean
	( for d in `cd $(SRCDIR) && find . -type d -print`; do \
	    if test -f "$(SRCDIR)/$$d/.cvsignore" ; then \
	      (cd "$$d" && rm -f `cat "$(SRCDIR)/$$d/.cvsignore"`); \
	      (cd "$(SRCDIR)/$$d" && rm -f `cat "$(SRCDIR)/$$d/.cvsignore"`); \
	    else :; fi; \
	  done)

# create tags
tags:
	ctags *.c

TAGS:
	etags -t *.h *.c

# verify / debug
module_testsuites:
	( cd modules && $(MAKE) $(MAKE_FLAGS) testsuites )

just_verify: module_testsuites testsuite master.pike
	if test "$(TESTARGS)" = "" ; then args="-a" ; else args="$(TESTARGS)" ; fi; \
	$(RUNPIKE) $(TMP_BINDIR)/test_pike.pike $$args

tinstall: aclocal master.pike aclocal
	-rm -rf test-install
	$(RUNPIKE) $(TMP_BINDIR)/install.pike $(INSTALLARGS) pike_name="test-pike" lib_prefix="$(lib_prefix)" TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" SRCDIR="$(SRCDIR)" prefix="./test-install" MANDIR_SRC="$(MANDIR_SRC)" man_prefix="$(man_prefix)" fakeroot="$(buildroot)"

just-tinstall: aclocal master.pike aclocal
	$(RUNPIKE) $(TMP_BINDIR)/install.pike $(INSTALLARGS) pike_name="test-pike" lib_prefix="$(lib_prefix)" TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" SRCDIR="$(SRCDIR)" prefix="./test-install" MANDIR_SRC="$(MANDIR_SRC)" man_prefix="$(man_prefix)" fakeroot="$(buildroot)"


verify: module_testsuites testsuite tinstall
	PIKE_MODULE_PATH=""; PIKE_INCLUDE_PATH=""; \
	if test "$(TESTARGS)" = "" ; then args="-a" ; else args="$(TESTARGS)" ; fi; \
	if test -f ./test-pike ; then ./test-pike -DNOT_INSTALLED $(PIKEOPTS) $(TMP_BINDIR)/test_pike.pike $$args ; else sprsh `pwd`/test-install/pike/*/bin/pike.exe -DNOT_INSTALLED $(PIKE_OPTS) $(TMP_BINDIR)/test_pike.pike $$args ; fi

verify_installed: module_testsuites testsuite master.pike
	if test "$(TESTARGS)" = "" ; then args="-a" ; else args="$(TESTARGS)" ; fi; \
	$(exec_prefix)/pike $(PIKEOPTS) $(TMP_BINDIR)/test_pike.pike $$args

check: verify

sure: verify

# verify / debug verbose
verbose_verify: module_testsuites testsuite master.pike
	if test "$(TESTARGS)" = "" ; then args="-a" ; else args="$(TESTARGS)" ; fi; \
	$(RUNPIKE) $(TMP_BINDIR)/test_pike.pike --verbose $$args

# verify & debug VERBOSE
gdb_verify: module_testsuites testsuite master.pike
	@echo >.gdbinit handle SIGFPE nostop noprint pass
	@echo >>.gdbinit handle SIGUSR1 nostop noprint pass
	@echo >>.gdbinit handle SIGUSR2 nostop noprint pass
	@echo >>.gdbinit handle SIGLWP nostop noprint pass
	@if kill -l | grep SIGRTMIN >/dev/null ; then \
	  echo >>.gdbinit handle SIG32 nostop noprint pass ;\
	else :; fi
	@echo >>.gdbinit break debug_fatal
	@if test "$(TESTARGS)" = "" ; then args="-a" ; else args="$(TESTARGS)" ; fi;  \
	echo >>.gdbinit run -m$(TMP_BUILDDIR)/master.pike $(PIKEOPTS) $(TMP_BINDIR)/test_pike.pike --no-watchdog -v -v $$args
	gdb ./pike
	@rm .gdbinit

# run hilfe, for interactive testing
run_hilfe:
	$(RUNPIKE) $(TMP_BINDIR)/hilfe

feature_list:
	$(RUNPIKE) $(TMP_BINDIR)/feature_list

lib: Makefile
	@for d in lib lib/modules lib/include; do \
	  if [ -d $$d/. ]; then : ; else \
	    echo "Creating $$d/."; \
	    (mkdir $$d && chmod u+rwx $$d) || exit 1; \
	  fi ; \
	done
	@echo "Done."
	-@touch ./lib 2>/dev/null || (touch lib/.broken_gnu_touch && rm lib/.broken_gnu_touch)


master.pike: $(LIBDIR_SRC)/master.pike.in Makefile
	t="$$PIKE_PATH_TRANSLATE"; if test "x$$t" = "x"; then t=s,x,x,; else :; fi; \
	sed -e 's!¤lib_prefix¤!'"`echo "$(TMP_LIBDIR)" | sed -e "$$t"`"'!' <$(LIBDIR_SRC)/master.pike.in \
	  | sed -e 's!¤share_prefix¤!'"`echo "$(LIBDIR_SRC)" | sed -e "$$t"`"'!' >master.pike

pike-module: $(SRCDIR)/pike-module.in Makefile ./pike
	$(RUNPIKE) $(SRCDIR)/pike-module.in --fixate=$(SRCDIR)/pike-module.in \
	   --set='make=$(MAKE)' --set='make_flags=$(MAKE_FLAGS)' \
	   --set='prefix=$(prefix)' --set='pike=$(exec_prefix)/pike' \
	   --set='include_path=$(prefix)/include/pike' \
	   --set='lib_prefix=$(TMP_LIBDIR)' --set='share_prefix=$(LIBDIR_SRC)' \
           --output=pike-module
	-@chmod +x pike-module

aclocal: $(SRCDIR)/aclocal.m4
	echo >aclocal "define(PIKE_INCLUDE_PATH,$(prefix)/include/pike)"
	cat >>aclocal $(SRCDIR)/aclocal.m4

# We touch the files that depend on language.h_src and
# interpret_protos.h_src to ensure that the .h_src.h rule doesn't have
# anything to do in the dist.
source: $(SRCDIR)/peep_engine.c $(SRCDIR)/case_info.h $(SRCDIR)/treeopt.h $(SRCDIR)/language.c $(SRCDIR)/language.h $(SRCDIR)/interpret_protos.h depend
	touch $(SRCDIR)/language.c $(SRCDIR)/language.h $(SRCDIR)/interpret_protos.h

# make export archive (requires compiled Pike)
# Do not compile in source tree if you want to use this!
# Beware that export archive this includes bison/yacc/byacc source
# and thus has to follow the rules stated in that code.

full_export: source
	chmod +x $(SRCDIR)/install-sh
	$(RUNPIKE) $(TMP_BINDIR)/export.pike --srcdir="$(SRCDIR)" 

export: full_export

all_exports: full_export
	( cd .. && $(TMP_BINDIR)/makedists )

bin_export: aclocal
	@rm -f *.burk
	@$(RUNPIKE) $(TMP_BINDIR)/install.pike --export \
	exec_prefix="$(exec_prefix)" lib_prefix="$(lib_prefix)" \
	TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	SRCDIR="$(SRCDIR)" prefix="$(prefix)" MANDIR_SRC="$(MANDIR_SRC)" \
	man_prefix="$(man_prefix)" pike_name=$(pike_name)
	@case " $(CC)" in \
	  *\ rnt*) \
	    $(MAKE) $(MAKE_FLAGS) uncompress_header ;\
	    echo "Compressing..." ;\
	    filename=`echo *.burk | sed 's@\.burk$$@@g'`.exe ;\
	    ( cat uncompress_header.exe ; gzip -9 -c *.burk ) > $$filename ;\
	    echo "Done." ;\
	  ;; \
	esac

#new_peep_engine:
#	$(RUNPIKE) $(TMP_BINDIR)/mkpeep.pike $(SRCDIR)/peep.in >$(SRCDIR)/peep_engine.c
#	$(RUNPIKE) $(TMP_BINDIR)/make_ci.pike <$(SRCDIR)/UnicodeData.txt >$(SRCDIR)/case_info.h

$(SRCDIR)/peep_engine.c: $(TMP_BUILDDIR)/tpike $(SRCDIR)/peep.in $(TMP_BINDIR)/mkpeep.pike
	$(RUNTPIKE) $(TMP_BINDIR)/mkpeep.pike $(SRCDIR)/peep.in >$(SRCDIR)/peep_engine.c || ( rm $(SRCDIR)/peep_engine.c ; exit 1 )

peep.o: $(SRCDIR)/peep_engine.c

peep_t.o: peep.c

$(SRCDIR)/case_info.h: $(TMP_BUILDDIR)/tpike $(SRCDIR)/UnicodeData.txt $(TMP_BINDIR)/make_ci.pike
	$(RUNTPIKE) $(TMP_BINDIR)/make_ci.pike <$(SRCDIR)/UnicodeData.txt >$(SRCDIR)/case_info.h || ( rm $(SRCDIR)/case_info.h ; exit 1 )

builtin_functions.o: $(SRCDIR)/case_info.h

builtin_functions_t.o: builtin_functions.c

$(SRCDIR)/treeopt.h: $(TMP_BUILDDIR)/tpike $(SRCDIR)/treeopt.in $(TMP_BINDIR)/mktreeopt.pike
	$(RUNTPIKE) $(TMP_BINDIR)/mktreeopt.pike $(SRCDIR)/treeopt.in || ( rm $(SRCDIR)/treeopt.h ; exit 1 )

las.o: $(SRCDIR)/treeopt.h

las_t.o: las.c

# This dependency is here to make sure that lexer[012].h are generated.
# The reason for the split is that some compilers (read lc) generate
# better code then. Strange, but true.
lex.o: lexer0.h lexer1.h lexer2.h

lex.protos: lexer0.h lexer1.h lexer2.h

lexer0.h: lexer.h
	cp "$(SRCDIR)/lexer.h" "$@"

lexer1.h: lexer.h
	cp "$(SRCDIR)/lexer.h" "$@"

lexer2.h: lexer.h
	cp "$(SRCDIR)/lexer.h" "$@"

# All the $(POBJ) dependencies, except tpike. See blurb at pike target.
stamp-tpike-predep: $(SRCDIR)/peep.in $(TMP_BINDIR)/mkpeep.pike peep.c $(SRCDIR)/UnicodeData.txt $(TMP_BINDIR)/make_ci.pike builtin_functions.c $(SRCDIR)/treeopt.in $(TMP_BINDIR)/mktreeopt.pike las.c
	@echo foo > stamp-tpike-predep

# make dependencies
depend: $(DEPEND)
	gcc -MM -MG $(PREFLAGS) $(SRCDIR)/*.c | $(TMP_BINDIR)/fixdepends.sh $(SRCDIR)
	-@(while :; do \
	  echo foo > cfl.$@; test "`echo cfl.*`" = cfl.$@ && break; \
	  rm cfl.$@; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=37; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES=Makefile CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.$@; exit $$EXITCODE)
	-@rm cfl.$@
	@for d in modules post_modules; do \
	  ( cd $$d && { \
	    rm -f remake; \
	    $(MAKE) $(MAKE_FLAGS) depend || \
	      { test -f remake && $(MAKE) $(MAKE_FLAGS) depend; }; \
	  }); \
	done

# Documentation...

docs:
	mkdir docs

wmml: force
	@test -d wmml/. || mkdir wmml
	@modules="`cd $(SRCDIR)/modules && ls -d */. | sed -e '/^_.*/d' -e 's/\/\.$$//'`"; \
	echo The following modules are interresting:; \
	echo "$$modules"; \
	for d in $$modules; do \
	  echo Testing $$d...; \
	  if test -f "$(SRCDIR)/modules/$$d/wmml-header"; then \
	    echo Module $$d seems to contain WMML docs.; \
	    $(RUNPIKE) $(TMP_BINDIR)/mkwmml.pike \
	      "$(SRCDIR)/modules/$$d/wmml-header" \
	      `find $(SRCDIR)/modules/$$d/. $(SRCDIR)/modules/_$$d*/. -name '*.[ch]' -print 2>/dev/null` \
	      "$(SRCDIR)/modules/$$d/wmml-footer" >wmml/$$d.wmml; \
	  else :; fi; \
	done

manpages: wmml
	@(if test -f "$(SRCDIR)/../tutorial/tutorial.wmml"; then \
	  cat "$(SRCDIR)/../tutorial/tutorial.wmml"; \
	else \
	  cat wmml/*.wmml; \
	fi) | (cd wmml && $(RUNPIKE) $(TMP_BINDIR)/wmmltohtml2 \
	  $(TMP_BINDIR)/manpages man/man)

tutorial: wmml
	( cd $(SRCDIR)/../tutorial/ ; $(MAKE) pike="$(RUNPIKE)" $(TARGET) )

# Lobotomization...

lobotomize_crypto:
	( cd $(SRCDIR)/modules/_Crypto && ./.build_lobotomized_crypto  )
	( cd $(SRCDIR)/modules/_Lobotomized_Crypto && autoconf )

#
# Pike internal targets
#

# touch modules-stamp here to avoid doing this work again if that
# target is checked later.
module_objects: $(MODULE_REQUIREMENTS)
	@( cd modules ; rm remake >/dev/null 2>&1 || : ; \
	   $(MAKE) $(MAKE_PARALLEL) $(MAKE_FLAGS) || \
	     ( test -f remake && $(MAKE) $(MAKE_PARALLEL) $(MAKE_FLAGS) ) ) || exit $$?
	@touch modules-stamp

modules-stamp: $(MODULE_REQUIREMENTS)
	@( cd modules ; rm remake >/dev/null 2>&1 || : ; \
	   $(MAKE) $(MAKE_PARALLEL) $(MAKE_FLAGS) || \
	     ( test -f remake && $(MAKE) $(MAKE_PARALLEL) $(MAKE_FLAGS) ) ) || exit $$?
	@touch modules-stamp

modules/modlist.h: modules-stamp

modules/modlist_headers.h: modules-stamp

modules/linker_options: modules-stamp

module.o:  modules/modlist_headers.h modules/modlist.h

$(SRCDIR)/interpret_protos.h_src: $(SRCDIR)/interpret_functions.h
	egrep '^OPCODE' <$(SRCDIR)/interpret_functions.h >$(SRCDIR)/interpret_protos.h_src || { rm $(SRCDIR)/interpret_protos.h_src; exit 1; }

lex.o: $(SRCDIR)/lex.c $(SRCDIR)/interpret_protos.h

interpret.o: $(SRCDIR)/lex.c $(SRCDIR)/interpret_protos.h

lex_t.o: $(SRCDIR)/lex_t.c $(SRCDIR)/interpret_protos.h

language.o: $(SRCDIR)/language.c $(SRCDIR)/object.h $(SRCDIR)/interpret.h $(SRCDIR)/program.h

$(SRCDIR)/language.h_src: $(SRCDIR)/language.yacc
	@echo "Expect 1 shift/reduce conflict."
	( cd $(SRCDIR) &&\
	 $(YACC) $(YFLAGS) language.yacc &&\
	 mv y.tab.c language.c &&\
	 mv y.tab.h language.h_src )

$(SRCDIR)/language.c: $(SRCDIR)/language.h_src
	touch $(SRCDIR)/language.c

#
# This rule makes sure that builtin.c is created in the source dir.
#
$(SRCDIR)/builtin.c: $(SRCDIR)/builtin.cmod precompile.sh-stamp $(TMP_BINDIR)/precompile.pike

$(SRCDIR)/iterators.c: $(SRCDIR)/iterators.cmod precompile.sh-stamp $(TMP_BINDIR)/precompile.pike

$(SRCDIR)/backend.c: $(SRCDIR)/backend.cmod precompile.sh-stamp $(TMP_BINDIR)/precompile.pike

# UnixWare make needs help to find the source file...
builtin.o: $(SRCDIR)/builtin.c

iterators.o: $(SRCDIR)/iterators.c

# Internal testing target
run_yacc: $(SRCDIR)/language.c

$(SRCDIR)/configure: $(SRCDIR)/configure.in
	cd $(SRCDIR) && autoconf

config.status: $(SRCDIR)/configure
	./config.status --recheck

modules/static_module_makefile: $(SRCDIR)/modules/static_module_makefile.in config.status
	-@(while :; do \
	  echo foo > cfl.static_module_makefile; test "`echo cfl.*`" = cfl.static_module_makefile && break; \
	  rm cfl.static_module_makefile; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=17; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES=modules/static_module_makefile CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.static_module_makefile; exit $$EXITCODE)
	-@rm cfl.static_module_makefile

modules/dynamic_module_makefile: $(SRCDIR)/@dmmsrc@ config.status
	-@(while :; do \
	  echo foo > cfl.dynamic_module_makefile; test "`echo cfl.*`" = cfl.dynamic_module_makefile && break; \
	  rm cfl.dynamic_module_makefile; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=19; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES=modules/dynamic_module_makefile:@dmmsrc@ CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.dynamic_module_makefile; exit $$EXITCODE)
	-@rm cfl.dynamic_module_makefile

Makefile: $(SRCDIR)/Makefile.in $(SRCDIR)/dependencies config.status
	-@(while :; do \
	  echo foo > cfl.$@; test "`echo cfl.*`" = cfl.$@ && break; \
	  rm cfl.$@; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=23; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES=Makefile CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.$@; exit $$EXITCODE)
	-@rm cfl.$@
	touch remake
	@echo "Run make again"
	@exit 1

precompile.sh: $(SRCDIR)/precompile.sh.in ./config.status
	-@(while :; do \
	  echo foo > cfl.$@; test "`echo cfl.*`" = cfl.$@ && break; \
	  rm cfl.$@; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=29; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES=precompile.sh CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.$@; exit $$EXITCODE)
	-@rm cfl.$@

# A dependency on precompile.sh-stamp only ensures that precompile.sh
# exists, not that it's older than the target. In source dists,
# precompile.sh is almost always newer than the targets that depend on
# it, e.g. builtin.c that comes with the dist.
precompile.sh-stamp: precompile.sh
	@touch 0103000070 precompile.sh-stamp

$(SRCDIR)/machine.h.in: $(SRCDIR)/stamp-h.in
	@if test -f $(SRCDIR)/machine.h.in; then :; else \
	  rm $(SRCDIR)/stamp-h.in; $(MAKE) $(SRCDIR)/stamp-h.in; \
	fi

$(SRCDIR)/stamp-h.in: $(SRCDIR)/configure.in $(SRCDIR)/acconfig.h
	cd $(SRCDIR) && autoheader
	echo foo > $(SRCDIR)/stamp-h.in

machine.h: stamp-h
	@if test -f machine.h; then :; else \
	  rm stamp-h; $(MAKE) stamp-h; \
	fi

stamp-h: $(SRCDIR)/stamp-h.in $(SRCDIR)/machine.h.in config.status
	-@(while :; do \
	  echo foo > cfl.$@; test "`echo cfl.*`" = cfl.$@ && break; \
	  rm cfl.$@; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=31; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES="" CONFIG_HEADERS=machine.h ./config.status || \
	  (EXITCODE=$$?; rm cfl.$@; exit $$EXITCODE)
	touch stamp-h
	-@rm cfl.$@

testsuite: $(SRCDIR)/testsuite.in
	$(TMP_BINDIR)/mktestsuite $(SRCDIR)/testsuite.in >testsuite -DSRCDIR="$(SRCDIR)"

header_uncompress: $(SRCDIR)/uncompressor.c
	$(CC) -O2 -static  $(SRCDIR)/uncompressor.c -o header_uncompress -lz

uncompress_header: $(SRCDIR)/uncompressor.c header_uncompress
	$(CC) -O2 -static  $(SRCDIR)/uncompressor.c -o uncompress_header -lz -DSEEK_TO=`wc -c header_uncompress|sed 's/[^0-9]//g'`
	test "`wc -c header_uncompress|sed 's/[^0-9]//g'`" = "`wc -c uncompress_header|sed 's/[^0-9]//g'`"

HFILES=						\
  operators.protos					\
  array.protos					\
  fd_control.protos					\
  backend.protos					\
  fdlib.protos					\
  bignum.protos					\
  fsort.protos					\
  pike_memory.protos					\
  pike_types.protos					\
  gc.protos						\
  port.protos					\
  builtin_functions_t.protos				\
  callback.protos					\
  hashtable.protos					\
  program.protos					\
  interpret.protos					\
  constants.protos					\
  language.protos					\
  queue.protos					\
  cpp.protos						\
  las_t.protos						\
  peep_t.protos                                     \
  rusage.protos					\
  cyclic.protos					\
  lex.protos						\
  security.protos					\
  signal_handler.protos				\
  pike_search.protos				\
  docode.protos					\
  main.protos					\
  stralloc.protos					\
  mapping.protos					\
  stuff.protos					\
  dynamic_buffer.protos				\
  svalue.protos					\
  dynamic_load.protos				\
  module_support.protos				\
  threads.protos					\
  multiset.protos					\
  encode.protos					\
  object.protos					\
  error.protos					\
  opcodes.protos					\
  version.protos                                    \
  builtin.protos

$(HFILES): precompile.sh-stamp

import-stamp: $(HFILES) precompile.sh-stamp
	@./precompile.sh fake_dynamic_load.pike >import_functions.tmp $(HFILES)
	@cmp import_functions.tmp import_functions.h >/dev/null || mv import_functions.tmp import_functions.h
	@echo hej >import-stamp

import_functions.h: import-stamp
	test -f import-stamp || ( rm import-stamp ; $(MAKE) import-stamp )

export_functions.c: import_functions.h
	touch export_functions.c

module.o: post_modules/modlist.h post_modules/modlist_headers.h 

@dependencies@


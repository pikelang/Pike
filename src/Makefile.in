
# This line is needed on some machines.
@SET_MAKE@

# Pike embed target, either libpike.so or libpike.a.
PIKE_LIB=@PIKE_LIB@

# Don't change this line.  Define EXTRALIBS before this line if you
# wish to add any libraries.
LIBS=@LIBS@ $(EXTRALIBS)

# This is normall the install program in the source directory
INSTALL=@INSTALL@

SRCDIR=@srcdir@
VPATH=@srcdir@

# These are used while compiling
LIBDIR_SRC = @LIBDIR@
TMP_BINDIR = @BINDIR@
TMP_BUILDDIR = @BUILDDIR@
TMP_LIBDIR = $(TMP_BUILDDIR)/lib

# This is used during autodoc extraction.
DOCDIR = @DOCDIR@

# These are used during binary exports and installation.
MANDIR_SRC = @MANDIR@
DOCDIR_SRC = @DOCDIR@
BASEDIR = @BASEDIR@
PACKAGINGDIR = $(SRCDIR)/../packaging

# These are used by the files generated by fixdepends.sh
PIKE_SRC_DIR=$(SRCDIR)
BUILD_BASE=

# The precompiler API level used by cmod files in the src root directory.
PRECOMPILER_ARGS=--api=3

#
# RPM and package builders, listen up, because this is your only
# documentation! This variable is prepended to the install path.
# Please note that Pike will not work until moved into the proper
# place.  -Hubbe
#
buildroot=

prefix = @prefix@
exec_prefix = @exec_prefix@
bindir = @bindir@
lib_prefix = @libdir@/pike
datarootdir = @datarootdir@
data_prefix = @datadir@
share_prefix = $(data_prefix)/pike
man_prefix = @mandir@
include_prefix = @includedir@/pike

# Arguments for test_pike.pike used by the verify targets.
TESTARGS_NOFORK = -a -a$(SRCDIR) -a$(LIBDIR_SRC) -v
TESTARGS_FORK = -F $(TESTARGS_NOFORK)

# Arguments for install.pike used by the install targets.
INSTALLARGS = --new-style

#
# use bison please, yacc isn't good enough.
#
YACC=@YACC@
YFLAGS=-d -v

EGREP=@EGREP@

#
# This may be -pg
#
PROFIL=@PROFIL@

#
# OS dependant flags
#
OSFLAGS=@OSFLAGS@

#
#Enable warnings from the compiler, if wanted.
#
WARN=@WARN@

#add extra defines here
DEFINES=@CPPFLAGS@ -DPIKE_CORE -DPIKE_BUILD_DATE=@BUILD_DATE@

# -O should work with all compilers
OPTIMIZE=@OPTIMIZE@

# Preprocessor flags.
PREFLAGS=-DPIKE_SRC_ROOT="$(BASEDIR)" -I. -I$(SRCDIR) $(DEFINES)

# Compiler flags.
OTHERFLAGS=$(OSFLAGS) $(OPTIMIZE) $(WARN) $(PROFIL)
NOOPTFLAGS=$(OSFLAGS) $(WARN) $(PROFIL)
CFLAGS=@CFLAGS@ $(PREFLAGS) $(OTHERFLAGS)
CXXFLAGS=@CXXFLAGS@ $(PREFLAGS) $(OTHERFLAGS)

SMARTLINK=@SMARTLINK@
REALCC=@REALCC@
CC=@CC@
CXX=@CXX@
CPP=@CPP@
GDB=gdb

CONFIG_HEADERS=@CONFIG_HEADERS@

CANDLE=@CANDLE@ -nologo
LIGHT=@LIGHT@ -nologo
RCEXE=@RCEXE@

FALLBACK_CC=@FALLBACK_CC@

PAXCTL=@PAXCTL@
PAXCTL_ALLOW_MPROTECT=@PAXCTL_ALLOW_MPROTECT@

AR=@AR@

LD=@LD@
LINKFORSHARED=@LINKFORSHARED@
LDFLAGS=@LDFLAGS@ $(LINKFORSHARED) $(EXTRALDFLAGS)
LDSHARED=@LDSHARED@

DEFAULT_RUNPIKE=$(TMP_BUILDDIR)/pike -DNOT_INSTALLED -DPRECOMPILED_SEARCH_MORE -m$(TMP_BUILDDIR)/master.pike $(PIKEOPTS)
USE_TPIKE=$(TMP_BUILDDIR)/precompile.sh
USE_PIKE=pike $(PIKEOPTS)
RUNPIKE=$(@RUNPIKE@)
RUNTPIKE=$(@RUNTPIKE@)
PIKE_MODULE_RELOC=@PIKE_MODULE_RELOC@

# Set to an appropriate invocation of valgrind (or similar)
VALGRIND=@VALGRIND@
VALGRINDARGS=@VALGRINDARGS@

MAKE_FLAGS=

# Add alloca.o if you don't have alloca() on your machine.
#
CORE_OBJ= \
 array.o \
 backend.o \
 bignum.o \
 block_allocator.o \
 buffer.o \
 builtin.o \
 builtin_functions.o \
 callback.o \
 constants.o \
 cpp.o \
 cyclic.o \
 docode.o \
 dynamic_load.o \
 encode.o \
 error.o \
 fd_control.o \
 fdlib.o \
 fsort.o \
 gc.o \
 interpret.o \
 iterators.o \
 language.o \
 las.o \
 lex.o \
 mapping.o \
 module_support.o \
 multiset.o \
 object.o \
 opcodes.o \
 operators.o \
 peep.o \
 pike_compiler.o \
 pike_cpulib.o \
 pike_dtoa.o \
 pike_embed.o \
 pike_float.o \
 pike_memory.o \
 pike_search.o \
 pike_types.o \
 pikecode.o \
 port.o \
 program.o \
 queue.o \
 rbtree.o \
 rusage.o \
 signal_handler.o \
 siphash24.o \
 sprintf.o \
 sscanf.o \
 stack_allocator.o \
 stralloc.o \
 string_builder.o \
 svalue.o \
 threads.o \
 version.o \
 @EXTRA_OBJS@

OBJ=$(CORE_OBJ) @MODULE_O@

MODULE_REQUIREMENTS= \
  headerfiles-stamp \
  machine.h \
  global.h \
  precompile.sh-stamp \
  modules/static_module_makefile \
  modules/dynamic_module_makefile \
  post_modules/static_module_makefile \
  post_modules/dynamic_module_makefile \
  propagated_variables \
  $(SRCDIR)/language.h \
  $(SRCDIR)/interpret_protos.h \
  lib @EXTRA_MODULE_REQUIREMENTS@

PMOD_TARGETS=@PMOD_TARGETS@

SRC_TARGETS= \
 $(SRCDIR)/language.c \
 $(SRCDIR)/language.h \
 $(SRCDIR)/interpret_protos.h \
 $(SRCDIR)/interpret_functions_fixed.h \
 $(SRCDIR)/peep_engine.c \
 $(SRCDIR)/case_info.h \
 $(SRCDIR)/whitespace.h \
 $(SRCDIR)/treeopt.h $(PMOD_TARGETS)


#
# User callable targets
#

# Update the dumped modules, but only if dump_modules has been used earlier.
all: module_objects
	@$(MAKE) $(MAKE_FLAGS) pike-complete-stamp
	@if [ -f dumpversion ]; then \
	  echo "$(MAKE) $(MAKE_FLAGS) dump_modules"; \
	  $(MAKE) $(MAKE_FLAGS) dump_modules; \
	else :; fi
	@if [ "`find . -name '*.fail' -print`" = "" ]; then :; else \
	  echo; \
	  echo "Pike compiled and linked ok, but the following file(s) "; \
	  echo "failed to compile with full optimization.";\
	  echo "This may affect performance negatively."; \
	  find . -name '*.fail' -print | sed -e 's/\.fail$$//' -e 's/^/	/'; \
	  echo; \
	fi

doc: documentation

documentation: onepage.xml traditional.xml modref.xml
	cd $(DOCDIR) && $(MAKE) $(MAKE_FLAGS) PIKE="$(RUNPIKE)" \
	  BUILDDIR="$(TMP_BUILDDIR)" $(DOCTARGET)

# Creation of include/.

headerfiles-stamp: include machine.h global.h $(SRC_TARGETS) force
	@$(MAKE) $(MAKE_FLAGS) headerfiles_low HEADERS="machine.h" HEADERSOURCE="`pwd`"
	@$(MAKE) $(MAKE_FLAGS) headerfiles_low HEADERS="`cd $(SRCDIR) && echo *.h`" HEADERSOURCE="$(SRCDIR)"
	@test -f headerfiles-stamp || echo foo > headerfiles-stamp

headerfiles_low: force
	@for f in $(HEADERS); do \
	  if [ -h "include/$$f" ]; then continue; fi; \
	  if cmp "$(HEADERSOURCE)/$$f" "include/$$f" >/dev/null 2>&1 ; then continue; fi; \
	  rm -f include/$$f 2>/dev/null; \
	  echo "Creating include/$$f"; \
	  if ln -s "$(HEADERSOURCE)/$$f" "include/$$f" && \
	     ls -L "include/$$f" >/dev/null 2>&1; then :; else \
	    echo "Symlink failed."; \
	    cp "$(HEADERSOURCE)/$$f" "include/$$f" || exit 1; \
	  fi; \
	  echo foo > headerfiles-stamp; \
	done

include:
	test -d include/. || mkdir include

compiler-warnings : clean
	@echo Summarizing compiler warnings.
	@echo
	@if $(MAKE) $(MAKE_FLAGS) all 2>compiler-warnings ; then \
	  echo; \
	  echo 'Compilation warning summary:'; \
	  echo '----------------------------'; \
	else \
	  echo; \
	  echo 'Compilation warning and error summary:'; \
	  echo '--------------------------------------'; \
	fi
	@echo
	@cat compiler-warnings
	@echo
	@echo 'End of summary'
	@echo '--------------'

#
# We assume that Pike.framework will be used as an embedded framework within an application bundle.
# if you want to install the framework in a standard location, like /Library/Frameworks, you will
# need to use install_name_tool to change the location. don't blame me, blame dyld.
#
# the following target assumes MacOS X 10.6 or higher, and is configured to use garbage collection
framework: OCPikeInterpreter.o $(OBJ) modules/linker_options @STATIC_POST_MODULES_LINKOPTS@
	@echo "Linking Pike.framework";\
	gcc -o Pike OCPikeInterpreter.o $(OBJ) `cat modules/linker_options @STATIC_POST_MODULES_LINKOPTS@` -framework Cocoa \
	  -dynamiclib -Wl,-no_pie -mpic-no-dynamic -Wl,-single_module \
	  -undefined dynamic_lookup -mmacosx-version-min=10.4 -current_version 7.9 -install_name @executable_path/../Frameworks/Pike.framework/Pike \
	  -isysroot /Developer/SDKs/MacOSX10.6.sdk
	ls -l Pike
	if test -x Pike.framework ; then rm -rf Pike.framework; fi
	mkdir Pike.framework
	mkdir Pike.framework/Versions
	mkdir Pike.framework/Versions/7.7
	mkdir Pike.framework/Versions/7.7/Headers
	mkdir Pike.framework/Versions/7.7/Resources
	mkdir Pike.framework/Versions/7.7/Resources/lib
	mv Pike Pike.framework/Versions/7.7
	cd Pike.framework/Versions && ln -s 7.7 Current
	cd Pike.framework && ln -s Versions/Current/Resources Resources && ln -s Versions/Current/Headers Headers && \
		ln -s Versions/Current/Pike Pike
	cp $(SRCDIR)/*.h Pike.framework/Versions/7.7/Headers
	cp *.h Pike.framework/Versions/7.7/Headers
	cp $(PACKAGINGDIR)/macosx/framework_Info.plist Pike.framework/Versions/7.7/Resources/Info.plist
	MACHINE=`uname -m | tr " " "_"` && mkdir Pike.framework/Versions/7.7/Resources/$$MACHINE && cp -rf lib/* Pike.framework/Versions/7.7/Resources/$$MACHINE
	cp -rf $(SRCDIR)/../lib/* Pike.framework/Versions/7.7/Resources/lib
	cp master.pike Pike.framework/Versions/7.7/Resources/lib
	cd Pike.framework && find . -type f -name '*.in' -exec rm -f {} \;

libpike.so: $(OBJ) modules/linker_options @STATIC_POST_MODULES_LINKOPTS@
	@echo "Linking libpike.so";\
	if $(TMP_BINDIR)/smartlink "$(LDSHARED)" $(LDFLAGS) -o libpike.@SO@ \
	  $(OBJ) `cat modules/linker_options @STATIC_POST_MODULES_LINKOPTS@` \
	  $(LIBS); then \
	  if test "@SO@" != so ; then mv "module.@SO@" module.so ; \
	  else :; fi ;\
	else \
	  echo "Linking failed:" >&2; \
	  echo $(TMP_BINDIR)/smartlink "$(LDSHARED)" $(LDFLAGS) -o libpike.@SO@ \
	    $(OBJ) `cat modules/linker_options @STATIC_POST_MODULES_LINKOPTS@` \
	    $(LIBS) >&2 ;\
	  exit 1; \
	fi

# FIXME: Static linked version; this doesn't work yet!
#        Since we need to split linker_options into archives and options.
libpike.a: $(OBJ) modules/linker_options @STATIC_POST_MODULES_LINKOPTS@
	-rm -f libpike.a
	$(AR) cq libpike.a $(OBJ)
	-@RANLIB@ libpike.a

# tpike is only used when dynamic modules aren't. It's a pike with no
# post modules linked in which is used during building of the post
# modules.
tpike-real: main.o $(CORE_OBJ) tmodule.o modules/linker_options
	-@rm -f tpike tpike.exe
	$(LD) $(LDFLAGS) main.o $(CORE_OBJ) tmodule.o \
	  `cat modules/linker_options` \
	  $(LIBS) -o tpike@EXEEXT@
# Turn off PaX mprotect inhibition on NetBSD and others.
	@$(PAXCTL_ALLOW_MPROTECT) tpike

# Only want tpike to exist for use with $(RUNPIKE) in the modules. We
# don't want to require it actually being up-to-date.
tpike@EXEEXT@: master-stamp
	$(MAKE) $(MAKE_FLAGS) tpike-real

# If we build without dynamic modules then tpike is built first with
# all modules under modules/ linked into it, then tpike is used for
# post_modules source targets, and then pike is linked with both
# modules/ and post_modules/.
#
# If we build with dynamic modules then pike is built first with the
# few always-static modules under modules/, then the dynamic modules
# under modules/ are built, then pike is used for post_modules source
# targets, and then all modules under post_modules/ are built
# dynamically.
#
# This means that a post_module can't be always-static and can't add
# stuff to the pike linkage using LINKER_OPTIONS.
#
# @LDSHARED_BASE_REQS@ expands to pike.lib if dynamic DLL modules are
# used on NT.
pike@EXEEXT@ pike.lib: main.o $(OBJ) master-stamp pike.syms modules/linker_options @STATIC_POST_MODULES_LINKOPTS@ @PIKE_ICON_RES@
	-@if [ -f pike.old.exe ] ; then rm -f pike.old.exe || : ; else : ; fi
	-@if [ -f pike.old ] ; then rm -f pike.old || : ; else : ; fi
	-@if [ -f pike.exe ] ; then mv pike.exe pike.old.exe || : ; else : ; fi
	-@if [ -f pike ] ; then mv pike pike.old || : ; else : ; fi
	$(LD) $(LDFLAGS) main.o $(OBJ) \
	  `cat modules/linker_options @STATIC_POST_MODULES_LINKOPTS@` \
	  $(LIBS) @PIKE_ICON_RES@ -o pike
	@MT_FIX_PIKE_EXE@
# Turn off PaX mprotect inhibition on NetBSD and others.
	@$(PAXCTL_ALLOW_MPROTECT) pike
# The dumped modules are removed whenever Pike is relinked since some
# of the bytecode methods (e.g. ia32) store absolute addresses to
# global structs. That should probably be fixed in them so that dumped
# modules aren't link order dependent.
	@if [ -f dumpversion ]; then \
	  echo "$(MAKE) $(MAKE_FLAGS) delete_dumped_modules"; \
	  $(MAKE) $(MAKE_FLAGS) delete_dumped_modules; \
	else :; fi

# gcov
gcov:
	@for f in `cd "$(SRCDIR)" && find . -type f -name '*.c' -print`; do \
	  if test -f `echo $$f | sed -e 's/\.$$/.bb/'`; then \
	    for gf in `gcov $$f | sed -e 's/Creating \(.*\)\.gcov.*/\1.gcov/p' -ed`; do \
	      echo "Generating $$f-$$gf."; \
	      test -f "$$f-$$gf" && rm -f "$$f-$$gf"; \
	      mv "$$gf" "$$f-$$gf"; \
	    done; \
	  else \
	    :; \
	  fi; \
	done
	@echo
	@echo "Summary:"
	@for f in `find . -name '*.gcov' -print`; do \
	  grep '######' $$f | \
	  grep -v fatal | \
	  grep -v -i inline | \
	  grep -v PIKE_MODULE_EXIT | \
	  $(EGREP) -v '######[ 	]*{$$' | \
	  $(EGREP) -v '######[ 	]*}$$' | \
	  wc -l | sed -e "s|^|$$f:|" -e 's/:[   ]*/:/' | \
	  grep -v ':0'; \
	done | sort -n -t: -k2

# purify
pure: $(OBJ) master-stamp module_objects
	-@mv pike@EXEEXT@ pike.old@EXEEXT@ 2>/dev/null || true
	$(SMARTLINK) purify -max-threads=128 -thread_stack_change=8192 -free-queue-length=500 -inuse-at-exit=yes -chain-length=12 $(REALCC) $(LDFLAGS) $(OBJ) `cat modules/linker_options @STATIC_POST_MODULES_LINKOPTS@` $(LIBS) -o pike@EXEEXT@

# purecov
cover: $(OBJ) master-stamp module_objects
	-@mv pike@EXEEXT@ pike.old@EXEEXT@ 2>/dev/null || true
	$(SMARTLINK) purecov purify -max-threads=128 -thread_stack_change=8192 -free-queue-length=500 -inuse-at-exit=yes -chain-length=12 $(REALCC) $(LDFLAGS) $(OBJ) `cat modules/linker_options @STATIC_POST_MODULES_LINKOPTS@` $(LIBS) -o pike@EXEEXT@

# quantify
quant: $(OBJ) master-stamp module_objects
	-@mv pike@EXEEXT@ pike.old@EXEEXT@ 2>/dev/null || true
	$(SMARTLINK) quantify $(REALCC) $(LDFLAGS) $(OBJ) `cat modules/linker_options @STATIC_POST_MODULES_LINKOPTS@` $(LIBS) -o pike@EXEEXT@

splint:
	splint $(PREFLAGS) -warnposix +charintliteral -realcompare -boolops -predboolint $(FILE)

atom: pike-complete-stamp
	atom pike -tool atom -env threads -g -v `find lib/modules -type f -name '*.so' -print | sed -e 's/^/-incobj /g'`
	mv pike pike.pre-atom
	mv pike.third.threads pike
	@echo Make sure you have '.' in your LD_LIBRARY_PATH.

pixie: pike-complete-stamp
	atom pike -tool pixie -env threads -g -v `find lib/modules -type f -name '*.so' -print | sed -e 's/^/-incobj /g'`
	mv pike pike.pre-pixie
	mv pike.pixie.threads pixie
	@echo Make sure you have '.' in your LD_LIBRARY_PATH.

dump_modules: pike-complete-stamp master-stamp
	-rm dumpmodule.log
	args="$(DUMPARGS)"; \
	args=$${args:-"--log-file --update-only=dumpversion --report-failed"}; \
	$(RUNPIKE) -x dump $$args \
	--recursive --target-dir=lib "$(LIBDIR_SRC)/modules"

force_dump_modules:
	-rm dumpversion 2>/dev/null
	$(MAKE) $(MAKE_FLAGS) dump_modules

delete_dumped_modules:
	-find lib -type f -name \*.o | xargs rm -f

undump_modules: delete_dumped_modules
	-rm dumpversion 2>/dev/null

.SUFFIXES:
.SUFFIXES: .c .h .S .o .m .mmod .cmod .pp .pph .h_src .wxs .wixobj .msi .msm

.c.pp:
	$(CPP) $(PREFLAGS) -DPMOD_EXPORT=PMOD_EXPORT \
	  -DPMOD_PROTO=PMOD_PROTO "$<" >"$@"

%.protos: %.c precompile.sh-stamp
	./precompile.sh --cache fake_dynamic_load.pike >"$@" --cpp --protos \
	  $(CPP) $(PREFLAGS) -DPMOD_EXPORT=PMOD_EXPORT \
	    -DPMOD_PROTO=PMOD_PROTO -DPIKE_PRECOMPILER=1 "$<" || \
	  { rm "$@"; exit 1; }

.h.pph:
	$(CPP) $(PREFLAGS) -DPMOD_EXPORT=PMOD_EXPORT \
	  -DPMOD_PROTO=PMOD_PROTO "$<" >"$@"


# Several optimizers have problems with interpret.c
# First try compiling with optimization and if that doesn't work, without.
# GCC dumps core on some files @ OSF1
# This kluge should work around that...
.c.o:
	@echo "Compiling `echo '$<' | sed -e 's|^$(PIKE_SRC_DIR)/||'`" ; \
	rm -f $@.fail >/dev/null 2>&1; \
	if $(CC) $(CFLAGS) $$EXTRAFLAGS -c $< -o $@ ; then : ; else \
	  status=$$?; \
	  echo "Compilation command was:" >&2;\
	  echo "$(CC) $(PREFLAGS) $(CFLAGS) $$EXTRAFLAGS -c $< -o $@" >&2 ;\
	  exit $$status; \
	fi

.c.S:
	@echo "Compiling `echo '$<' | sed -e 's|^$(PIKE_SRC_DIR)/||'`" ; \
	rm -f $@.fail >/dev/null 2>&1; \
	if $(CC) $(CFLAGS) $$EXTRAFLAGS -S $< -o $@ ; then : ; else \
	  status=$$?; \
	  echo "Compilation command was:" >&2;\
	  echo "$(CC) $(PREFLAGS) $(CFLAGS) $$EXTRAFLAGS -S $< -o $@" >&2 ;\
	  exit $$status; \
	fi

.m.o:
	@echo "Compiling `echo '$<' | sed -e 's|^$(PIKE_SRC_DIR)/||'`" ; \
	rm -f $@.fail >/dev/null 2>&1; \
	if $(CC) $(CFLAGS) $$EXTRAFLAGS -fobjc-exceptions -fobjc-gc -c $< -o $@ ; then : ; else \
	  status=$$?; \
	  echo "Compilation command was:" >&2;\
	  echo "$(CC) $(PREFLAGS) $(CFLAGS) $$EXTRAFLAGS -fobjc-exceptions -c $< -o $@" >&2 ;\
	  exit $$status; \
	fi

.m.S:
	@echo "Compiling `echo '$<' | sed -e 's|^$(PIKE_SRC_DIR)/||'`" ; \
	rm -f $@.fail >/dev/null 2>&1; \
	if $(CC) $(CFLAGS) $$EXTRAFLAGS -fobjc-exceptions -fobjc-gc -S $< -o $@ ; then : ; else \
	  status=$$?; \
	  echo "Compilation command was:" >&2;\
	  echo "$(CC) $(PREFLAGS) $(CFLAGS) $$EXTRAFLAGS -fobjc-exceptions -S $< -o $@" >&2 ;\
	  exit $$status; \
	fi

$(PMOD_TARGETS): precompile.sh-stamp $(TMP_BINDIR)/precompile.pike $(PIKE_SRC_DIR)/../lib/modules/Tools.pmod/Standalone.pmod/precompile.pike Makefile.in

#
# Please note that this must be accompanied by a dependency rule as
# The .c file will not be created in the SOURCE directory otherwise.
# -Hubbe
#
.cmod.c:
	./precompile.sh --cache precompile.pike $(PRECOMPILER_ARGS) >"$@" "$<" || { rm "$@"; exit 1; }

# The same applies to this.
%.c: %.symlist precompile.sh-stamp $(SRCDIR)/mklibpike.pike
	./precompile.sh --cache $(SRCDIR)/mklibpike.pike -I. -I "$(SRCDIR)" -S "$<" -o "$@" || { rm "$@"; exit 1; }

# This rule is used for some header files that are generated from the
# source, to avoid excessive rebuilding when the source change in ways
# that doesn't affect the header.
#
# It can cause a .h target to be out-of-date repeatedly, but since it
# runs fast that's not an issue. This technique only works well in
# make's that stat the target again after the rule has run and
# recalculate the dependencies from that. Most make's seems to behave
# like that.
.h_src.h:
	@if test -f "$@"; then \
	  test -f "$@.nolines" || \
	    sed -e '/^[ \t]*$$/d;/^[ \t]*#[ \t]*line.*$$/d' < "$@" > "$@.nolines" && \
	  sed -e '/^[ \t]*$$/d;/^[ \t]*#[ \t]*line.*$$/d' < "$<" > "$<.nolines" && \
	  cmp -s "$<.nolines" "$@.nolines"; \
	else \
	  false; \
	fi || ( \
	  rm -f "$@.nolines" 2>/dev/null; \
	  echo "cp $< $@"; \
	  cp "$<" "$@"; \
	)

.wxs.wixobj:
	@if test -f "$@"; then rm -f "$@"; else :; fi # Paranoia
	$(CANDLE) "$<" -out "$@" || { rm -f "$@"; exit 1; }

.wixobj.msm:
	@test -d cab_cache || mkdir cab_cache
	@if test -f "$@"; then rm -f "$@"; else :; fi # Paranoia
	$(LIGHT) "$<" -cc cab_cache -o "$@" || { rm -f "$@"; exit 1; }

.wixobj.msi:
	@test -d cab_cache || mkdir cab_cache
	@if test -f "$@"; then rm -f "$@"; else :; fi # Paranoia
	$(LIGHT) "$<" -cc cab_cache -o "$@" || { rm -f "$@"; exit 1; }

Pike_banner.bmp: $(SRCDIR)/make_banner.pike $(SRCDIR)/../refdoc/src_images/pike_logo.gif
	$(RUNPIKE) $(SRCDIR)/make_banner.pike $(SRCDIR)/../refdoc/src_images/pike_logo.gif >Pike_banner.bmp || rm Pike_banner.bmp

UpFldrBtn.ibd: $(PACKAGINGDIR)/windows/UpFldrBtn.ibd
	cp "$<" "$@"

NewFldrBtn.ibd: $(PACKAGINGDIR)/windows/NewFldrBtn.ibd
	cp "$<" "$@"

PikeWin32Installer.vbs: $(PACKAGINGDIR)/windows/installer.vbs
	@if [ -f "$@" ] && cmp "$<" "$@" >/dev/null; then \
	  echo "PikeWin32Installer.vbs is up to date."; \
	else \
	  echo cp '"'"$<"'"' '"'"$@"'"'; \
	  cp "$<" "$@"; \
	fi

Pike_module.msm: PikeWin32Installer.vbs

Pike_module.wxs: pike-complete-stamp $(TMP_BINDIR)/install.pike Makefile
	@no_autodoc="--no-autodoc"; \
	if [ -f autodoc.xml ]; then no_autodoc=""; fi; \
	$(RUNPIKE) $(TMP_BINDIR)/install.pike --wix-module $$no_autodoc \
	@INSTALL_EXPORT_ARGS@ \
	exec_prefix="$(bindir)" lib_prefix="$(lib_prefix)" \
	TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	SRCDIR="$(SRCDIR)" prefix="$(prefix)" DOCDIR_SRC="$(DOCDIR_SRC)" \
	MANDIR_SRC="$(MANDIR_SRC)" \
	BASEDIR="$(BASEDIR)" man_prefix="$(man_prefix)" \
	cflags="@DYNAMIC_MODULE_FLAGS@" ldflags="" \
	pike_name=$(pike_name) PIKE_MODULE_RELOC="$(PIKE_MODULE_RELOC)"

Pike.wxs: $(TMP_BINDIR)/install.pike Makefile
	@no_autodoc="--no-autodoc"; \
	if [ -f autodoc.xml ]; then no_autodoc=""; fi; \
	$(RUNPIKE) $(TMP_BINDIR)/install.pike --wix $$no_autodoc \
	@INSTALL_EXPORT_ARGS@ \
	exec_prefix="$(bindir)" lib_prefix="$(lib_prefix)" \
	TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	SRCDIR="$(SRCDIR)" prefix="$(prefix)" DOCDIR_SRC="$(DOCDIR_SRC)" \
	MANDIR_SRC="$(MANDIR_SRC)" \
	BASEDIR="$(BASEDIR)" man_prefix="$(man_prefix)" \
	cflags="@DYNAMIC_MODULE_FLAGS@" ldflags="" \
	pike_name=$(pike_name) PIKE_MODULE_RELOC="$(PIKE_MODULE_RELOC)"

Pike.msi: Pike.wixobj Pike_ui.wixobj Pike_module.msm Pike_banner.bmp UpFldrBtn.ibd NewFldrBtn.ibd
	@test -d cab_cache || mkdir cab_cache
	@if test -f Pike.msi; then rm Pike.msi; else :; fi # Paranoia
	$(LIGHT) Pike.wixobj Pike_ui.wixobj -o Pike.msi -cc cab_cache

wix: Pike.msi

wix_export: Pike.msi
	VER=`$(RUNPIKE) --dumpversion` ;\
	cp Pike.msi $(BASEDIR)/Pike-v$(VER)-win32.msi ;\
	cp config.info $(BASEDIR)/Pike-v$(VER)-win32.info

amigaos_export:
	@$(RUNPIKE) $(TMP_BINDIR)/install.pike --export-amigaos \
	  `test -f autodoc.xml || echo --no-autodoc` \
	  lib_prefix="$(lib_prefix)" \
	  TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	  SRCDIR="$(SRCDIR)" DOCDIR_SRC="$(DOCDIR_SRC)" \
	  MANDIR_SRC="$(MANDIR_SRC)" \
	  man_prefix="$(man_prefix)" fakeroot="$(buildroot)" \
	  PIKE_MODULE_RELOC="$(PIKE_MODULE_RELOC)" \
	  cflags="@DYNAMIC_MODULE_FLAGS@" ldflags=""

force :
	@:

pike.ico: $(PACKAGINGDIR)/windows/pike.ico
	cp "$<" $@

pike_icon.res: pike.ico
	echo 'pike ICON pike.ico' > pike_icon.rc
	$(RCEXE) /fo $@ pike_icon.rc

# install
install: pike-complete-stamp
	@$(RUNPIKE) $(TMP_BINDIR)/install.pike \
	exec_prefix="$(bindir)" lib_prefix="$(lib_prefix)" \
	include_prefix="$(include_prefix)" \
	TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	SRCDIR="$(SRCDIR)" prefix="$(prefix)" DOCDIR_SRC="$(DOCDIR_SRC)" \
	MANDIR_SRC="$(MANDIR_SRC)" \
	man_prefix="$(man_prefix)" pike_name=$(pike_name) \
	fakeroot="$(buildroot)" PIKE_MODULE_RELOC="$(PIKE_MODULE_RELOC)" \
	cflags="@DYNAMIC_MODULE_FLAGS@" ldflags="" \
	$(INSTALLARGS)

install_interactive: pike-complete-stamp
	@$(RUNPIKE) $(TMP_BINDIR)/install.pike --interactive \
	exec_prefix="$(bindir)"  prefix=$(prefix) \
	TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	SRCDIR="$(SRCDIR)" DOCDIR_SRC="$(DOCDIR_SRC)" \
	MANDIR_SRC="$(MANDIR_SRC)" \
	cflags="@DYNAMIC_MODULE_FLAGS@" ldflags="" \
	fakeroot="$(buildroot)" PIKE_MODULE_RELOC="$(PIKE_MODULE_RELOC)"

# tidy up a bit
tidy:
	-rm -f a.out a.out.* *.fail *.pp *.protos core y.output y.tab.c y.tab.h
	-rm -f core core.* *.o *.obj *.i *.i~ dynloadtest* cfl.*
	-rm -f conftest.* hdrlist.h a.out.exe
	-rm testsuite testsuite.tmp testsuite_test.pike testsuite_test_dir.pmod
	-rm -f *.wixobj *.wxs Pike_banner.bmp UpFldrBtn.ibd NewFldrBtn.ibd PikeWin32Installer.vbs
	-rm -f pike.ico pike_icon.rc pike_icon.res
	-find lib -type f -name \*.o -o -name \*.obj | xargs rm -f

# make clean
clean_here: tidy doc_clean
	-find tlib -name testsuite | xargs rm
	-find extra_tests -name testsuite | xargs rm
	-rm -f confdefs.h
	-rm -rf test-install test-pike tpike tpike.* *.pdb
	-rm -f TAGS tags yacc.acts yacc.debug yacc.tmp *.debug.log a.out pike.tmp
	-rm -f master.pike compiler-warnings dumpmodule.log
	-rm -f interpreter_debug.h
	-rm -f import-stamp master-stamp headerfiles-stamp
	-rm -f static-modules-stamp dynamic-modules-stamp post-modules-stamp
	-rm -f post-module-pike-stamp pike-complete-stamp
	-rm -rf lib/modules/*
#	-rm -f lib/master.pike

clean: clean_here
	-( cd modules; $(MAKE) $(MAKE_FLAGS) clean )
	-( cd post_modules; $(MAKE) $(MAKE_FLAGS) clean )

clean_pike:
	-rm -f pike pike.lib pike.exe pike.exe.manifest pike.exp

# Clean up everything that needs to go if the configure args change.
config_change_clean: clean clean_pike

# make _really_ clean
spotless: clean_here clean_pike
	-( cd modules; $(MAKE) $(MAKE_FLAGS) spotless )
	-( cd post_modules; $(MAKE) $(MAKE_FLAGS) spotless )
	-(cd $(SRCDIR); find . -type f -name '*.h.in' -print) | \
	  sed -e 's/\.in$$//' | xargs rm -f
	-rm -f Makefile config.* make_variables specs pike.syms
	-rm -f .pure stamp-h
	-rm -f lexical.c mon.out *.ln
	-rm -f pike.old pike.old.exe l.outa* num_files_to_install
	-rm -f *.msm *.msi
	-rm -f precompile.sh precompile.sh-stamp smartlink
	-rm -rf tlib extra_tests lib precompile

distclean: spotless

# create tags
tags:
	ctags *.c

TAGS:
	etags -t *.h *.c

# verify / debug
testsuites:
	$(MAKE) $(MAKE_FLAGS) testsuite
	( cd modules && $(MAKE) $(MAKE_FLAGS) testsuites )
	( cd post_modules && $(MAKE) $(MAKE_FLAGS) testsuites )
	( cd $(TMP_BUILDDIR) && $(TMP_BINDIR)/mklibtests.sh \
	  --srcdir=$(LIBDIR_SRC) \
	  --destdir=tlib --bindir=$(TMP_BINDIR) )
	if test -d "$(BASEDIR)/extra_tests" ; then \
	  (cd "$(TMP_BUILDDIR)" && $(TMP_BINDIR)/mklibtests.sh \
	   --srcdir="$(BASEDIR)/extra_tests" \
	   --destdir=extra_tests --bindir=$(TMP_BINDIR) ) ; fi;

just_verify: testsuites master-stamp
	if test "x$(TESTARGS)" = x ; then args="$(TESTARGS_FORK)" ; \
	else args="$(TESTARGS)" ; fi; \
	$(RUNPIKE) -x test_pike $$args

valgrind_just_verify: testsuites master-stamp
	if test "x$(TESTARGS)" = x ; then args="$(TESTARGS_NOFORK)" ; \
	else args="$(TESTARGS)" ; fi; \
	$(VALGRIND) $(VALGRINDARGS) $(RUNPIKE) -x test_pike --subproc-start="$(VALGRIND) $(VALGRINDARGS)" $$args

dtrace_probes.h: $(SRCDIR)/dtrace/dtrace_probes.d
	dtrace -h -s "$(SRCDIR)/dtrace/dtrace_probes.d" -o "$(TMP_BUILDDIR)/dtrace_probes.h"


# Testsuite for dynamic loading debugging
test_dlopen: dynloadtest.sh
	sh ./dynloadtest.sh

dynloadtest.sh: $(SRCDIR)/test_dynamic_loading.in
	m4 "$(SRCDIR)/test_dynamic_loading.in" >"$@"

dynloadtest.c: dynamic_load.c

dynloadtest@EXEEXT@: dynloadtest.o @EXTRA_OBJS@ fdlib.o port.o
	$(LD) $(LDFLAGS) dynloadtest.o @EXTRA_OBJS@ fdlib.o port.o $(LIBS) -o $@


tinstall: master-stamp
	-rm -rf test-install
	$(RUNPIKE) $(TMP_BINDIR)/install.pike \
	  `test -f autodoc.xml || echo --no-autodoc` \
	  lib_prefix="$(lib_prefix)" \
	  TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	  SRCDIR="$(SRCDIR)" DOCDIR_SRC="$(DOCDIR_SRC)" \
	  MANDIR_SRC="$(MANDIR_SRC)" \
	  man_prefix="$(man_prefix)" fakeroot="$(buildroot)" \
	  PIKE_MODULE_RELOC="$(PIKE_MODULE_RELOC)" pike_name="test-pike" \
	  cflags="@DYNAMIC_MODULE_FLAGS@" ldflags="" \
	  prefix="./test-install" $(INSTALLARGS)

just-tinstall: master-stamp
	$(RUNPIKE) $(TMP_BINDIR)/install.pike \
	  `test -f autodoc.xml || echo --no-autodoc` \
	  lib_prefix="$(lib_prefix)" \
	  TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	  SRCDIR="$(SRCDIR)" DOCDIR_SRC="$(DOCDIR_SRC)" \
	  MANDIR_SRC="$(MANDIR_SRC)" \
	  man_prefix="$(man_prefix)" fakeroot="$(buildroot)" \
	  PIKE_MODULE_RELOC="$(PIKE_MODULE_RELOC)" pike_name="test-pike" \
	  cflags="@DYNAMIC_MODULE_FLAGS@" ldflags="" \
	  prefix="./test-install" $(INSTALLARGS)


verify: testsuites tinstall
	PIKE_MODULE_PATH=""; PIKE_INCLUDE_PATH=""; \
	if test "$(TESTARGS)" = "" ; then args="$(TESTARGS_FORK)" ; else \
	  args="$(TESTARGS)" ; fi; \
	if test -f ./test-pike ; then \
	  ./test-pike -DNOT_INSTALLED $(PIKEOPTS) -x test_pike $$args ; \
	else \
	  if test -f some-sprsh-test ; then \
	    sprsh `pwd`/test-install/pike/*/bin/pike.exe -DNOT_INSTALLED $(PIKEOPTS) -x test_pike $$args ; \
	  else \
	    `pwd`/test-install/pike/*/bin/pike.exe -DNOT_INSTALLED $(PIKEOPTS) -x test_pike $$args ; \
	  fi \
	fi

valgrind_verify: testsuites tinstall
	PIKE_MODULE_PATH=""; PIKE_INCLUDE_PATH=""; \
	if test "$(TESTARGS)" = "" ; then args="$(TESTARGS_NOFORK)" ; else \
	  args="$(TESTARGS)" ; fi; \
	if test -f ./test-pike ; then \
	  $(VALGRIND) $(VALGRINDARGS) ./test-pike -DNOT_INSTALLED $(PIKEOPTS) -x test_pike --subproc-start="$(VALGRIND) $(VALGRINDARGS)" $$args ; \
	else \
	  sprsh `pwd`/test-install/pike/*/bin/pike.exe -DNOT_INSTALLED $(PIKEOPTS) -x test_pike $$args ; \
	fi

bench: tinstall
	if test -f ./test-pike ; then \
	  ./test-pike -DNOT_INSTALLED $(PIKEOPTS) -x benchmark; \
	else \
	  if test -f some-sprsh-test ; then \
	    sprsh `pwd`/test-install/pike/*/bin/pike.exe -DNOT_INSTALLED $(PIKEOPTS) -x benchmark ; \
	  else \
	    `pwd`/test-install/pike/*/bin/pike.exe -DNOT_INSTALLED $(PIKEOPTS) -x benchmark ; \
	  fi \
	fi

verify_installed: testsuites master-stamp
	if test "$(TESTARGS)" = "" ; then args="$(TESTARGS_FORK)" ; else \
	  args="$(TESTARGS)" ; fi; \
	$(bindir)/pike $(PIKEOPTS) -x test_pike $$args

check: verify

sure: verify

# verify / debug verbose
verbose_verify: testsuites master-stamp
	if test "$(TESTARGS)" = "" ; then args="$(TESTARGS_FORK)" ; else args="$(TESTARGS)" ; fi; \
	$(RUNPIKE) -x test_pike -v $$args

# verify & debug VERBOSE
gdb_verify: testsuites master-stamp
	@echo >.gdbinit handle SIGFPE nostop noprint pass
	@echo >>.gdbinit handle SIGUSR1 nostop noprint pass
	@echo >>.gdbinit handle SIGUSR2 nostop noprint pass
	@echo >>.gdbinit handle SIGLWP nostop noprint pass
	@echo >>.gdbinit handle SIGPIPE nostop noprint pass
	@if kill -l | grep SIGRTMIN >/dev/null ; then \
	  echo >>.gdbinit handle SIG32 nostop noprint pass ;\
	else :; fi
	@echo >>.gdbinit break debug_fatal
	@echo >>.gdbinit break pike_gdb_breakpoint
	@echo >>.gdbinit break abort
	@if test "$(TESTARGS)" = "" ; then args="$(TESTARGS_NOFORK) -v" ; else \
	  args="$(TESTARGS)" ; fi;  \
	echo >>.gdbinit set args \
	  -m`echo "$(TMP_BUILDDIR)/master.pike" | ./posix_to_native.sh` \
	  $(PIKEOPTS) -x test_pike --no-watchdog $$args
	$(GDB) $(TMP_BUILDDIR)/pike
	@rm .gdbinit

gdb_hilfe: master.pike
	@echo >.gdbinit handle SIGFPE nostop noprint pass
	@echo >>.gdbinit handle SIGUSR1 nostop noprint pass
	@echo >>.gdbinit handle SIGUSR2 nostop noprint pass
	@echo >>.gdbinit handle SIGLWP nostop noprint pass
	@echo >>.gdbinit handle SIGPIPE nostop noprint pass
	@if kill -l | grep SIGRTMIN >/dev/null ; then \
	  echo >>.gdbinit handle SIG32 nostop noprint pass ;\
	else :; fi
	@echo >>.gdbinit break debug_fatal
	@echo >>.gdbinit break pike_gdb_breakpoint
	@echo >>.gdbinit break abort
	@echo >>.gdbinit set args -m$(TMP_BUILDDIR)/master.pike $$ARGS
	$(GDB) $(TMP_BUILDDIR)/pike
	@rm .gdbinit

# fast test
fast_verify_testsuite: testsuite
	PIKE_MODULE_PATH=""; PIKE_INCLUDE_PATH=""; \
	if test "$(TESTARGS)" = "" ; then args="$(TESTARGS_FORK)" ; \
	else args="$(TESTARGS)" ; fi; \
	if test -f ./test-pike ; then \
	  ./test-pike -DNOT_INSTALLED $(PIKEOPTS) -x test_pike $$args ; \
	else \
	  sprsh `pwd`/test-install/pike/*/bin/pike.exe -DNOT_INSTALLED \
	    $(PIKEOPTS) -x test_pike $$args ; \
	fi

# run hilfe, for interactive testing
run_hilfe: master.pike
	$(RUNPIKE) $(ARGS)

valgrind_hilfe: master.pike
	$(VALGRIND) $(VALGRINDARGS) $(RUNPIKE) $(ARGS)

feature_list:
	$(RUNPIKE) --features

run_bench:
	$(RUNPIKE) $(ARGS) -x benchmark $(BENCHARGS)

lib: Makefile
	@for d in lib lib/modules lib/include; do \
	  if [ -d $$d/. ]; then : ; else \
	    echo "Creating $$d/."; \
	    (mkdir $$d && chmod u+rwx $$d) || exit 1; \
	  fi ; \
	done
	@echo "Done."
	-@touch ./lib 2>/dev/null || (touch lib/.broken_gnu_touch && rm lib/.broken_gnu_touch)

$(SRCDIR)/type_checker.c: type_checker-stamp
$(SRCDIR)/type_checker.h: type_checker-stamp
type_checker-stamp: $(SRCDIR)/type_checker.in $(SRCDIR)/make_type_checker.pike
	$(RUNPIKE) $(SRCDIR)/make_type_checker.pike "$<" && touch "$@"

master.pike: $(LIBDIR_SRC)/master.pike.in Makefile
	@if test "x$(PIKE_MODULE_RELOC)" = "x"; \
	  then u=s,x,x,; \
	  else u='s/^#undef PIKE_MODULE_RELOC/#define PIKE_MODULE_RELOC 1/'; \
	fi; \
	LC_ALL=C; export LC_ALL; \
	cmd="sed -e 's!#lib_prefix#!`echo '$(TMP_LIBDIR)' | ./posix_to_native.sh`!' \
	  -e 's!#share_prefix#!`echo '$(LIBDIR_SRC)' | ./posix_to_native.sh`!' \
	  -e 's!#include_prefix#!`echo '$(TMP_BUILDDIR)/include' | ./posix_to_native.sh`!' \
	  -e '$$u'"; \
	echo "$$cmd <$(LIBDIR_SRC)/master.pike.in >master.pike"; \
	eval $$cmd <$(LIBDIR_SRC)/master.pike.in >master.pike || { rm "master.pike"; exit 1; }

# Want master.pike up-to-date, but yet there's no dependency on the
# that file. Works like the .h_src.h target.
master-stamp: master.pike
	@test -f master-stamp || echo foo > master-stamp

#
# Documentation related stuff.
#

onepage.xml: autodoc.xml $(DOCDIR)/structure/onepage.xml
	(cd "$(DOCDIR)" && \
	  $(RUNPIKE) -x assemble_autodoc structure/onepage.xml \
	    $(TMP_BUILDDIR)/autodoc.xml) >onepage.xml || { rm "$@"; exit 1; }

traditional.xml: autodoc.xml $(DOCDIR)/structure/traditional.xml
	( cd "$(DOCDIR)" && \
	  $(RUNPIKE) -x assemble_autodoc structure/traditional.xml \
	    $(TMP_BUILDDIR)/autodoc.xml) >traditional.xml || { rm "$@"; exit 1; }

modref.xml: autodoc.xml $(DOCDIR)/structure/modref.xml
	(cd "$(DOCDIR)" && \
	  $(RUNPIKE) -x assemble_autodoc structure/modref.xml \
	    $(TMP_BUILDDIR)/autodoc.xml) >modref.xml || { rm "$@"; exit 1; }

autodoc.xml: pike-complete-stamp doc_build/src doc_build/lib doc_build/images images2 force
	$(RUNPIKE) -x extract_autodoc -q --srcdir=$(SRCDIR) \
	  --imgsrc=$(DOCDIR)/src_images --builddir=doc_build/src \
	  --imgdir=doc_build/images
	$(RUNPIKE) -x extract_autodoc -q --srcdir=$(LIBDIR_SRC) \
	  --imgsrc=$(DOCDIR)/src_images --builddir=doc_build/lib \
	  --imgdir=doc_build/images
	$(RUNPIKE) -x join_autodoc --quiet --post-process autodoc.xml doc_build

autodoc-stamp:
	@test -f autodoc.xml || $(MAKE) autodoc.xml
	@test -f autodoc-stamp || echo foo > autodoc-stamp

images2: doc_build/src/post_modules/GTK2/refdoc/images
	@cp $(SRCDIR)/post_modules/GTK2/refdoc/images/*.png \
	  doc_build/src/post_modules/GTK2/refdoc/images/

# Directories

doc_build:
	@test -d doc_build || mkdir doc_build

doc_build/src: doc_build
	@test -d doc_build/src || mkdir doc_build/src

doc_build/lib: doc_build
	@test -d doc_build/lib || mkdir doc_build/lib

doc_build/images: doc_build
	@test -d doc_build/images || mkdir doc_build/images

doc_build/src/post_modules: doc_build/src
	@test -d doc_build/src/post_modules || \
	  mkdir doc_build/src/post_modules

doc_build/src/post_modules/GTK2/refdoc/images: doc_build/src/post_modules
	@test -d doc_build/src/post_modules/GTK2 || \
	  mkdir doc_build/src/post_modules/GTK2
	@test -d doc_build/src/post_modules/GTK2/refdoc || \
	  mkdir doc_build/src/post_modules/GTK2/refdoc
	@test -d doc_build/src/post_modules/GTK2/refdoc/images || \
	  mkdir doc_build/src/post_modules/GTK2/refdoc/images

doc_clean:
	-rm -f onepage.xml traditional.xml modref.xml autodoc.xml \
		autodoc.xml.stamp resolution.log
	-rm -rf doc_build


pike.syms: $(SRCDIR)/interpret.c $(SRCDIR)/interpreter.h $(SRCDIR)/program.c $(SRCDIR)/builtin_functions.c
	( cat $(SRCDIR)/*.h *.h | $(EGREP)  '^[ 	]*#[ 	]*define[ 	][ 	]*[a-zA-Z_0-9]*[ 	][ 	]*[0-9][xabcdefABCDEF0-9]*[ 	]*' ; \
	echo "#define" `$(CPP) $(PREFLAGS) -DSTEP_BREAK_LINE='STEP_BREAK_LINE __LINE__' $(SRCDIR)/interpreter.h | grep STEP_BREAK_LINE` ) >pike.syms

# We touch the files that depend on language.h_src and
# interpret_protos.h_src to ensure that the .h_src.h rule doesn't have
# anything to do in the dist.
source: depend
	if test -f $(SRCDIR)/language.c; then touch $(SRCDIR)/language.c; else :; fi
	if test -f $(SRCDIR)/language.h; then touch $(SRCDIR)/language.h; else :; fi
	if test -f $(SRCDIR)/interpret_protos.h; then touch $(SRCDIR)/interpret_protos.h; else :; fi

# make export archive (requires compiled Pike)
# Do not compile in source tree if you want to use this!
# Beware that export archive this includes bison/yacc/byacc source
# and thus has to follow the rules stated in that code.

full_export: source
	chmod +x $(SRCDIR)/install-sh
	$(RUNPIKE) $(TMP_BINDIR)/export.pike --srcdir="$(SRCDIR)"  \
	--exportlist="$(SRCDIR)/export_list" --name=Pike-v%maj.%min.%bld \
	--tag $(EXPORTARGS)

EXPORT_NAME=Pike-v%maj.%min-%Y%M%D
snapshot_export: source
	chmod +x $(SRCDIR)/install-sh
	$(RUNPIKE) $(TMP_BINDIR)/export.pike --srcdir="$(SRCDIR)"  \
	--exportlist="$(SRCDIR)/export_list" --name=$(EXPORT_NAME) \
	$(EXPORTARGS)

export: full_export

bin_export:
	@rm -f *.burk
	@no_autodoc="--no-autodoc"; \
	if [ -f autodoc.xml ]; then no_autodoc=""; fi; \
	$(RUNPIKE) $(TMP_BINDIR)/install.pike --export $$no_autodoc \
	@INSTALL_EXPORT_ARGS@ \
	exec_prefix="$(bindir)" lib_prefix="$(lib_prefix)" \
	TMP_LIBDIR="$(TMP_LIBDIR)" LIBDIR_SRC="$(LIBDIR_SRC)" \
	SRCDIR="$(SRCDIR)" prefix="$(prefix)" DOCDIR_SRC="$(DOCDIR_SRC)" \
	MANDIR_SRC="$(MANDIR_SRC)" \
	BASEDIR="$(BASEDIR)" man_prefix="$(man_prefix)" \
	cflags="@DYNAMIC_MODULE_FLAGS@" ldflags="" \
	pike_name=$(pike_name) PIKE_MODULE_RELOC="$(PIKE_MODULE_RELOC)"
	@case " $(CC)" in \
	  *\ rnt*) \
	    $(MAKE) $(MAKE_FLAGS) uncompress_header ;\
	    echo "Compressing..." ;\
	    filename=`echo *.burk | sed 's@\.burk$$@@g'`.exe ;\
	    ( cat uncompress_header.exe ; gzip -9 -c *.burk ) > $$filename ;\
	    echo "Done." ;\
	  ;; \
	esac

#new_peep_engine:
#	$(RUNTPIKE) $(TMP_BINDIR)/mkpeep.pike $(SRCDIR)/peep.in >$(SRCDIR)/peep_engine.c
#	$(RUNTPIKE) $(TMP_BINDIR)/make_ci.pike <$(SRCDIR)/UnicodeData.txt >$(SRCDIR)/case_info.h

$(SRCDIR)/peep_engine.c: $(SRCDIR)/peep.in $(TMP_BINDIR)/mkpeep.pike
	./precompile.sh $(TMP_BINDIR)/mkpeep.pike $(SRCDIR)/peep.in >$(SRCDIR)/peep_engine.c || ( rm $(SRCDIR)/peep_engine.c ; exit 1 )

peep.o: $(SRCDIR)/peep_engine.c

$(SRCDIR)/whitespace.h: $(SRCDIR)/UnicodeData.txt $(TMP_BINDIR)/getwhitespace.sh
	$(TMP_BINDIR)/getwhitespace.sh >$(SRCDIR)/whitespace.h \
	  <$(SRCDIR)/UnicodeData.txt

$(SRCDIR)/case_info.h: $(SRCDIR)/UnicodeData.txt $(TMP_BINDIR)/make_ci.pike
	./precompile.sh $(TMP_BINDIR)/make_ci.pike $(SRCDIR)/case_info.h \
	  <$(SRCDIR)/UnicodeData.txt

builtin_functions.o: $(SRCDIR)/case_info.h $(SRCDIR)/combine_path.h

$(SRCDIR)/treeopt.h: $(SRCDIR)/treeopt.in $(TMP_BINDIR)/mktreeopt.pike
	./precompile.sh $(TMP_BINDIR)/mktreeopt.pike $(SRCDIR)/treeopt.in || ( rm $(SRCDIR)/treeopt.h ; exit 1 )

las.o: $(SRCDIR)/treeopt.h

interpret.o: $(SRCDIR)/interpret_functions_fixed.h

# make dependencies
depend: $(SRC_TARGETS)
	$(CC) -MM -MG $(PREFLAGS) $(SRCDIR)/*.c | $(TMP_BINDIR)/fixdepends.sh "$(SRCDIR)" "$(SRCDIR)" /dev/null
	-@(while :; do \
	  echo foo > cfl.$@; test "`echo cfl.*`" = cfl.$@ && break; \
	  rm cfl.$@; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=37; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES=Makefile CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.$@; exit $$EXITCODE)
	-@rm cfl.$@
	@( cd modules && { \
	  rm -f remake; \
	  $(MAKE) $(MAKE_FLAGS) depend || \
	    { test -f remake && $(MAKE) $(MAKE_FLAGS) depend; }; \
	})
	@if [ "x$(RUNTPIKE)" = "x$(USE_TPIKE)" ]; then \
	  if [ -x $(TMP_BUILDDIR)/pike ]; then \
	    $(MAKE) $(MAKE_FLAGS) post_modules_depend; \
	  else \
	    echo "Skipping make depend in post_modules since a fresh pike is"; \
	    echo "needed to make the autogenerated sources there."; \
	    :; \
	  fi \
	else \
	  echo "Skipping make depend in post_modules since a fresh pike is"; \
	  echo "needed to make the autogenerated sources there, and we are"; \
	  echo "cross-compiling or --disable-binary."; \
	  :; \
	fi

post_modules_depend:
	@if [ "x$(RUNTPIKE)" != "x$(USE_TPIKE)" ]; then :; \
	  echo "Skipping make depend in post_modules since a fresh pike is"; \
	  echo "needed to make the autogenerated sources there, and we are"; \
	  echo "cross-compiling or --disable-binary."; \
	  :; \
	else \
	  if [ -x $(TMP_BUILDDIR)/pike ]; then :; \
	  else $(MAKE) $(MAKE_FLAGS) pike@EXEEXT@; \
	  fi; \
	  ( cd post_modules && { \
	    rm -f remake; \
	    $(MAKE) $(MAKE_FLAGS) depend || \
	      { test -f remake && $(MAKE) $(MAKE_FLAGS) depend; }; \
	  }); \
	fi

#
# Pike internal targets
#

# touch static-modules-stamp here to avoid doing this work again if
# that target is checked later.
static_module_objects static-modules-stamp: $(MODULE_REQUIREMENTS)
	@MODULE_BUILD_TYPE=static; \
	export MODULE_BUILD_TYPE; \
	( cd modules && ( rm remake >/dev/null 2>&1 || : ) && \
	  ( $(MAKE) $(MAKE_FLAGS) || \
	    ( test -f remake && $(MAKE) $(MAKE_FLAGS) ) ) \
	) || exit $$?
	@touch static-modules-stamp

dynamic_module_objects dynamic-modules-stamp: $(MODULE_REQUIREMENTS) @LDSHARED_BASE_REQS@
	@MODULE_BUILD_TYPE=dynamic; \
	export MODULE_BUILD_TYPE; \
	( cd modules && ( rm remake >/dev/null 2>&1 || : ) && \
	  ( $(MAKE) $(MAKE_FLAGS) || \
	    ( test -f remake && $(MAKE) $(MAKE_FLAGS) ) ) \
	) || exit $$?
	@touch dynamic-modules-stamp

# Use submakes here to ensure both correct sequencing and that all
# modules are properly rechecked.
module_objects:
	@$(MAKE) $(MAKE_FLAGS) static_module_objects
	@$(MAKE) $(MAKE_FLAGS) dynamic_module_objects

modules/modlist.h: static-modules-stamp

modules/modlist_headers.h: static-modules-stamp

modules/linker_options: static-modules-stamp

post-module-pike-stamp: @BUILD_PIKE@@EXEEXT@ dynamic-modules-stamp
	@touch post-module-pike-stamp

pike_modules.o:  modules/modlist_headers.h modules/modlist.h post_modules/modlist_headers.h post_modules/modlist.h

tmodule.o:  modules/modlist_headers.h modules/modlist.h

# Backward compat.
post_modules: post_module_objects

post_module_objects post-modules-stamp: pike@EXEEXT@ $(MODULE_REQUIREMENTS) post-module-pike-stamp @LDSHARED_BASE_REQS@
	@MODULE_BUILD_TYPE=@POST_MODULE_BUILD_TYPE@; \
	export MODULE_BUILD_TYPE; \
	( cd post_modules && ( rm remake >/dev/null 2>&1 || : ) && \
	  ( $(MAKE) $(MAKE_FLAGS) || \
	    ( test -f remake && $(MAKE) $(MAKE_FLAGS) ) ) \
	) || exit $$?
	@touch post-modules-stamp

post_modules/modlist_headers.h: post-modules-stamp

post_modules/modlist.h: post-modules-stamp

post_modules/linker_options: post-modules-stamp

pike-complete-stamp: pike@EXEEXT@ post-modules-stamp
	@touch pike-complete-stamp

$(SRCDIR)/interpret_protos.h_src: $(SRCDIR)/interpret_functions.h $(SRCDIR)/strip_opcodes
	$(CPP) $(PREFLAGS) -DGEN_PROTOS $(SRCDIR)/interpret_functions.h | $(SRCDIR)/strip_opcodes >$(SRCDIR)/interpret_protos.h_src || { rm $(SRCDIR)/interpret_protos.h_src; exit 1; }

lex.o: $(SRCDIR)/lex.c $(SRCDIR)/interpret_protos.h

interpret.o: $(SRCDIR)/lex.c $(SRCDIR)/interpret_protos.h @DTRACE_REQUIREMENTS@

lex_t.o: $(SRCDIR)/lex_t.c $(SRCDIR)/interpret_protos.h

language.o: $(SRCDIR)/language.c $(SRCDIR)/object.h $(SRCDIR)/interpret.h $(SRCDIR)/program.h

$(SRCDIR)/language.c_src: $(SRCDIR)/language.yacc
	-@awk 'BEGIN { COUNT=1; } \
	       /%expect/ { COUNT=$$2; } \
	       END { print "Expect " COUNT " shift/reduce conflict(s)."; }' \
	    <$(SRCDIR)/language.yacc 2>/dev/null
	cd $(SRCDIR) && $(YACC) $(YFLAGS) language.yacc
	@mv $(SRCDIR)/y.tab.c $(SRCDIR)/language.c_src
	@mv $(SRCDIR)/y.tab.h $(SRCDIR)/language.h_src
	@touch $(SRCDIR)/language.h_src

$(SRCDIR)/language.h_src: $(SRCDIR)/language.c_src
	@

$(SRCDIR)/language.c: $(SRCDIR)/language.c_src
	@sed -e 's/YY_COUNT_TYPE/@YY_COUNT_TYPE@/' \
	    -e 's/YY_FROM_CONST/@YY_FROM_CONST@/' \
	    -e 's/short[ 	]*int[ 	]/\/* short *\/ int /g' \
	    -e 's/(short[ 	]*int)/(\/* short *\/ int)/g' \
	    < $(SRCDIR)/language.c_src > $(SRCDIR)/language.c

$(SRCDIR)/interpret_functions_fixed.h: $(SRCDIR)/interpret_functions.h precompile.sh-stamp
	./precompile.sh --cache make_interpret_functions.pike >"$@" "$(SRCDIR)/interpret_functions.h" || { rm "$@"; exit 1; }

# UnixWare make needs help to find the source file...
builtin.o: $(SRCDIR)/builtin.c $(SRCDIR)/whitespace.h

cpp.o: $(SRCDIR)/cpp.c

iterators.o: $(SRCDIR)/iterators.c

backend.o: $(SRCDIR)/backend.c

las.o: $(SRCDIR)/las.c

libpike.o: $(SRCDIR)/libpike.c

pike_compiler.o: $(SRCDIR)/pike_compiler.c

pike_types.o: $(SRCDIR)/pike_types.c

string_builder.o: $(SRCDIR)/string_builder.c

# Internal testing target
run_yacc: $(SRCDIR)/language.c

$(SRCDIR)/configure $(SRCDIR)/stamp-h.in: $(SRCDIR)/configure.in $(SRCDIR)/aclocal.m4 $(SRCDIR)/acconfig.h
	cd $(SRCDIR) && ./run_autoconfig --no-recursion .
	echo foo > $(SRCDIR)/stamp-h.in

config.status propagated_variables: $(SRCDIR)/configure $(SRCDIR)/make_variables.in
	./config.status --recheck
	@test -f propagated_variables && touch propagated_variables

modules/common_module_makefile: $(SRCDIR)/modules/common_module_makefile.in config.status
	-@(while :; do \
	  echo foo > cfl.common_module_makefile; test "`echo cfl.*`" = cfl.common_module_makefile && break; \
	  rm cfl.common_module_makefile; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=17; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES=modules/common_module_makefile CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.common_module_makefile; exit $$EXITCODE)
	-@rm cfl.common_module_makefile

modules/static_module_makefile post_modules/static_module_makefile: modules/common_module_makefile $(SRCDIR)/modules/static_module_makefile.in config.status
	-@(while :; do \
	  echo foo > cfl.static_module_makefile; test "`echo cfl.*`" = cfl.static_module_makefile && break; \
	  rm cfl.static_module_makefile; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=17; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES="modules/static_module_makefile post_modules/static_module_makefile:modules/static_module_makefile.in" CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.static_module_makefile; exit $$EXITCODE)
	-@rm cfl.static_module_makefile

modules/dynamic_module_makefile post_modules/dynamic_module_makefile: modules/common_module_makefile $(SRCDIR)/@dmmsrc@ config.status
	-@(while :; do \
	  echo foo > cfl.dynamic_module_makefile; test "`echo cfl.*`" = cfl.dynamic_module_makefile && break; \
	  rm cfl.dynamic_module_makefile; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=19; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES="modules/dynamic_module_makefile:@dmmsrc@ post_modules/dynamic_module_makefile:@dmmsrc@" CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.dynamic_module_makefile; exit $$EXITCODE)
	-@rm cfl.dynamic_module_makefile

Makefile: $(SRCDIR)/Makefile.in $(SRCDIR)/dependencies config.status
	-@(while :; do \
	  echo foo > cfl.$@; test "`echo cfl.*`" = cfl.$@ && break; \
	  rm cfl.$@; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=23; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES=Makefile CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.$@; exit $$EXITCODE)
	-@rm cfl.$@
	touch remake
	@echo "Run make again"
	@exit 1

precompile.sh: $(SRCDIR)/precompile.sh.in ./config.status
	-@(while :; do \
	  echo foo > cfl.$@; test "`echo cfl.*`" = cfl.$@ && break; \
	  rm cfl.$@; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=29; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES=precompile.sh CONFIG_HEADERS="" ./config.status || \
	  (EXITCODE=$$?; rm cfl.$@; exit $$EXITCODE)
	-@rm cfl.$@

# A dependency on precompile.sh-stamp only ensures that precompile.sh
# exists, not that it's older than the target. In source dists,
# precompile.sh is almost always newer than the targets that depend on
# it, e.g. builtin.c that comes with the dist.
#
# The date stamp used to be 0103000070, but that seems to confuse some
# recent OS's, that haven't heard of the 70's...
#
# Note that gnu touch is stupid, and warns about the syntax; thus the
# redirect of stderr.
#
# BSD make is stupid, and doesn't restat precompile.sh-stamp and
# recalculate the dependencies after executing the rule, thus the
# recursive use of make.
precompile.sh-stamp:
	@if [ -f precompile.sh ]; then :; else $(MAKE) precompile.sh; fi
	@touch -t 198501010101 precompile.sh-stamp 2>/dev/null

$(SRCDIR)/machine.h.in: $(SRCDIR)/stamp-h.in
	@if test -f $(SRCDIR)/machine.h.in; then :; else \
	  rm $(SRCDIR)/stamp-h.in; $(MAKE) $(SRCDIR)/stamp-h.in; \
	fi

$(CONFIG_HEADERS): stamp-h
	@if test -f $(CONFIG_HEADERS); then :; else \
	  rm stamp-h; $(MAKE) stamp-h; \
	fi

stamp-h: $(SRCDIR)/stamp-h.in $(SRCDIR)/machine.h.in config.status
	-@(while :; do \
	  echo foo > cfl.$@; test "`echo cfl.*`" = cfl.$@ && break; \
	  rm cfl.$@; echo "Waiting to run config.status serially:" cfl.*; sleep 1; \
	  arb=31; while test $$arb != 0; do arb=`expr $$arb - 1`; done; \
	done;)
	CONFIG_FILES="" CONFIG_HEADERS="$(CONFIG_HEADERS)" ./config.status || \
	  (EXITCODE=$$?; rm cfl.$@; exit $$EXITCODE)
	touch stamp-h
	-@rm cfl.$@

testsuite: $(SRCDIR)/testsuite.in $(TMP_BINDIR)/mktestsuite
	if test "$$PIKE_PATH_TRANSLATE" = ""; then \
	  $(TMP_BINDIR)/mktestsuite $(SRCDIR)/testsuite.in >testsuite \
	    -DSRCDIR="`echo $(SRCDIR)|./posix_to_native.sh`"; \
	else \
	  $(TMP_BINDIR)/mktestsuite $(SRCDIR)/testsuite.in >testsuite \
	    -DSRCDIR="`echo $(SRCDIR)|sed -e $$PIKE_PATH_TRANSLATE|./posix_to_native.sh`"; \
	fi

header_uncompress: $(SRCDIR)/uncompressor.c
	$(CC) -O2 -static  $(SRCDIR)/uncompressor.c -o header_uncompress @UNCOMPRESS_LIBZ@

uncompress_header: $(SRCDIR)/uncompressor.c header_uncompress
	$(CC) -O2 -static  $(SRCDIR)/uncompressor.c -o uncompress_header @UNCOMPRESS_LIBZ@ -DSEEK_TO=`wc -c header_uncompress|sed 's/[^0-9]//g'`
	test "`wc -c header_uncompress|sed 's/[^0-9]//g'`" = "`wc -c uncompress_header|sed 's/[^0-9]//g'`"

HFILES=						\
  operators.protos				\
  array.protos					\
  fd_control.protos				\
  backend.protos				\
  fdlib.protos					\
  bignum.protos					\
  fsort.protos					\
  pike_memory.protos				\
  pike_types.protos				\
  gc.protos					\
  port.protos					\
  callback.protos				\
  program.protos				\
  interpret.protos				\
  constants.protos				\
  language.protos				\
  queue.protos					\
  cpp.protos					\
  rusage.protos					\
  cyclic.protos					\
  lex.protos					\
  signal_handler.protos				\
  pike_search.protos				\
  docode.protos					\
  main.protos					\
  stralloc.protos				\
  mapping.protos				\
  block_allocator.protos			\
  buffer.protos					\
  svalue.protos					\
  dynamic_load.protos				\
  module_support.protos				\
  threads.protos				\
  multiset.protos				\
  encode.protos					\
  object.protos					\
  error.protos					\
  opcodes.protos				\
  version.protos				\
  builtin.protos				\
  iterators.protos				\
  rbtree.protos

$(HFILES): precompile.sh-stamp

import-stamp: $(HFILES) precompile.sh-stamp
	@./precompile.sh fake_dynamic_load.pike >import_functions.tmp $(HFILES)
	@cmp import_functions.tmp import_functions.h >/dev/null || mv import_functions.tmp import_functions.h
	@echo hej >import-stamp

import_functions.h: import-stamp
	test -f import-stamp || ( rm import-stamp ; $(MAKE) import-stamp )

export_functions.c: import_functions.h
	touch export_functions.c

# Must have manual depends on all the bytecode methods in the code
# dir, since make depend will only include the one that was chosen,
# and that doesn't suffice in source dists.

$(SRCDIR)/pikecode.h: \
  $(SRCDIR)/code/ia32.h \
  $(SRCDIR)/code/amd64.h \
  $(SRCDIR)/code/sparc.h \
  $(SRCDIR)/code/ppc32.h \
  $(SRCDIR)/code/ppc64.h \
  $(SRCDIR)/code/arm32.h \
  $(SRCDIR)/code/arm64.h \
  $(SRCDIR)/code/riscv.h \
  $(SRCDIR)/code/bytecode.h
	touch $(SRCDIR)/pikecode.h

$(SRCDIR)/pikecode.c: \
  $(SRCDIR)/code/ia32.c \
  $(SRCDIR)/code/amd64.c \
  $(SRCDIR)/code/sparc.c \
  $(SRCDIR)/code/ppc32.c \
  $(SRCDIR)/code/ppc64.c \
  $(SRCDIR)/code/arm32.c \
  $(SRCDIR)/code/arm64.c \
  $(SRCDIR)/code/riscv.c \
  $(SRCDIR)/code/bytecode.c
	touch $(SRCDIR)/pikecode.c

@dependencies@

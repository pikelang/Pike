/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/

#include "global.h"
#include "main.h"
#include "object.h"
#include "mapping.h"
#include "multiset.h"
#include "svalue.h"
#include "array.h"
#include "pike_macros.h"
#include "pike_error.h"
#include "pike_memory.h"
#include "interpret.h"
#include "las.h"
#include "gc.h"
#include "stralloc.h"
#include "opcodes.h"
#include "program.h"
#include "operators.h"
#include "builtin_functions.h"
#include "constants.h"
#include "pike_types.h"

#define DEFAULT_CMOD_STORAGE

DECLARATIONS

/*! @class Iterator
 *!
 *! This is the interface for iterator objects. They implement an
 *! interface to a collection or stream of data items and a cursor
 *! that can be used to iterate over and examine individual items in
 *! the data set.
 *!
 *! Iterators are typically created to access a data set in some
 *! specific object, array, mapping, multiset or string. An object can
 *! have several iterators that access different data sets in it, or
 *! the same in different ways. E.g. strings have both an iterator for
 *! access char-by-char (@[String.Iterator]), and another for access
 *! over splitted substrings (@[String.SplitIterator]).
 *! @[lfun::_get_iterator] may be defined in an object to get an
 *! instance of the canonical iterator type for it. It's used by e.g.
 *! @[foreach] to iterate over objects conveniently.
 *!
 *! It's not an error to advance an iterator past the beginning or end
 *! of the data set; @[_iterator_index] and @[_iterator_value] will
 *! just return @[UNDEFINED] then. An iterator in that state
 *! need not keep track of positions, so it's undefined what happens
 *! if it's "moved back" into the set of items.
 *!
 *! Backward movement for iterators is currently not supported.
 *!
 *! @seealso
 *!   @[predef::get_iterator], @[lfun::_get_iterator],
 *!   @[Array.Iterator], @[Mapping.Iterator], @[Multiset.Iterator],
 *!   @[String.Iterator], @[String.SplitIterator], @[8.0::Iterator].
 */

PIKECLASS Iterator
{
  /*! @decl optional protected void create (void|mixed data)
   *!
   *! Initialize this iterator to access a data set in @[data]. The
   *! type of @[data] is specific to the iterator implementation. An
   *! iterator may also access some implicit data set, in which case
   *! @[data] isn't specified at all.
   *!
   *! The iterator initially points to before the first item in the data set,
   *! if there is any.
   *!
   *! The iterator does not need to support being reused, so this
   *! function is typically declared @expr{protected@}.
   *!
   *! @note
   *!   In the iterator API in Pike 8.0 and earlier the iterators initially
   *!   pointed to the first element.
   *!
   *! @seealso
   *!   @[CompatIterator]
   */
  PIKEFUN void create(void|mixed data)
    flags ID_PROTECTED;
    prototype;
  {}

  /*! @decl optional protected mixed _iterator_index()
   *!
   *! Returns the current index, or @[UNDEFINED] if the iterator
   *! doesn't point to any item.
   *!
   *! If there's no obvious index set then the index is the current
   *! position in the data set, counting from @expr{0@} (zero).
   *!
   *! @seealso
   *!   @[_iterator_value()], @[lfun::_iterator_index()],
   *!   @[iterator_index()]
   */
  PIKEFUN mixed _iterator_index()
    flags ID_PROTECTED|ID_OPTIONAL;
    prototype;
  {}

  /*! @decl optional protected mixed _iterator_value()
   *!
   *! Returns the current value, or @[UNDEFINED] if the iterator
   *! doesn't point to any item.
   *!
   *! @seealso
   *!   @[_iterator_index()], @[lfun::_iterator_value()],
   *!   @[iterator_value()]
   */
  PIKEFUN mixed _iterator_value()
    flags ID_PROTECTED|ID_OPTIONAL;
    prototype;
  {}

  /*! @decl optional protected int _sizeof()
   *!
   *! Returns the total number of items in the data set according to
   *! this iterator. If the size of the data set is unlimited or
   *! unknown then this function shouldn't be defined.
   */
  PIKEFUN int _sizeof()
    flags ID_PROTECTED|ID_OPTIONAL;
    prototype;
  {}

  /*! @decl optional protected void _random(function random_string, @
   *!                                       function random)
   *!
   *! If this function is defined then it sets the iterator to point
   *! to before a random item in the accessible set. The random
   *! distribution should be rectangular within that set, and the
   *! pseudorandom sequence provided by @[random] should be used.
   *!
   *! @seealso
   *!   @[random()]
   */
  PIKEFUN void _random(function rnd_str, function rnd)
    flags ID_PROTECTED|ID_OPTIONAL;
    prototype;
  {}

  /*! @decl optional int(0..1) first()
   *!
   *! If this function is defined then it resets the iterator to point
   *! to before the first item.
   *!
   *! @returns
   *!   Returns zero if there are no items at all in
   *!   the data set, one otherwise.
   *!
   *! @note
   *!   It's not enough to set the iterator to the earliest accessible
   *!   item. If the iterator doesn't support backing up to the
   *!   original start position then this function should not be
   *!   implemented.
   */
  PIKEFUN int(0..1) first()
    flags ID_OPTIONAL;
    prototype;
  {}

  /*! @decl protected mixed _iterator_next()
   *!
   *!   This function advances the iterator one step.
   *!
   *! @note
   *!   This is the only function that is required in the Pike 9.0
   *!   and later iterator API. Presence of this function indicates
   *!   that the iterator implements the Pike 9.0 API.
   *!
   *! @returns
   *!   Returns @expr{UNDEFINED@} if there are no more values in the set
   *!   of elements. It may return any other value if it succeeded in
   *!   advancing to a new element. The returned value is used as the
   *!   result for @[_iterator_index()] and @[_iterator_value()] if
   *!   they are not implemented.
   *!
   *! @seealso
   *!   @[_iterator_prev()], @[lfun::_iterator_next()], @[iterator_next()],
   *!   @[_iterator_index()], @[_iterator_value()]
   */
  PIKEFUN mixed _iterator_next()
    flags ID_PROTECTED;
    prototype;
  {}

  /*! @decl optional protected mixed _iterator_prev()
   *!
   *!   This function advances the iterator one step backwards.
   *!
   *! @returns
   *!   Returns @expr{UNDEFINED@} if there are no more values in the set
   *!   of elements. It may return any other value if it succeeded in
   *!   advancing to the previous element. The returned value may be used
   *!   as the result for @[_iterator_index()] and @[_iterator_value()] if
   *!   they are not implemented.
   *!
   *! @seealso
   *!   @[_iterator_next()], @[lfun::_iterator_prev()], @[iterator_prev()],
   *!   @[_iterator_index()], @[_iterator_value()]
   */
  PIKEFUN mixed _iterator_prev()
    flags ID_PROTECTED|ID_OPTIONAL;
    prototype;
  {}

  /*! @decl optional void set_index(zero index)
   *!
   *! If this function is defined it should set the iterator at
   *! the specified index.
   *!
   *! @note
   *!   It should be possible to set the index at the end of
   *!   the iterator.
   */
  PIKEFUN void set_index(zero index)
    flags ID_OPTIONAL;
    prototype;
  {}

  /*! @decl optional protected Iterator `+ (int steps)
   *!
   *! Returns a clone of this iterator which is advanced the specified
   *! number of steps. The amount may be negative to move backwards.
   *!
   *! If the iterator doesn't support backward movement it should
   *! throw an exception in that case.
   *!
   *! @seealso
   *!   @[_iterator_next], @[`-]
   */
  PIKEFUN Iterator `+(int steps)
    flags ID_PROTECTED|ID_OPTIONAL;
    prototype;
  {}

  /*! @decl optional protected Iterator `- (int steps)
   *!
   *! Returns a clone of this iterator which is backed up the specified
   *! number of steps. The amount may be negative to move forward.
   *!
   *! @seealso
   *!   @[_iterator_next], @[`+],
   */
  PIKEFUN int(0..1) `-(int steps)
    flags ID_PROTECTED|ID_OPTIONAL;
    prototype;
  {}
}

/*! @class CompatIterator
 *!
 *! Wrapper for iterators implementing the Pike 8.0 and
 *! earlier iterator API (@[8.0::Iterator]). Used transparently by
 *! @[predef::get_iterator()] to provide an iterator suitable
 *! for @[foreach()].
 *!
 *! @note
 *!   This class provides only those functions that are required
 *!   by the iterator API. It does not proxy any other functions.
 *!
 *! @seealso
 *!   @[get_iterator()], @[8.0::Iterator]
 */
PIKECLASS CompatIterator
{
  /*! @decl inherit Iterator
   */
  INHERIT Iterator;

  PIKEVAR object iter flags ID_PRIVATE;

  CVAR int count;

  /*! @decl void create(Iterator old_style_iterator)
   */
  PIKEFUN void create(object iter)
    flags ID_PROTECTED;
  {
    /* In the old API the following functions were required
     * (in order of use):
     *
     * `!(), next() or `+=(), index(), value()
     */
#define REQUIRE_LFUN(LFUN) do {				\
      if (FIND_LFUN(iter->prog, LFUN) < 0) {	\
        SIMPLE_BAD_ARG_ERROR("create", 1, "Iterator");	\
      }							\
    } while(0)
    REQUIRE_LFUN(LFUN_NOT);
    REQUIRE_LFUN(LFUN__ITERATOR_INDEX_FUN);
    REQUIRE_LFUN(LFUN__ITERATOR_VALUE_FUN);
    if ((FIND_LFUN(iter->prog, LFUN__ITERATOR_NEXT_FUN) < 0) &&
	(FIND_LFUN(iter->prog, LFUN_ADD_EQ) < 0)) {
      SIMPLE_BAD_ARG_ERROR("create", 1, "Iterator");
    }
    if (THIS->iter) {
      free_object(THIS->iter);
    }
    THIS->iter = iter;
    add_ref(THIS->iter);
    THIS->count = 0;
  }

  PIKEFUN mixed _iterator_next()
    flags ID_PROTECTED;
  {
    int fun;
    if (!THIS->iter || !THIS->iter->prog) {
      goto fail;
    }
    if (!THIS->count) {
      fun = FIND_LFUN(THIS->iter->prog, LFUN_NOT);
      apply_low(THIS->iter, fun, 0);
      if (!UNSAFE_IS_ZERO(Pike_sp-1)) {
	goto fail;
      }
      THIS->count++;
    } else {
      fun = FIND_LFUN(THIS->iter->prog, LFUN__ITERATOR_NEXT_FUN);
      if (fun < 0) {
	fun = FIND_LFUN(THIS->iter->prog, LFUN_ADD_EQ);
	push_int(1);
	apply_low(THIS->iter, fun, 1);
	pop_stack();
	fun = FIND_LFUN(THIS->iter->prog, LFUN_NOT);
	apply_low(THIS->iter, fun, 0);
	if (!UNSAFE_IS_ZERO(Pike_sp-1)) {
	  goto fail;
	}
      } else {
	apply_low(THIS->iter, fun, 0);
	if (UNSAFE_IS_ZERO(Pike_sp-1)) {
	  goto fail;
	}
      }
    }

    fun = FIND_LFUN(THIS->iter->prog, LFUN__ITERATOR_INDEX_FUN);
    apply_low(THIS->iter, fun, 0);
    return;

  fail:
    if (THIS->iter) {
      free_object(THIS->iter);
      THIS->iter = NULL;
    }
    push_undefined();
  }

  PIKEFUN mixed _iterator_index()
    flags ID_PROTECTED;
  {
    int fun;
    if (!THIS->iter || !THIS->iter->prog || !THIS->count) {
      push_undefined();
      return;
    }
    fun = FIND_LFUN(THIS->iter->prog, LFUN__ITERATOR_INDEX_FUN);
    apply_low(THIS->iter, fun, 0);
  }

  PIKEFUN mixed _iterator_value()
    flags ID_PROTECTED;
  {
    int fun;
    if (!THIS->iter || !THIS->iter->prog || !THIS->count) {
      push_undefined();
      return;
    }
    fun = FIND_LFUN(THIS->iter->prog, LFUN__ITERATOR_VALUE_FUN);
    apply_low(THIS->iter, fun, 0);
  }
}
/*! @endclass
 */

/* Calls the random(int) function of the top of the stack with the
   given range limit. */
static unsigned INT_TYPE call_random(unsigned INT_TYPE limit)
{
  unsigned INT_TYPE value;
  push_int(limit);
  apply_svalue(&Pike_sp[-2], 1);
  if( TYPEOF(Pike_sp[-1])!=T_INT )
    Pike_error("Wrong return type from random.\n");
  value = Pike_sp[-1].u.integer;
  if( value >= limit )
    Pike_error("random returned value out of bounds.\n");
  pop_stack();
  return value;
}

/*! @endclass
 */

/*! @module Function
 */
/*! @class Iterator
 *! @inherit predef::Iterator
 *!
 *!   An object of this class is returned by @[get_iterator()] when
 *!   called with a function.
 *!
 *! @seealso
 *!   @[get_iterator()]
 */
PIKECLASS function_iterator
  num_generics 1;
{
  /*! @decl __generic__ ValueType;
   */

  PIKEVAR function(:mixed) fun
    flags ID_PRIVATE;

  /*! @decl protected void create(function(:ValueType) fun)
   *!
   *!   Create an iterator that calls @[fun()] until
   *!   it returns @[UNDEFINED].
   */
  PIKEFUN void create(function(:mixed) fun)
    flags ID_PROTECTED;
    rawtype tFunc(tFunc(tNone, tFunctionIterValueType), tVoid);
  {
    assign_svalue(&THIS->fun, fun);
  }

  /*! @decl protected ValueType _iterator_next()
   *!
   *!   Call the wrapped function and return its result.
   */
  PIKEFUN mixed _iterator_next()
    flags ID_PROTECTED;
    rawtype tFunc(tNone, tFunctionIterValueType);
  {
    apply_svalue(&THIS->fun, 0);
  }
}
/*! @endclass
 */
/*! @endmodule
 */

/*! @module Mapping
 */
/*! @class Iterator
 *! @inherit predef::Iterator
 *!
 *!   An object of this class is returned by @[get_iterator()] when
 *!   called with a mapping.
 *!
 *! @seealso
 *!   @[get_iterator]
 */
PIKECLASS mapping_iterator
{
  /* All variables *must* be before all functions! */
  CVAR int bucket;
  CVAR struct mapping *m;
  CVAR struct mapping_data *md;
  CVAR struct keypair *current;

  PIKEFUN mixed _iterator_value()
    flags ID_PROTECTED;
    {
      if(THIS->current)
	push_svalue(& THIS->current->val);
      else
      {
	push_undefined();
      }
    }

  PIKEFUN mixed _iterator_index()
    flags ID_PROTECTED;
    {
      if(THIS->current)
	push_svalue(& THIS->current->ind);
      else
      {
	push_undefined();
      }
    }

  PIKEFUN mixed value()		/* Compat. */
    {
      if(THIS->current)
	push_svalue(& THIS->current->val);
      else
      {
	push_undefined();
      }
    }

  PIKEFUN mixed index()		/* Compat. */
    {
      if(THIS->current)
	push_svalue(& THIS->current->ind);
      else
      {
	push_undefined();
      }
    }

  PIKEFUN int _sizeof()
    flags ID_PROTECTED;
  {
    if (THIS->md) {
      push_int(THIS->md->size);
    } else
      push_int(0);
  }

#ifdef PIKE_MAPPING_KEYPAIR_LOOP
  static int mi_step(struct mapping_iterator_struct *i)
    {
      if (!i->md) {
	return 0;
      }

      if (++i->current >= i->md->free_list) {
	i->current = NULL;
	return 0;
      }

      return 1;
    }
#else /* !PIKE_MAPPING_KEYPAIR_LOOP */
  static int step_bucket(struct mapping_iterator_struct *i)
    {
      if (!i->md) {
	return 0;
      }

      do {
	while(!i->current)
	{
	  i->bucket++;
	  if(i->bucket >= i->md->hashsize) {
	    i->bucket = -1;
	    return 0;
	  }
	  i->current=i->md->hash[i->bucket];
	}
	if (!IS_DESTRUCTED (&i->current->ind)) break;
	i->current = i->current->next;
      } while (1);

      return 1;
    }

  static int mi_step(struct mapping_iterator_struct *i)
    {
      if (i->current) {
	i->current = i->current->next;
      }
      if (!i->current) {
	return step_bucket(i);
      }
      return 1;
    }
#endif /* PIKE_MAPPING_KEYPAIR_LOOP */

  PIKEFUN int first()
    {
      THIS->current = 0;
      THIS->bucket = -1;
      RETURN !!THIS->md->size;
    }

  /* Hubbe: Should this really be destructive ?? */
  PIKEFUN object _random(function rnd_str, function rnd)
    flags ID_PROTECTED;
    {
#ifdef PIKE_MAPPING_KEYPAIR_LOOP
      size_t k = call_random(THIS->md->size);
      THIS->current =
	k?(MD_KEYPAIRS(THIS->md, THIS->md->hashsize) + k - 1):0;
#else /* !PIKE_MAPPING_KEYPAIR_LOOP */
      THIS->current = 0;
      THIS->bucket = -1;
      if(THIS->md && THIS->md->hashsize)
      {
        int count = call_random(THIS->md->size);
	while (count--) {
	  mi_step(THIS);
	}
      }
#endif /* PIKE_MAPPING_KEYPAIR_LOOP */
      REF_RETURN Pike_fp->current_object;
    }

  PIKEFUN int _iterator_next()
    flags ID_PROTECTED;
  {
    RETURN mi_step(THIS);
  }
  PIKEFUN int next() { RETURN mi_step(THIS); }	/* Compat. */

  PIKEFUN void create(mapping map)
    flags ID_PROTECTED;
    {
      if(THIS->m)
	Pike_error("Mapping iterators cannot be reused.\n");

      add_ref(THIS->m=map);
      THIS->md=map->data;
      add_ref(THIS->md);
      THIS->md->valrefs++;
      THIS->current = NULL;
      THIS->bucket = -1;
      pop_stack();
    }

#ifdef PIKE_NULL_IS_SPECIAL
  INIT
    {
      THIS->m=0;
      THIS->md=0;
      THIS->current=0;
      THIS->bucket=0;
    }
#endif

  EXIT
    gc_trivial;
    {
      if (THIS->md) {
	THIS->md->valrefs--;
	free_mapping_data(THIS->md);
      }
      if (THIS->m) {
	free_mapping(THIS->m);
      }
    }
};
/*! @endclass
 */
/*! @endmodule
 */


/*! @module Array
 */
/*! @class Iterator
 *! @inherit predef::Iterator
 *!
 *!   An object of this class is returned by @[get_iterator()] when
 *!   called with an array.
 *!
 *! @seealso
 *!   @[get_iterator]
 */
PIKECLASS array_iterator
{
  CVAR int pos;
  CVAR struct array *a;

  PIKEFUN mixed _iterator_value()
    flags ID_PROTECTED;
    {
      if(!THIS->a || THIS->pos < 0 || THIS->pos >= THIS->a->size)
      {
	push_undefined();
      }else{
	push_svalue(THIS->a->item + THIS->pos);
      }
    }

  PIKEFUN int _iterator_index()
    flags ID_PROTECTED;
    {
      if(!THIS->a || THIS->pos < 0 || THIS->pos >= THIS->a->size)
      {
	push_undefined();
      }else{
	RETURN THIS->pos;
      }
    }

  PIKEFUN mixed value()		/* Compat. */
    {
      if(!THIS->a || THIS->pos < 0 || THIS->pos >= THIS->a->size)
      {
	push_undefined();
      }else{
	push_svalue(THIS->a->item + THIS->pos);
      }
    }

  PIKEFUN int index()		/* Compat. */
    {
      if(!THIS->a || THIS->pos < 0 || THIS->pos >= THIS->a->size)
      {
	push_undefined();
      }else{
	RETURN THIS->pos;
      }
    }

  PIKEFUN int _sizeof()
    flags ID_PROTECTED;
  {
    if (THIS->a) {
      push_int(THIS->a->size);
    }
    else
      push_int(0);
  }

  PIKEFUN int first()
    {
      THIS->pos = -1;
      RETURN THIS->a && THIS->a->size;
    }

  PIKEFUN void set_index(int pos)
    {
      if(!THIS->a || pos < 0 || pos > THIS->a->size)
      {
	Pike_error("Bad position.\n");
      }else{
	THIS->pos = pos;
      }
    }

  /* Hubbe: Should this really be destructive ?? */
  PIKEFUN object _random(function rnd_str, function rnd)
    flags ID_PROTECTED;
    {
      if(THIS->a && THIS->a->size)
        THIS->pos = call_random(THIS->a->size) - 1;
      else
	THIS->pos = -1;
      REF_RETURN Pike_fp->current_object;
    }

  PIKEFUN int _iterator_next()
    flags ID_PROTECTED;
    {
      THIS->pos++;
      RETURN THIS->a && THIS->pos >= 0 && THIS->pos < THIS->a->size;
    }

  PIKEFUN int next()		/* Compat. */
    {
      THIS->pos++;
      RETURN THIS->a && THIS->pos >= 0 && THIS->pos < THIS->a->size;
    }

  PIKEFUN void create(array a)
    flags ID_PROTECTED;
    {
      if(THIS->a)
	Pike_error("Array iterators cannot be reused.\n");

      add_ref(THIS->a=a);
      THIS->pos = -1;
      pop_stack();
    }

#ifdef PIKE_NULL_IS_SPECIAL
  INIT
    {
      THIS->a=0;
      THIS->pos=0;
    }
#endif

  EXIT
    gc_trivial;
    {
      if (THIS->a)
	free_array(THIS->a);
    }

};

/*! @endclass
 */
/*! @endmodule
 */

/*! @module Multiset
 */
/*! @class Iterator
 *! @inherit predef::Iterator
 *!
 *!   An object of this class is returned by @[get_iterator()] when
 *!   called with a multiset.
 *!
 *! @seealso
 *!   @[get_iterator]
 */
PIKECLASS multiset_iterator
{
  CVAR struct multiset *l;
  CVAR int lock_index;
  CVAR ptrdiff_t nodepos;

  PIKEFUN int _iterator_value()
    flags ID_PROTECTED;
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      if (THIS->nodepos < 0 || msnode_is_deleted (THIS->l, THIS->nodepos))
	push_undefined();
      else
	push_multiset_value (THIS->l, THIS->nodepos);
    }

  PIKEFUN mixed _iterator_index()
    flags ID_PROTECTED;
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      if (THIS->nodepos < 0 || msnode_is_deleted (THIS->l, THIS->nodepos))
	push_undefined();
      else
	push_multiset_index (THIS->l, THIS->nodepos);
    }

  PIKEFUN int value()		/* Compat. */
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      if (THIS->nodepos < 0 || msnode_is_deleted (THIS->l, THIS->nodepos))
	push_undefined();
      else
	push_multiset_value (THIS->l, THIS->nodepos);
    }

  PIKEFUN mixed index()		/* Compat. */
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      if (THIS->nodepos < 0 || msnode_is_deleted (THIS->l, THIS->nodepos))
	push_undefined();
      else
	push_multiset_index (THIS->l, THIS->nodepos);
    }

  PIKEFUN int _sizeof()
    flags ID_PROTECTED;
  {
    if (THIS->l) {
      push_int(THIS->l->msd->size);
    }
    else
      push_int(0);
  }

  static struct object *li_copy (struct multiset_iterator_struct *li)
    {
      struct object *o = low_clone (multiset_iterator_program);
      struct multiset_iterator_struct *copy = OBJ2_MULTISET_ITERATOR (o);
      if (!(copy->l = li->l))
	return o;
      add_ref(copy->l);
      if ((copy->nodepos = li->nodepos) >= 0) add_msnode_ref (copy->l);
      if ((copy->lock_index = li->lock_index)) {
	add_ref (copy->l->msd);
	copy->l->msd->noval_refs++;
      }
      return o;
    }

  static void li_step (struct multiset_iterator_struct *li, int steps)
    {
      ptrdiff_t newpos = li->nodepos;

      if (li->nodepos < 0) return;

      if (steps > 0)
	do {
	  newpos = multiset_next (li->l, newpos);
	  if (newpos < 0) {
	    sub_msnode_ref (li->l);
	    break;
	  }
	} while (--steps);
      else if (steps < 0)
	do {
	  newpos = multiset_prev (li->l, newpos);
	  if (newpos < 0) {
	    sub_msnode_ref (li->l);
	    break;
	  }
	} while (++steps);

      li->nodepos = newpos;
    }

  PIKEFUN object `+= (int steps)
    flags ID_PROTECTED;
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      li_step (THIS, steps);
      REF_RETURN Pike_fp->current_object;
    }

  PIKEFUN object `+ (int steps)
    flags ID_PROTECTED;
    {
      struct object *o;
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      o = li_copy (THIS);
      li_step (OBJ2_MULTISET_ITERATOR (o), steps);
      RETURN o;
    }

  PIKEFUN object `- (int steps)
    flags ID_PROTECTED;
    {
      struct object *o;
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      o = li_copy (THIS);
      li_step (OBJ2_MULTISET_ITERATOR (o), -steps);
      RETURN o;
    }

  PIKEFUN int first()
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      if (THIS->nodepos >= 0) sub_msnode_ref (THIS->l);
      THIS->nodepos = multiset_first (THIS->l);
      RETURN THIS->nodepos >= 0;
    }

  PIKEFUN int _iterator_next()
    flags ID_PROTECTED;
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      if (THIS->nodepos < 0) {
	THIS->nodepos = multiset_first(THIS->l);
	if (THIS->nodepos >= 0) RETURN 1;
      } else {
	THIS->nodepos = multiset_next (THIS->l, THIS->nodepos);
	if (THIS->nodepos >= 0) RETURN 1;
	sub_msnode_ref (THIS->l);
      }
      RETURN 0;
    }

  PIKEFUN int next()		/* Compat. */
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      if (THIS->nodepos < 0) {
	THIS->nodepos = multiset_first(THIS->l);
	if (THIS->nodepos >= 0) RETURN 1;
      } else {
	THIS->nodepos = multiset_next (THIS->l, THIS->nodepos);
	if (THIS->nodepos >= 0) RETURN 1;
	sub_msnode_ref (THIS->l);
      }
      RETURN 0;
    }

  /* Hubbe: Should this really be destructive ??
   * I let this question stand; I'm only adapting multiset_iterator. /mast */
  PIKEFUN object _random(function rnd_str, function rnd)
    flags ID_PROTECTED;
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      if (THIS->nodepos >= 0) {
	sub_msnode_ref (THIS->l);
	THIS->nodepos = -1;
      }
      if (!multiset_is_empty (THIS->l)) {
	int count = call_random(multiset_sizeof (THIS->l));
	THIS->nodepos =
          count?multiset_get_nth (THIS->l, count - 1):-1;
      }
      REF_RETURN Pike_fp->current_object;
    }

  PIKEFUN void lock_index()
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      if (!THIS->lock_index) {
	add_ref (THIS->l->msd);
	THIS->l->msd->noval_refs++;
	THIS->lock_index = 1;
      }
    }

  PIKEFUN void unlock_index()
    {
      if (!THIS->l) Pike_error ("Iterator not initialized.\n");
      if (THIS->lock_index) {
	THIS->l->msd->noval_refs--;
	sub_ref (THIS->l->msd);
#ifdef PIKE_DEBUG
	if (THIS->l->msd->refs <= 0) Pike_fatal ("msd ran out of refs unexpectedly.\n");
#endif
	THIS->lock_index = 0;
      }
    }

  /* FIXME: Add more functions, e.g. insert, delete, add. */

  /* FIXME: Maybe the index should be locked when the iterator is used
   * in foreach, to behave more like the mapping iterator. */

  PIKEFUN void create (multiset l)
    flags ID_PROTECTED;
    {
      if (THIS->l) Pike_error ("Multiset iterators cannot be reused.\n");
      add_ref (THIS->l = l);
      THIS->lock_index = 0;
      THIS->nodepos = -1;
      pop_stack();
    }

#ifdef PIKE_NULL_IS_SPECIAL
  INIT
    {
      THIS->l = NULL;
    }
#endif

  EXIT
    gc_trivial;
    {
      if (THIS->l) {
	if (THIS->nodepos >= 0) sub_msnode_ref (THIS->l);
	if (THIS->lock_index) {
	  THIS->l->msd->noval_refs--;
	  sub_ref (THIS->l->msd);
#ifdef PIKE_DEBUG
	  if (THIS->l->msd->refs <= 0) Pike_fatal ("msd ran out of refs unexpectedly.\n");
#endif
	}
	free_multiset (THIS->l);
      }
    }
};

/*! @endclass
 */
/*! @endmodule
 */

/*! @module String
 */
/*! @class Iterator
 *! @inherit predef::Iterator
 *!
 *!   An object of this class is returned by @[get_iterator()] when
 *!   called with a string.
 *!
 *! @seealso
 *!   @[get_iterator]
 */
PIKECLASS string_iterator
{
  CVAR int pos;
  CVAR struct pike_string *s;

  PIKEFUN int _iterator_value()
    flags ID_PROTECTED;
    {
      if(!THIS->s || THIS->pos < 0 || THIS->pos >= THIS->s->len)
      {
	push_undefined();
      }else{
	RETURN index_shared_string(THIS->s, THIS->pos);
      }
    }

  PIKEFUN int _iterator_index()
    flags ID_PROTECTED;
    {
      if(!THIS->s || THIS->pos < 0 || THIS->pos >= THIS->s->len)
      {
	push_undefined();
      }else{
	RETURN THIS->pos;
      }
    }

  PIKEFUN int value()		/* Compat. */
    {
      if(!THIS->s || THIS->pos < 0 || THIS->pos >= THIS->s->len)
      {
	push_undefined();
      }else{
	RETURN index_shared_string(THIS->s, THIS->pos);
      }
    }

  PIKEFUN int index()		/* Compat. */
    {
      if(!THIS->s || THIS->pos < 0 || THIS->pos >= THIS->s->len)
      {
	push_undefined();
      }else{
	RETURN THIS->pos;
      }
    }

  PIKEFUN int _sizeof()
    flags ID_PROTECTED;
  {
    if (THIS->s) {
      push_int(THIS->s->len);
    }
    else
      push_int(0);
  }

  PIKEFUN int first()
    {
      THIS->pos = -1;
      RETURN THIS->s && THIS->s->len;
    }

  PIKEFUN void set_index(int pos)
    {
      if (!THIS->s || pos < 0 || pos > THIS->s->len) {
	Pike_error("Bad position.\n");
      }
      THIS->pos = pos;
    }

  /* Hubbe: Should this really be destructive ?? */
  PIKEFUN object _random(function rnd_str, function rnd)
    flags ID_PROTECTED;
    {
      if(THIS->s->len)
        THIS->pos = call_random(THIS->s->len) - 1;
      else
	THIS->pos = -1;
      REF_RETURN Pike_fp->current_object;
    }

  PIKEFUN int _iterator_next()
    flags ID_PROTECTED;
    {
      THIS->pos++;
      RETURN THIS->s && THIS->pos >= 0 && THIS->pos < THIS->s->len;
    }

  PIKEFUN int next()		/* Compat. */
    {
      THIS->pos++;
      RETURN THIS->s && THIS->pos >= 0 && THIS->pos < THIS->s->len;
    }

  PIKEFUN int _search(string|int needle, int|void start)
    flags ID_PROTECTED;
    {
      if (!THIS->s)
	Pike_error("No data to search.\n");
      ref_push_string(THIS->s);
      push_svalue(needle);
      if (start) push_svalue(start);
      else push_int(THIS->pos);
      f_search(3);
      stack_pop_n_elems_keep_top(args);
      /* Advance to the found position. */
      if (TYPEOF(Pike_sp[-1]) == T_INT) {
	if (Pike_sp[-1].u.integer >= 0) {
	  THIS->pos = Pike_sp[-1].u.integer;
	} else {
	  THIS->pos = THIS->s->len;
	}
      }
    }

  PIKEFUN void create(string s)
    flags ID_PROTECTED;
    {
      if(THIS->s)
	Pike_error("String iterators cannot be reused.\n");

      add_ref(THIS->s=s);
      THIS->pos = -1;
      pop_stack();
    }

#ifdef PIKE_NULL_IS_SPECIAL
  INIT
    {
      THIS->s=0;
      THIS->pos=0;
    }
#endif

  EXIT
    gc_trivial;
    {
      if (THIS->s)
	free_string(THIS->s);
    }
};

/*! @endclass
 */
/*! @endmodule
 */

/* Internal (for Stdio.File) class: Stdio.File->line_iterator.
 * Splits on lines, does only handle 8-bit characters.
 */
PIKECLASS file_line_iterator
{
  CVAR struct pike_string *buffer;
  CVAR struct pike_string *current;
  CVAR int offset;
  CVAR int index;
  CVAR struct svalue feed;


  static void fl_find_next(struct file_line_iterator_struct *ssi)
  {
    unsigned char *ptr, *eptr, *start;
    int start_off = ssi->offset;

    if (ssi->current)
    {
      free_string(ssi->current);
      ssi->current = NULL;
    }

    if (!ssi->buffer)
      return;

  again:
      start = (unsigned char*)ssi->buffer->str + start_off;
      ptr   = (unsigned char*)ssi->buffer->str + ssi->offset;
      eptr  = (unsigned char*)ssi->buffer->str + ssi->buffer->len;

      /* Loop until we find a '\n'. */
      while( ptr < eptr )
	if( *ptr != '\n'  )
	  ptr++;
	else
	{
	  ssi->current = make_shared_binary_string( (char*)start, ptr-start );
	  // skip the '\n'
	  ssi->offset =  ptr - ((unsigned char *)ssi->buffer->str) + 1;
	  ssi->index++;
	  return;
	}

      apply_svalue( &ssi->feed, 0 );
      if( TYPEOF(Pike_sp[-1]) == PIKE_T_STRING &&
	  Pike_sp[-1].u.string->len )
      {
	push_string(make_shared_binary_string( ssi->buffer->str+start_off,
					       ssi->buffer->len-start_off));
	free_string( ssi->buffer );
	stack_swap();
	f_add( 2 );
	ssi->buffer = Pike_sp[-1].u.string;
	dmalloc_touch_svalue(Pike_sp-1);
	Pike_sp--;

	if( !ssi->buffer->size_shift )
	{
	  ssi->offset -= start_off;
	  start_off = 0;
	  goto again;
	}
	// Wide string.
      }
      else {
	// End of stream.
	pop_stack();
	if (start != ptr) {
	  ssi->current = make_shared_binary_string((char*)start, ptr-start);
	  ssi->index++;
	}
      }
      free_string( ssi->buffer );
      ssi->buffer = NULL;
      return;
   }

  PIKEFUN string _iterator_value()
    flags ID_PROTECTED;
    {
      if (THIS->current) {
	ref_push_string(THIS->current);
      } else {
	push_undefined();
      }
    }

  PIKEFUN int _iterator_index()
    flags ID_PROTECTED;
    {
      if (!THIS->current) {
	push_undefined();
      }else{
	RETURN THIS->index;
      }
    }

  PIKEFUN string value()	/* Compat. */
    {
      if (THIS->current) {
	ref_push_string(THIS->current);
      } else {
	push_undefined();
      }
    }

  PIKEFUN int index()		/* Compat. */
    {
      if (!THIS->current) {
	push_undefined();
      }else{
	RETURN THIS->index;
      }
    }

  PIKEFUN int _iterator_next()
    flags ID_PROTECTED;
    {
      fl_find_next(THIS);
      RETURN !!THIS->current;
    }

  PIKEFUN int next()		/* Compat. */
    {
      fl_find_next(THIS);
      RETURN !!THIS->current;
    }

  PIKEFUN void create(function(:string) feed)
    flags ID_PROTECTED;
    {
      if (THIS->buffer) {
	Pike_error("iterators cannot be reused.\n");
      }
      assign_svalue( &THIS->feed, feed );
      apply_svalue( &THIS->feed, 0 );
      if( TYPEOF(Pike_sp[-1]) != PIKE_T_STRING )
	Pike_error("Feed function returned illegal value\n");
      THIS->buffer = Pike_sp[-1].u.string;
      dmalloc_touch_svalue(Pike_sp-1);
      Pike_sp--;
      THIS->offset = 0;
      THIS->current = NULL;
      THIS->index = -1;
      pop_stack();
    }

  INIT
    {
#ifdef PIKE_NULL_IS_SPECIAL
      THIS->buffer = NULL;
      THIS->current = NULL;
      THIS->offset = 0;
      THIS->index = 0;
#endif
      mark_free_svalue (&THIS->feed);
    }

  EXIT
    gc_trivial;
    {
      if (THIS->buffer)
	free_string(THIS->buffer);
      if (THIS->current)
	free_string(THIS->current);
      free_svalue(&THIS->feed);
      assert_free_svalue (&THIS->feed);
    }
}

/*! @module String
 */

/*! @class SplitIterator(<string StringType>)
 *! @inherit predef::Iterator
 *!
 *! An iterator that iterates over substrings of a string, separated
 *! by a character or several different characters.
 *!
 *! @note
 *!   Typically you don't need to explicitly use the @[SplitIterator].
 *!   Expressions like the following are automatically optimized into
 *!   using a @[SplitIterator].
 *!   @code
 *!     foreach(str/"\n", string line)
 *!       write("%s\n", line);
 *!   @endcode
 */
PIKECLASS string_split_iterator
  num_generics 1;
{
  CVAR struct pike_string *buffer;
  CVAR struct pike_string *current;
  CVAR int offset;
  CVAR int index;
  CVAR p_wchar2 *split_set;
  CVAR int split_set_size;
  CVAR int flags;
  CVAR struct svalue feed;

  EXTRA
  {
    /* __generic__ string StringType; */
    ref_push_type_value(string_type_string);
    f_aggregate(1);
    add_constant(lfun_strings[LFUN___GENERIC_TYPES__],
                 Pike_sp - 1,
                 ID_PRIVATE|ID_PROTECTED|ID_LOCAL|ID_USED);
    /* add_ref(Pike_compiler->generic_types = Pike_sp[-1].u.array); */
    pop_stack();
  }

#define SIMPLE_SKIP(THIS, SHIFT, OFF) 	 	\
  do {						\
    PIKE_CONCAT(p_wchar, SHIFT) *s = 		\
      PIKE_CONCAT(STR,SHIFT)(THIS->buffer);	\
    while((OFF < THIS->buffer->len) &&		\
          s[OFF] == THIS->split_set[0]) {	\
      OFF++;					\
    }						\
  } while(0)

#define SIMPLE_SKIP_CASE(THIS, SHIFT, OFF)	\
  case SHIFT:					\
    SIMPLE_SKIP(THIS, SHIFT, OFF);		\
    break

#define COMPLEX_SKIP(THIS, SHIFT, OFF)	 		\
  do {							\
    PIKE_CONCAT(p_wchar, SHIFT) *s = 			\
      PIKE_CONCAT(STR,SHIFT)(THIS->buffer);		\
    while(OFF < THIS->buffer->len) {			\
      int i;						\
      p_wchar2 ch = s[OFF];				\
      for (i=0; i < THIS->split_set_size; i++) {	\
	if (ch == THIS->split_set[i]) {			\
	  goto PIKE_CONCAT(continue_skip,SHIFT);	\
	}						\
      }							\
      break;						\
    PIKE_CONCAT(continue_skip,SHIFT):			\
      OFF++;						\
    }							\
  } while(0)

#define COMPLEX_SKIP_CASE(THIS, SHIFT, OFF)	\
  case SHIFT:					\
    COMPLEX_SKIP(THIS, SHIFT, OFF);		\
    break

#define SIMPLE_SCAN(THIS, SHIFT, OFF)		\
  do {						\
    PIKE_CONCAT(p_wchar, SHIFT) *s = 		\
      PIKE_CONCAT(STR,SHIFT)(THIS->buffer);	\
    while((OFF < THIS->buffer->len) &&		\
          s[OFF] != THIS->split_set[0]) {	\
      OFF++;					\
    }						\
  } while(0)

#define SIMPLE_SCAN_CASE(THIS, SHIFT, OFF)	\
  case SHIFT:					\
    SIMPLE_SCAN(THIS, SHIFT, OFF);		\
    break

#define COMPLEX_SCAN(THIS, SHIFT, OFF)				\
  do {								\
    PIKE_CONCAT(p_wchar, SHIFT) *s = 				\
      PIKE_CONCAT(STR,SHIFT)(THIS->buffer);			\
    while(OFF < THIS->buffer->len) {				\
      int i;							\
      p_wchar2 ch = s[OFF];					\
      for (i=0; i < THIS->split_set_size; i++) {		\
	if (ch == THIS->split_set[i]) {				\
	  goto PIKE_CONCAT(break_scan,SHIFT);			\
	}							\
      }								\
      OFF++;							\
    }								\
  PIKE_CONCAT(break_scan, SHIFT): ;/* gcc complains without ;*/ \
  } while(0)

#define COMPLEX_SCAN_CASE(THIS, SHIFT, OFF)	\
  case SHIFT:					\
    COMPLEX_SCAN(THIS, SHIFT, OFF);		\
    break

#define SIMPLE_SCAN_PUSH(THIS, SHIFT, OFF)			\
  do {								\
    PIKE_CONCAT(p_wchar, SHIFT) *s = 				\
      PIKE_CONCAT(STR,SHIFT)(THIS->buffer);			\
    while((OFF < THIS->buffer->len) &&				\
          s[OFF] != THIS->split_set[0]) {			\
      OFF++;							\
    }								\
    push_string(PIKE_CONCAT(make_shared_binary_string, SHIFT)	\
      (s+offset, OFF-offset));					\
  } while(0)

#define COMPLEX_SCAN_PUSH(THIS, SHIFT, OFF)				\
  do {									\
    PIKE_CONCAT(p_wchar, SHIFT) *s = 					\
      PIKE_CONCAT(STR,SHIFT)(THIS->buffer);				\
    while(OFF < THIS->buffer->len) {					\
      int i;								\
      p_wchar2 ch = s[OFF];						\
      for (i=0; i < THIS->split_set_size; i++) {			\
	if (ch == THIS->split_set[i]) {					\
	  push_string(PIKE_CONCAT(make_shared_binary_string, SHIFT)	\
	    (s+offset, OFF-offset));					\
	  goto PIKE_CONCAT(break_scan,SHIFT);				\
	}								\
      }									\
      OFF++;								\
    }									\
    push_string(PIKE_CONCAT(make_shared_binary_string, SHIFT)		\
      (s+offset, OFF-offset));						\
  PIKE_CONCAT(break_scan, SHIFT):					\
    ;									\
  } while(0)

#define NEW_SKIP_CASE(SHIFT, FLAGS)				\
  case SHIFT:							\
    if (FLAGS) {						\
      /* Skip empty */						\
      if (ssi->split_set_size == 1) {				\
	SIMPLE_SKIP(ssi, SHIFT, offset);			\
      } else {							\
        COMPLEX_SKIP(ssi, SHIFT, offset);			\
      }								\
    }								\
    if (offset >= ssi->buffer->len) {				\
      free_string(ssi->buffer);					\
      ssi->buffer = NULL;					\
      ssi->offset = 0;						\
      offset = 0;						\
      if (TYPEOF(ssi->feed) == PIKE_T_FREE) {			\
	if (!(FLAGS)) {						\
	  copy_shared_string(ssi->current, empty_pike_string);	\
	  ssi->index++;						\
	}							\
	return;							\
      } else {							\
	/* Attempt to fill the buffer with some more. */	\
	apply_svalue(&ssi->feed, 0);				\
	if ((TYPEOF(Pike_sp[-1]) == T_STRING) &&		\
	    (Pike_sp[-1].u.string->len)) {			\
	  ssi->buffer = Pike_sp[-1].u.string;			\
          dmalloc_touch_svalue(Pike_sp-1);			\
	  Pike_sp--;						\
	  goto reskip_empty;					\
	}							\
	free_svalue(&ssi->feed);				\
	mark_free_svalue (&ssi->feed);				\
	pop_stack();						\
	if (!(FLAGS)) {						\
	  copy_shared_string(ssi->current, empty_pike_string);	\
	  ssi->index++;						\
	}							\
	return;							\
      }								\
    }								\
    ssi->index++;						\
    end = offset;						\
    goto PIKE_CONCAT(scan_more_,SHIFT)

#define NEW_SCAN_MORE_CASE(SHIFT)				\
  case SHIFT:							\
  PIKE_CONCAT(scan_more_,SHIFT):				\
    if (ssi->split_set_size == 1) {				\
      SIMPLE_SCAN_PUSH(ssi, SHIFT, end);			\
    } else {							\
      COMPLEX_SCAN_PUSH(ssi, SHIFT, end);			\
    }								\
    if ((end == ssi->buffer->len) &&				\
	(TYPEOF(ssi->feed) != PIKE_T_FREE)) {			\
      apply_svalue(&ssi->feed, 0);				\
      if ((TYPEOF(Pike_sp[-1]) == T_STRING) &&			\
	  (Pike_sp[-1].u.string->len)) {			\
	f_add(2);						\
	if (TYPEOF(Pike_sp[-1]) != T_STRING) {			\
	  Pike_error("Bad result from concatenation!\n");	\
	}							\
	free_string(ssi->buffer);				\
	ssi->buffer = Pike_sp[-1].u.string;			\
        dmalloc_touch_svalue(Pike_sp-1);			\
	Pike_sp--;						\
	end -= offset;						\
	offset = 0;						\
	goto scan_more;						\
      }								\
      pop_stack();	/* Pop the end of stream marker. */	\
      								\
      /* Make sure we don't call feed() any more. */		\
      free_svalue(&ssi->feed);					\
      mark_free_svalue (&ssi->feed);				\
    }								\
    ssi->offset = end+1;					\
    ssi->current = Pike_sp[-1].u.string;			\
    dmalloc_touch_svalue(Pike_sp-1);				\
    Pike_sp--;							\
    if (ssi->offset > ssi->buffer->len) {			\
      free_string(ssi->buffer);					\
      ssi->buffer = 0;						\
    }								\
    break

  static void find_next(struct string_split_iterator_struct *ssi)
    {
      int offset = ssi->offset;
      int end = 0;
      if (ssi->current) {
	free_string(ssi->current);
      }
      ssi->current = NULL;
      if (!ssi->buffer) {
	return;
      }
    reskip_empty:
      switch(ssi->buffer->size_shift) {
        NEW_SKIP_CASE(0, ssi->flags);
	NEW_SKIP_CASE(1, ssi->flags);
	NEW_SKIP_CASE(2, ssi->flags);
      }
    scan_more:
      switch(ssi->buffer->size_shift)
      {
	NEW_SCAN_MORE_CASE(0);
	NEW_SCAN_MORE_CASE(1);
	NEW_SCAN_MORE_CASE(2);
      }
    }

  PIKEFUN string _iterator_value()
    flags ID_PROTECTED;
    rawtype tFunc(tNone, tOr(tZero, tStringSplitIterValueType));
    {
      if (THIS->current) {
	ref_push_string(THIS->current);
      } else {
	push_undefined();
      }
    }

  PIKEFUN int _iterator_index()
    flags ID_PROTECTED;
    {
      if (!THIS->current) {
	push_undefined();
      }else{
	RETURN THIS->index;
      }
    }

  PIKEFUN string value()	/* Compat. */
    rawtype tFunc(tNone, tOr(tZero, tStringSplitIterValueType));
    {
      if (THIS->current) {
	ref_push_string(THIS->current);
      } else {
	push_undefined();
      }
    }

  PIKEFUN int index()		/* Compat. */
    {
      if (!THIS->current) {
	push_undefined();
      }else{
	RETURN THIS->index;
      }
    }

  PIKEFUN int _iterator_next()
    flags ID_PROTECTED;
    {
      find_next(THIS);
      RETURN !!THIS->current;
    }

  PIKEFUN int next()		/* Compat. */
    {
      find_next(THIS);
      RETURN !!THIS->current;
    }

  PIKEFUN int `!()
    flags ID_PROTECTED;
    {
      RETURN !THIS->current;
    }

  PIKEFUN int _sizeof()
    flags ID_PROTECTED;
  {
    INT_TYPE res = 0;
    if (THIS->buffer) {
      int i, off;
      ref_push_string(THIS->buffer);
      if (THIS->offset) {
	push_int(THIS->offset);
	push_int(THIS->buffer->len);
	o_range();
      }
      for (i = 1; TYPEOF(THIS->feed) != PIKE_T_FREE; i++) {
	apply_svalue(&THIS->feed, 0);
	if ((TYPEOF(Pike_sp[-1]) != T_STRING) ||
	    (!Pike_sp[-1].u.string->len)) {
	  /* End of stream marker. */
	  pop_stack();
	  free_svalue(&THIS->feed);
	  mark_free_svalue (&THIS->feed);
	  break;
	}
      }
      f_add(i);	/* Join the segments. */
      free_string(THIS->buffer);
      THIS->buffer = Pike_sp[-1].u.string;
      THIS->offset = 0;
      dmalloc_touch_svalue(Pike_sp-1);
      Pike_sp--;

      /* Perform the scan. */
      for (off=0; off < THIS->buffer->len; off++) {
	if (THIS->flags) {
	  if (THIS->split_set_size == 1) {
	    switch(THIS->buffer->size_shift) {
	      SIMPLE_SKIP_CASE(THIS, 0, off);
	      SIMPLE_SKIP_CASE(THIS, 1, off);
	      SIMPLE_SKIP_CASE(THIS, 2, off);
            }
	  } else {
	    switch(THIS->buffer->size_shift) {
	      COMPLEX_SKIP_CASE(THIS, 0, off);
	      COMPLEX_SKIP_CASE(THIS, 1, off);
	      COMPLEX_SKIP_CASE(THIS, 2, off);
            }
	  }
	  if (off >= THIS->buffer->len) {
	    break;
	  }
	}
	res++;
	if (THIS->split_set_size == 1) {
	  switch(THIS->buffer->size_shift) {
	    SIMPLE_SCAN_CASE(THIS, 0, off);
	    SIMPLE_SCAN_CASE(THIS, 1, off);
	    SIMPLE_SCAN_CASE(THIS, 2, off);
          }
	} else {
	  switch(THIS->buffer->size_shift) {
	    COMPLEX_SCAN_CASE(THIS, 0, off);
	    COMPLEX_SCAN_CASE(THIS, 1, off);
	    COMPLEX_SCAN_CASE(THIS, 2, off);
          }
	}
      }
      if ((!THIS->flags) && (off == THIS->buffer->len)) {
	/* Ends with an empty segment. */
	res++;
      }
    }
    if (THIS->current) {
      res++;
    }
    RETURN res;
  }

  /*! @decl void create(StringType buffer, @
   *!                   int|array(int)|multiset(int) split_set,@
   *!                   int|void flags, function(:StringType|zero)|void feed)
   *! @param buffer
   *!   The string to split.
   *! @param split_set
   *!   The character or characters to split on.
   *! @param flags
   *!   Skip empty elements if set.
   *! @param feed
   *!   Callback function that is called once the @[buffer] is used up
   *!   and the SplitIterator wants more data.
   */
  PIKEFUN void create(string buffer, int|array(int)|multiset(int) split_set,
                      int|void flags, function(:string|zero)|void feed)
    flags ID_PROTECTED;
    rawtype tFunc(tStringSplitIterValueType
                  tOr3(tInt,tArr(tInt),tSet(tInt))
                  tOr(tInt, tVoid)
                  tOr(tFunc(tNone, tOr(tStringSplitIterValueType, tZero)),
                      tVoid), tVoid);
    {
      if (THIS->buffer) {
	Pike_error("String.split() iterators cannot be reused.\n");
      }
      if (TYPEOF(*split_set) == T_INT) {
	THIS->split_set = (p_wchar2 *)xalloc(sizeof(p_wchar2));
	THIS->split_set[0] = split_set->u.integer;
	THIS->split_set_size = 1;
      } else {
	struct array *a;
	int i;
	if (TYPEOF(*split_set) == T_ARRAY) {
	  a = split_set->u.array;
	} else if (TYPEOF(*split_set) == T_MULTISET) {
	  a = multiset_indices (split_set->u.multiset);
	  push_array (a);
	} else {
	  SIMPLE_ARG_TYPE_ERROR("create", 2,
                                "int|array(int)|multiset(int)");
	}
	if (!a->size) {
	  SIMPLE_ARG_TYPE_ERROR("create", 2,
                                "int|array(int)|multiset(int)");
	}
	for (i=0; i < a->size; i++) {
	  if (TYPEOF(a->item[i]) != T_INT) {
	    SIMPLE_ARG_TYPE_ERROR("create", 2,
                                  "int|array(int)|multiset(int)");
	  }
	}
	THIS->split_set = (p_wchar2 *)xalloc(a->size * sizeof(p_wchar2));
	for (i=0; i < a->size; i++) {
	  THIS->split_set[i] = a->item[i].u.integer;
	}
	THIS->split_set_size = a->size;
	if (TYPEOF(*split_set) == T_MULTISET) pop_stack();
      }
      add_ref(THIS->buffer = buffer);
      if (args > 2) {
	if (flags && (TYPEOF(*flags) == T_INT)) {
	  THIS->flags = flags->u.integer;
	} else {
	  THIS->flags = 0;
	}
	if (feed) {
	  assign_svalue(&THIS->feed, feed);
	} else {
	  /* NB: THIS->feed has already been set to PIKE_T_FREE by the
	   * init code. */
	}
      } else {
	THIS->flags = 0;
      }
      THIS->offset = 0;
      THIS->current = NULL;
      THIS->index = -1;
      pop_n_elems(args);
    }

  INIT
    {
#ifdef PIKE_NULL_IS_SPECIAL
      THIS->buffer = NULL;
      THIS->current = NULL;
      THIS->offset = 0;
      THIS->index = 0;
      THIS->split_set = NULL;
      THIS->split_set_size = 0;
      THIS->flags = 0;
#endif
      mark_free_svalue (&THIS->feed);
    }

  EXIT
    gc_trivial;
    {
      if (THIS->buffer)
	free_string(THIS->buffer);
      if (THIS->current)
	free_string(THIS->current);
      free(THIS->split_set);
      free_svalue(&THIS->feed);
      mark_free_svalue (&THIS->feed);
    }

  OPTIMIZE
    {
      if (CDR(n) && (CDR(n)->token == F_ARG_LIST) &&
	  CADR(n) && (CADR(n)->token == F_APPLY) &&
	  CAADR(n) && (CAADR(n)->token == F_CONSTANT) &&
	  (TYPEOF(CAADR(n)->u.sval) == T_FUNCTION) &&
	  (SUBTYPEOF(CAADR(n)->u.sval) == FUNCTION_BUILTIN) &&
	  (CAADR(n)->u.sval.u.efun->function == f_replace)) {
	/* String.SplitIterator(replace(...),...) */
	node *repl_args = CDADR(n);
	node **str = my_get_arg(&repl_args, 0);
	node **from = my_get_arg(&repl_args, 1);
	node **to = my_get_arg(&repl_args, 2);

	if (str && from && to) {
	  /* String.SplitIterator(replace(str, from, to), ...) */

	  int num;

	  if (((*to)->token == F_APPLY) &&
	      CAR(*to) && (CAR(*to)->token == F_CONSTANT) &&
	      (TYPEOF(CAR(*to)->u.sval) == T_FUNCTION) &&
	      (SUBTYPEOF(CAR(*to)->u.sval) == FUNCTION_BUILTIN) &&
	      (CAR(*to)->u.sval.u.efun->function == f_allocate) &&
	      CDR(*to) && (CDR(*to)->token == F_ARG_LIST) &&
	      CADR(*to) && (CADR(*to)->token == F_CONSTANT) &&
	      (TYPEOF(CADR(*to)->u.sval) == T_INT) &&
	      (num = CADR(*to)->u.sval.u.integer) &&
	      CDDR(*to) && (CDDR(*to)->token == F_CONSTANT) &&
	      (TYPEOF(CDDR(*to)->u.sval) == T_STRING) &&
	      (CDDR(*to)->u.sval.u.string->len == 1)) {
	    /* String.SplitIterator(replace(str, from, allocate(num, "x")),
	     *                      ...) */
	    int split_val = index_shared_string(CDDR(*to)->u.sval.u.string, 0);

	    if (CDDR(n) &&
		(((CDDR(n)->token == F_CONSTANT) &&
		  (TYPEOF(CDDR(n)->u.sval) == T_INT) &&
		  (CDDR(n)->u.sval.u.integer == split_val)) ||
		 ((CDDR(n)->token == F_ARG_LIST) &&
		  CADDR(n) && (CADDR(n)->token == F_CONSTANT) &&
		  (TYPEOF(CADDR(n)->u.sval) == T_INT) &&
		  (CADDR(n)->u.sval.u.integer == split_val)))) {
	      /* String.SplitIterator(replace(str, from, allocate(n, "x")),
	       *                      'x', ...)
	       */
	      struct array *split = NULL;
	      node *res = NULL;

	      switch((*from)->token) {
	      case F_CONSTANT:
		if ((TYPEOF((*from)->u.sval) == T_ARRAY) &&
		    ((*from)->u.sval.u.array->size == num)) {
		  int i;
		  for (i=0; i < num; i++) {
		    if ((TYPEOF((*from)->u.sval.u.array->item[i]) != T_STRING) ||
			((*from)->u.sval.u.array->item[i].u.string->len != 1)) {
		      return NULL;
		    }
		  }
		  split = allocate_array(num+1);
		  split->item[0].u.integer = split_val;
		  for (i=0; i < num; i++) {
		    split->item[i+1].u.integer =
		      index_shared_string((*from)->u.sval.u.array->
					  item[i].u.string, 0);
		  }
		  split->type_field = BIT_INT;
		}
		break;
	      case F_APPLY:
		if (CAR(*from) && (CAR(*from)->token == F_CONSTANT) &&
		    (TYPEOF(CAR(*from)->u.sval) == T_FUNCTION) &&
		    (SUBTYPEOF(CAR(*from)->u.sval) == FUNCTION_BUILTIN)) {
		  if (CAR(*from)->u.sval.u.efun->function == f_allocate) {
		    /* FIXME: Not likely */
		  } else if (CAR(*from)->u.sval.u.efun->function ==
			     debug_f_aggregate) {
		    node *tmp = CDR(*from);
		    int i;
		    for (i = 0; tmp && (tmp->token == F_ARG_LIST);
			 tmp = CDR(tmp)) {
		      if (!CAR(tmp)) continue;
		      if ((CAR(tmp)->token != F_CONSTANT) ||
			  (TYPEOF(CAR(tmp)->u.sval) != T_STRING) ||
			  (CAR(tmp)->u.sval.u.string->len != 1)) {
			return NULL;
		      }
		      i++;
		    }
		    if (i != num) {
		      return NULL;
		    }
		    split = allocate_array(num+1);
		    split->item[0].u.integer = split_val;
		    tmp = CDR(*from);
		    for (i = 1; tmp && (tmp->token == F_ARG_LIST);
			 tmp = CDR(tmp)) {
		      if (!CAR(tmp)) continue;
		      split->item[i].u.integer =
			index_shared_string(CAR(tmp)->u.sval.u.string, 0);
		      i++;
		    }
		    split->type_field = BIT_INT;
		  }
		} else {
		  return NULL;
		}
		break;
	      default:
		return NULL;
	      }
	      if (!split) {
		return NULL;
	      }
	      push_array(split);	/* Simplify error-handling... */

	      /* Create the result...
	       *
	       * String.SplitIterator(str, split, ...)
	       */
	      if (CDDR(n)->token == F_ARG_LIST) {
		ADD_NODE_REF2(CAR(n),
		ADD_NODE_REF2(*str,
		ADD_NODE_REF2(CDDDR(n),
		  res =
		    mkapplynode(CAR(n),
			        mknode(F_ARG_LIST, *str,
				       mknode(F_ARG_LIST,
					      mkconstantsvaluenode(Pike_sp-1),
					      CDDDR(n))));
		)));
	      } else {
		ADD_NODE_REF2(CAR(n),
		ADD_NODE_REF2(*str,
		  res =
		    mkapplynode(CAR(n),
			        mknode(F_ARG_LIST, *str,
				       mkconstantsvaluenode(Pike_sp-1)));
		));
	      }
	      pop_stack();
	      return res;
	    }
	  }
	}
      }
      return NULL;
    }
};

/*! @endclass
 */

/*! @endmodule
 */

/*! @decl Iterator get_iterator (function|object|array|mapping|multiset|string data, @
 *!                              mixed ... args)
 *!
 *! Creates and returns a canonical iterator for @[data].
 *!
 *! @returns
 *!   @mixed data
 *!     @type object
 *!       If @[data] is an object with @[lfun::_get_iterator] defined then that
 *!       function will be called with the arguments @[args] to create the iterator.
 *!
 *!       If @[data] is an object that lacks @[lfun::_get_iterator] then
 *!       it is assumed to already be an iterator object. In this case
 *!       @[args] will be ignored (note this behavior may be changed).
 *!
 *!       The iterator object is then checked whether it has
 *!       @[lfun::_iterator_next()] in which case it will simply be returned.
 *!       Otherwise an attempt to wrap it in a @[CompatIterator] will be performed.
 *!     @type array
 *!       If @[data] is an array, an @[Array.Iterator] object will be
 *!       returned.
 *!     @type function
 *!       If @[data] is a function, a @[Function.Iterator] object will be
 *!       returned.
 *!     @type mapping
 *!       If @[data] is a mapping, a @[Mapping.Iterator] object will be
 *!       returned
 *!     @type multiset
 *!       If @[data] is a multiset, a @[Multiset.Iterator] object will be
 *!       returned
 *!     @type string
 *!       If @[data] is a string, a @[String.Iterator] object will be
 *!       returned
 *!   @endmixed
 *!
 *! @note
 *!   This function is used by @[foreach] to get an iterator for an
 *!   object.
 *!
 *! @seealso
 *!   @[Iterator], @[lfun::_get_iterator]
 */
PIKEFUN object(Iterator) get_iterator(function|object|array|mapping|multiset|string data,
				      mixed ... extra)
  efun;
{
  if (extra && (TYPEOF(*data) != PIKE_T_OBJECT)) {
    SIMPLE_WRONG_NUM_ARGS_ERROR("get_iterator", 1);
  }
  switch(TYPEOF(*data))
  {
    case PIKE_T_FUNCTION:
      pop_n_elems(args - 1);
      push_object(clone_object(function_iterator_program, 1));
      return;

    case PIKE_T_STRING:
      pop_n_elems(args - 1);
      push_object(clone_object(string_iterator_program, 1));
      return;

    case PIKE_T_MAPPING:
      pop_n_elems(args - 1);
      push_object(clone_object(mapping_iterator_program,1));
      return;

    case PIKE_T_MULTISET:
      pop_n_elems(args - 1);
      push_object(clone_object(multiset_iterator_program, 1));
      return;

    case PIKE_T_ARRAY:
      pop_n_elems(args - 1);
      push_object(clone_object(array_iterator_program, 1));
      return;

    case PIKE_T_OBJECT: {
      int fun;
      struct program *p;

      if(!(p = data->u.object->prog))
	SIMPLE_ARG_ERROR ("get_iterator", 1, "Got a destructed object.\n");

      fun = FIND_LFUN(p->inherits[SUBTYPEOF(*data)].prog, LFUN__GET_ITERATOR);
      if (fun != -1)
      {
	apply_low(data->u.object,
		  fun + p->inherits[SUBTYPEOF(*data)].identifier_level, args-1);
        args = 1;

	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  /* FIXME: Ought to include what we got in the error message. */
	  pop_stack();
	  SIMPLE_ARG_ERROR ("get_iterator", 1,
			    "_get_iterator() didn't return an object.\n");
	}
	stack_pop_keep_top();

        /* We've received an iterator object.
         *
         * Now we need to check if it needs a compat wrapper.
         */
        data = Pike_sp-1;
        p = data->u.object->prog;
      } else if (args > 1) {
        /* FIXME: Should we throw an error here instead? */
        pop_n_elems(args-1);
      }

      /* Check if data is an iterator object implementing the new API. */
      fun = FIND_LFUN(p->inherits[SUBTYPEOF(*data)].prog,
		      LFUN__ITERATOR_NEXT_FUN);
      if ((fun >= 0) &&
	  (ID_FROM_INT(p->inherits[SUBTYPEOF(*data)].prog, fun)->name ==
	   lfun_strings[LFUN__ITERATOR_NEXT_FUN])) {
	/* Assume it already is an iterator... */
	return;
      }

      /* Assume an old-style iterator. */
      push_object(clone_object(CompatIterator_program, 1));
      return;
    }

    default:
      SIMPLE_ARG_TYPE_ERROR("get_iterator", 1,
                            "function|multiset|array|string|mapping|object");
  }
}

/* Pike_sp[-4] = index; Pike_sp[-2] = value
 *
 * FIXME: Ought to get the inherit number as an argument.
 */
int foreach_iterate(struct object *o)
{
  struct program *prog = o->prog;
  int fun;

  if(!prog)
    Pike_error("foreach on destructed iterator.\n");

  if(prog->flags & PROGRAM_HAS_C_METHODS)
  {
    if(prog == function_iterator_program) {
      struct function_iterator_struct *i = OBJ2_FUNCTION_ITERATOR(o);

      if (IS_UNDEFINED(&(i->fun))) {
        return 0;
      }

      apply_svalue(&(i->fun), 0);

      pike_fprintf(stderr, "ret: %pO\n", Pike_sp-1);

      if (IS_UNDEFINED(Pike_sp-1)) {
        /* Terminate. */
        free_svalue(&(i->fun));
        SET_SVAL(i->fun, PIKE_T_INT, NUMBER_UNDEFINED, integer, 0);
        pop_stack();
        return 0;
      }

      if(TYPEOF(Pike_sp[-5]) != T_INT) {
        /* Index. */
        assign_lvalue(Pike_sp-5, Pike_sp-1);
      }

      if(TYPEOF(Pike_sp[-3]) != T_INT) {
        /* Value. */
        assign_lvalue(Pike_sp-3, Pike_sp-1);
      }

      pop_stack();
      return 1;
    }

    else if(prog == mapping_iterator_program)
    {
      struct mapping_iterator_struct *i=OBJ2_MAPPING_ITERATOR(o);

      if (!i->current) {
#ifdef PIKE_MAPPING_KEYPAIR_LOOP
	i->current = MD_KEYPAIRS(THIS->md, THIS->md->hashsize);
	if (i->current >= i->md->free_list) {
	  i->current = 0;
	  return 0;
	}
#else /* !PIKE_MAPPING_KEYPAIR_LOOP */
	i->bucket = -1;
	if (!step_bucket(i)) {
	  return 0;
	}
#endif /* PIKE_MAPPING_KEYPAIR_LOOP */
      } else {
#ifdef PIKE_MAPPING_KEYPAIR_LOOP
	if (++i->current >= i->md->free_list) {
	  i->current = 0;
	  return 0;
	}
#else /* !PIKE_MAPPING_KEYPAIR_LOOP */
	mi_step (i);
	if (!i->current) return 0;
#endif /* PIKE_MAPPING_KEYPAIR_LOOP */
      }

      if(TYPEOF(Pike_sp[-4]) != T_INT)
	assign_lvalue(Pike_sp-4, & i->current->ind);

      if(TYPEOF(Pike_sp[-2]) != T_INT)
	assign_lvalue(Pike_sp-2, & i->current->val);

      return 1;
    }

    else if(prog == string_split_iterator_program)
    {
      struct string_split_iterator_struct *i=OBJ2_STRING_SPLIT_ITERATOR(o);

      find_next(i);
      if (!i->current) {
	i->offset = 0;
	i->index = -1;
	return 0;
      }

      if(TYPEOF(Pike_sp[-4]) != T_INT)
      {
	/* Black Magic... */
	push_int(i->index);
	Pike_sp--;
	assign_lvalue(Pike_sp-4, Pike_sp);
      }

      if(TYPEOF(Pike_sp[-2]) != T_INT)
      {
	/* Black Magic... */
	push_string(i->current);
	dmalloc_touch_svalue(Pike_sp-1);
	Pike_sp--;
	assign_lvalue(Pike_sp-2, Pike_sp);
      }

      return 1;
    }

    else if(prog == file_line_iterator_program)
    {
      struct file_line_iterator_struct *i=OBJ2_FILE_LINE_ITERATOR(o);

      fl_find_next (i);
      if (!i->current) {
	i->offset = 0;
	i->index = -1;
	return 0;
      }

      if(TYPEOF(Pike_sp[-4]) != T_INT)
      {
	/* Black Magic... */
	push_int(i->index);
	Pike_sp--;
	assign_lvalue(Pike_sp-4, Pike_sp);
      }

      if(TYPEOF(Pike_sp[-2]) != T_INT)
      {
	/* Black Magic... */
	push_string(i->current);
	dmalloc_touch_svalue(Pike_sp-1);
	Pike_sp--;
	assign_lvalue(Pike_sp-2, Pike_sp);
      }

      return 1;
    }

    else if(prog == array_iterator_program)
    {
      struct array_iterator_struct *i=OBJ2_ARRAY_ITERATOR(o);

      if (++i->pos >= i->a->size) {
	i->pos = -1;
	return 0;
      }

      if(TYPEOF(Pike_sp[-4]) != T_INT)
      {
	push_int(i->pos);
	assign_lvalue(Pike_sp-5, Pike_sp-1);
	pop_stack();
      }

      if(TYPEOF(Pike_sp[-2]) != T_INT)
	assign_lvalue(Pike_sp-2, i->a->item + i->pos);

      return 1;
    }

    else if(prog == multiset_iterator_program)
    {
      struct multiset_iterator_struct *i=OBJ2_MULTISET_ITERATOR(o);

      struct svalue ind;

      if (i->nodepos < 0) {
	i->nodepos = multiset_first(i->l);
	if (i->nodepos < 0) {
	  /* NB: multiset_first() does not add a ref on failure. */
	  return 0;
	}
      } else {
	i->nodepos = multiset_next (i->l, i->nodepos);

	if (i->nodepos < 0) {
	  /* Release the reference that we've held since multiset_first(). */
	  sub_msnode_ref (i->l);
	  return 0;
	}
      }

      if (TYPEOF(Pike_sp[-4]) != T_INT)
	assign_lvalue (Pike_sp - 4, use_multiset_index (i->l, i->nodepos, ind));
      if (TYPEOF(Pike_sp[-2]) != T_INT)
	assign_lvalue (Pike_sp - 2, get_multiset_value (i->l, i->nodepos));

      return 1;
    }

    else if(prog == string_iterator_program)
    {
      struct string_iterator_struct *i=OBJ2_STRING_ITERATOR(o);

      if (++i->pos >= i->s->len) {
	i->pos = -1;
	return 0;
      }

      if(TYPEOF(Pike_sp[-4]) != T_INT)
      {
	push_int(i->pos);
	assign_lvalue(Pike_sp-5, Pike_sp-1);
	pop_stack();
      }

      if(TYPEOF(Pike_sp[-2]) != T_INT)
      {
	push_int(index_shared_string(i->s, i->pos));
	assign_lvalue(Pike_sp-3, Pike_sp-1);
	pop_stack();
      }

      return 1;
    }
  }

  /* Generic iteration */

  if ((fun = FIND_LFUN(prog, LFUN__ITERATOR_NEXT_FUN)) < 0) {
    Pike_error("Iterator object lacks lfun::_iterator_next().\n");
  }

  /* NOTE: _iterator_next() returns UNDEFINED on failure, and
   *       anything else is regarded as success. That value
   *       can thus often be used in place of the return value
   *       from _iterator_index() and/or _iterator_value(),
   *       which means that they are both optional to implement.
   */
  apply_low(o, fun, 0);
  if(IS_UNDEFINED(Pike_sp-1))
  {
    pop_stack();
    return 0;
  }

  if(TYPEOF(Pike_sp[-5]) != T_INT)
  {
    fun = FIND_LFUN(prog, LFUN__ITERATOR_INDEX_FUN);
    if (fun >= 0) {
      apply_low(o, fun, 0);
      assign_lvalue(Pike_sp-6, Pike_sp-1);
      pop_stack();
    } else {
      /* NB: Use return value from _iterator_next() above. */
      assign_lvalue(Pike_sp-5, Pike_sp-1);
    }
  }

  if(TYPEOF(Pike_sp[-3]) != T_INT)
  {
    fun = FIND_LFUN(prog, LFUN__ITERATOR_VALUE_FUN);
    if (fun >= 0) {
      apply_low(o, fun, 0);
      assign_lvalue(Pike_sp-4, Pike_sp-1);
      pop_stack();
    } else {
      /* NB: Use return value from _iterator_next() above. */
      assign_lvalue(Pike_sp-3, Pike_sp-1);
    }
  }

  pop_stack();	/* Pop return value from _iterator_next(). */

  return 1;
}


void init_iterators(void)
{
  INIT;
  add_global_program ("Iterator", Iterator_program);
  add_global_program ("CompatIterator", CompatIterator_program);
}

void exit_iterators(void)
{
  EXIT
}

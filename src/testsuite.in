START_MARKER
test_true([["$Id: testsuite.in,v 1.729 2004/05/27 19:03:21 mast Exp $"]]);

// This triggered a bug only if run sufficiently early.
test_compile_any([[#pike 7.2]])
test_compile_any([[#pike 7.4]])
test_compile_any([[#pike 7.0]])
test_compile_any([[#pike 0.6]])

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]]);
test_eq(1e1,10.0);
test_eq(1E1,10.0);
test_eq(1e+1,10.0);
test_eq(1.1e1,11.0);
test_eq(1e-1,0.1);
test_eq('\x20',32);
test_eq("\x20","\040");
test_eq("\d32","\x20");
test_eq('Å',"Å"[0]);
test_eq('\7777',"\7777"[0]);
test_eq('\77777777',"\77777777"[0]);
test_eq("\x10000","\x10000");
test_eq(0x80000000-0x80000000, 0);
test_eq(0xf0000000-0xf0000000, 0);
test_eq(0x80000001-0x80000000, 1);
test_eq(0x80000000-0x80000001,-1);
test_eq(-2147483648*-1, -2147483648/-1);
cond([[ 0x8000000000000000 ]],
[[
  test_eq(0x8000000000000000-0x8000000000000000, 0);
  test_eq(0xf000000000000000-0xf000000000000000, 0);
  test_eq(0x8000000000000001-0x8000000000000000, 1);
  test_eq(0x8000000000000000-0x8000000000000001,-1);
  test_eq(-9223372036854775808*-1, -9223372036854775808/-1);
]])
test_true([[1.0e-40]]);
test_eq([[#"foo
bar"]],[["foo\nbar"]]);
test_eq([[#"foo\
bar"]],[["foobar"]]);
test_true([[stringp(#string "Makefile")]]);
test_any([[class Bar { array(int) foo = ({}); };
	   class Foo { inherit Bar; array(int) foo = ({1}); };
	   return sizeof(Foo()->foo);]],1);

test_eq(8, 0b1000);
test_eq(-8, -0b1000);
test_eq(16, 0b10000);
test_eq(-16, -0b10000);

test_true(1e-100000000000000000000000000000000000000000000000000000000000<=1e-10000)
test_true(1e-10000<=1e-1000)
test_true(1e-1000<=1e-100)
test_true(1e-100<=1e-10)
test_true(1e-10<=1e-1)
test_true(1e-1<=1e1)
test_true(1e1<=1e10)
test_true(1e10<=1e100)
test_true(1e100<=1e1000)
test_true(1e1000<=1e10000)
test_true(1e10000<=1e100000000000000000000000000000000000000000000000000000000000)

test_do([[
  // bug 2677
  int x;
  if (time())
    x = 1;
  else
    foo: break foo;
]])

test_any([[
  // bug 2690
  array(function) foo(void|int b)
  {
    int add() { return b++; };
    return ({ add, add });
  };
  array(function) bar = foo();
  return equal(({`==(@bar),@bar()}), ({ 1, 0, 1 }));
]], 1)

test_any([[
  int f (int i) {i = 0; return i;};
  return f (1);
]],0)

test_any([[
  // Test that F_TAIL_RECUR and RECUR work properly.
  class X
  {
    int Ack(int M, int N) {
      if (M == 0) return( N + 1 );
      if (N == 0) return( Ack(M - 1, 1) );
      return( Ack(M - 1, Ack(M, (N - 1))) );
    }
  };

  return X()->Ack(3,5);
]],253)

test_any([[
  // Test that F_COND_RECUR works properly.
  // This test forces F_COND_RECUR to fail.
  class X
  {
    int Ack(int M, int N) {
      if (M == 0) return( N + 1 );
      if (N == 0) return( Ack(M - 1, 1) );
      return( Ack(M - 1, Ack(M, (N - 1))) );
    }
  };

  class Y { inherit X;
    int Ack(int M, int N) { return ::Ack(M, N); }
  };

  return Y()->Ack(2,2);
]],7)

test_any([[
  // Test that loop optimizer isn't too aggressive.
  // Thanks to Alexander Demenshin <aldem-pike@aldem.net>
  int x,y,a;
  for(;x<10000;x++) {
    y += (x - a++);
  }
  return a;
]], 10000)

test_any([[
  // Test that loop optimizer isn't too aggressive.
  // Thanks to Alexander Demenshin <aldem-pike@aldem.net>
  mapping m = ([]);
  for(;m->x<10000;m->x++) {
    m->y += (m->x - m->a++);
  }
  return m->a;
]], 10000)

test_any([[
  // Test that loop optimizer isn't too aggressive.
  // Thanks to me.  / Marcus
  for(int i=0; i<3.0; i++)
    if(i>4.0)
      return -1;
  return 0;
]], 0)

test_any([[
  // Test that optimizer notes side effects in arguments to `!=
  // Thanks to Marcus Agehall
  int j = 20, i;
  string end = "17";
  for( ; i < j ; i++)
    if(sscanf(end, "%d%s", j, end) != 2)
      cd(".");
  return i;
]], 17)

test_any([[
  // Another over-optimization test.
  string x(string i) { return i; };
  return x("")+1+1;
]], "11")

test_compile_any([[
  void foo() 
  {
    Stdio.File bar(int x, int y)
    { 
      return 0;
    }; 
  } 
]])

test_compile_any([[
  string foo (string a, string b, string c, string d, string e, string f, string g)
  {
    string out;
    if (a)
      out = "foo";
    else
      out = "bar";
    return out;
  }
]])


dnl FIXME: Add test that local and local:: in combination
dnl        with recursion works correctly.

test_eval_error([[mixed x; return mkmapping(x,x)]]);

test_eval_error([[class Foo {
  void bar() {}
  void foo() {destruct(this_object());bar();}
};
  Foo()->foo();
]])

test_do([[
  void foo (int i) {
    multiset res = (<>);
    if (i) res = res;
  };
  foo (1);
]])

test_any([[
  array tmp=({});
  tmp=({([])})+tmp;
  tmp->foo=7;
  tmp=({([])})+tmp;
  return sizeof(tmp[0]);
]], 0)


test_any([[int a=0xffffffff; return a+17]], 0x100000010);
test_any([[int a=0xffffffff; return a-17]], 0xffffffee);
test_any([[int a=0xffffffff; return a*17]], 0x10ffffffef);
test_any([[int a=0xffffffff; return a^17]], 0xffffffee);
test_any([[int a=0xffffffff; return a&17]], 17);
test_any([[int a=0xffffffff; return a|17]], 0xffffffff);
test_any([[int a=0xffffffff; return a<<17]], 0x1fffffffe0000);

test_any([[ int a=0xffffffff; return a/17 ]],
	 [[ (0xffffffff == -1)?-1:0x0f0f0f0f ]]);
test_any([[ int a=0xffffffff; return a%17 ]],
	 [[ (0xffffffff == -1)?16:0 ]]);
test_any([[ int a=0xffffffff; return a>>17 ]],
	 [[ (0xffffffff == -1)?-1:0x7fff ]]);

test_any([[return sprintf("%O", typeof(aggregate("foo")));]], "array(string)");
test_any([[int a; return sprintf("%O", typeof(aggregate(a)));]], "array(int)");
test_any([[int|string a;
	   string s = sprintf("%O", typeof(aggregate(a)));
	   return (< "array(string | int)", "array(int | string)" >)[s];]], 1);
test_any([[return sprintf("%O", typeof(aggregate()));]], "array(zero)");
test_any([[int i; return (< "int", "int | zero", "zero | int" >)
                          [sprintf("%O", typeof(max(i,0)))];]], 1)

test_any([[array(string) a; return sprintf("%O", typeof(a[0])); ]], "string")

test_any([[class foo { string a; };
	   object(foo) bar;
	   return sprintf("%O", typeof(bar->a));]], "string");

test_any([[class foo { string a; };
	   array(object(foo)) bar;
	   return sprintf("%O", typeof(bar[0]->a));]], "string");

test_any([[function(:string)|function(int:int) f;
	   return sprintf("%O", typeof(f())); ]],
	 "string")

test_any([[function(:string)|function(int:int) f;
	   return sprintf("%O", typeof(f(1))); ]],
	 "int")

test_any([[function(:string)|function(mixed, mixed...:int) f;
	  return sprintf("%O", typeof(f())); ]],
	 "string")

test_any([[function(:string)|function(mixed, mixed ...:int) f;
	  return sprintf("%O", typeof(f(1))); ]],
	 "int")

test_any([[mapping(object:string)|mapping(string:int) f;
	  return sprintf("%O", typeof(f[class{}()])); ]],
	 "string")

test_any([[mapping(object:string)|mapping(string:int) f;
	  return sprintf("%O", typeof(f[""])); ]],
	 "int")

test_any([[mapping(object:string)|mapping(string:int) f;
	  return sort((sprintf("%O", typeof(f[0])) - " ")/"|")*"|"; ]],
	 "int|string")

test_any([[class Foo { string `[](mixed y) {return "";} };
	  object(Foo) foo;
	  return sprintf("%O", typeof(foo[0])); ]],
	 "string")

test_any([[class Foo { array(int) _indices() {return ({0});} };
	  object(Foo) foo;
	  return sprintf("%O", typeof(indices(foo))); ]],
	 "array(int)")

test_any([[class Foo { array(string) _values() {return ({""});} };
	  object(Foo) foo;
	  return sprintf("%O", typeof(values(foo))); ]],
	 "array(string)")

test_any([[mapping(string:int) foo;
	  array(string) bar;
	  return sprintf("%O", typeof(rows(foo, bar))); ]],
	 "array(int)")

test_any([[{
  class Foo
  {
    mixed m;
  };
  class Bar
  {
    inherit Foo;
    string m;
    Foo b;
    mixed f() {
      return typeof(b->m);
    }
  };
  Foo c;
  Bar d;
  return sprintf("%O$%O$%O$%O",
                 Bar()->f(), typeof(c->m), typeof(d->m), typeof(d->b->m));
}]], "mixed$mixed$string$mixed")

// las.c:find_return_type() checks.
test_eq([[
  // Test case from Robert J. Budzynski <Robert.Budzynski@fuw.edu.pl>.
  // When broken the return type will be mixed.
  sprintf("%O", typeof(lambda(string s){
    return Locale.Charset.decoder("utf-8")->feed(s)->drain();
  }))
]], [[ "function(string : string)" ]])

// Argument checking

// Test get_all_args.
test_eval_error([[
  // A trick to get some svalues to freed refcounted stuff on the stack.
  lambda (mixed a, mixed b, mixed c) {} (({time()}), ({time()}), ({time()}));
  // set_weak_flag is chosen since it calls get_all_args with an
  // argument spec that contains two arguments of different types.
  ([function] set_weak_flag)();
]])
test_eval_error([[
  lambda (mixed a, mixed b, mixed c) {} (({time()}), ({time()}), ({time()}));
  ([function] set_weak_flag) (17);
]])
test_eval_error([[
  lambda (mixed a, mixed b, mixed c) {} (({time()}), ({time()}), ({time()}));
  ([function] set_weak_flag) ("foo");
]])
test_eval_error([[
  lambda (mixed a, mixed b, mixed c) {} (({time()}), ({time()}), ({time()}));
  ([function] set_weak_flag) (17, "foo");
]])

// type checks

define(test_type_error, [[
   test_compile_error([[ $1 x; x=$3; ]])
   test_compile_error_any([[ class ErrBa { $1 x() { return $3; } } ]])
   test_compile_error_any([[ class ErrBa { $1 x() { $2 a=$3; return a; } } ]])
]])

test_type_error(int,float,17.23)
test_type_error(int,array,({1,2,3}))
test_type_error(int,mapping,([1:2,3:4]))
test_type_error(int,multiset,(<1,2,3>))
test_type_error(int,function,lambda() { return 17; })
test_type_error(int,program,object_program(this_object()))
test_type_error(int,object,this_object())

test_type_error(float,int,17)
test_type_error(float,array,({1,2,3}))
test_type_error(float,mapping,([1:2,3:4]))
test_type_error(float,multiset,(<1,2,3>))
test_type_error(float,function,lambda() { return 17; })
test_type_error(float,program,object_program(this_object()))
test_type_error(float,object,this_object())

test_type_error(array,int,17)
test_type_error(array,float,17.23)
test_type_error(array,mapping,([1:2,3:4]))
test_type_error(array,multiset,(<1,2,3>))
test_type_error(array,function,lambda() { return 17; })
test_type_error(array,program,object_program(this_object()))
test_type_error(array,object,this_object())

test_type_error(mapping,int,17)
test_type_error(mapping,float,17.23)
test_type_error(mapping,array,({1,2,3}))
test_type_error(mapping,multiset,(<1,2,3>))
test_type_error(mapping,function,lambda() { return 17; })
test_type_error(mapping,program,object_program(this_object()))
test_type_error(mapping,object,this_object())

test_type_error(multiset,int,17)
test_type_error(multiset,float,17.23)
test_type_error(multiset,array,({1,2,3}))
test_type_error(multiset,mapping,([1:2,3:4]))
test_type_error(multiset,function,lambda() { return 17; })
test_type_error(multiset,program,object_program(this_object()))
test_type_error(multiset,object,this_object())

test_type_error(function,int,17)
test_type_error(function,float,17.23)
test_type_error(function,array,({1,2,3}))
test_type_error(function,mapping,([1:2,3:4]))
test_type_error(function,multiset,(<1,2,3>))

test_type_error(program,int,17)
test_type_error(program,float,17.23)
test_type_error(program,array,({1,2,3}))
test_type_error(program,mapping,([1:2,3:4]))
test_type_error(program,multiset,(<1,2,3>))

test_type_error(object,int,17)
test_type_error(object,float,17.23)
test_type_error(object,array,({1,2,3}))
test_type_error(object,mapping,([1:2,3:4]))
test_type_error(object,multiset,(<1,2,3>))

test_compile_error([[ string a="abcb"; a=a/"b"; ]])
test_compile_error([[ string a="abcb"; a/="b"; ]])
test_compile_error([[ string a="abcb"; string b="b"; a=a/b; ]])
test_compile_error([[ string a="abcb"; string b="b"; a/=b; ]])
test_compile_error([[ string a="x"; int b; b="x"*17; ]])
test_compile_error([[ string a="x"; array b; b="x"*17; ]])
test_compile_error([[ int b=17; string a; a=b*42; ]])
test_compile_error([[ int b=17; float c=42.0; b=b/c; ]])
test_compile_error([[ int b=17; float c=42.0; b/=c; ]])
test_compile_error([[ int b=17; float c=42.0; b=b*c; ]])
test_compile_error([[ int b=17; float c=42.0; b*=c; ]])
test_compile_error([[ int b=17; float c=42.0; b=b+c; ]])
test_compile_error([[ int b=17; float c=42.0; b+=c; ]])
test_compile_error([[ int b=17; float c=42.0; b=b-c; ]])
test_compile_error([[ int b=17; float c=42.0; b-=c; ]])
test_compile_error([[ float b=17.0; string a; a=b*42; ]])
test_compile_error([[ float b=17.0; string a; a=b*42.0; ]])

test_compile_error([[class F {inherit master()->dirnode;};]]);

// Warnings

test_compile_warning([[ int *a ]])
test_compile_warning([[ int|float *a ]])
test_compile_warning([[ [mixed]1 ]])
test_compile_warning([[
 class A { int a = 6; };
 class B {
   constant a = 5;
   inherit A;
 };
]])

//

test_any([[
  class Foo {
    constant zero = 0;
    mapping(string:array(int)) m;
    string foo() { return sprintf("%O", typeof(m[""][zero])); }
  };
  return Foo()->foo();
]], "int")

test_compile_any([[
  class { ; }
]])

test_compile_any([[
  class { ; ; }
]])

test_compile_any([[
  class { ; constant c = 0; }
]])

test_compile_any([[
  class { void a() {  constant c = 17; }
	  void b() {  constant c = 17; }  }
]])

test_compile_any([[
  constant FOO = 0;
  mapping(int:string) foo = ([FOO: "foo"]);
]])

test_compile_error([[
  function(...:int) foo;
]]);

test_compile_error([[
  function(,...:int) foo;
]]);

test_compile_error([[
  function(string,...:int) foo;
]]);

test_any([[return class Z {
string bonk() { return "oiff"; }

class A
{
  string bonk_me() { return bonk(); }
}

class B { inherit A; }

class C
{
  string oiff() { return "bonk"; }
  class D { inherit B; }
}
}()->C()->D()->bonk_me()]],"oiff")

test_compile_error([[
 class A { constant q = "x"; }
 class B { inherit A; string z="z"; constant q="x"+z; }
]])

test_compile_any([[
  class A
  {
     object x(int y)
     {
        return B(y);
     }
  }
  
  class B
  {
     void create(int y)
     {
     }
  }
]])

// Test that prototypes evaluate to zero.
test_any([[
  class Foo {int foo();};
  return Foo()->foo == 0;
]], 1)
test_any_equal([[
  class Foo {int foo();};
  return indices(Foo());
]], ({"foo"}))
test_any_equal([[
  class Foo {int foo();};
  return values(Foo());
]], ({0}))
test_any([[
  class Foo
  {
    int foo();
    int(0..1) f()
    {
      return foo == 0;
    }
  };
  return Foo()->f();
]], 1)
test_any([[
  class Foo
  {
    int foo();
    int(0..1) f()
    {
      return functionp(foo);
    }
  };
  class Bar
  {
    inherit Foo;
    int foo() {}
  };
  return Bar()->f();
]], 1)

test_do([[
class Foo
{
  inherit Stdio.File;

  void create() {  }
};

class Bar
{
  int y;


  class Gazonk
  {
    inherit Foo;
    

    void create(Stdio.File f)
      {
	assign(f);
      }
  }

  void create()
    {
      Gazonk(Stdio.stdin);
    }
};

Bar();

]])

test_any([[
  object f = class {
      array recursive(mixed func, array data, mixed ... args)
      {
	array ret=({});

	foreach(data, mixed foo)
	{
	  if(arrayp(foo))
	  {
	    ret+=({ recursive(func, foo, @args) });
	  }else{
	    ret+=({ foo });
	  }
	}
  
	return func(ret, @args);
      };
    }();

  mixed x = ({ "A", ({}) });
  x = f->recursive(replace, x, "B", ({}));

  for(int i = 0; i < sizeof(x); i++) {
    if (!stringp(x[i]) && !arrayp(x[i])) return 0;
  }
  return 1;
]], 1);

test_compile_error( [[
  // This triggs a compiler bug on old Pike 7.3.
  non_existant(17) {
    return 0;
  }
]])

test_compile_error( [[
  // This triggs a compiler bug on old Pike 7.5.
  return lambda(object (([mixed]a)->syntax_error) { return 0; }(0);
]])

test_any( [[
// bug [2861] ------------------------------------------------------------
// http://community/crunch/show_bug.cgi?id=2861
return mktime(0,0,0,1,0,70,0,0);
]], 0)

test_any( [[
// bug [3270] ------------------------------------------------------------
// http://community/crunch/show_bug.cgi?id=3270
// Tue, 15 Oct 2002 09:38:32 GMT
return mktime(32, 38, 9, 15, 9, 102, 0, 0);
]], 1034674712)

cond( [[ master()->resolv("Pike")->Security ]],[[
  test_any( [[
  // bug [2830] ------------------------------------------------------------
  // http://community/crunch/show_bug.cgi?id=2830
  class User{};

  object luser = User();

  object luser_creds = Pike.Security.Creds(luser, 0, 0);
  return !catch {
    return !!Pike.Security.call_with_creds(luser_creds, Stdio.File,
        "/dev/null");
  };

  return 0;
  ]], 0 )
]])

test_any( [[
// bug [1996] ------------------------------------------------------------
// http://community/crunch/show_bug.cgi?id=1996
class Implementation
{
   int foo() { return 1; }
};
class Prototype
{
   int foo();
   int bar() { return foo(); }
};
class Test
{
   inherit Implementation;
   inherit Prototype;
   int test() { return bar(); }
};
return Test()->test(); 
]], 1 );

test_any( [[
// bug [721] -------------------------------------------------------------
// http://community/crunch/show_bug.cgi?id=721
int res=0;
program p;
catch
{
add_constant("test_a",compile_string("int foo();","test_a"));
add_constant("test_b",compile_string("int foo();","test_b"));
add_constant("test_c",compile_string(
 "inherit test_a;\n"
 "inherit test_b;\n"
 "final int foo() { return 1; }\n","test_c"));
 res=compile_string("inherit test_c;\n","test_d")()->foo();
};
return res;
	]],1);
test_do(add_constant("test_a"))
test_do(add_constant("test_b"))
test_do(add_constant("test_c"))

test_any( [[
// bug [1858] ------------------------------------------------------------
// http://community/crunch/show_bug.cgi?id=1858
string s=#"
   constant foo=({this_object()});
   int|string test()
   {
      if (!foo[0]) return sprintf(\"foo is %O\\n\",foo)-\"\\n\";
      if (foo[0]==this_object()) return 1;
      return sprintf(\"foo is %O\\n\",foo)-\"\\n\";
   }
";
class handler { void compile_error(string file, int line, string err) { }};
catch {
  program p=compile_string(s,"test",handler());
  return p()->test();
};
return 1; // compile error is ok
	]],1);

// -----------------------------------------------------------------------



// This test checks for excessive recursion in
// destruct_objects_to_destruct, and also that it keeps the destruct
// order sane.
test_do([[
  class Top
  {
    int count = 0;

    class Foo
    {
      int c;
      object foo;
      static void create(object o)
      {
	foo = o;
	c = count++;
      }

      void destroy()
      {
	count--;
	if (count != c)
	  error ("Destruct out of sequence, "
		 "%d destructed when %d should be.\n", c, count);
	object x = foo && Foo(0);
	x = 0;
	// Cause call to destruct_objects_to_destruct.
	for (int j = 0; j < 10; j++) werror ("");
      }
    }

    mixed eat_stack()
    {
      mixed err = 1;
      if (catch (err = eat_stack()) || err != 10)
	return intp (err) && err > 0 ? err + 1 : err;
      if (err = catch {

	Foo foo;
	for(int i=0; i < 10000; i++)
	  foo = Foo(foo);
	foo = 0;
	// Cause call to destruct_objects_to_destruct.
	for (int j = 0; j < 10; j++) werror ("");

      }) return err;
    }

    static void create()
    {
      if (mixed err = eat_stack()) {
	catch (err[1] = err[1][sizeof (err[1]) - 50..]);
	throw (err);
      }
    }
  };

  Top();
]]);

// Testing stack popping wrt the various function call opcodes
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    object key = monitor::lock();
    return f (1); // F_CALL_LFUN_AND_RETURN
  };
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  mixed g = f;
  int a()
  {
    object key = monitor::lock();
    return g (1); // F_CALL_FUNCTION_AND_RETURN
  }
]]);
test_program([[
  Thread.Mutex monitor = Thread.Mutex();
  int f (int x)
  {
    if(monitor->trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    add_constant ("f", f);
    add_constant ("monitor", monitor);
    return compile_string(#"
      int g()
      {
	object key = monitor->lock();
	return f (1); // F_APPLY_AND_RETURN
      }")()->g();
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int dummy;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    object key = monitor::lock();
    int res = this->f (1); // F_CALL_OTHER (no `->)
    dummy = random (res);
    return res;
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  mixed `-> (string what) {return this[what];}
  int dummy;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    object key = monitor::lock();
    int res = this->f (1); // F_CALL_OTHER (with `->)
    dummy = random (res);
    return res;
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int res = 0;
  void f (int x)
  {
    if(monitor::trylock(1))
      res = 0;
    else
      res = x;
  };
  int a()
  {
    object key = monitor::lock();
    this->f (1); // F_CALL_OTHER_AND_POP (no `->)
    return res;
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  mixed `-> (string what) {return this[what];}
  int res = 0;
  void f (int x)
  {
    if(monitor::trylock(1))
      res = 0;
    else
      res = x;
  };
  int a()
  {
    object key = monitor::lock();
    this->f (1); // F_CALL_OTHER_AND_POP (with `->)
    return res;
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    object key = monitor::lock();
    return this->f (1); // F_CALL_OTHER_AND_RETURN (no `->)
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  mixed `-> (string what) {return this[what];}
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    object key = monitor::lock();
    return this->f (1); // F_CALL_OTHER_AND_RETURN (with `->)
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (iter == 1) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      object key = monitor::lock();
      iter = 1;
      return a (1); // F_COND_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      object key = monitor::lock();
      iter = 2;
      return a (1); // F_TAIL_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      object key = monitor::lock();
      iter = 2;
      int res = a (1); // F_RECUR
      iter = -1;
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	iter = 0;
      iter = x;
    }
    else {
      object key = monitor::lock();
      iter = 2;
      a (1); // F_RECUR_AND_POP
      return iter;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    foreach (({0, monitor::lock()}), mixed m)
      return f (1); // F_CALL_LFUN_AND_RETURN
  };
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  mixed g = f;
  int a()
  {
    foreach (({0, monitor::lock()}), mixed m)
      return g (1); // F_CALL_FUNCTION_AND_RETURN
  }
]]);
test_program([[
  Thread.Mutex monitor = Thread.Mutex();
  int f (int x)
  {
    if(monitor->trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    add_constant ("f", f);
    add_constant ("monitor", monitor);
    return compile_string(#"
      int g()
      {
	foreach (({0, monitor->lock()}), mixed m)
	  return f (1); // F_APPLY_AND_RETURN
      }")()->g();
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int dummy;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    int res;
    foreach (({0, monitor::lock()}), mixed m) {
      res = this->f (1); // F_CALL_OTHER (no `->)
      dummy = random (res);
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  mixed `-> (string what) {return this[what];}
  int dummy;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    int res;
    foreach (({0, monitor::lock()}), mixed m) {
      res = this->f (1); // F_CALL_OTHER (with `->)
      dummy = random (res);
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int res = 0;
  void f (int x)
  {
    if(monitor::trylock(1))
      res = 0;
    else
      res = x;
  };
  int a()
  {
    foreach (({0, monitor::lock()}), mixed m) {
      this->f (1); // F_CALL_OTHER_AND_POP (no `->)
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  mixed `-> (string what) {return this[what];}
  int res = 0;
  void f (int x)
  {
    if(monitor::trylock(1))
      res = 0;
    else
      res = x;
  };
  int a()
  {
    foreach (({0, monitor::lock()}), mixed m) {
      this->f (1); // F_CALL_OTHER_AND_POP (with `->)
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    foreach (({0, monitor::lock()}), mixed m)
      return this->f (1); // F_CALL_OTHER_AND_RETURN (no `->)
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  mixed `-> (string what) {return this[what];}
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    foreach (({0, monitor::lock()}), mixed m)
      return this->f (1); // F_CALL_OTHER_AND_RETURN (with `->)
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (iter == 1) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      iter = 1;
      foreach (({0, monitor::lock()}), mixed m)
	return a (1); // F_COND_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      iter = 2;
      foreach (({0, monitor::lock()}), mixed m)
	return a (1); // F_TAIL_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      iter = 2;
      int res;
      foreach (({0, monitor::lock()}), mixed m) {
	res = a (1); // F_RECUR
	iter = random (res);
	return res;
      }
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	iter = 0;
      iter = x;
    }
    else {
      iter = 2;
      foreach (({0, monitor::lock()}), mixed m) {
	a (1); // F_RECUR_AND_POP
	return iter;
      }
    }
  }
]]);
test_do(add_constant("f"))
test_do(add_constant("monitor"))

// Testing scoped frames wrt the various function call opcodes
test_program([[
  int f (int x)
  {
    return x;
  }
  int a (void|int x)
  {
    function s = lambda () {return x;};
    return f (1); // F_CALL_LFUN_AND_RETURN
  };
]]);
test_program([[
  int f (int x)
  {
    return x;
  };
  mixed g = f;
  int a (void|int x)
  {
    function s = lambda () {return x;};
    return g (1); // F_CALL_FUNCTION_AND_RETURN
  }
]]);
test_program([[
  int f (int x)
  {
    return x;
  }
  int a()
  {
    add_constant ("f", f);
    return compile_string(#"
      int g (void|int x)
      {
        function s = lambda () {return x;};
	return f (1); // F_APPLY_AND_RETURN
      }")()->g();
  }
]]);
test_program([[
  int dummy;
  int f (int x)
  {
    return x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    int res = this->f (1); // F_CALL_OTHER (no `->)
    dummy = random (res);
    return res;
  }
]]);
test_program([[
  mixed `-> (string what) {return this[what];}
  int dummy;
  int f (int x)
  {
    return x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    int res = this->f (1); // F_CALL_OTHER (with `->)
    dummy = random (res);
    return res;
  }
]]);
test_program([[
  int res = 0;
  void f (int x)
  {
    res = x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    this->f (1); // F_CALL_OTHER_AND_POP (no `->)
    return res;
  }
]]);
test_program([[
  mixed `-> (string what) {return this[what];}
  int res = 0;
  void f (int x)
  {
    res = x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    this->f (1); // F_CALL_OTHER_AND_POP (with `->)
    return res;
  }
]]);
test_program([[
  int f (int x)
  {
    return x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    return this->f (1); // F_CALL_OTHER_AND_RETURN (no `->)
  }
]]);
test_program([[
  mixed `-> (string what) {return this[what];}
  int f (int x)
  {
    return x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    return this->f (1); // F_CALL_OTHER_AND_RETURN (with `->)
  }
]]);
test_program([[
  int iter = 0;
  int a (void|int x)
  {
    if (iter == 1) {
      return x;
    }
    else {
      function s = lambda () {return x;};
      iter = 1;
      return a (1); // F_COND_RECUR
    }
  }
]]);
test_program([[
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      return x;
    }
    else {
      function s = lambda () {return x;};
      iter = 2;
      return a (1); // F_TAIL_RECUR
    }
  }
]]);
test_program([[
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      return x;
    }
    else {
      function s = lambda () {return x;};
      iter = 2;
      int res = a (1); // F_RECUR
      iter = -1;
      return res;
    }
  }
]]);
test_program([[
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      iter = x;
    }
    else {
      function s = lambda () {return x;};
      iter = 2;
      a (1); // F_RECUR_AND_POP
      return iter;
    }
  }
]]);
test_do(add_constant("f"))

test_false([[object_variablep(class X { int y; int z() { return 1; }}(),"foo")]])
test_false([[object_variablep(class X { int y; int z() { return 1; }}(),"z")]])
test_true([[object_variablep(class X { int y; int z() { return 1; }}(),"y")]])

test_any([[ int a,b; [a,b]=({1,2}); return a]],1)
test_any([[ int a,b; [a,b]=({1,2}); return b]],2)
test_any([[ int a,b; [ [a],b]=({ ({ 1 }) ,2}); return a]],1)
test_any([[ int a,b; [ [a],b]=({ ({ 1 }) ,2}); return b]],2)
test_any([[ int a; catch { [a]=({1,2}); }; return 1]],1)
test_any([[ int a,b; catch { [a,b]=({1}); }; return 1]],1)
test_any([[ mapping m=([]); m[m]=m; return stringp(sprintf("%O",m)); ]],1)
dnl test_any([[ 
dnl // don't know if this /should/ be valid  /Mirar
dnl // remove if it shouldn't
dnl
dnl // I see no reason this should be allowed - Hubbe
dnl
dnl array a=({});
dnl []=a; return 1; ]],1)

test_any([[
  int q() { throw(1); };
  catch {
     return q();
  };
  return 17;
]],17)

test_any([[
 return class
 {
   int q() { throw(1); };
   int p() {
     catch {
        return q();
     };
     return 17;
   }
 }()->p();
]],17)

test_compile_error([[
  static function foo(string ...:object);
  int bar()
  {
    return 17;
  }
]])
test_compile_error([[ 
  array a;
  a = path_info[..(sizeof(path_info)-2]*"/";
]])
test_compile_error([[ default ; ]])
test_compile_error([[ 0999; ]])
test_compile_error([[ int a,b; [a,b]++; ]])
test_compile_error([[
array(int) x;

string foo()
{
 return "foo "+(array(string) x) * ",";
}

int main()
{
  return 0;
}
]])

dnl
dnl this_program
dnl

test_true(this_program)
test_any([[int this_program; return this_program;]], 0)
test_any([[class A { int a() { return this_program == A; }}; return A()->a();]], 1)
test_program([[
  class A (int v)
  {
    this_program clone() {return this_program (v);}
  }
  int a() {return A (4)->clone()->v == 4;}
]])
test_program([[
  int i = 17, j = 18;
  class A (int v)
  {
    this_program clone() {return this_program (i);}
  }
  int a() {return A (4)->clone()->v == 17;}
]])
test_program([[
  class A (int v)
  {
    this_program clone() {return this_program (j);}
  }
  int i = 17, j = 18;
  int a() {return A (4)->clone()->v == 18;}
]])
test_program([[
  int i = 17, v;
  this_program clone() {return this_program (i);}
  void create (int v_) {v = v_;}
  int a() {return clone()->v == 17;}
]])
test_program([[
  this_program clone() {return this_program (i);}
  int i = 17, v;
  void create (int v_) {v = v_;}
  int a() {return clone()->v == 17;}
]])
test_program([[
  class A {this_program clone() {return this_program();}}
  class B {inherit A;}
  int a() {return object_program (B()->clone()) == B;}
]])
test_program([[
  class A {this_program clone() {return this_program();}}
  class B {inherit A;}
  int a() {return typeof(B()->clone()) <= B;}
]])

test_program([[
  class A {
    class B {
      mixed f() {
	return ({global::this_program,
		 A::this_program, // Works, but not really useful.
		 B::this_program, // Ditto.
		 this_program});
      }
    }
  }
  int a() {
    return equal (A()->B()->f(), ({object_program (this_object()), A, A.B, A.B}));
  }
]])

test_compile_error([[
  mixed x() {
    return ::x;
  }
]])

test_program([[
  class A {
    class B {
      constant this_program = "foo";
      mixed f (int this_program) {
	return ({A::this_program, B::this_program, this_program});
      }
    }
  }
  int a() {
    return equal (A()->B()->f (1), ({A, "foo", 1}));
  }
]])

test_program([[
  class I {
    string this_program = "foo";
  }
  class A {
    class B {
      inherit I;
      mixed f (int this_program) {
	return ({A::this_program, B::this_program, this_program});
      }
    }
  }
  int a() {
    return equal (A()->B()->f (1), ({A, "foo", 1}));
  }
]])

test_program([[
  string this_program = "foo";
  class A {
    class B {
      mixed f() {
	return ({A::this_program, B::this_program, this_program});
      }
    }
  }
  int a() {
    return equal (A()->B()->f(), ({A, A.B, "foo"}));
  }
]])

test_compile_error_any([[
  class A {}
  class B {
    inherit A;
    mixed f() {return A::this_program;}
  }
]])

dnl test_compile_error(0())
test_compile_error(1())
test_compile_error(""())
test_compile_error(([])())
test_compile_error(([])())
test_any([[ class X { int y; class Z { void destroy() { y++; } } }; X x=X(); destruct(x->Z()); return x->y;]],1)

test_eval_error([[ class Z { int destroy() { return 1/y; } }(); ]])

test_any([[ class X { int y; class Z { static void destroy() { y++; } } }; X x=X(); destruct(x->Z()); return x->y;]],1)
test_any([[ class X { int y; class Z { static void create() { y++; } } }; X x=X(); destruct(x->Z()); return x->y;]],1)

cond([[all_constants()->_debug]],
[[
  test_do(_debug(_debug(0)))
]])
test_do(indices(_static_modules))
test_compile_any([[import Stdio; class x { string y() { read_file("foo"); } }]])

dnl ----------------------------------------------------------------
dnl backtrace/linenumber tests
dnl ----------------------------------------------------------------

test_any([[
  program p=compile_string(
"int foo()\n"
"{\n"
"  error(\"test error\\n\"); // line 3\n"
"  return 17;\n"
"}","test");
  mixed err=catch { p()->foo(); };
  if (err[1][-1][1]!=3)
  {
     werror("backtrace is:\n"+master()->describe_backtrace(err));
  }
  return err[1][-1][1];
]],3);

// Bug 2660
test_any([[
  int foo(mixed a, mixed ... b) {
    return sizeof(backtrace()[-1]) - (3 + 1 + sizeof(b));
  };
  return foo(1,2,3,4)|foo(1);
]], 0)
  
define(test_backtrace_line_charset, [[
test_any([[
  program p=compile_string(
Locale.Charset.encoder("]]$1[[")->feed(
"#charset ]]$1[[\n"
"int foo()\n"
"{\n"
"  error(\"test error\\n\"); // line 3\n"
"  return 17;\n"
"}")->drain(),"test");
  mixed err=catch { p()->foo(); };
  if (err[1][0][1]!=3)
  {
     werror("backtrace is:\n"+master()->describe_backtrace(err));
  }
  return err[1][0][1];
]],3);
]])
dnl test_backtrace_line_charset(utf-7)

test_program([[
  class X
  {
    static void create (int i)
    {
      if (i)
	error ("foo\n"); // Line 7
    }
  }

  int f()
  {
    X (0);
    X (1); // Line 14
  }

  int a()
  {
    array bt = catch (f())[1];
    int ok = 0;
    foreach (reverse (bt), object ent) 
      switch (functionp (ent[2]) && function_name (ent[2])) {
	case "create": if (ent[1] == 7) ok++; break;
	case "f": if (ent[1] == 14) ok++; break;
      }
    return ok == 2;
  }
]])

test_program([[// [bug 3060]
  void x (mixed val)
  {
  }

  class X
  {
    void create() {error ("foo\n");} // Line 8
  }

  object rx = class {}();

  int y()
  {
    x (rx->x);
    rx = X(); // Line 16
  }

  int a()
  {
    mixed bt = catch (y())[1];
    int ok = 0;
    foreach (reverse (bt), object ent)
      switch (functionp (ent[2]) && function_name (ent[2])) {
	case "create": if (ent[1] == 8) ok++; break;
	case "y": if (ent[1] == 16) ok++; break;
      }
    return ok == 2;
  }
]])

test_any([[
  // Test a lot of code without a relative pc update in it. There must
  // not be any labels in it since the pc counting is reset then.
  int a = 1, b = 1, c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c;
  return __LINE__ == backtrace()[-1][1];
]], 1)

dnl Note: This line number error tend to go away with more debug.
test_program([[
  int x = 0;
  int y = [int] backtrace()[-1][1];
  int a() {return y == 3;}
]])

dnl ----------------------------------------------------------------
dnl scopes and stuff
dnl ----------------------------------------------------------------

dnl
dnl Undocumented but important behaviour...
dnl
test_eq([[Stdio._stdin]],[[Stdio.stdin->_fd]])

test_program([[
  class A {
    string f() {return "A";}
  }
  class B {
    string f() {return "B";}
  }
  class C {
    inherit B;
  }
  class D {
    inherit A;
    inherit C;
    string g() {return f();}
  }
  int a() {
    return D()->g() == "B";
  }
]])
test_program([[
  class A {
    string f() {return "A";}
  }
  class B {
    string f() {return "B";}
  }
  class C {
    inherit B;
  }
  class D {
    inherit C;
    inherit A;
    string g() {return f();}
  }
  int a() {
    return D()->g() == "A";
  }
]])
test_program([[
  class A {
    string f() {return "A";}
  }
  class B {
    string f() {return "B";}
  }
  class C {
    inherit B;
  }
  class D {
    string f() {return "D";}
    inherit A;
    inherit C;
    string g() {return f();}
  }
  int a() {
    return D()->g() == "D";
  }
]])

test_compile_any([[
class Bar
{
  int f() {return 17;}

  class Foo {
    int g() {return f();}
  }

  inherit Foo;
}
]])
test_compile_any([[
class Bar
{
  int f() {return 17;}

  class Foo {
    int g() {return f();}
  }
}

class Gnu
{
  inherit Bar;
  inherit Foo;
}

]])

dnl Bug 2571
test_any([[
  int var;
  void x() {var++;};
  lambda () {x();}();
  return var;
]], 1);

test_do([[
  // Save our constants for future use...
  add_constant("__saved_constants__", ([]) + all_constants());
]])

test_any([[
 Stdio.write_file("testsuite_test.pmod",
	#"
// this crashes Pike /Mirar 2001-05-19
// I haven't been able to minimize it futher,
// and it needs to be in a separate module.

mapping es=0;

string efoo(string e)
{
   if (!es)
   {
      mapping res=([]);

      string l;

      if (sscanf(l,\"%s%s\",string ext,string type)==4 &&
	  ext!=\"\" && ext[0]!=\"#\") // note the type error
	 res[ext]=type;

      es=res;
   }
}	
	");

 // Compilation handler that hides compilation errors.
 class handler
 {
   void compile_error(string file, int line, string err)
   {
     // werror("file: %O, line: %O, err: %O\n", file, line, err);
   }
 };

 // turn this on when the bug is found
 // master()->set_inhibit_compile_errors(lambda(){});

 //_optimizer_debug(2);
 //_assembler_debug(20);

 object orig_master = master();
 replace_master(object_program(orig_master)());
 catch {
   compile_string("import \".\";\n"
                  "int foo() { testsuite_test.efoo; }\n",
		  "testsuite_test", handler());
 };
 replace_master(orig_master);
 return 0;
]],0);

test_any([[
// infokom:350113
 Stdio.recursive_rm("testsuite_test_dir.pmod");
 mkdir("testsuite_test_dir.pmod");
 Stdio.write_file("testsuite_test_dir.pmod/module.pmod",
	#"
    .A a() {return 0;}
	");
 Stdio.write_file("testsuite_test_dir.pmod/A.pike",
	#"
    void create (.X x) {.y();}
	");

 // Compilation handler that hides compilation errors.
 class handler
 {
   void handle_error(array(mixed)|object trace) { }
   void compile_error(string file, int line, string err) { } 
   void compile_warning(string file, int line, string err) { } 
 };

  object orig_master = master();
  replace_master(object_program(orig_master)());
  master()->set_inhibit_compile_errors(handler());
  mixed err = catch {
     compile_string("import \".\"; "
	"int foo() { testsuite_test_dir.a(); }",
	"test",handler());
  };
  master()->set_inhibit_compile_errors(0);
  replace_master(orig_master);
  if(err)
  { 
    Stdio.recursive_rm("testsuite_test_dir.pmod");
    return 0;
  }
  
 return 1;
]],0);

test_do([[
 Stdio.recursive_rm("testsuite_test_dir.pmod");
 mkdir("testsuite_test_dir.pmod");

 Stdio.write_file("testsuite_test_dir.pmod/module.pmod",
	#"
    .A a();
    class X {}
	");
 Stdio.write_file("testsuite_test_dir.pmod/A.pike",
	#"
    .X f() {return 0;}
	");

 object orig_master = master();
 replace_master(object_program(orig_master)());
 mixed err = catch {
   compile_string("import \".\"; "
		  "int foo() { testsuite_test_dir.A(); }",
		  "test");
 };
 replace_master(orig_master);
 if (err) throw (err);

 Stdio.recursive_rm("testsuite_test_dir.pmod");
]]);

test_do([[
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/module.pmod", #"\
    .B b();
    class X {}");
  Stdio.write_file ("testsuite_test_dir.pmod/A.pike", #"\
    int f() {return 0;}");
  Stdio.write_file ("testsuite_test_dir.pmod/B.pike", #"\
    inherit .A;
    .X g() {return f() && .X();}");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed err = catch {
      compile_string ("import \".\";\n"
		      "int foo() { testsuite_test_dir.B(); }",
		      "test");
    };
  replace_master (orig_master);
  if (err) throw (err);

  Stdio.recursive_rm ("testsuite_test_dir.pmod");
]]);

test_do([[
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/module.pmod", #"\
    .B.B b();
    class X {}");
  Stdio.write_file ("testsuite_test_dir.pmod/A.pike", #"\
    int f() {return 0;}");
  Stdio.write_file ("testsuite_test_dir.pmod/B.pmod", #"\
    class B {
      inherit .A;
      .X g() {return f() && .X();}
    }");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed err = catch {
      compile_string ("import \".\";\n"
		      "int foo() { testsuite_test_dir.B.B(); }",
		      "test");
    };
  replace_master (orig_master);
  if (err) throw (err);

  Stdio.recursive_rm ("testsuite_test_dir.pmod");
]]);

test_do([[
  // Problem: The expression .B.c in module.pmod is resolved during
  // compilation pass 1 of B.pike, but it's only declared then and
  // doesn't yet have any value.
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/module.pmod", #"\
    mixed x = .B.c;
    class A {}");
  Stdio.write_file ("testsuite_test_dir.pmod/B.pike", #"\
    constant c = .A();"); // Should give a "not constant" compile error.

  // Compilation handler that hides compilation errors.
  class handler
  {
    void handle_error(array(mixed)|object trace) { }
    void compile_error(string file, int line, string err) { } 
    void compile_warning(string file, int line, string err) { } 
  };

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed err = catch {
      compile_string (#"\
	mixed foo() {return .testsuite_test_dir.A;}",
        "test", handler());
    };
  replace_master (orig_master);
  if (!err) error ("Expected compile error.\n");
  if (!objectp (err) || !err->is_compilation_error) throw (err);

  Stdio.recursive_rm("testsuite_test_dir.pmod");
]]);

test_any_equal([[
  // Problem: module.pmod is in pass 1 when it tries to resolve the
  // .B.c constant and is therefore temporarily interned as a
  // placeholder object. The (<>) in B.pike is equivalent to
  // aggregate_multiset, which due to the import is looked up in the
  // placeholder object and therefore resolved as a nonconstant
  // placeholder object.
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/module.pmod", #"\
    mixed x = .B.C;
    mixed foo() {return x->c;}");
  Stdio.write_file ("testsuite_test_dir.pmod/B.pike", #"\
    import \".\";
    class C {
      constant c = (<>);
    }");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed res;
  mixed err = catch {
      res = compile_string (#"\
	mixed foo() {return .testsuite_test_dir.foo();}",
        "test")()->foo();
    };
  replace_master (orig_master);
  if (err) throw (err);
  Stdio.recursive_rm("testsuite_test_dir.pmod");
  return res;
]], (<>));

test_do([[
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/A.pmod", #"\
    string pof() {return testsuite_test_dir.A.bingo();}
    string bingo () {return \"17\";}");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  master()->add_module_path (getcwd());
  mixed err = catch {
      compile_string (#"\
	string foo() {
	  return testsuite_test_dir.A.pof();
	}", "test");
    };
  replace_master (orig_master);
  if (err) throw (err);

  Stdio.recursive_rm ("testsuite_test_dir.pmod");
]])

test_do([[
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/module.pmod", #"\
    .Foo.C x;");
  Stdio.write_file ("testsuite_test_dir.pmod/Foo.pmod", #"\
    import \".\";
    class C
    {
      int f (array x)
      {
	return lambda() {
		 // 'sizeof' below will be a placeholder object in
		 // pass 1. That shouldn't cause a type error.
		 int i = sizeof (x);
		 return i;
	       }();
      }
    }");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed err = catch {
      compile_string (#"\
	mixed foo() {return .testsuite_test_dir.x;}",
        "test");
    };
  replace_master (orig_master);
  if (err) throw (err);
  Stdio.recursive_rm("testsuite_test_dir.pmod");
]]);

cond(0,[[
test_do([[
  // This is a case of cyclic references I think should work, but
  // afaict it's not possible without changing the resolve methods
  // thoroughly. /mast
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/A.pmod", #"\
    .B.B b() {}
    class A {}
    class Ab {int ai() {return 4711;}}
    class Ad {inherit .B.Bb; int ai() {return bi() + 1;}}");
  Stdio.write_file ("testsuite_test_dir.pmod/B.pmod", #"\
    .A.A a() {}
    class B {}
    class Bb {int bi() {return 17;}}
    class Bd {inherit .A.Ab; int bi() {return ai() - 1;}}");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed err = catch {
      compile_string (#"\
	import \".\";
	int foo() {
	  testsuite_test_dir.A.Ad();
	  testsuite_test_dir.B.Bd();
	}", "test");
    };
  replace_master (orig_master);
  if (err) throw (err);

  Stdio.recursive_rm ("testsuite_test_dir.pmod");
]]);
]]);

test_do([[
  // Restore constants that were zapped by the various masters used above.
  foreach(__saved_constants__; string const; mixed val) {
    add_constant(const, val);
  }
  add_constant("__saved_constants__");  
]])

test_compile_any([[int log() { return 17; } class Greta { int hanna() { return log(); } }]])
test_compile_any([[int kajsa(int a,int b) { return 17; } class Jenny { int kajsa() { return 17; } class Greta { int hanna() { return kajsa(); } } }]])
test_any([[add_constant("kajsa",lambda(int a,int b) { return 17; }); return compile_string("int kajsa() { return 17; } class Greta { int hanna() { return kajsa(); } }")()->kajsa()]],17)
test_do(add_constant("kajsa"))

test_compile([[Stdio.File foo=Stdio.File();]])
test_compile([[  string|multiset(string) foo;
  array(string) gazonk;
  array(string) bar = indices(foo)-gazonk;
]])
test_compile([[class { Stdio.File foo=Stdio.File(); }]])
test_compile_any([[void foo(Stdio.FILE f) {}]])
test_compile_any([[void foo(array(Stdio.FILE) f) {}]])
test_compile_any([[void foo(array(Stdio.FILE) f) {}]])
test_compile_any([[Stdio.File foo(array(Stdio.FILE) f) { return f[0]; }]])
test_compile_any([[
class a {
  int `== (mixed x) {
    return 0;
  }
}

class b {
  inherit a;
  class c {
    int d (string x, string y) {
      return x==y;
     }
  }
}
]])
test_compile([[Stdio.File foo=Stdio.FILE();]])

test_any([[string gurk="bozo"; string b(int x) { return (x?b(x-1)+gurk:""); }; return b(5)]],[["bozo"*5]])

dnl this should really work...
dnl test_compile_any([[void foo(int,string,...);]])

dnl This test doesn't run out of stack anymore, freaky
dnl test_eval_error([[class X { int create() { create(); } }();]])
test_compile_error([[ int float; ]])
test_compile_error([[ int array; ]])
test_compile_error([[ int function; ]])
test_compile_error([[ int int; ]])
test_compile_error([[ int mapping; ]])
test_compile_error([[ int multiset; ]])
test_compile_error([[ int object; ]])
test_compile_error([[ int string; ]])
test_compile_error([[ int void; ]])
test_compile_error([[ int inline; ]])
test_compile_error([[ int local; ]])
test_compile_error([[ int nomask; ]])
test_compile_error([[ int predef; ]])
test_compile_error([[ int private; ]])
test_compile_error([[ int protected; ]])
test_compile_error([[ int public; ]])
test_compile_error([[ int static; ]])
test_compile_error([[ int final; ]])
test_compile_error([[ int do; ]])
test_compile_error([[ int else; ]])
test_compile_error([[ int return; ]])
test_compile_error([[ int constant; ]])
test_compile_error([[ int import; ]])
test_compile_error([[ int inherit; ]])
test_compile_error([[ int catch; ]])
test_compile_error([[ float gauge; ]])
test_compile_error([[ int lambda; ]])
test_compile_error([[ int sscanf; ]])
test_compile_error([[ int switch; ]])
test_compile_error([[ int typeof; ]])
test_compile_error([[ int break; ]])
test_compile_error([[ int case; ]])
test_compile_error([[ int continue; ]])
test_compile_error([[ int default; ]])
test_compile_error([[ int for; ]])
test_compile_error([[ int foreach; ]])
test_compile_error([[ int if; ]])
test_compile_error([[ int float = 0; ]])
test_eval_error([[ return 0.0[0]; ]])
test_eval_error([[ return 0[0]; ]])
test_compile_error([[constant x=class {}(); ]])

test_compile_error_any([[
 mixed foo;
 mapping query_variables() { return ([]); };
 mixed foo(mixed bar) { return 1/foo; }
]])

test_compile_error_any([[
  class A {int wrong = "bogus"; void create() {}}
  class B {inherit A;}
]])


test_compile([[float x=(gauge { return; },1.0);]])
cond( [[ master()->resolv("Gmp")->mpz ]],
[[
  test_compile_error([[object x = Gmp.mpz(17); constant y = x;]])
]])
test_any([[object(Stdio.File) f; f=Stdio.File(); return 1]],1)
test_compile([[float t=gauge { string foo; };]])
test_compile_any([[class { object(Stdio.FILE) f; void create() { f=Stdio.FILE(); }}]])
test_eq([[compile_string("#define A(X) (X)\nint x() { return A \n\t(1); }")()->x()]],1)

test_any([[class G { mapping t=([]);
 class tO { void init(string name) { t[name]=this_object(); }}
 class W { inherit tO; void create() { init("foo"); }}
}; object x=G(); x->W(); return objectp(x->t->foo)]],1)

test_program([[class foo { program x() { return class {}; }}; class bar { inherit foo; program x() { return class {}; }} int a() { return foo()->x != bar()->x(); }]])

test_any([[
  class A {
    constant gurka = 2;
    int foo = gurka;
  };
  class B {
    static inherit A;
    constant gurka = 1;
    int bar;

    void create() { bar = foo; }
  };
  return B()->bar;
]], 1)

test_any([[
  class A {
    constant gurka = 2;
    int foo = gurka;
  };
  class B {
    static inherit A;
    constant gurka = 1;
    int bar;
    int baz = 3;

    void create() { bar = baz + foo; }
  };
  return B()->bar;
]], 4)

test_any([[
  class A {
    constant gurka = 1;
    int foo = gurka;
  };
  class B {
    constant banan = 2;
    int foo = banan;
  };
  class C {
    static inherit A;
    static inherit B;
    constant gurka = 3;
    constant banan = 4;
    int bar;
    int baz = 5;

    void create() { bar = baz + A::foo + B::foo; }
  };
  return C()->bar;
]], 12)

test_any([[
  class A { int a = 1; };
  class B { int b = 2; };
  class C {
    inherit A;
    inherit B;
    int c = 4;
  };
  class D {
    inherit C;
  };
  object d = D();
  return d->a + d->b + d->c;
]], 7)

test_compile_error_any([[
  class AScope
  {
     int gurka;
     class A
     {
  	int func() { return gurka; }
     }
  }
  
  class CScope
  {
     string hohum;
     class C
     {
  	inherit AScope.A;
     }
  }

]])

test_program([[
class A
{
  constant x = 1.0;
}

class B
{
  inherit A;
  class C
  {
    constant y = x+2.0;
  }
}

mixed a()
{
  return 3.0 == B()->C()->y;
}
]])

test_program_eq([[
  constant x = X;
  class X {constant c = "right";}

  constant y = Y;
  class Y {constant c = "wrong";}

  string a()
  {
    return ::`[]("x")->c;
  }
]], "right")

test_program_eq([[
  class A {
    string x = "x";
    class B {
      string f() {return x;}
    }
  }
  class C {
    inherit A;
    constant D = A::B;
  }
  string a() {
    return C()->D()->f();
  }
]], "x")

test_program_eq([[
  class A {
    string x = "x";
    class B {
      string f() {return x;}
    }
  }
  class C {
    inherit A;
    string x = "y";
    constant D = A::B;
  }
  string a() {
    return C()->D()->f();
  }
]], "y")

test_program_eq([[
  class A {
    local string x = "x";
    class B {
      string f() {return x;}
    }
  }
  class C {
    inherit A;
    string x = "y";
    constant D = A::B;
  }
  string a() {
    return C()->D()->f();
  }
]], "x")

test_program_eq([[
  class A {
    local string x = "x";
    class B {
      void set (string new) {x = new;}
      string f() {return x;}
    }
  }
  class C {
    inherit A;
    string x = "y";
    constant D = A::B;
  }
  string a() {
    C c = C();
    C.D d = c->D();
    d->set ("bar");
    c->x = "foo";
    return d->f();
  }
]], "bar")


dnl Come back when we decide that this should be possible
dnl test_do([[
dnl  class A {
dnl    constant i = 5;
dnl  };
dnl  class B {
dnl    inherit A;
dnl    int i = 17;
dnl  };
dnl  B();
dnl ]])


test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(D,A);
]],1)

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(A,D);
]],0)

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(A,C);
]],0)

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(C,A);
]],1)

test_any_equal([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherit_list(D);
]],[[ ({ C }) ]] )

test_any_equal([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit A; inherit B; inherit C; };
 return Program.inherit_list(D);
]],[[ ({ A,B,C }) ]])

test_any_equal([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherit_tree(D);
]],[[  ({D, ({C, ({B, ({A})})})}) ]])

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return sizeof( Program.all_inherits(D) - ({A,B,C}) );
]],0)

test_any_equal([[
  class A {
    class C {}
  };
  class B {
    class C {}
  };
  return ({A <= B, A >= B});
]], ({1, 1}))

test_tests([[

int errors;
int tests;

#define indent(X) (X)
#define FMT "%d:%d  "

int maxdepth;
int quiet;
string status_prefix="";

class Codec {
  string nameof(mixed x)
  {
    return ([ trace:"efun:trace", werror:"efun:werror", `+:"efun:`+" ])[x];
  }

  function functionof(string x)
  {
    return ([ "efun:trace":trace, "efun:werror":werror, "efun:`+":`+ ])[x] ||
      0;
  }

  mixed encode_object (object o) {}
  void decode_object (object o, mixed d) {}
}

void low_generate(int depth,
		  array(string) code,
		  string acc,
		  string ans,
		  int cnt)
{
  mixed tmp;
  if(--depth<0)
  {
    string res="None";
    tests++;

    if(!(tests & 63))
    {	
      __signal_watchdog();
      if(!quiet)
        werror("\r%s" FMT, status_prefix,maxdepth,tests);
    }

    string test=code*"\n"+"\n"
      "mixed Q() { return "+acc+"();}\n"
      "int main() { trace(9); werror(\"%O\\n\","+acc+"()); }\n"
      ;

    mixed tmp, x;
    mixed err=catch {
      tmp=compile_string(test)();
      res=tmp->Q();
      if(res != ans)
	throw("Test failed");
      res = "None";
      tmp = decode_value(encode_value(tmp, Codec()), Codec());
      res=tmp->Q();
      if(res != ans)
	throw("Test failed for encode/decode.");
      x=Program.inherit_list(object_program(tmp));
    };
    if(err)
    {
      errors++;
      werror("\nTest failed:\n"
	     "----------------------------------\n"
	     "%s\n"
	     "---------------------------------\n"
	     "expected answer: %O\n"
	     "Answer received: %O\n",test,ans,res);
      if(!stringp(err) || !has_prefix(err, "Test failed"))
      {
	string tmp=master()->describe_backtrace(err);
	array s=tmp/"\n";
	s=s[..20];
	werror("%s\n",s*"\n");
      }
      if (res == "None") {
        // Probable decode error; try to get some debug.
	catch {
	  werror("Encoding...\n");
	  string encoded = ((function)encode_value)(tmp, Codec(), 6);
	  werror("Decoding...\n");
          tmp = ((function)decode_value)(encoded, Codec(), 6);
	  werror("Strange... No error thrown...\n");
        };
      }
      return;
    }
  }else{
    low_generate(depth, 
		 code+
		 ({sprintf("string F%d(){ return %s()+\"F%d\"; }",cnt,acc,cnt)}),
		 sprintf("F%d",cnt),
		 sprintf("%sF%d",ans,cnt),
		 cnt+1);

    for(int e=0;e<sizeof(code);e++)
    {
      low_generate(depth, 
		   code[..e-1]+({
		     sprintf("class C%d {\n%s\n};",cnt,indent(code[e..]*"\n"))
		       }),
		   sprintf("C%d()->%s",cnt,acc),
		   ans,cnt+1);
    }
      

    if(sscanf(acc,"%s()->%s",string classname,string rest))
    {
      low_generate(depth, 
		   code+({sprintf("inherit %s;",classname) }),
		   rest,
		   ans,
		   cnt);
    }
  }
}

array(int) a()
{
  werror("\nTesting vtables and scope access.\n");

  quiet = !_verbose;

  int total_tests;
  for(maxdepth=1;maxdepth<9 && !errors;maxdepth++)
  {
    low_generate(maxdepth,
		 ({ "string X(){return \"X\";}" }),
		 "X",
		 "X",0);

    status_prefix+=sprintf(FMT,maxdepth,tests);
    if(quiet)
      werror("%d .. ",maxdepth);
    else
      werror("\r%s",status_prefix);
    total_tests+=tests;
    tests=0;
  }
  
  werror("\n");
  return ({ total_tests-errors, errors });
}

]])




test_true([[Program.implements( class { int x; string y; void foo(int x) {} },
	class { void foo(mixed z) {} int x; })]])
test_false([[Program.implements( class { int x; string y; void foo(int x) {} },
	class { void foo(mixed z) {} string x; })]])

test_eq([[object_program(master())]],[[(program)"/master"]])
test_compile([[object("master") m = master();]])
test_any([[if(int x=1,y=2) return x;]],1)
test_any([[int x; x++; if(x) return x; return -1;]],1)
test_any([[int x; if(x) return x; return -1;]],-1)
test_any([[int x,y; if(x==y || x==1) return 2; return 0;]],2);
test_any([[int x,y; if(x==y && x==0) return 2; return 0;]],2);
test_any([[int x,y=1; if(x==y || x==1) return 2; return 0;]],0);
test_any([[int x,y=1; if(x==y && x==0) return 2; return 0;]],0);


test_any([[
return class { int i=17; }()["i"]
]],17)

test_any([[
return class { int i=17; mixed `[](string foo) { return i; }}()[""]
]],17)

test_any([[
return class { int i=17; mixed `[](string foo) { return ::`[]("i"); }}()[""]
]],17)

test_any([[
return class { int i=17; mixed `[](string foo) { return ::`[]; }}()[""]("i")
]],17)

test_any([[
return class { int i=17; mixed `[](string foo) { return ::`[]; }}()[""]("y")
]],0)

test_any([[
object o=class {
  int i=17;
  mixed `[](string foo) { return ::`[]=; }
  mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
object o=class {
  int foo=7;
  int bar=11;
  int i=17;
  int gazonk=12;
  mixed `[](string foo) { return ::`[]=; }
  mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
class Fonk {
  int foo=1;
  int bar=2;
  int i=17;
  int gazonk=3;
};

object o=class
{
  inherit Fonk;
  mixed `[](string foo) { return ::`[]=; }
  mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
class Fonk {
  int foo=1;
  int bar=2;
  int i=17;
  int gazonk=3;
};

object o=class
{
  inherit Fonk : zonk;
  mixed `[](string foo) { return zonk::`[]=; }
  mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
  class A {int foo() {return bar();} int bar();};
  class B {int bar() {return 1;}};
  class C {inherit A; inherit B; int bar() {return B::bar();}};
  return C()->foo();
]], 1)

test_compile_any([[
  class X { void hej() {} }
  class Y { inherit X:banan; void hopp() { banan::hej(); } }
]])


test_compile_any([[
  class X { static void hej() {} }
  class Y { inherit X:banan; void hopp() { ::hej(); } }
]])

test_compile_any([[
  class X { static void hej() {} }
  class Y { inherit X; void hopp() { X::hej(); } }
]])

test_compile_any([[
  class X { static void hej() {} }
  class Y { public inherit X:banan; void hopp() { banan::hej(); } }
]])

test_compile_any([[
  class X { static void hej() {} }
  class Y { inherit X:banan; void hopp() { banan::hej(); } }
]])

// Testing hidden identifier lookup with ::

test_program([[
  class X {
    int i = 17;
    class Y {
      constant i = 18;
      mixed f (int i) {return ({i, Y::i, X::i});}
    }
  }
  int a() {return equal (X()->Y()->f (19), ({19, 18, 17}));}
]])

test_compile_error_any([[
  #pike 7.2
  class X {
    int i = 17;
    class Y {
      constant i = 18;
      mixed f (int i) {return ({i, Y::i, X::i});}
    }
  }
]])

test_compile_error_any([[
  class X {
    constant i = 18;
    mixed f() {return Y::i;}
  }
]])

test_program([[
  class A {
    int i = 17;
  }
  class X {
    inherit A: Y;
    class Y {
      constant i = 18;
      mixed f() {return Y::i;}
    }
  }
  int a() {return X()->Y()->f() == 18;}
]])

test_program([[
  #pike 7.2
  class A {
    int i = 17;
  }
  class X {
    inherit A: Y;
    class Y {
      constant i = 18;
      mixed f() {return Y::i;}
    }
  }
  int a() {return X()->Y()->f() == 17;}
]])

test_program([[
  class A {
    string s = "A";
  }
  class B {
    constant s = "B";
  }
  class X {
    constant s = "X";
    inherit A;
    class Y {
      inherit B: A;
      constant s = "Y";
      mixed f() {return X::s + X::A::s + Y::s + Y::A::s + A::s;}
    }
  }

  int a() {
    // Ignore the warning we get from overloading a constant with a string.
    master()->get_inhibit_compile_errors()->warning=0;
    return X()->Y()->f() == "XAYBB";
  }
]])

test_program([[
  class A {
    string s = "A";
  }
  inherit A;
  class X {
    constant s = "X";
    mixed f (string s) {return s + X::s + A::s;}
  }
  int a() {return X()->f("L") == "LXA";}
]])

test_program([[
  class A {
    string f() {return "A";}
    string g() {return A::f();}
  }
  class B {
    inherit A;
    string f() {return "B";}
  }
  int a() {return B()->g() == "B";}
]])

test_program([[
  class A {
    string g() {return A::f();}
    string f() {return "A";}
  }
  class B {
    inherit A;
    string f() {return "B";}
  }
  int a() {return B()->g() == "B";}
]])

test_program([[
  class A {
    string f() {return "A";}
    string g() {return A::f();}
  }
  class B {
    string f() {return "B";}
    inherit A;
  }
  int a() {return B()->g() == "B";}
]])

test_program([[
  class A {
    string f() {return "A";}
    class I {
      string g() {return A::f();}
    }
  }
  class B {
    inherit A;
    string f() {return "B";}
  }
  int a() {return B()->I()->g() == "B";}
]])

// Testing 'global::'

test_equal([[
  compile_string (#"
    string p = \"g\";
    mixed f (string p) {return ({global::p, p});}")()->f ("l");
]], ({"g", "l"}))

test_eval_error([[
  compile_string (#"
    string pp = \"g\";
    mixed f (string p) {return global::p;}");
]])

test_eval_error([[
  compile_string (#"
    #pike 7.2
    string p = \"g\";
    mixed f (string p) {return global::p;}");
]])

test_equal([[
  compile_string (#"
    int x = 23;
    class A {
      constant x = 24;
    }
    inherit A;
    class X {
      int x = 32;
      mixed f (int x) {return ({global::x, global::A::x, X::x, x});}
    }")()->X()->f (33);
]], ({23, 24, 32, 33}))

// Testing 'global.'

test_compile([[
  mixed a() {return global.Parser.HTML;}
]], 0);

test_compile_error([[
  #pike 7.2
  mixed a() {return global.Parser.HTML;}
]], 0);

test_any([[
  if (!programp (Parser.HTML)) error ("This test uses the existence of Parser.HTML.\n");
  return compile_string (#"
    class Parser {constant HTML = 1;}
    mixed foo() {return programp (Parser.HTML);}")()->foo();
]], 0);

test_any([[
  if (!programp (Parser.HTML)) error ("This test uses the existence of Parser.HTML.\n");
  return compile_string (#"
    mixed foo() {return programp (Parser.HTML);}
    class Parser {constant HTML = 1;}")()->foo();
]], 0);

test_any([[
  if (!programp (Parser.HTML)) error ("This test uses the existence of Parser.HTML.\n");
  return compile_string (#"
    class Parser {constant HTML = 1;}
    mixed foo() {return programp (global.Parser.HTML);}")()->foo();
]], 1);

test_any([[
  if (!programp (Parser.HTML)) error ("This test uses the existence of Parser.HTML.\n");
  return compile_string (#"
    mixed foo() {return programp (global.Parser.HTML);}
    class Parser {constant HTML = 1;}")()->foo();
]], 1);

// testing virtual overloading
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],2)

// testing 'local'
test_any([[
class fnord
{
  local int ber() { return 1; }
  int goo() { return ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],1)

// testing 'local::'
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return local::ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],1)
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return local::ber()+ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],3)
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return ber()+local::ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],3)

test_compile_error_any([[class X {int x; int f() {return local::x;}}]])
test_compile_any([[
  #pike 7.2
  class X {int x; int f() {return local::x;}}
]])

// Testing the 'inline' keyword
test_program([[class foo { inline int c() { return time(); } int d() { return c(); } }; class bar { inherit foo; int c() { return 0; } } int a() { return bar()->d(); }]],0)

test_compile_any([[
  class top
  {
     class the_class
     {
     }
  }
  
  class inherit_top
  {
     inherit top:top;
  
     constant top_the_class=top::the_class;
  
     class the_other_class
     {
        inherit top_the_class;
     }
  }
]])

// Identity of nested programs.
test_program([[
  class A {int i; class X {int j;};}
  class B {inherit A;}
  int a() {return A()->X == B()->X;}
]])
test_program([[
  class A {int i; class X {int j;};}
  class B {inherit A;}
  int a() {return A.X == B.X;}
]])
test_program([[
  class A {int i; class X {int j = i;};}
  class B {inherit A;}
  int a() {return A()->X != B()->X;}
]])
test_program([[
  class A {int i; class X {int j = i;};}
  class B {inherit A;}
  int a() {return A.X == B.X;}
]])

// Testing __INIT
test_any([[
  class X { int x = 1; };
  class Y { int y = 2; };
  class Z { inherit X; inherit Y; int z = 4; };
  object zz = Z();
  return zz->x + zz->y + zz->z;
]], 7)

test_do([[
  // bug 3006
  class X {
    constant foo = Foo;
    class Foo {}
    void bar()
    {
      foo f = Foo();
    }
  };
]])

test_program([[
  // Another variant of [bug 3006].
  class X {
    constant foo = Foo;
    class Foo {}
  }
  int a() {return programp (X.foo);}
]])

cond(0,[[
  test_program([[
    // This shows a case when on-demand resolving is required.
    class X {
      constant foo = a + 1;
      constant a = b + 1;
      constant b = c + 1;
      constant c = d + 1;
      constant d = 1;
    };
    int a() {return X.foo == 5;}
  ]])
  test_program([[
    // Reference case for the test above.
    class X {
      constant d = 1;
      constant c = d + 1;
      constant b = c + 1;
      constant a = b + 1;
      constant foo = a + 1;
    };
    int a() {return X.foo == 5;}
  ]])
]])

test_any([[
class X {
 static string f() { return "p"; }
 static class gazonk { void create() { f(); }};
  static class g { object e() { return gazonk(); }};
 void create() { g()->e(); }}; return objectp(X()); ]],1)
test_any([[class A { protected int x=1; }; class B { inherit A; int foo() { return A::x; }}; return A()->x==B()->x && B()->foo()==A()->x;]],1)
test_any([[class C { int q() { return p(); } int p() { return 17; }}; return C()->q();]],17)
test_any([[class C1 {
 class D { string id() { return "foo"; } };
 class Y { program YinD() { return D; }} };
 class C2 { inherit C1; class D { string id() { return "bar"; } } };
 return C2()->Y()->YinD()()->id()]],"bar")
test_any([[object o=class foo{int c;class bar{void create(){c++;};}}(); o->bar(); return o->c;]],1)
test_do([[add_constant("GURKA2",class foo { int c; class bar{void create() {c+=17;}}}()); ]])
test_any([[class x { inherit GURKA2.bar; }(); return GURKA2->c;]],17)
test_any([[class x { inherit GURKA2.bar; }(); return GURKA2->c;]],34)

test_do([[add_constant("GURKA2",class foo { int c; class bar{void create() { class sune { void create() {c+=17;}}(); }}}()); ]])
test_any([[class x { inherit GURKA2.bar; }(); return GURKA2->c;]],17)
test_any([[class x { inherit GURKA2.bar; }(); return GURKA2->c;]],34)
test_do([[add_constant("GURKA2");]]);

test_eq(class { static int foo=17; }()->foo,0)
test_eval_error(class c { static int foo=17; }()->foo=18;)
test_equal( [[ ({ (["foo":"bar"]), (<"foo">), ([]) })->foo ]], [[ ({"bar",1,0}) ]])
test_any([[mixed a=({([]),0}); a[1]=a; return a->foo[0];]],0)
test_eval_error([[return column(({0}),"foo");]])

test_any([[
class A { constant a=0; int foo() { return a; } };
class B { inherit A; constant a=1; };
return B()->foo(); ]], 1)

test_any([[
class p1 { int foo() { return 1; }};
class p2 { int foo() { return 3; }};
class c1 { inherit p1; inherit p2; int foo() { return p1::foo()+p2::foo(); }};
class c2 { inherit c1; }; return c2()->foo();]],4)

test_any([[
class p1 { int foo() { return 1; } };
class p2 { int foo() { return 2; } };
class c1 { inherit p1; inherit p2; };
return c1()->foo();]],2)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b += 1;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b ++;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b=b+1;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b-=-1;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)


test_compile_error([[void foo() { 1++; }]])
dnl test_compile_error([[void foo() { return destruct(this_object()); }]])
test_any([[class foo { constant x=17; }; class bar { inherit foo; constant x=18; }; return bar()->x;]],18)
test_program([[inline string foo(string s){ while(s[0] == ' ' || s[0] == '\t') s = s[1..]; return(s); } string a() { return foo("   bar"); }]])


// lambda function tests

test_true([[lambda(int x) { return lambda() { return x; };}]])
test_eq([[lambda(int x) { return lambda() { return x; };}(4)()]],4)
test_eq([[lambda(int x) { return lambda() { return x; };}(17)()]],17)
test_eq([[lambda(int x) { return lambda() { return lambda() { return x; };};}(17)()()]],17)

// trampoline tests
test_do([[{
    function trampoline =
      lambda() {
	int i = 17;
	return lambda () {
		 error ("Trampoline called.\n");
		 return i;
	       };
      }();

    // Now find the trampoline object. Pike tries very hard to hide
    // it, so we have to do it the hard way..
    object obj;
  find_trampoline_object: {
      for (obj = next_object();
	   objectp (obj) ||		// It's a normal object.
	   (intp (obj) && obj);		// It's a bignum object.
	   obj = next_object (obj))
	if (obj->`() == trampoline) break find_trampoline_object;
      error ("Trampoline object not found.\n");
    }

    if (!obj) error ("Trampoline object false.\n");
    if (!stringp (sprintf ("%O", obj)))
      // The important part is to try to call the _sprintf lfun in the
      // trampoline object, not to check what sprintf() returns.
      error ("Failed to describe trampoline object.\n");
  }]])

// local function tests
test_eq(120,
        [[ lambda()
           {
             int f(int i) { return i == 0 ? 1 : i*f(i-1); };
             return f(5);
           }(); ]])
  
test_eq([[function f;
	for(int i = 0; i < 2; i++)
	  { {int _i = i; f = lambda(int j) { return _i+j; }; } }
	return f(17);]],
	[[function f;
	for(int i = 0; i < 2; i++)
	  { {int _i = i; f = lambda(int j) { return _i+j; }; } int FEL; }
	return f(17);]]);

test_any([[
  int x,y,z;
  function p;
  void foo() { y+=7; };
  void bar()
  {
    foo();
    void gazonk()
    {
      foo();
      void quux()
      {
        foo();
        y+=4711;
      };
      p=quux;
    };

    gazonk();
    gazonk();
  };
  foo();
  bar();
  p();
  return y;
]], 7 * 5 + 4711 )

test_any([[
   int x=1;
   void for10(function f) { for(int e=0;e<10;e++) f(); };
   for10(lambda() { x++; });
   return x;
]], 11)

// implicit lambda tests
test_any([[
   int x=1;
   void for10(function f) { for(int e=0;e<10;e++) f(); };
   for10() { x++; };
   return x;
]], 11)

test_compile_error([[
   int x=1;
   void for10(function f) { for(int e=0;e<10;e++) f(); };
   for10() { x++; }
   return x;
]])

test_any([[
  int x;
  for(int i=5; i < 10; i++) x++;
  return x;
]], 5)

test_true([[lambda(function f) {return 1;}(object_program(this_object()));]])
test_any([[
  function my_lambda;

  {
    string foo = "foo", bar = "bar";
    my_lambda = lambda() { return foo; };
  }

  int really_magic_var;
  return my_lambda();
]],"foo")

test_eq([[class c { int `()(){ return 4711; } }()(); ]],4711)
teste_eval_error(mixed foo=({}); sort(@foo); )
test_compile_error([[int foo() { return 1} ; constant foo=(["foo":foo]); return foo->foo();]])
test_compile_error([[class T{void p(object e,object f){lambda::create(f);}}]])
test_eval_error(array foo=({}); return mkmapping(foo,({1})); )
test_compile_error([[mapping (string:array(string:string)) foo=([]); ]])
test_compile_error([[int a() { switch(random(2)) { case 3: if(random(2)) { case 0: return 1; } else { case 1: return 2; } } }]])

test_true(encode_value(0)[0]=='\266')
define(test_encode, [[ test_equal($1, decode_value(encode_value($1)))
		       test_equal($1, decode_value(encode_value_canonic($1))) ]])
test_eq(replace("foobar","","X"),"fXoXoXbXaXr")
test_encode(0)
test_encode("")
test_encode(0.0)
test_encode(1.0)
test_encode(-1.0)
test_encode(12.0)
test_encode(100000.0)
test_encode(3.1875)
test_encode(0.0000019073486328125)
test_encode(({}))
test_encode(([]))
test_encode("foobar")
test_encode((<>))
test_encode("\7")
test_encode("\77")
test_encode("\777")
test_encode("\7777")
test_encode("\77777")
test_encode("\777777")
test_encode("\7777777")
test_encode("\77777777")
test_encode(({"en","sv","de"}))
test_encode((<"en","sv","de">))
test_encode((["en":1,"sv":2,"de":3]))
test_encode(({"s",1,0,-3.40625}))
test_encode((<"s",1,0,-3.40625>))
test_encode((["s":1,1:2,0:3,-3.40625:4]))
test_encode((<1, 2, 2, 3, 3, 3>))
test_eq(decode_value("\210\201"),1)
test_eq(decode_value("\210\011\001"),-1)
test_eq(decode_value("\206\200"),""))
test_equal(decode_value("\200\200"),({}))
test_equal(decode_value("\206\206\146\157\157\142\141\162"),"foobar")
test_any([[mixed a=({0}); a[0]=a; return equal(a, decode_value(encode_value(a)));]], 1)
test_any([[ int e; for(e=0;e<100000;e+=1+(e>>4)) if(decode_value(encode_value(e))!=e) return e; return -1;]], -1)
test_any([[ int e; for(e=0;e<100000;e+=1+(e>>4)) if(decode_value(encode_value(-e))!=-e) return e; return -1;]], -1)

test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346de~\200\335\1\362PO\35\242")]])
test_eval_error([[return decode_value("\266ke0\241\346abcpf\221\337v\37\224")]])
test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346def`\266\212\340\337\b\252\b")]])
test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346def`\266\264\22\330\207")]])
test_eval_error([[return decode_value("\266ke0\241\262\266\216\213{@\333|")]])
test_eval_error([[return decode_value("\266ke0\241\346a\211[\266SN\313\331")]])
test_eval_error([[return decode_value("\266ke0\241\346ab-\266""6\227}u\320\274\251\211")]])
test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346de\276\266\364\30\251s\233UF\362")]])
test_eval_error([[return decode_value("\266ke0\241\346abcv\22C\246\264\264L"          )]])
test_eval_error([[return decode_value("\266ke0\241\260\303\rl")]])

test_equal(encode_value_canonic ((["en":1,"sv":2,"de":3])),
           encode_value_canonic ((["en":1,"de":3,"sv":2])))
test_equal(encode_value_canonic ((["en":1,"sv":2,"de":3])),
           encode_value_canonic ((["de":3,"sv":2,"en":1])))
test_equal(encode_value_canonic ((["en":1,"sv":2,"de":3])),
           encode_value_canonic ((["sv":2,"en":1,"de":3])))
test_equal(encode_value_canonic ((<"en","sv","de">)),
           encode_value_canonic ((<"en","de","sv">)))
test_equal(encode_value_canonic ((<"en","sv","de">)),
           encode_value_canonic ((<"de","sv","en">)))
test_equal(encode_value_canonic ((<"en","sv","de">)),
           encode_value_canonic ((<"sv","en","de">)))


test_any([[
// bug 3013
class Test
{
    class Resolver (array c)
    {
      mixed resolv (string id)
      {
	if (id == "c") return c;
      }
    }

    class Codec
    {
      mixed fooof (string name) {return all_constants()[name];}
      function objectof = fooof;
      function functionof = fooof;
      function programof = fooof;

      string nameof (mixed what)
      {
	if (string name = search (all_constants(), what)) return name;
	return ([])[0];
      }

      mixed encode_object (object o) {}
      void decode_object (object o, mixed d) {}
    }

    mixed main()
    {
      array c = ({"subres"});
      object o = compile (
	#"string res() {return `+(@c());}
	string subres() {return \"foo\";}",
	Resolver (c))();
      for (int i = 0; i < sizeof (c); i++)
	if (stringp (c[i])) c[i] = o[c[i] ];
#ifdef DEBUG
#define D ,1
#else
#define D
#endif
      function e=encode_value;
      function d=decode_value;
      return d (e (o, Codec() D), Codec() D)->res();
    }
};
  return Test()->main();
]],"foo")

test_any([[
// bug 3014
class Test
{
    class Codec
    {
      mixed nameof (mixed what)
      {
	return ([])[0];
      }
      mixed encode_object (object o) {}
      void decode_object (object o, mixed d) {}
    }

    int main()
    {
      object o = compile_string (#"
	constant x = ({0});
	int f() {return 17;}
	int g() {return x[0]();}
      ")();
      o->x[0] = o->f;
      function e=encode_value;
      function d=decode_value;
      o = d (e (o, Codec()), Codec());
      return function_object (o->x[0]) == o;
    }
};
  return Test()->main();
]],1);


test_any([[mixed s="foo"; return s++;]],"foo")
test_any([[mixed s="foo"; s++; return s;]],"foo1")
test_any([[mixed s="foo"; return ++s;]],"foo1")
test_any([[float p=2.0; return p--;]],2.0);
test_any([[float p=2.0; p--; return p;]],1.0)
test_any([[float p=2.0; return --p;]],1.0)

test_compile_error(int foo() { LJjjjjJJJ ; })
test_true(class c { constant i=1; }()->i)
test_true(class c { constant i=0; mixed `->(string s) { if(s=="i") return 1; }}()->i)
test_true(class c { constant i=1; mixed `->(string s) { return 0; }}()["i"])
test_true(class c { constant i=0; mixed `[](string s) { if(s=="i") return 1; }}()["i"])
test_true(class c { optional constant i=0; mixed `[](string s) { if(s=="i") return 1; }}()["i"])
test_true(class c { mixed `[]=(mixed a, mixed b) { if(a!=b) throw(1); }}()[1]=1)
test_true(class c { mixed `->=(mixed a, mixed b) { if(a!=b) throw(1); }}()->i="i")

test_eq((["static":42])->static,42)

test_compile_any(class A {}; class B { inherit A; })


// Automap tests

test_equal([[ ({10,20})[*] + 30  ]], [[ ({40, 50}) ]])
test_equal([[ 30 + ({10,20})[*]  ]], [[ ({40, 50}) ]])
test_equal([[ ({1,2})[*] + ({10,20})[*]  ]], [[ ({11, 22}) ]])


test_equal([[ ({ ({10,20}), ({30,40}) })[*][*] + 5  ]],
           [[ ({ ({15,25}), ({35,45}) }) ]])

test_equal([[ 5 + ({ ({10,20}), ({30,40}) })[*][*] ]],
           [[ ({ ({15,25}), ({35,45}) }) ]])

test_any_equal([[
  array a=({ ({10,20}), ({30,40}) });
  a[*][*] += 5;
  return a;
]],
[[ ({ ({15,25}), ({35,45}) }) ]])

test_any_equal([[
  mixed a=({1,2,3});
  a[*] += -2;
  return a;
]], [[ ({-1,0,1}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  a[*] += -1;
  return a;
]], [[ ({0,1,2}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  a[*] += 0;
  return a;
]], [[ ({1,2,3}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  a[*] += 1;
  return a;
]], [[ ({2,3,4}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  a[*] += 2;
  return a;
]], [[ ({3,4,5}) ]])


test_any_equal([[
  mixed a=({1,2,3});
  return a[*] += -2;
]], [[ ({-1,0,1}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  return a[*] += -1;
]], [[ ({0,1,2}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  return a[*] += 0;
]], [[ ({1,2,3}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  return a[*] += 1;
]], [[ ({2,3,4}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  return a[*] += 2;
]], [[ ({3,4,5}) ]])

test_equal([[ "foo"[ ({ 2,0,1,2 })[*] ]  ]],
           [[ ({ 'o', 'f', 'o', 'o' }) ]])

test_equal([[ ({ ({1}), ({2}), ({3}) })[*][0] ]],
           [[ ({ 1,2,3 }) ]])

test_equal([[ ({ ({1,2}), ({3,4}), ({5,6}) })[*][ ({0,1,1})[*] ] ]],
           [[ ({ 1,4,6 }) ]])

// map tests
test_any_equal(array a = ({({1,0,0}),({1,1,0}),({0,1,1})}); return map(a,`[],1);,
               ({0,1,1}))
test_any_equal(array a = ({({1,0,0}),({1,1,0}),({0,1,1})}); map(a,`[]=,1,0); return a;,
               ({({1,0,0}),({1,0,0}),({0,0,1})}))
test_any_equal(array a = ({(<1>),(<1,2>),(<2,3>),(<1,3>)}); return map(a,`[],1);,
               ({1,1,0,1}))
test_any_equal(array a = ({(<1>),(<1,2>),(<2,3>),(<1,3>)}); map(a,`[]=,1,0); return a;,
               ({(<>),(<2>),(<2,3>),(<3>)}))
test_any_equal(array a = ({(<"a">),(<"b">),(<>)}); map(a,`->=,"a",1); return a;,
               ({(<"a">),(<"a","b">),(<"a">)}))
test_any_equal(array a = ({([1:10]),([1:11,2:12]),([2:13])}); return map(a,`[],1);,
               ({10,11,0}))
test_any_equal(array a = ({([1:10]),([1:11,2:12]),([2:13])}); map(a,`[]=,1,1); return a;,
               ({([1:1]),([1:1,2:12]),([1:1,2:13])}))
test_any_equal(array a = ({(["a":10]),(["b":11]),([])}); map(a,`->=,"a",1); return a;,
               ({(["a":1]),(["a":1,"b":11]),(["a":1])}))
test_any_equal(array a = ({(["i":1]),([])}); return a["i"];,
	       ({1,0}))
test_any_equal(array a = ({(["i":1]),([])}); a["i"] = 7; return a;,
	       ({(["i":7]),(["i":7])}))
test_any([[
  class A {local int i = 10; int ii(){return i;}};
  class B {inherit A;};
  class C {inherit A; int i = 11;};
  array a = ({A(),B(),C()});
  map(a,`[]=,"i",7);
  return equal(a->i,({7,7,7})) && equal(a->ii(),({7,7,10}));
]],1)
test_any([[
  class A {local int i = 10; int ii(){return i;}};
  class B {inherit A;};
  class C {inherit A; int i = 11;};
  array a = ({A(),B(),C()});
  a->i = 7;
  return equal(a->i,({7,7,7})) && equal(a->ii(),({7,7,10}));
]],1)
test_any([[
  class A {local int i = 10; int ii(){return i;}};
  class B {inherit A;};
  class C {inherit A; int i = 11;};
  array a = ({A(),B(),C()});
  map(a,`->=,"i",7);
  return equal(a->i,({7,7,7})) && equal(a->ii(),({7,7,10}));
]],1)
test_any_equal([[
  array a = ({({(["a":"b"]),([]),(["c":17])}),({(["a":"b"]),(["a":7])}),(["b":"d"])});
  a->a = 1;
  return a;
]], ({({(["a":1]),(["a":1]),(["a":1,"c":17])}),
      ({(["a":1]),(["a":1])}),
      (["a":1,"b":"d"])}))
test_any_equal([[
  array a = ({({(["a":"b"]),([]),(["c":17])}),({(["a":"b"]),(["a":7])}),(["b":"d"])});
  map(a,`->=,"a",1);
  return a;
]], ({({(["a":1]),(["a":1]),(["a":1,"c":17])}),
      ({(["a":1]),(["a":1])}),
      (["a":1,"b":"d"])}))

test_any_equal([[
  /* This test tests a wild program pointer in the object o. The bug can trig
     a coredump in a later test. */
  class A {
    array a = ({1});
    void `->= (string var, mixed val) {::`->= (var, val);}
  };
  class B {
    inherit A;
    void `->= (string var, mixed val) {if (var) ::`->= (var, val);}
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))

test_any_equal([[
  class A {
    array a = ({1});
    void `->= (string var, mixed val) {::`->= (var, val);}
  };
  class B {
    inherit A;
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))

test_any_equal([[
  class A {
    array a = ({1});
//    void `->= (string var, mixed val) {::`->= (var, val);}
  };
  class B {
    int z;
    inherit A;
    void `->= (string var, mixed val) { A::`->= (var, val);}
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))

test_any_equal([[
  class FOO
  {
    int q,w,z;
  };
  class A {
    array a = ({1});
  };
  class B {
    inherit FOO;
    int b,c,d,e,f,g;
    inherit A;
    void `->= (string var, mixed val) { A::`->= (var, val);}
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))


test_any_equal([[
  class A {
    array a = ({1});
  };
  class B {
    int z;
    inherit A : FNORD;

    class Q
    {
	mixed `-> (string var)
	{
	  return FNORD::`-> (var);
	}
      void `->= (string var, mixed val)
	{
	  FNORD::`->= (var, val);
	}
    }
  };
  object o = B();
  object o2=o->Q();
  o2->a += ({2});
  return o->a;
]], ({1,2}))


dnl // Undefined behaviour, don't do this - Hubbe
dnl test_any_equal([[
dnl   class A {
dnl    array a = ({1});
dnl    void `->= (string var, mixed val) {::`->= (var, val); a += ({17});}
dnl  };
dnl  class B {
dnl    inherit A;
dnl  };
dnl  object o = B();
dnl  o->a += ({2});
dnl  return o->a;
dnl ]], ({1,2,17}))

cond(0,[[
dnl This test is not really right, since ::`->= is defined to look up
dnl statically. Still, a variant of ::`->= that does a low-level dynamic
dnl lookup instead would be really useful in cases like this.
test_any_equal([[
  class A {
    int f;
    void `->= (string var, mixed val) {::`->= (var, val); f = 17;}
  };
  class B {
    inherit A;
    array a = ({1});
  };
  object o = B();
  o->a += ({2});
  return o->a + ({o->f});
]], ({1,2,17}))
]])

test_true(mappingp(_memory_usage()))
test_true(_refs(""));
test_true(_refs(({})));
test_true(_refs(([])));
test_true(_refs(this_object()))
test_true(arrayp( _next(({})) || _prev(({}))))
test_do(object o=this_object(); while(o=_next(o)))
test_do(object o=this_object(); while(o=_prev(o)))

test_any([[
  object q=class {}();
  object o=_next(this_object());
  while(zero_type(o)) o=_next(o);  /* skip destructed */
  catch { if(objectp(o) || object_program(o)) return 1;  };
  o=_prev(this_object());
  while(zero_type(o)) o=_prev(o); /* skip destructed */
  catch { if(objectp(o) || object_program(o)) return 1;  };
  return 0;  
]],1)

test_any([[object(Stdio.File) o=Stdio.File(); return objectp(o);]],1)
test_any([[class Test {}; object(Test) o=Test(); return object_program(o);]],Test)
test_define_program(test,[[constant foo = 1; int a() { return foo; }]])
test_true(test()->a())
test_program(inherit test;)
test_program(inherit test; int a() { return foo; } )
test_define_program(test,[[class TEST { int a() { return 1; } }]])
test_program(inherit test; inherit TEST; )
test_do(add_constant("test");)

test_any([[
  /* don't save parent */
  class Foo {  };
  return  (!function_object(object_program(Foo()))) &&
	  (function_program(object_program(Foo())) ==
	   object_program(this_object()));
]], 1)

test_any([[
  class Foo {  };
  return  function_name(object_program(Foo()));
]], "Foo")

test_any([[
  int q;
  return stringp(function_name( lambda() { return q; }));
]],1)

test_any([[
  int q;
  return function_object( lambda() { return q; });
]],[[this_object()]])
  

test_compile(class c { object(Stdio.File) foo=class foobar {} ();})
test_compile(class c { object(Stdio.File) foo=class {} ();})
test_compile_error(class c { object(Stdio.File) foo=class {float is_file;} ();})
test_compile(class c { object(Stdio.File) foo=class { int is_file;} ();})
test_do(class c { object foo; object(Stdio.File) bar=foo; })
test_do(class c { object foo; Stdio.File bar=foo; })
test_do(class c { object(Stdio.File) foo; object bar=foo; })
test_do(class c { Stdio.File foo; object bar=foo; })
test_any(if(int i=1) return i; return 0;,1)
test_compile(for(int i=0;i<100;i++) return 0;)
test_compile(foreach(({}),mixed i){})
test_compile(sscanf("","",mixed foo))
test_compile_error(sscanf("","",float))
test_compile_error(sscanf("",float))

// ++
test_any([[int e; e++; return e;]],1)
test_any([[int e; ++e; return e;]],1)
test_any([[int e; return e++;]],0)
test_any([[int e; return ++e;]],1)
test_any([[int e; if(e++) return 0; return e;]],1)
test_any([[string e=""; e++; return e;]],"1")

// --
test_any([[int e; e--; return e;]],-1)
test_any([[int e; --e; return e;]],-1)
test_any([[int e; return e--;]],0)
test_any([[int e; return --e;]],-1)
test_any([[int e; if(e--) return 0; return e;]],-1)

test_compile_error_any(master()->add_precompiled_program(\"/test\",compile_string(\"int foo() { return 17; }\",\"62\")))

test_any([[function f=random_seed; int t; foreach(allocate(1),t) f(t); return 1;]],1)
test_compile([[while(0)if(0)continue;else;]])
test_compile([[do { break; } while (0);]])
test_program([[int b=1,c; int a() { c=b+2; return c==3; }]])
test_true([[ ("foobar"/"o") & ({ "foo" }) ]])
test_any([[ array a="foo bar"/" "; return sizeof(a & ({"foo"}))]],1)

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]])

cond([[all_constants()->thread_create]],
[[
// thread_create
  test_do(thread_create(lambda() { }))

// /precompiled/mutex
  test_true(Thread.Mutex())
  test_do(add_constant("_tmp_mutex",Thread.Mutex()))
  test_true(_tmp_mutex->lock())
  test_true(_tmp_mutex->lock())
  test_true(_tmp_mutex->trylock())
  test_true(_tmp_mutex->trylock())
  test_do(add_constant("_tmp_mutex_lock",_tmp_mutex->lock()))
  test_true(catch(_tmp_mutex->trylock()))
  test_do(add_constant("_tmp_mutex_lock"))
  test_true(_tmp_mutex->trylock())
  test_do(add_constant("_tmp_mutex"))
  test_any([[ object m = Thread.Mutex(); object k = m->lock(); thread_create(lambda(object k){ sleep(10); catch { destruct(k); }; }, k);if (catch{m->lock(); return 0;}) { return 1; } return 0; ]],1)
  test_any([[ array data=({0,Thread.Mutex(),Thread.Mutex(),0}); data[3]=data[2]->lock(); thread_create(lambda(array data) {object o=data[1]->lock(); destruct(data[3]); sleep(10); data[0]=1; destruct(o);  },data); object l=data[2]->lock(1); object ll=data[1]->lock(); return data[0]; ]],1)
  test_any([[
    array data=({1, Thread.Mutex(), Thread.Condition(), 0});
    object key = data[1]->lock();

    for(int e=0;e<3;e++) {
      data[3]++;
      thread_create(lambda(array data) {
        for(int e=0;e<1000;e++) {
          object o=data[1]->lock();
          data[0]*=2;
          for(int d=0;d<5;d++) {
            data[0]--;
            data[0]*=2;
          }
          data[0]--;
          destruct(o);
        }
	object o = data[1]->lock();
        data[3]--;
        data[2]->signal();
      }, data);
    }

    while(data[3])
      data[2]->wait(key);
    return data[0];
  ]],1)
  test_any([[
    object lock = Thread.Mutex()->lock();
    gc();
    return objectp (lock);
  ]], 1)

// /precompiled/condition
  test_true(Thread.Condition())
  test_do(Thread.Condition()->signal())
  test_do(Thread.Condition()->broadcast())

  test_true(objectp(Thread.Fifo()))
  test_true(objectp(Thread.Queue()))

  test_any([[object o=Thread.Queue(); thread_create(lambda(object f) { for(int e=0;e<10000;e++) f->write(random(4711)); f->write(-1); },o); int tmp=0; while(o->read() != -1) tmp++; return tmp;]],10000)
  test_any([[object o=Thread.Fifo(); thread_create(lambda(object f) { for(int e=0;e<10000;e++) f->write(random(4711)); f->write(-1); },o); int tmp=0; while(o->read() != -1) tmp++; return tmp;]],10000)

dnl this will crash pike on out-of-address-space-related errors
dnl  test_any([[ catch { allocate(10000,thread_create)(lambda() { sleep(1); })->wait(); } ]])

  test_any([[
    // Test that a loop relinquishes the interpreter lock every now and then.
    int count, stop;
    Thread.thread_create (lambda() {while (!stop) count++;});
    sleep (0.1);
    stop = 1;
    sleep (0.1);
    return count > 0; 
  ]], 1)
]])

cond([[all_constants()->thread_create]],
[[
  // _disable_threads
  test_any([[
#ifndef __NT__
// Using a named pipe here to make open() block. That doesn't exist on NT.

object t = class {
void log (function f, string msg)
{
#if 0
  if (f == test) msg = "[T] " + msg;
  else if (f == thread_disabler) msg = " " * 20 + "[D] " + msg;
  else if (f == mutex_locker) msg = " " * 40 + "[L] " + msg;
  werror (msg);
#endif
}

mixed err;

string fifo = "/tmp/testpipe." + getpid();

int started;
Thread.Mutex start_lock = Thread.Mutex();
Thread.Mutex locker_lock = Thread.Mutex();
Thread.Mutex locked_mutex = Thread.Mutex();
Thread.MutexKey locked_mutex_key;

void mutex_locker()
{
  log (mutex_locker, "locker started\n");
  started++;
  Thread.MutexKey k = start_lock->lock();
  k = 0;

  k = locker_lock->lock();
  k = 0;

  log (mutex_locker, "locker running\n");
  err = catch (k = locked_mutex->lock());
  log (mutex_locker, "locker done, error: " + (err && describe_error (err)) + "\n");
  k = 0;
}

void thread_disabler()
{
  log (thread_disabler, "disabler started\n");
  Thread.MutexKey locker_key = locker_lock->lock();

  started++;
  Thread.MutexKey k = start_lock->lock();
  k = 0;

  sleep (0.1);
  log (thread_disabler, "disabling\n");
  locker_key = 0;
  // Race: Don't want mutex_locker to get the lock on locker_lock
  // until we're in _disable_threads.
  object disable = _disable_threads();
  log (thread_disabler, "disabled\n");
  sleep (0.1);
  disable = 0;
  log (thread_disabler, "disabler done\n");
}

void test()
{
  locked_mutex_key = locked_mutex->lock();
  started = 0;

  Thread.MutexKey start_key = start_lock->lock();
  object disabler = thread_create (thread_disabler);
  object locker = thread_create (mutex_locker);
  while (started < 2) sleep (0.1);

  Process.Process writer = Process.create_process(
    RUNPIKE_ARRAY + ({
      "-e",
      sprintf ("sleep(0.5); "
	       "Stdio.File f = Stdio.File(%O, \"w\"); "
	       "sleep(0.5); "
	       "f->close();", fifo)
    }));

  log (test, "opening pipe\n");
  start_key = 0;
  Stdio.File f = Stdio.File (fifo, "r");
  log (test, "pipe opened\n");
  locked_mutex_key = 0;

  f->close();
  disabler->wait();
  locker->wait();
  writer->wait();
  log (test, "test done\n");
}
}();

  rm (t->fifo);
  Process.system ("mkfifo " + t->fifo);
  for (int i = 0; i < 5; i++) {
    t->test();
    if (t->err) return 0;
    t->log (0, "------------\n");
  }
  rm (t->fifo);

#endif
  return 1;
]], 1);
]])

cond([[0]],
[[
  test_any([[
  // test if read() hangs when fd is closed by other thread
       object f=Stdio.File();
       object g=f->pipe();
       object t=thread_create(
    	  lambda()
    	  {
    	     g->read(4);
    	  });
       sleep(0.1); // yield
       g->close(); // close same side of pipe as we have in read above
       sleep(0.1); // yield
       if (!t->status()) return 0; // should be done now
	  // if not, there's no way to kill that thread
       return 1;]],1);

]])


// m_delete
test_any_equal([[ mapping m=([1:1]); m_delete(m,0); return m; ]],[[ ([1:1]) ]])
test_any_equal([[ mapping m=([1:1,0:3]); m_delete(m,0); return m; ]],[[ ([1:1]) ]])
test_any([[mapping a=([1:1]); return m_delete(a,1)]],1)
test_any([[mapping m=([]); m[1]++; return m[1];]],1)
test_any([[mapping m=([1:1]); m[1]++; return m[1];]],2)
test_any([[mapping m=([1:1]); m[1]++; return m[1]++;]],2)
test_any([[mapping m=([]); m[1]++; m[1]++; return m[1];]],2)

// multiset tests

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[e]=1;
  for(e=0;e<1000;e++) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[e]++;
  for(e=0;e<1000;e++) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[e]=1;
  for(e=999;e>=0;e--) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=999;e>=0;e--) m[e]=1;
  for(e=0;e<1000;e++) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=999;e>=0;e--) m[e]=1;
  for(e=999;e>=0;e--) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e++) if(!m[reverse(e)]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=999;e>=0;e--) m[reverse(e)]=1;
  for(e=0;e<1000;e++) if(!m[reverse(e)]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e++) m[reverse(e)]=0;
  return sizeof(m);
]],0)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e+=2) m[reverse(e)]=0;
  for(e=0;e<1000;e+=2) if(m[reverse(e)]) return e;
  for(e=1;e<1000;e+=2) if(!m[reverse(e)]) return e;
  return -1;
]],-1)


test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e++) m[reverse(e)]++;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=1) return e;
  return -1;
]],-1)


test_any([[multiset m=(<>);int e;
  mixed a;
  a=allocate(1000);
  for(e=0;e<1000;e++)
  {
    m[reverse(e)]=1;
    a[e]=reverse(e);
  }
  add_constant("mtest_m",m);
  add_constant("mtest_i",a);
  return 1;
]],1)

test_any([[
  multiset m = set_weak_flag((<>), 1);
  m[1] = 1;
  return sizeof(m);
]], 1)

test_true([[
  multiset m = set_weak_flag((<>), 1);
  m[1] = 1;
  return get_weak_flag(m);
]])

test_eq([[sizeof(mtest_m)]],sizeof(mtest_i))
test_equal(Array.sort_array(indices(mtest_m)),Array.sort_array(mtest_i))
test_equal(mtest_m,copy_value(mtest_m))

test_any([[multiset m=(<>);int e;
  mixed a;
  a=allocate(100);
  for(e=0;e<100;e++)
  {
    m[reverse(e-50)]=1;
    a[e]=reverse(e-50);
    if(sizeof(m)!=e+1) return e;
  }
  add_constant("mtest_m2",m);
  add_constant("mtest_i2",a);
  return -1;
]],-1)

test_eq([[sizeof(mtest_m2)]],sizeof(mtest_i2))
test_any([[int e;multiset q=(<>),p=(<>); for(e=0;e<1000;e++) { p[reverse(e)]=1; q+=(<reverse(e)>); if(!equal(sort(indices(p)),sort(indices(q)))) return 0; } return 1;]],1)

test_equal(sort(indices(mtest_m|mtest_m2)),sort(mtest_i|mtest_i2))
test_equal(sort(indices(mtest_m&mtest_m2)),sort(mtest_i&mtest_i2))
test_equal(sort(indices(mtest_m-mtest_m2)),sort(mtest_i-mtest_i2))
test_equal(sort(indices(mtest_m^mtest_m2)),sort(mtest_i^mtest_i2))
test_equal(sort(indices(mtest_m2|mtest_m)),sort(mtest_i2|mtest_i))
test_equal(sort(indices(mtest_m2&mtest_m)),sort(mtest_i2&mtest_i))
test_equal(sort(indices(mtest_m2-mtest_m)),sort(mtest_i2-mtest_i))
test_equal(sort(indices(mtest_m2^mtest_m)),sort(mtest_i2^mtest_i))

test_do(add_constant("mtest_m"); add_constant("mtest_i"); )
test_do(add_constant("mtest_m2"); add_constant("mtest_i2"); )

define([[MTEST]],[[test_equal([[mkmultiset(indices(allocate($1)))]],[[mkmultiset(reverse(indices(allocate($1))))]])]])

MTEST(0)
MTEST(1)
MTEST(2)
MTEST(3)
MTEST(5)
MTEST(8)
MTEST(13)
MTEST(21)
MTEST(34)
MTEST(55)

define([[MTEST]])

test_equal([[lambda(multiset x){return ({x[17]++,x[17]++,x[17]++});}((<>))]],
		[[({0,1,1})]])

test_do([[
  multiset a = copy_value ((<(<1,2,3>), ({5,4}), ([1:2]), 1, ({}), (<1,2>), "foo">));
  foreach (a; mixed i;)
    if (!a[i]) error ("Can't find multiset member in itself: %O\n", i);
]])

// mapping tests

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[e]=e;
  for(e=0;e<1000;e++) if(m[e]!=e) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[e]=e;
  for(e=999;e>=0;e--) if(m[e]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=999;e>=0;e--) m[e]=e;
  for(e=0;e<1000;e++) if(m[e]!=e) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  for(e=999;e>=0;e--) m[e]=e;
  for(e=999;e>=0;e--) if(m[e]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=999;e>=0;e--) m[reverse(e)]=e;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e++) m_delete(m,reverse(e));
  return sizeof(m);
]],0)

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e+=2) m_delete(m,reverse(e));
  for(e=0;e<1000;e+=2) if(m[reverse(e)]) return 0;
  for(e=1;e<1000;e+=2) if(m[reverse(e)]!=e) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e++) m[reverse(e)]++;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=e+1) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  mixed a,b;
  a=allocate(1000);
  b=allocate(1000);
  for(e=0;e<1000;e++)
  {
    m[reverse(e)]=e;
    a[e]=reverse(e);
    b[e]=e;
  }
  add_constant("mtest_m",m);
  add_constant("mtest_i",a);
  add_constant("mtest_v",b);
  return 1;
]],1)


test_eq([[sizeof(mtest_m)]],sizeof(mtest_i))
test_equal(Array.sort_array(indices(mtest_m)),Array.sort_array(mtest_i))
test_equal(Array.sort_array(values(mtest_m)),Array.sort_array(mtest_v))
test_equal(mtest_m,copy_value(mtest_m))
test_any([[int e; for(e=0;e<1000;e++) if(!equal(mtest_m[mtest_i[e] ],mtest_v[e])) return 0; return 1;]],1)


test_any([[mapping m=([]);int e;
  mixed a,b;
  a=allocate(100);
  b=allocate(100);
  for(e=0;e<100;e++)
  {
    m[reverse(e-50)]=e-50;
    a[e]=reverse(e-50);
    b[e]=e-50;
  }
  add_constant("mtest_m2",m);
  add_constant("mtest_i2",a);
  add_constant("mtest_v2",b);
  return 1;
]],1)

test_any([[int e;mapping q=([]),p=([]); for(e=0;e<1000;e++) { p[reverse(e)]=e; q+=([reverse(e):e]); if(!equal(sort(indices(p)),sort(indices(q)))) return 0; } return 1;]],1)
test_any([[mapping m=([]); m+=(["foo":"bar"]); m+=(["bar":"foo"]); m+=(["foo":"foo"]); if(sizeof(m)==3) return 1; return m["foo"]=="foo" && m["bar"]=="foo"]],1)

test_equal(sort(indices(mtest_m|mtest_m2)),sort(mtest_i|mtest_i2))
test_equal(sort(indices(mtest_m&mtest_m2)),sort(mtest_i&mtest_i2))
test_equal(sort(indices(mtest_m-mtest_m2)),sort(mtest_i-mtest_i2))
test_equal(sort(indices(mtest_m^mtest_m2)),sort(mtest_i^mtest_i2))
test_equal(sort(indices(mtest_m2|mtest_m)),sort(mtest_i2|mtest_i))
test_equal(sort(indices(mtest_m2&mtest_m)),sort(mtest_i2&mtest_i))
test_equal(sort(indices(mtest_m2-mtest_m)),sort(mtest_i2-mtest_i))
test_equal(sort(indices(mtest_m2^mtest_m)),sort(mtest_i2^mtest_i))

test_equal(sort(values(mtest_m|mtest_m2)),sort(map(mtest_i|mtest_i2,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m&mtest_m2)),sort(map(mtest_i&mtest_i2,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m-mtest_m2)),sort(map(mtest_i-mtest_i2,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m^mtest_m2)),sort(map(mtest_i^mtest_i2,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m2|mtest_m)),sort(map(mtest_i2|mtest_i,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m2&mtest_m)),sort(map(mtest_i2&mtest_i,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m2-mtest_m)),sort(map(mtest_i2-mtest_i,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m2^mtest_m)),sort(map(mtest_i2^mtest_i,mtest_m|mtest_m2)))

test_do(add_constant("mtest_m"); add_constant("mtest_i"); add_constant("mtest_v");)
test_do(add_constant("mtest_m2"); add_constant("mtest_i2"); add_constant("mtest_v2");)

define([[MTEST]],[[test_equal([[mkmapping(indices(allocate($1)),reverse(indices(allocate($1))))]],[[mkmapping(reverse(indices(allocate($1))),indices(allocate($1)))]])]])

MTEST(0)
MTEST(1)
MTEST(2)
MTEST(3)
MTEST(5)
MTEST(8)
MTEST(13)
MTEST(21)
MTEST(34)
MTEST(55)

define([[MTEST]])

test_do([[

class X {
mapping gurka;

class Tomat
{
  int `==(mixed x)
    {
      /* make hash bigger */
      for(int e=sizeof(gurka);e<1000;e++) gurka[e]=e;
      return 0;
    }

  int __hash()
    {
      return 99999;
    }
};

class Sallad
{
  int __hash()
    {
      return 99999;
    }
};

void create()
{
  for(int x=1;x<255;x++)
  {
    gurka=([]);
    for(int e=0;e<x;e++) gurka[~e]=e;
    gurka[Sallad()]=-2;
    gurka[Tomat()]=-3;
  }
}
}();

]])

test_equal([[ `+( ([1:2]) )]],[[ ([1:2]) ]])
test_false( `+( ([1:2]) ) == ([1:2]) )
test_equal([[ `+( ([1:2]), ([1:2])  )]],[[ ([1:2]) ]])
test_equal([[ `+( ([1:2]), ([1:2]), ([2:3,4:5])  )]],[[ ([1:2,2:3,4:5]) ]])
test_equal([[ `+( ([1:2]), ([1:2]), ([2:3,4:5]), ([6:7,1:2])  )]],[[ ([1:2,2:3,4:5,6:7]) ]])
test_equal([[ `+( ([1:2]), ([1:2]), ([2:3,4:5]), ([6:7,1:2]),([8:9])  )]],[[ ([1:2,2:3,4:5,6:7,8:9]) ]] )

test_any([[mapping m=([1:2,3:2]); return search(m,2,search(m,2))!=-1;]],1)

test_any([[mapping m=([]); for(int e=0;e<1000;e++) m[e&3]+=({e}); return sizeof(m)==4 && sizeof(m[0])==250;]],1)

test_any([[
  mapping m = set_weak_flag (([1:1]), 1);
  m_delete (m, 1);
  return get_weak_flag (([]));
]], 0);

test_equal([[lambda(mapping x){return ({x[17]++,x[17]++,x[17]++});}(([]))]],
		[[({0,1,2})]])

test_equal([[([1:2, 3:4]) - (<0, 1, 2>)]], ([3:4]))
test_equal([[([1:2, 3:4]) - ({0, 1, 2})]], ([3:4]))
test_equal([[([1:2, 3:4]) & (<0, 1, 2>)]], ([1:2]))
test_equal([[([1:2, 3:4]) & ({0, 1, 2})]], ([1:2]))

// destructed indices
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]);
  destruct (o);
  return equal (m, ([])) && equal (m, ([]));
}]], 1)
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]), n = ([class{}(): 1]);
  destruct (o);
  return !equal (m, n) && !equal (m, n);
}]], 1)
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]);
  destruct (o);
  return sizeof (indices (m)) || sizeof (m);
}]], 0)
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]);
  destruct (o);
  return sizeof (values (m)) || sizeof (m);
}]], 0)

// gc

  test_true(intp(gc()));
  test_any([[ array a=({0}); a[0]=a; gc(); a=0; return gc() > 0; ]],1);
  test_any([[mapping m=([]); m[m]=m; gc(); m=0; return gc() > 0; ]],1);
  test_any([[multiset m=(<>); m[m]=1; gc(); m=0; return gc() > 0; ]],1);
  test_any([[{
#if !constant (_debug)
    int _debug (int d) {return 0;};
#endif
    // Must turn off debug in this test or else we'll get extra
    // references to p in the backlog.
    int dlevel = _debug (0);
    program p=compile_string("constant a=({0});");
    object o=p();
    o->a[0]=p;
    gc();
    p=o=0;
    _debug (dlevel);
    return gc() > 0;
  }]], 1);

test_any([[
  object o = class {function f; void foo() {}}();
  o->f = o->foo;
  gc();
  o = 0;
  return gc();
]], 0)
test_any([[
  object o = class {object o;}();
  o->o = o;
  gc();
  o = 0;
  return gc();
]], 0)
test_any([[
  class X {function f; void foo() {}};
  object o1 = X(), o2 = X();
  o1->f = o2->foo;
  o2->f = o1->foo;
  gc();
  o1 = o2 = 0;
  return gc();
]], 2)
test_any([[
  class X {object o;};
  object o1 = X(), o2 = X();
  o1->o = o2;
  o2->o = o1;
  gc();
  o1 = o2 = 0;
  return gc();
]], 2)

  test_any([[gc();
      int q=lambda() { mixed foo; foo=lambda() { return foo; }; return 1; }();
      return gc()>0;
  ]],1)

  test_true([[
    object o = class{}();
    mapping m = ([class{}(): o, o: class{}()]);
    set_weak_flag (m, 1);
    gc();
    return !sizeof (m);
  ]])
  test_true([[
    object o = class{}();
    mapping m = ([class{}(): o, o: class{}()]);
    set_weak_flag (m, Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]])
  test_true([[
    object o = class{}();
    mapping m = ([class{}(): o, o: class{}()]);
    set_weak_flag (m, Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]])
  test_true([[
    object o = class{}();
    multiset m = (<o>);
    set_weak_flag (m, 1);
    m[class{}()] = 1;
    m[o] = 0;
    gc();
    return !sizeof (m);
  ]])

  test_do([[
    mixed eat_stack()
    {
      mixed err = 1;
      if (catch (err = eat_stack()) || err != 10)
	return intp (err) && err ? err + 1 : err;
      if (err = catch {
	class Foo
	{
	  object foo;
	  static void create(object o) {foo = o;}
	};
	Foo foo;
	for(int i=0; i < 10000; i++)
	  foo = Foo(foo);
	gc();
      }) return err;
    };
    if (mixed err = eat_stack()) throw (err);
  ]])

  test_any([[
    mapping m=([]);
    m->self=m;

    mapping q=(["foo":"bar","gazonk":1]);
    m->q=q;

    q+=([]);
    m=0;
    gc();
    return sizeof(q);
  ]],2)

  test_eq([[
    int dummy;
    gc();
    function f = lambda() {
      object o = class{}();
      int i;
      return lambda() {return i;};
    }();
    lambda() {dummy++;}(); // Ensure refcount garbing is done.
    int n = gc();
    // n should be 0; o should be refcount garbed above, the frame for f
    // should be intact for use below.
    dummy += f();
    return n;
  ]], 0)

  test_true([[
    class Foo
    {
      object c;
      class A {object b;}
      class B {object a; void destroy() {c = class{}();}}
      mixed test()
      {
	object a = A(), b = B();
	a->b = b;
	b->a = a;
	a = b = 0;
	gc();
	return c;
      }
    }()->test();
  ]])

  test_any([[{
    array a = ({({0})}); a[0][0] = a;
    gc(); a = 0; return gc() > 0;
  }]], 1)

  test_any([[{
    object o = class {}();
    mapping m = ([o: ({17})]);
    gc(); destruct (o); return gc() > 0;
  }]], 1)

  test_any([[{
    class Dead {object o;};
    object o = Dead(); o->o = Dead(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Live {object o; void destroy() {}};
    object o = Live(); o->o = Live(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; void destroy() {}};
    object o = Dead(); o->o = Live(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; void destroy() {}};
    object o = Live(); o->o = Dead(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)

  test_any_equal([[{
    class Live {object o; void destroy() {}};
    array a = set_weak_flag(({Live()}), 1);
    gc();
    return set_weak_flag(a, 0);
  }]], ({0}))
  test_any_equal([[{
    class Live {object o; void destroy() {}};
    multiset l = set_weak_flag((<Live()>), 1);
    gc();
    return set_weak_flag(l, 0);
  }]], (<>))
  test_any_equal([[{
    class Live {object o; void destroy() {}};
    mapping m = set_weak_flag(([0: Live()]), 1);
    gc();
    return set_weak_flag(m, 0);
  }]], ([]))
  test_any_equal([[{
    class Live {object o; void destroy() {}};
    mapping m = set_weak_flag(([Live(): 0]), 1);
    gc();
    return set_weak_flag(m, 0);
  }]], ([]))
  test_any_equal([[{
    array a = set_weak_flag(({4711, 0x54325827a124*0x12348795482485425}), 1);
    gc();
    return set_weak_flag(a, 0);
  }]], ({4711, 0x54325827a124*0x12348795482485425}))

  test_any_equal([[{
    object o = class Live {
      array g;
      array a = ({17});
      void create() {g = ({this_object()});}
      void destroy() {all_constants()->kablutt = a;}
    }();
    o = 0;
    gc();
    return all_constants()->kablutt;
  }]], ({17}));
  test_any([[{
    object o = class Live {
      array g;
      array a = set_weak_flag (({({17})}), 1);
      void create() {g = ({this_object()});}
      void destroy() {
	if (!equal (a, ({({17})})))
	  error ("Contents in weak array zapped: %O.\n", a);
      }
    }();
    o = 0;
    return gc() >= 3;
  }]], 1);
  test_any_equal([[{
    object o = class Live {
      array g;
      array a = set_weak_flag (({({17})}), 1);
      void create() {g = ({this_object()});}
      void destroy() {all_constants()->blatinka = a;}
    }();
    o = 0;
    gc();
    if (!equal (all_constants()->blatinka, ({({17})})))
      error ("Contents in saved weak array zapped: %O.\n",
	     all_constants()->blatinka);
    gc();
    return all_constants()->blatinka;
  }]], ({0}));

test_do(add_constant("kablutt");)
test_do(add_constant("blatinka");)

  test_any([[{
#if constant (_debug)
    // Temporarily disable debug so we don't get references to p in
    // the intepreter backlog.
    int old_debug = _debug (0);
#endif
    object o = class {program p; object o;}();
    class Resolver (mixed x) {mixed resolv (string id) {return x;}};
    program p = compile ("constant o = foo;", Resolver (o));
    o->p = p;
    o->o = p();
    gc();
    o = p = 0;
#if constant (_debug)
    _debug (old_debug);
#endif
    return gc() > 0;
  }]], 1)

  test_any([[{
    class Dead {object o;};
    object o = Dead(); o->o = Dead();
    array a = set_weak_flag(({o}), 1);
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; void destroy() {}};
    object o = Live(); o->o = Dead();
    array a = set_weak_flag(({o}), 1);
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; void destroy() {}};
    object o = Dead(); o->o = Live();
    array a = set_weak_flag(({o}), 1);
    gc(); o = 0; return gc() > 0;
  }]], 1)

  test_do([[{
    object o = class {}();
    array a = ({o});
    destruct (o);
    gc();
  }]]);

  test_any([[{
    array a = ({0}), b = ({a, set_weak_flag (({a}), 1)});
    array x = set_weak_flag (({a}), 1);
    a[0] = b;
    a = b = 0;
    gc();
    return !x[0];
  }]], 1);
  test_any([[{
    mapping a = ([]), b = ([a:set_weak_flag (([a:a]), 1)]);
    mapping x = set_weak_flag (([a:2]), 1);
    a[b] = b;
    a = b = 0;
    gc();
    return !sizeof (x);
  }]], 1);
  test_any([[{
    multiset a = (<>), b = (<a, set_weak_flag ((<a>), 1)>);
    multiset x = set_weak_flag ((<a>), 1);
    a[b] = 1;
    a = b = 0;
    gc();
    return !sizeof (x);
  }]], 1);

  test_any([[{
    class Foo {
      array(Foo) f = ({this_object()});
      multiset(Foo) g = set_weak_flag((<this_object()>), 1);
    };
    multiset(Foo) x = set_weak_flag ((<Foo()>), 1);
    gc();
    return !sizeof (x);
  }]], 1);
  test_any([[{
    class Foo {
      array(Foo) f = ({this_object()});
      multiset(Foo) g = set_weak_flag((<this_object()>), 1);
      void destroy() {add_constant("beltbent_oblivion", 1);}
    };
    multiset(Foo) x = set_weak_flag ((<Foo()>), 1);
    gc();
    int res = all_constants()->beltbent_oblivion;
    add_constant("beltbent_oblivion");
    return res;
  }]], 1);

  test_any([[{
    gc();
    array x = set_weak_flag (({0}), 1);
    x[0] = x;
    multiset b = set_weak_flag ((<x>), 1);
    array a = ({17});
    b[a] = 1;
    x = 0;
    return gc() >= 1;
  }]], 1);

  test_any([[{
    gc();
    array a = set_weak_flag (({0, this_object()}), 1);
    a[0] = a;
    a = 0;
    return gc() >= 1;
  }]], 1);

  test_any([[{
    gc();
    array y = set_weak_flag (({0}), 1), z = set_weak_flag (({y}), 1);
    y[0] = z;
    y = z = 0;
    return gc() >= 2;
  }]], 1);

  test_any([[{
    class Live {
      array a;
      array g = ({this_object()});
      void create()
      {
	a = set_weak_flag (({0}), 1);
	array b = set_weak_flag (({a}), 1);
	a[0] = b;
      }
      void destroy()
      {
	if (!arrayp(a) || !arrayp(a[0]) || a[0][0] != a)
	  add_constant ("my_little_error", "GC garbed weak things too early.\n");
      }
    };
    gc();
    object o = Live();
    o = 0;
    int res = gc() >= 3;
    if (all_constants()->my_little_error)
      error (all_constants()->my_little_error);
    return res;
  }]], 1);

  test_do([[{
    class Live
    {
      Foo f;
      void destroy()
      {
	if (!f->l || !f->a || !f->a[0] || !f->a[1])
	  add_constant ("my_little_error", "GC garbed live things.\n");
      }
    };
    class Foo
    {
      int i;
      class Bar
      {
	int j = i++;		// Ensure parent pointer.
	array a = ({j});
      }
      Live l;
      void create (Live _l)
      {
	l = _l;
	l->f = this_object();
      }
      array a = allocate (2, Bar)();
    };
    object o = Foo(Live());
    o = 0;
    gc(), gc();
    if (all_constants()->my_little_error)
      error (all_constants()->my_little_error);
  }]]);

  test_do([[{
  object o = compile_string(#"
      class Foo
      {
	int i;
	class Bar
	{
	  int j = i++;		// Ensure parent pointer.
	}
	inherit Bar;
      }")();
    o = 0;
    gc();
  }]]);

  test_do([[{
    mapping a = ([1:({17}),2:3,4:5,6:7,8:9]), b = a + ([]);
    set_weak_flag (b, 1);
    gc();
  }]]);
  test_do([[{
    mapping a = ([1:({17})]), b = a + ([]);
    set_weak_flag (b, 1);
    gc();
  }]]);
  test_any([[{
    mapping a = ([17:({17})]);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    set_weak_flag (b, 1);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return sizeof (a) == 1 && sizeof (b) == 1;
  }]], 1);
  test_any([[{
    mapping a = ([17:({17})]);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    set_weak_flag (a, 1);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return sizeof (a) == 1 && sizeof (b) == 1;
  }]], 1);
  test_any([[{
    mapping a = ([17:({17})]);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    set_weak_flag (a, 1);
    set_weak_flag (b, 1);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return !sizeof (a) && !sizeof (b);
  }]], 1);
  test_any([[{
    mapping a = ([17:({17})]);
    set_weak_flag (a, 1);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return sizeof (a) == 1 && sizeof (b) == 1;
  }]], 1);
  test_any([[{
    mapping a = set_weak_flag (([17: set_weak_flag (({({17})}), 1)]), 1);
    return gc() >= 2 && !sizeof (a);
  }]], 1);

  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag ((["foo": o]), 1);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 1);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o1 = class{}(), o2 = class{}();
    mapping a = set_weak_flag (([o1: o2]), 1);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 1);
    o = 0;
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([class{}(): o]), 1);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: class{}()]), 1);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    mapping a = set_weak_flag (([class{}(): class{}()]), 1);
    return gc() >= 2 && !sizeof (a);
  }]], 1);

  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag ((["foo": o]), 1);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 1);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([class{}(): o]), 1);
    destruct (o);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: class{}()]), 1);
    destruct (o);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 0);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([class{}(): o]), 0);
    destruct (o);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: class{}()]), 0);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);

  test_any_equal([[{
    array a = set_weak_flag (({1, "foo", 3.14}), 1);
    gc();
    return set_weak_flag(a, 0);
  }]], ({1, "foo", 3.14}));
  test_any_equal([[{
    multiset a = set_weak_flag ((<1, "foo", 3.14>), 1);
    gc();
    return set_weak_flag(a, 0);
  }]], (<1, "foo", 3.14>));
  test_any_equal([[{
    mapping a = set_weak_flag (([1: 1, "foo": "foo", 3.14: 3.14]), 1);
    gc();
    return set_weak_flag(a, 0);
  }]], ([1: 1, "foo": "foo", 3.14: 3.14]));

  test_do([[{
    object f = class
    {
      object o = class {}();
      array a = set_weak_flag (({o}), 1);
      object this = this_object();
      void create() {destruct (o);}
    }();
    f = 0;
    gc();
  }]]);
  test_do([[{
    object f = class
    {
      object o = class {}();
      mapping m = set_weak_flag (([1:o]), 1);
      object this = this_object();
      void create() {destruct (o);}
    }();
    f = 0;
    gc();
  }]]);
  test_do([[{
    object f = class
    {
      object o = class {}();
      mapping m = set_weak_flag (([o:1]), 1);
      object this = this_object();
      void create() {destruct (o);}
    }();
    f = 0;
    gc();
  }]]);
  test_do([[{
    object f = class
    {
      object o = class {}();
      multiset m = set_weak_flag ((<o>), 1);
      object this = this_object();
      void create() {destruct (o);}
    }();
    f = 0;
    gc();
  }]]);

  test_tests([[inherit "]]SRCDIR[[/test_gc.pike";]])

  test_any([[mapping q=([ "t":class {} ()]); gc(); if(!objectp(q->t)) return -1; set_weak_flag(q,1); gc(); if(objectp(q->t)) return -2; return 0;]],0);

  test_do([[class bar { object foo; void create(void|object tmp) { foo=tmp; } };
             object o=bar(),o2=o;
             for(int e=0;e<10000;e++) o=bar(o);
             o2->foo=o;
             o=o2=0;
             gc();
          ]])

  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    mapping m = set_weak_flag (([class{}(): "x"]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    mapping m = set_weak_flag (([class{}(): "x"]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    mapping m = set_weak_flag ((["x": class{}()]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    mapping m = set_weak_flag ((["x": class{}()]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: o]), Pike.WEAK_INDICES);
    o = 0;
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: o]), Pike.WEAK_VALUES);
    o = 0;
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: o]), Pike.WEAK);
    o = 0;
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_INDICES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_VALUES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = ([o: "x"]);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_INDICES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_VALUES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = (["x": o]);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 1)

  test_do([[
    mapping m = set_weak_flag (([]), Pike.WEAK_INDICES);
    object o = class {object o;}();
    m[o] = ({1});
    o->o = o;
    o = 0;
    gc();
  ]])

  test_do([[
    mapping m = set_weak_flag (([]), Pike.WEAK_INDICES);
    object o = class {object o;}();
    m[o] = ({1});
    array a = set_weak_flag (({class (object o) {} (o)}), 1);
    o = 0;
    gc();
  ]])

  test_any([[
    return class {
      mapping x;
      int test()
      {
	object o = class {
	    mapping a = ([1: this_object()]);
	    void destroy() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !x[1];
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      multiset x;
      int test()
      {
	object o = class {
	    multiset a = (<this_object()>);
	    void destroy() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !sizeof (indices (x + (<>)));
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      array x;
      int test()
      {
	object o = class {
	    array a = ({this_object()});
	    void destroy() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !x[0];
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      class Obj (object o) {void destroy() {}}
      Obj x;
      int test()
      {
	object o = class {
	    Obj a = Obj (this_object());
	    void destroy() {x = a;}
	  }();
	o = 0;
	gc();
	return !x;
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      class Obj (object o) {}
      Obj x;
      int test()
      {
	object o = class {
	    Obj a = Obj (this_object());
	    void destroy() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !x->o;
      }
    }()->test();
  ]], 1)

// Numerical limits.
test_true([[Int.NATIVE_MIN <= -2147483648]])
test_true([[Int.NATIVE_MAX >= 2147483647]])
test_true([[Float.DIGITS_10 >= 6]])
test_true([[Float.MIN_10_EXP <= -37]])
test_true([[Float.MAX_10_EXP >= 37]])
test_true([[Float.MIN <= 1e-37]])
test_true([[Float.MAX >= 1e37]])
test_true([[Float.EPSILON <= 1e-5]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  // Test the lexer.
  test_eq("2147483648", [[ (string)0x80000000 ]])
  test_eq("2147483649", [[ (string)0x80000001 ]])
  test_eq("-2147483648", [[ (string)-0x80000000 ]])
  test_eq("-2147483649", [[ (string)-0x80000001 ]])
  test_eq("2147483648", [[ (string)-(-0x80000000) ]])
  test_eq("2147483649", [[ (string)-(-0x80000001) ]])
  test_eq("9223372036854775808", [[ (string)0x8000000000000000 ]])
  test_eq("9223372036854775809", [[ (string)0x8000000000000001 ]])
  test_eq("-9223372036854775808", [[ (string)-0x8000000000000000 ]])
  test_eq("-9223372036854775809", [[ (string)-0x8000000000000001 ]])
  test_eq("9223372036854775808", [[ (string)-(-0x8000000000000000) ]])
  test_eq("9223372036854775809", [[ (string)-(-0x8000000000000001) ]])
  test_eq("123456789123456789", [[ (string)123456789123456789 ]])
  test_eq("-123456789123456789", [[ (string)-123456789123456789 ]])
  test_eq("335812727629498640265", [[ (string)0x123456789123456789 ]])
  test_eq("-335812727629498640265", [[ (string)-0x123456789123456789 ]])
  test_eq("718046312823", [[ (string)012345671234567 ]])
  test_eq("-718046312823", [[ (string)-012345671234567 ]])
  test_eq("1125899906842624", [[ (string)0b100000000000000000000000000000000000000000000000000 ]])
  test_eq("-1125899906842624", [[ (string)-0b100000000000000000000000000000000000000000000000000 ]])
  test_eq(500000000 * 10, 5000000000)
  test_eq(5000000000000000000 * 10, 50000000000000000000)

  // Numbers that shouldn't be native integers. Has to resort to
  // strange methods to test this since bignums behave like native
  // integers in almost every way.
  test_do([[ _next ((mixed) Int.NATIVE_MAX + 1) ]])
  test_do([[ _next ((mixed) Int.NATIVE_MIN - 1) ]])
]])
    
  // These numbers should be native integers.
  test_eval_error([[ _next ((mixed) -0x80000000) ]])
  test_eval_error([[ _next ((mixed) -0x7fffffff) ]])
  test_eval_error([[ _next ((mixed) 0x7fffffff) ]])
  test_eval_error([[ _next ((mixed) Int.NATIVE_MAX) ]])
  test_eval_error([[ _next ((mixed) Int.NATIVE_MIN) ]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  // Test incrementations (FIXME: More cases?).
  test_eq("2147483648",
   [[ (string)(class { int f(int x) { x++; return x; } })()->f(0x7fffffff) ]])
  test_eq("2147483648",
   [[ (string)(class { int f(int x) { ++x; return x; } })()->f(0x7fffffff) ]])
  test_eq("2147483648",
   [[ (string)(class { int x=0x7fffffff;int f() { ++x;return x; } })()->f() ]])
  test_eq("2147483648",
   [[ (string)(class { int x=0x7fffffff;int f() { x++;return x; } })()->f() ]])
  test_eq("2147483648",
   [[ (string)(class { int f() { int x=0x7fffffff;++x;return x; } })()->f() ]])
  test_eq("2147483648",
   [[ (string)(class { int f() { int x=0x7fffffff;x++;return x; } })()->f() ]])
  test_eq("9223372036854775808",
   [[ (string)(class { int f(int x) { x++; return x; } })()->f(0x7fffffffffffffff) ]])
  test_eq("9223372036854775808",
   [[ (string)(class { int f(int x) { ++x; return x; } })()->f(0x7fffffffffffffff) ]])
  test_eq("9223372036854775808",
   [[ (string)(class { int x=0x7fffffffffffffff;int f() { ++x;return x; } })()->f() ]])
  test_eq("9223372036854775808",
   [[ (string)(class { int x=0x7fffffffffffffff;int f() { x++;return x; } })()->f() ]])
  test_eq("9223372036854775808",
   [[ (string)(class { int f() { int x=0x7fffffffffffffff;++x;return x; } })()->f() ]])
  test_eq("9223372036854775808",
   [[ (string)(class { int f() { int x=0x7fffffffffffffff;x++;return x; } })()->f() ]])
  
  // Test decrementations (FIXME: More cases?).
  test_eq("-2147483649",
   [[ (string)(class { int f(int x) { x--; return x; } })()->f(-0x80000000) ]])
  test_eq("-2147483649",
   [[ (string)(class { int f(int x) { --x; return x; } })()->f(-0x80000000) ]])
  test_eq("-2147483649",
   [[ (string)(class { int x=-0x80000000;int f() { --x;return x; } })()->f()]])
  test_eq("-2147483649",
   [[ (string)(class { int x=-0x80000000;int f() { x--;return x; } })()->f()]])
  test_eq("-2147483649",
   [[ (string)(class { int f() { int x=-0x80000000;--x;return x; } })()->f()]])
  test_eq("-2147483649",
   [[ (string)(class { int f() { int x=-0x80000000;x--;return x; } })()->f()]])
  test_eq("-9223372036854775809",
   [[ (string)(class { int f(int x) { x--; return x; } })()->f(-0x8000000000000000) ]])
  test_eq("-9223372036854775809",
   [[ (string)(class { int f(int x) { --x; return x; } })()->f(-0x8000000000000000) ]])
  test_eq("-9223372036854775809",
   [[ (string)(class { int x=-0x8000000000000000;int f() { --x;return x; } })()->f()]])
  test_eq("-9223372036854775809",
   [[ (string)(class { int x=-0x8000000000000000;int f() { x--;return x; } })()->f()]])
  test_eq("-9223372036854775809",
   [[ (string)(class { int f() { int x=-0x8000000000000000;--x;return x; } })()->f()]])
  test_eq("-9223372036854775809",
   [[ (string)(class { int f() { int x=-0x8000000000000000;x--;return x; } })()->f()]])

  test_encode(1<<99);
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  // - Left shift.
  test_eq("1073741824", [[ (string)(1<<30) ]])
  test_eq("2147483648", [[ (string)(1<<31) ]])
  test_eq("4294967296", [[ (string)(1<<32) ]])
  test_eq("8589934592", [[ (string)(1<<33) ]])
  test_eq("1267650600228229401496703205376", [[ (string)(1<<100) ]])
  
  test_eval_error(return 1<<100000000000000000000)
  test_eval_error(return (-1)<<100000000000000000000)
  test_eq(0<<100000000000000000000, 0)
  test_eval_error(return 100000000000000000000<<100000000000000000000)
  test_eval_error(return (-100000000000000000000)<<100000000000000000000)

  // - Right shift.
  test_eq("53265209898187398182",
		[[ (string)((int)"54543574935743895738479">>10) ]])
  test_false([[ objectp((int)"54543574935743895738479">>60) ]])
  test_eq(0, [[ 25>>30 ]])
  test_eq(0, [[ 25>>31 ]])
  test_eq(0, [[ 25>>32 ]])
  test_eq(0, [[ 25>>33 ]])

  test_eq(1>>100000000000000000000, 0)
  test_eq(-1>>100000000000000000000, -1)
  test_eq(0>>100000000000000000000, 0)
  test_eq(100000000000000000000>>100000000000000000000, 0)
  test_eq((-100000000000000000000)>>100000000000000000000, -1)

  // - abs.
  test_eq("2147483648", [[ (string)abs(-0x80000000) ]])
  test_eq("2147483648", [[ (string)abs(0x80000000) ]])
  test_eq("2147483649", [[ (string)abs(0x80000001) ]])
  test_eq("2147483649", [[ (string)abs(-0x80000001) ]])
  test_eq("9223372036854775808", [[ (string)abs(-0x8000000000000000) ]])
  test_eq("9223372036854775808", [[ (string)abs(0x8000000000000000) ]])
  test_eq("9223372036854775809", [[ (string)abs(0x8000000000000001) ]])
  test_eq("9223372036854775809", [[ (string)abs(-0x8000000000000001) ]])
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  // - Add.
  test_eq("2147483648", [[ (string)(0x7fffffff + 1) ]])
  test_eq("2147483649", [[ (string)(0x7fffffff + 2) ]])
  test_eq("-2147483648", [[ (string)((-0x80000001) + 1) ]])
  test_eq("9223372036854775808", [[ (string)(0x7fffffffffffffff + 1) ]])
  test_eq("9223372036854775809", [[ (string)(0x7fffffffffffffff + 2) ]])
  test_eq("-9223372036854775808", [[ (string)((-0x8000000000000001) + 1) ]])
  test_eq("2684354560", [[ (string)(0x50000000 + 0x50000000) ]])
  test_eq("-2684354560", [[ (string)((-0x50000000) + (-0x50000000)) ]])
  test_false([[ objectp((-0x80000001) + 1) ]])

  // - Add-eq.
  test_eq([[lambda() { int a=0x100000000; int b = a; a += 1; return b+a; }()]],
	  [[0x200000001]])

  // - Sub.
  test_eq("-2147483648", [[ (string)(-0x7fffffff - 1) ]])
  test_eq("-2147483649", [[ (string)(-0x80000000 - 1) ]])
  test_eq("2147483647", [[ (string)(0x80000000 - 1) ]])
  test_eq("-9223372036854775808", [[ (string)(-0x7fffffffffffffff - 1) ]])
  test_eq("-9223372036854775809", [[ (string)(-0x8000000000000000 - 1) ]])
  test_eq("9223372036854775807", [[ (string)(0x8000000000000000 - 1) ]])
  test_false([[ objectp(0x80000000 - 1) ]])

  // - Multiplication.
  test_eq("6442450941", [[ (string)(0x7fffffff * 3) ]])
  test_eq("-6442450941", [[ (string)(0x7fffffff * -3) ]])
  test_eq(-2147483648*-1,2147483648)
  test_eq(-9223372036854775808*-1,9223372036854775808)

  // Division.
  test_eq("1073741824", [[ (string)((int)"2147483648" / 2) ]])
  test_false([[ objectp((int)"2147483648" / 2) ]])
  test_eq("13934998268672547360069539025",
          [[ (string)(48324683476346278246238462784624627348 / 3467864333) ]])

  // sprintf (and the describe stuff in the master)
  test_do([[sprintf ("%O", 10->pow);]])
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[

  // - sscanf.
  test_eq("12345678901234567890",
	   [[ (string)array_sscanf("12345678901234567890", "%d")[0] ]])
  test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("123456789F01234567890", "%x")[0] ]])
  test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0x123456789F01234567890", "%x")[0] ]])
  test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0X123456789F01234567890", "%x")[0] ]])
  test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0x123456789F01234567890", "%i")[0] ]])
  test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0X123456789F01234567890", "%i")[0] ]])
  test_eq("45954944846776",
	   [[ (string)array_sscanf("1234567012345670", "%o")[0] ]])
  test_eq("45954944846776",
	   [[ (string)array_sscanf("01234567012345670", "%i")[0] ]])
  test_eq("11", [[ (string)array_sscanf("1011", "%b")[0] ]])
  test_eq("1125968643114208", [[ (string)array_sscanf("100000000000001000000000001000000000100010011100000", "%b")[0] ]])
  test_eq("11", [[ (string)array_sscanf("0b1011", "%i")[0] ]])
  test_eq("1125968643114208", [[ (string)array_sscanf("0b100000000000001000000000001000000000100010011100000", "%i")[0] ]])
  
  test_eq("-12345678901234567890",
	   [[ (string)array_sscanf("-12345678901234567890", "%d")[0] ]])
  test_eq("-1375488932614371410344080",
	   [[ (string)array_sscanf("-123456789F01234567890", "%x")[0] ]])
  test_eq("-1375488932614371410344080",
	   [[ (string)array_sscanf("-0x123456789F01234567890","%i")[0] ]])
  test_eq("-45954944846776",
	   [[ (string)array_sscanf("-1234567012345670", "%o")[0] ]])
  test_eq("-45954944846776",
	   [[ (string)array_sscanf("-01234567012345670", "%i")[0] ]])
  test_eq("-11", [[ (string)array_sscanf("-1011", "%b")[0] ]])
  test_eq("-1125968643114208", [[ (string)array_sscanf("-100000000000001000000000001000000000100010011100000", "%b")[0] ]])
  test_eq("-11", [[ (string)array_sscanf("-0b1011", "%i")[0] ]])
  test_eq("-1125968643114208", [[ (string)array_sscanf("-0b100000000000001000000000001000000000100010011100000", "%i")[0] ]])

  test_eq([[ sprintf("%x", @array_sscanf("\0\0\0\0\1\2\3\4", "%4c")) ]], "0")
  test_eq([[ sprintf("%x", @array_sscanf("\0\0\0\0\1\2\3\4", "%8c")) ]], "1020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\0\0\0\0\1\2\3\4", "%8c")) ]], "01020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\0\0\0\5\1\2\3\4", "%8c")) ]], "501020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\0\0\6\5\1\2\3\4", "%8c")) ]], "60501020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\0\7\6\5\1\2\3\4", "%8c")) ]], "7060501020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\8\7\6\5\1\2\3\4", "%8c")) ]], "3807060501020304")
  test_eq([[ sprintf("%08x", @array_sscanf("\010\7\6\5\1\2\3\4", "%8c")) ]], "807060501020304")

  test_equal([[ ({ 118 }) ]], [[ array_sscanf("0x76", "%x") ]])
  test_equal([[ ({42 }) ]], [[ array_sscanf("101010", "%b") ]])
  test_equal([[ ({42 }) ]], [[ array_sscanf("0b101010", "%b") ]])
  test_equal([[ ({42 }) ]], [[ array_sscanf("0B101010", "%b") ]])
  test_equal([[ ({ 557239244978618154304871 }) ]],
             [[ array_sscanf("0x76000000000001234567", "%x") ]])

  test_equal([[array_sscanf("foo \12345 bar <fie>","%[^<]")]],
	     [[ ({"foo \12345 bar " }) ]])

  test_equal(471100000000000000000000000000000000000000000000042,
             (int)(mixed)471100000000000000000000000000000000000000000000042)
  test_eq(6745697846498645967,
          [[ Gmp.mpz("6745697846498645967")->cast_to_int(); ]])
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  test_eq(0x7fffffff, [[ decode_value(encode_value(0x7fffffff)) ]])
  test_eq(0x7ffffffff, [[ decode_value(encode_value(0x7ffffffff)) ]])
  test_eq(0x7fffffffff, [[ decode_value(encode_value(0x7fffffffff)) ]])
  test_eq(0x7ffffffffff, [[ decode_value(encode_value(0x7ffffffffff)) ]])
  test_eq(0x7fffffffffff, [[ decode_value(encode_value(0x7fffffffffff)) ]])
  test_eq(0x7ffffffffffff, [[ decode_value(encode_value(0x7ffffffffffff)) ]])
  test_eq(0x80000000, [[ decode_value(encode_value(0x80000000)) ]])
  test_eq(0x800000000, [[ decode_value(encode_value(0x800000000)) ]])
  test_eq(0x8000000000, [[ decode_value(encode_value(0x8000000000)) ]])
  test_eq(0x80000000000, [[ decode_value(encode_value(0x80000000000)) ]])
  test_eq(0x800000000000, [[ decode_value(encode_value(0x800000000000)) ]])
  test_eq(0x8000000000000, [[ decode_value(encode_value(0x8000000000000)) ]])
  test_eq(0x12345678, [[ decode_value(encode_value(0x12345678)) ]])
  test_eq(0x123456780, [[ decode_value(encode_value(0x123456780)) ]])
  test_eq(0x1234567801, [[ decode_value(encode_value(0x1234567801)) ]])
  test_eq(0x12345678012, [[ decode_value(encode_value(0x12345678012)) ]])
  test_eq(0x123456780123, [[ decode_value(encode_value(0x123456780123)) ]])
  test_eq(0x1234567801234, [[ decode_value(encode_value(0x1234567801234)) ]])

  test_eq(-0x7fffffff, [[ decode_value(encode_value(-0x7fffffff)) ]])
  test_eq(-0x7ffffffff, [[ decode_value(encode_value(-0x7ffffffff)) ]])
  test_eq(-0x7fffffffff, [[ decode_value(encode_value(-0x7fffffffff)) ]])
  test_eq(-0x7ffffffffff, [[ decode_value(encode_value(-0x7ffffffffff)) ]])
  test_eq(-0x7fffffffffff, [[ decode_value(encode_value(-0x7fffffffffff)) ]])
  test_eq(-0x7ffffffffffff, [[ decode_value(encode_value(-0x7ffffffffffff))]])
  test_eq(-0x80000000, [[ decode_value(encode_value(-0x80000000)) ]])
  test_eq(-0x800000000, [[ decode_value(encode_value(-0x800000000)) ]])
  test_eq(-0x8000000000, [[ decode_value(encode_value(-0x8000000000)) ]])
  test_eq(-0x80000000000, [[ decode_value(encode_value(-0x80000000000)) ]])
  test_eq(-0x800000000000, [[ decode_value(encode_value(-0x800000000000)) ]])
  test_eq(-0x8000000000000, [[ decode_value(encode_value(-0x8000000000000))]])
  test_eq(-0x12345678, [[ decode_value(encode_value(-0x12345678)) ]])
  test_eq(-0x123456780, [[ decode_value(encode_value(-0x123456780)) ]])
  test_eq(-0x1234567801, [[ decode_value(encode_value(-0x1234567801)) ]])
  test_eq(-0x12345678012, [[ decode_value(encode_value(-0x12345678012)) ]])
  test_eq(-0x123456780123, [[ decode_value(encode_value(-0x123456780123)) ]])
  test_eq(-0x1234567801234, [[ decode_value(encode_value(-0x1234567801234))]])

  test_eval_error([[ _next ((mixed) decode_value (encode_value (Int.NATIVE_MAX))) ]])
  test_eval_error([[ _next ((mixed) decode_value (encode_value (Int.NATIVE_MIN))) ]])
  test_do([[ _next ((mixed) decode_value (encode_value (Int.NATIVE_MAX + 1))) ]])
  test_do([[ _next ((mixed) decode_value (encode_value (Int.NATIVE_MIN - 1))) ]])
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  test_eq(2147483648, -2147483648/-1)
  test_eq(2147483648, -2147483648*-1)

  test_true([[ random(0x7fffffff)+1 ]])
  test_true([[ random(0x7ffffffff)+1 ]])
  test_true([[   sqrt(0x7fffffff)+1 ]])
  test_true([[   sqrt(0x7ffffffff)+1 ]])

  test_true([[ catch { destruct((mixed)0x4783647824687234628462); } ]])

  test_any_equal([[
    array a = ({4711, 0x54325827a124*0x12348795482485425});
    set_weak_flag (a, 1);
    gc();
    return set_weak_flag(a, 0);
  ]], [[ ({4711, 0x54325827a124*0x12348795482485425}) ]])

  test_any_equal([[
    mapping m = ([
      4711: 0x54325827a124*0x12348795482485425,
      0x54325827124*0x1234879548a2485425: 1174,
    ]);
    set_weak_flag (m, 1);
    gc();
    return set_weak_flag(m, 0);
  ]], [[ ([
    4711: 0x54325827a124*0x12348795482485425,
    0x54325827124*0x1234879548a2485425: 1174,
  ]) ]])
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  test_any([[int a=2147483648; a=a+17;  return a]], 2147483665)
  test_any([[int a=2147483648; a=a-17;  return a]], 2147483631)
  test_any([[int a=2147483648; a=a*17;  return a]], 36507222016)
  test_any([[int a=2147483648; a=a/17;  return a]], 126322567)
  test_any([[int a=2147483648; a=a%17;  return a]], 9)
  test_any([[int a=2147483648; a=a^17;  return a]], 2147483665)
  test_any([[int a=2147483648; a=a&17;  return a]], 0)
  test_any([[int a=2147483648; a=a|17;  return a]], 2147483665)
  test_any([[int a=2147483648; a=a<<17; return a]], 281474976710656)
  test_any([[int a=2147483648; a=a>>17; return a]], 16384)

  test_eq([[2147483648+17 ]], 2147483665)
  test_eq([[2147483648-17 ]], 2147483631)
  test_eq([[2147483648*17 ]], 36507222016)
  test_eq([[2147483648/17 ]], 126322567)
  test_eq([[2147483648%17 ]], 9)
  test_eq([[2147483648^17 ]], 2147483665)
  test_eq([[2147483648&17 ]], 0)
  test_eq([[2147483648|17 ]], 2147483665)
  test_eq([[2147483648<<17]], 281474976710656)
  test_eq([[2147483648>>17]], 16384)

  test_true([[ floatp((1<<99)/3.14) ]]);
  test_true([[ floatp((1<<99)*3.14) ]]);
  test_true([[ floatp((1<<99)-3.14) ]]);
  test_true([[ floatp((1<<99)+3.14) ]]);
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
   test_eq([[(12)+(3)]],0xf);
   test_eq([[(12)+(3*(1<<32))]],0x30000000c);
   test_eq([[(12)+(3*(1<<64))]],0x3000000000000000c);
   test_eq([[(12)+(3*(1<<128))]],0x30000000000000000000000000000000c);
   test_eq([[(12*(1<<32))+(3)]],0xc00000003);
   test_eq([[(12*(1<<32))+(3*(1<<32))]],0xf00000000);
   test_eq([[(12*(1<<32))+(3*(1<<64))]],0x30000000c00000000);
   test_eq([[(12*(1<<32))+(3*(1<<128))]],0x300000000000000000000000c00000000);
   test_eq([[(12*(1<<64))+(3)]],0xc0000000000000003);
   test_eq([[(12*(1<<64))+(3*(1<<32))]],0xc0000000300000000);
   test_eq([[(12*(1<<64))+(3*(1<<64))]],0xf0000000000000000);
   test_eq([[(12*(1<<64))+(3*(1<<128))]],0x3000000000000000c0000000000000000);
   test_eq([[(12*(1<<128))+(3)]],0xc00000000000000000000000000000003);
   test_eq([[(12*(1<<128))+(3*(1<<32))]],0xc00000000000000000000000300000000);
   test_eq([[(12*(1<<128))+(3*(1<<64))]],0xc00000000000000030000000000000000);
   test_eq([[(12*(1<<128))+(3*(1<<128))]],0xf00000000000000000000000000000000);
   test_eq([[(12)-(3)]],0x9);
   test_eq([[(12)-(3*(1<<32))]],-0x2fffffff4);
   test_eq([[(12)-(3*(1<<64))]],-0x2fffffffffffffff4);
   test_eq([[(12)-(3*(1<<128))]],-0x2fffffffffffffffffffffffffffffff4);
   test_eq([[(12*(1<<32))-(3)]],0xbfffffffd);
   test_eq([[(12*(1<<32))-(3*(1<<32))]],0x900000000);
   test_eq([[(12*(1<<32))-(3*(1<<64))]],-0x2fffffff400000000);
   test_eq([[(12*(1<<32))-(3*(1<<128))]],-0x2fffffffffffffffffffffff400000000);
   test_eq([[(12*(1<<64))-(3)]],0xbfffffffffffffffd);
   test_eq([[(12*(1<<64))-(3*(1<<32))]],0xbfffffffd00000000);
   test_eq([[(12*(1<<64))-(3*(1<<64))]],0x90000000000000000);
   test_eq([[(12*(1<<64))-(3*(1<<128))]],-0x2fffffffffffffff40000000000000000);
   test_eq([[(12*(1<<128))-(3)]],0xbfffffffffffffffffffffffffffffffd);
   test_eq([[(12*(1<<128))-(3*(1<<32))]],0xbfffffffffffffffffffffffd00000000);
   test_eq([[(12*(1<<128))-(3*(1<<64))]],0xbfffffffffffffffd0000000000000000);
   test_eq([[(12*(1<<128))-(3*(1<<128))]],0x900000000000000000000000000000000);
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
   test_eq([[(12)*(3)]],0x24);
   test_eq([[(12)*(3*(1<<32))]],0x2400000000);
   test_eq([[(12)*(3*(1<<64))]],0x240000000000000000);
   test_eq([[(12)*(3*(1<<128))]],0x2400000000000000000000000000000000);
   test_eq([[(12*(1<<32))*(3)]],0x2400000000);
   test_eq([[(12*(1<<32))*(3*(1<<32))]],0x240000000000000000);
   test_eq([[(12*(1<<32))*(3*(1<<64))]],0x24000000000000000000000000);
   test_eq([[(12*(1<<32))*(3*(1<<128))]],0x240000000000000000000000000000000000000000);
   test_eq([[(12*(1<<64))*(3)]],0x240000000000000000);
   test_eq([[(12*(1<<64))*(3*(1<<32))]],0x24000000000000000000000000);
   test_eq([[(12*(1<<64))*(3*(1<<64))]],0x2400000000000000000000000000000000);
   test_eq([[(12*(1<<64))*(3*(1<<128))]],0x24000000000000000000000000000000000000000000000000);
   test_eq([[(12*(1<<128))*(3)]],0x2400000000000000000000000000000000);
   test_eq([[(12*(1<<128))*(3*(1<<32))]],0x240000000000000000000000000000000000000000);
   test_eq([[(12*(1<<128))*(3*(1<<64))]],0x24000000000000000000000000000000000000000000000000);
   test_eq([[(12*(1<<128))*(3*(1<<128))]],0x240000000000000000000000000000000000000000000000000000000000000000);
   test_eq([[(12)/(3)]],0x4);
   test_eq([[(12)/(3*(1<<32))]],0x0);
   test_eq([[(12)/(3*(1<<64))]],0x0);
   test_eq([[(12)/(3*(1<<128))]],0x0);
   test_eq([[(12*(1<<32))/(3*(1<<32))]],0x4);
   test_eq([[(12*(1<<32))/(3*(1<<64))]],0x0);
   test_eq([[(12*(1<<32))/(3*(1<<128))]],0x0);
   test_eq([[(12*(1<<64))/(3*(1<<64))]],0x4);
   test_eq([[(12*(1<<64))/(3*(1<<128))]],0x0);
   test_eq([[(12*(1<<128))/(3*(1<<128))]],0x4);
   test_eq([[(17+12)%(3)]],0x2);
   test_eq([[(17+12)%(3*(1<<32))]],0x1d);
   test_eq([[(17+12)%(3*(1<<64))]],0x1d);
   test_eq([[(17+12)%(3*(1<<128))]],0x1d);
   test_eq([[(17+12*(1<<32))%(3*(1<<32))]],0x11);
   test_eq([[(17+12*(1<<32))%(3*(1<<64))]],0xc00000011);
   test_eq([[(17+12*(1<<32))%(3*(1<<128))]],0xc00000011);
   test_eq([[(17+12*(1<<64))%(3*(1<<64))]],0x11);
   test_eq([[(17+12*(1<<64))%(3*(1<<128))]],0xc0000000000000011);
   test_eq([[(17+12*(1<<128))%(3*(1<<128))]],0x11);

  cond( [[ master()->resolv("Gmp")->mpz ]],
  [[
    test_eq([[Gmp.mpz(68719476736)/Gmp.mpz(12884901888)]],5);
    test_eq([[Gmp.mpz(123456789012345678901234567890)/Gmp.mpz(12884901888)]],
	    Gmp.mpz(9581507883061474724));
    test_eq([[Gmp.mpz(123456789012345678901234567890)/
	      Gmp.mpz(67890123456789012345)]],1818479371);
    test_eq([[Gmp.mpz(123456789012345678901234567890)/
	      Gmp.mpz(67890123456789)]],Gmp.mpz(1818479371169857));
  ]] )
]])

cond([[ sizeof( cpp("__AUTO_BIGNUM__")/"__AUTO_BIGNUM__" ) == 1 ]],
[[
  test_any([[int a=10->pow(30); int b=1000000000000000000000000000000; 
            return ([a:1])[b]]],1);
  test_any([[int a=10->pow(30); int b=1000000000000000000000000000000; 
            return (<a>)[b]]],1);
  test_any([[int a=10->pow(30); int b=1000000000000000000000000000000; 
            return sizeof( ({a})-({b}) )]],0);
  test_any([[int a=10->pow(30); int b=1000000000000000000000000000000; 
            return sizeof( ({a})&({b}) )]],1);
  test_any([[int k=10->pow(30); 
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
            return sort(a)[0]==k && sort(a)[-1]==k+17]],1)

  test_do([[
     // This is a memleak test
     rm("testsuite_test.pike");
     Stdio.write_file("testsuite_test.pike",
	"constant Q=10000000000000000;\n"
	"int main() {}\n");
     Process.system(RUNPIKE +" testsuite_test.pike");
     rm("testsuite_test.pike");
  ]])

// test the corresponding integer operations first
  test_any([[int k=100; int j=k+1;
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	    array b=({j+16,j+15,j+12,j+13,j+11,j-1,j+8});
            return sizeof( a&b )]],7);
  test_any([[int k=100; int j=k+1;
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	    array b=({j+13,j+11,j-1,j+8,j+16,j+15,j+12});
            return sizeof( a-b )]],0);

// now the bignum ones
  test_any([[int k=10->pow(30); int j=k+1;
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	    array b=({j+16,j+15,j+12,j+13,j+11,j-1,j+8});
            return sizeof( a&b )]],7);
  test_any([[int k=10->pow(30); int j=k+1;
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	    array b=({j+13,j+11,j-1,j+8,j+16,j+15,j+12});
            return sizeof( a-b )]],0);

]])

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]])

test_eq("\377"[0],255)
test_do(add_constant("foo",class c {int i;}()))
test_eq(foo->i,0)
test_do(foo->i=17)
test_eq(foo->i,17)
test_do(add_constant("foo"));
test_do(add_constant("foo",class c {array(int) i=({0});}()))
test_eq(foo->i[0],0)
test_do(foo->i[0]=17)
test_eq(foo->i[0],17)
test_do(add_constant("foo"));

// signum, signame
test_true(intp(signum("SIGKILL")))

// kill, signal, getpid
test_true(intp(getpid()))
cond([[all_constants()->kill && (cpp("__NT__")/"\n")[1]=="__NT__" ]],
[[
  test_do(signal(signum("SIGFPE"),lambda() { add_constant("AFJLLAF",17); }))
  test_do(kill(getpid(),signum("SIGFPE")))
  test_do(sleep(2))
  test_eq(AFJLLAF,17)
  test_do(add_constant("AFJLLAF"))
  test_do(signal(signum("SIGFPE"), 0))
  test_do(signal(signum("SIGFPE")))
]])

// typeof
test_eq(sprintf("%O", typeof(1)),"int(1..1)")
test_eq(sprintf("%O", typeof("")),"string")
test_eq(sprintf("%O", typeof(""[0])),"int")
test_eq(sprintf("%O", typeof(0.0)),"float")
test_eq(sprintf("%O", typeof(all_constants()["all_constants"])),"mixed")

// _typeof
test_eq(sprintf("%O", _typeof(1)),"int(1..1)")
test_eq(sprintf("%O", _typeof("")),"string")
test_eq(sprintf("%O", _typeof("x"[0])),"int(120..120)")
test_eq(sprintf("%O", _typeof(0.0)),"float")
test_eq([[sscanf(sprintf("%Ox", _typeof(this_object))-" ",
		 "function(void|int(0..%*[0-9]):object)%*c")]], 2)


// class
test_true(programp(class c {}))
test_true(functionp(class c { int foo() { return 1; }}()->foo))
test_true(class c { int foo() { return 1; }}()->foo())
test_true(class c { int i=1; }()->i)
test_false(class c { int foo() { return 1; }}()->bar)
test_eq(class c { program foo=class c { int i=20; }; }()->foo()->i,20)

// class()
test_true(programp(class c(){}))
test_equal(indices(class c(string a,static int b){}("foo",0)), ({"a"}))
test_equal(values(class c(string a,static int b){}("foo",0)), ({"foo"}))
test_true(programp(class c(string ... a){}))
test_equal(indices(class c(string a,static int ... b){}("foo",0)), ({"a"}))
test_equal(values(class c(static string a, int ... b){}("foo",0)), ({({0})}))

test_do([[
  class A (int i) {};
  class B (int i, int j) {inherit A;};
  class C {inherit B;};
  C (1,1);
]])

// type checks
test_compile_error([[} int foo() { return]]);
test_compile_error([[} void foo() { return 1]]);
test_compile([[mapping a; int b; a = b = 0;]]);
test_compile_error([[mapping a; int b; a = b = 1;]]);
test_compile_any([[void a(int q){} void b(function(int:void) f){} void c(){b(a);}]]);
test_compile_error_any([[void a(int i){} void b(function(:void) f){} void c(){b(a);}]]);
test_compile_any([[void a(){} function(int:void) b = a;]]);
test_compile_error_any([[void a(int i){} function(:void) b = a;]]);

// Duplicate local variable
test_compile_error([[void f() {int i; int i;}]]);
test_compile_error([[void f() {int i; mapping i;}]]);
test_compile_error([[void f() {int i; void i() {};}]]);
test_compile_error([[void f (int i) {string i;}]]);

// Not yet cataloged
test_any(int i=10; { int i; } return i, 10)
test_program(void foo(int a, int b){} function(int,int:void) a() { return foo; })
test_program(void foo(int a, int ... b){} function(int,int ...:void) a() { return foo; })
test_program(void foo(){} function(:void) a() { return foo; })
test_compile_error([[} void foo(){} function(:string) a() { return foo;]])

test_do(lambda(){return;}())
test_equal( ({ lambda() { return 3; } , lambda() { return 7; }, lambda() { return 9; } })(), ({ 3,7,9 }))
test_any(array(int) a=({10}); a[0]++; return a[0], 11)
test_any(mapping a=([10:11]); a[10]++; return a[10], 12)
test_equal(mkmapping( ({3,6,2}), ({"3","6","2"})), ([3:"3", 6:"6", 2:"2"]))
test_equal(`+(([3:"3", 6:"6", 2:"2"])), ([3:"3", 6:"6", 2:"2"]))
test_true(`+(([3:"3", 6:"6", 2:"2"])) != ([3:"3", 6:"6", 2:"2"]))

test_true(predef::stringp(""))
test_equal([["a,b,4,7,8s,asfd,a,d,f" / ","]],[["a,b,4,7,8s,asfd,a,d,f" / ","]])
test_any([[array(string) a="a,b"/","; a[0]="c"; return equal(a,({"c","b"}))]],1)
test_true(0||1)
test_true(1||0)
test_true(!0||!0)
test_true(!0&&!0)
test_any(mixed a=1; a+=1; return a,2)
test_any(mixed a=1; a-=1; return a,0)
test_equal("abcd"/"" - indices("abcd"),({"a","b","c","d"}))
test_equal("abcd"/"" & indices("abcd"),({}))
test_eq(sizeof("abcd"/"" & "de"/""),1)
test_equal( ({0,0,0,0,0}), ({0,0,0,0,0}))
test_equal( ({"object","object","object","object","object"}), allocate(5,"object"))
test_equal(mkmapping("abcd"/"","jklm"/"") | mkmapping("jclm"/"","alcd"/""),
	mkmapping("abcdjlm"/"","jklmacd"/""))
test_program(int foo() { return 17;} mixed a() { return foo() == 17; })
test_any([[mixed a; a=2; a=a*3; return a]],6)
test_any([[mixed a = ({1}); a=a+({2}); return equal(a,({1,2}))]],1)
test_define_program(test,[[int foo() { return 17; }]])
test_any(function bar=test()->foo; return bar(),17)
test_do(add_constant("test"))

// sscanf
test_any([[mixed a; return sscanf("11","%d",a)]],1)

test_any([[mixed a; sscanf("11","%d",a); return a]],11)
test_any([[mixed a; sscanf("11","%o",a); return a]],011)
test_any([[mixed a; sscanf("11","%x",a); return a]],0x11)
test_any([[mixed a; sscanf("11","%D",a); return a]],11)


test_any([[mixed a; sscanf("11","%2d",a); return a]],11)
test_any([[mixed a; sscanf("11","%2o",a); return a]],011)
test_any([[mixed a; sscanf("11","%2x",a); return a]],0x11)
test_any([[mixed a; sscanf("11","%2D",a); return a]],11)

test_any([[mixed a; sscanf("11","%4711d",a); return a]],11)
test_any([[mixed a; sscanf("11","%4711o",a); return a]],011)
test_any([[mixed a; sscanf("11","%4711x",a); return a]],0x11)
test_any([[mixed a; sscanf("11","%4711D",a); return a]],11)

test_any([[mixed a; sscanf("11","%1d",a); return a]],1)
test_any([[mixed a; sscanf("11","%1o",a); return a]],1)
test_any([[mixed a; sscanf("11","%1x",a); return a]],1)
test_any([[mixed a; sscanf("11","%1D",a); return a]],1)

test_any([[mixed a; sscanf("0x11","%D",a); return a]],0x11)
test_any([[mixed a; sscanf("011","%D",a); return a]],011)
test_any([[mixed a,b; return sscanf("11foo","%dfoo",a)]],1)
test_any([[mixed a,b; sscanf("11foo","%dfoo",a); return a]],11)
test_any([[mixed a,b; return sscanf("11foo","%d%s",a,b)]],2)
test_any([[mixed a,b; sscanf("11foo","%d%s",a,b); return b]],"foo")
test_any([[mixed a,b; return sscanf("foo","%c%s",b,a)]],2)
test_any([[mixed a,b; sscanf("foo","%c%s",b,a); return b]],'f')
test_any([[mixed a,b; sscanf("foo","%c%s",b,a); return a]],"oo")
test_any([[mixed a,b; return sscanf("1.0","%f",a),a]],1.0)
test_any([[mixed a,b; return sscanf("-1.0","%f",a),a]],-1.0)
test_any([[mixed a,b; return sscanf("1.25","%f",a),a]],1.25)
test_any([[mixed a,b; return sscanf("-1.25","%f",a),a]],-1.25)
test_any([[mixed a,b; return sscanf("1.25e3","%f",a),a]],1.25e3)
test_any([[mixed a,b; return sscanf("-1.25e3","%f",a),a]],-1.25e3)
test_any([[mixed a,b; return sscanf("1.25e-3","%f",a),a]],1.25e-3)
test_any([[mixed a,b; return sscanf("-1.25e-3","%f",a),a]],-1.25e-3)
test_any([[mixed a,b; sscanf("1.0","%f",a); return a]],1.0)
test_any([[mixed a,b; sscanf("-z ","%[-z]%s",a,b); return a]],"-z")
test_any([[mixed a,b; sscanf("-z ","%[z-]%s",a,b); return a]],"-z")
test_any([[mixed a,b; sscanf("abcdeFGji","%[a-z]%s",a,b); return a]],"abcde")
test_any([[mixed a,b; sscanf("abcdeFGji","%[a-z]%s",a,b); return b]],"FGji")

test_any([[mixed a,b; return sscanf("foo-%-bar","%s-%%-%s",a,b);]],2)
test_any([[mixed a,b; sscanf("foo-%-bar","%s-%%-%s",a,b); return a]],"foo")
test_any([[mixed a,b; sscanf("foo-%-bar","%s-%%-%s",a,b); return b]],"bar")
test_any([[mixed a; sscanf("ab","%2c",a); return a]],'a'*256+'b')
test_any([[mixed a; sscanf("abc","%3c",a); return a]],'a'*256*256+'b'*256+'c')
test_any([[mixed a; sscanf("abc","%2c",a); return a]],'a'*256+'b')
test_any([[mixed a; sscanf("ac","%3c",a); return a]],0)
test_any([[mixed a; sscanf("ab","%2s",a); return a]],"ab")
test_any([[mixed a; sscanf("abc","%3s",a); return a]],"abc")
test_any([[mixed a; sscanf("abc","%2s",a); return a]],"ab")
test_any([[mixed a; sscanf("ac","%3s",a); return a]],0)
test_any([[mixed a; sscanf("a3","%*s%d",a); return a]],3)
test_any([[mixed a; sscanf("a3","%s%*d",a); return a]],"a")
test_any([[mixed a; sscanf("a93","%s%*o",a); return a]],"a9")
test_any([[mixed a; sscanf("a93","%*s%o",a); return a]],3)
test_any([[mixed a; sscanf("a93","%s%*x",a); return a]],"")
test_any([[mixed a; sscanf("a93","%*s%x",a); return a]],0xa93)
test_any([[mixed a; sscanf("f","f%n",a); return a]],1)

test_any([[mixed a; sscanf("\102\052\100\000","%F",a); return a]],42.5625)
test_any([[mixed a; sscanf("\102\052\100\000","%4F",a); return a]],42.5625)
test_any([[mixed a; sscanf("\100\105\110\000\0\0\0\0","%8F",a); return a]],42.5625)
test_any([[mixed a; sscanf("\275\007\053\002","%4F",a); return a]],-0.032999999821186065673828125)
test_any([[mixed a; sscanf("\277\240\345\140\100\0\0\0","%8F",a); return a]],-0.032999999821186065673828125)

// Inf
test_any([[mixed a; sscanf("\177\200\0\0","%4F",a); return a>0.0]],1)
test_any([[mixed a; sscanf("\177\200\0\0","%4F",a); return (a/2)==a]],1)
// -Inf
test_any([[mixed a; sscanf("\377\200\0\0","%4F",a); return a<0.0]],1)
test_any([[mixed a; sscanf("\377\200\0\0","%4F",a); return (a/2)==a]],1)
// NaN
test_any([[mixed a; sscanf("\177\300\0\0","%4F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\177\300\0\0","%4F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\177\300\0\0","%4F",a); return a==0.0]],0)
// -NaN
test_any([[mixed a; sscanf("\377\300\0\0","%4F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\377\300\0\0","%4F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\377\300\0\0","%4F",a); return a==0.0]],0)

// Inf
test_any([[mixed a; sscanf("\177\360\0\0\0\0\0\0","%8F",a); return a>0.0]],1)
test_any([[mixed a; sscanf("\177\360\0\0\0\0\0\0","%8F",a); return(a/2)==a]],1)
// -Inf
test_any([[mixed a; sscanf("\377\360\0\0\0\0\0\0","%8F",a); return a<0.0]],1)
test_any([[mixed a; sscanf("\377\360\0\0\0\0\0\0","%8F",a); return(a/2)==a]],1)
// NaN
test_any([[mixed a; sscanf("\177\370\0\0\0\0\0\0","%8F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\177\370\0\0\0\0\0\0","%8F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\177\370\0\0\0\0\0\0","%8F",a); return a==0.0]],0)
// -NaN
test_any([[mixed a; sscanf("\377\370\0\0\0\0\0\0","%8F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\377\370\0\0\0\0\0\0","%8F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\377\370\0\0\0\0\0\0","%8F",a); return a==0.0]],0)

test_equal([[array_sscanf("10 20 30","%d %d %d")]],[[({10,20,30})]])
test_equal([[array_sscanf("1 2 3 4 5 6 7 8 9","%d %d %d %d %d %d %d %d %s")]],[[({1,2,3,4,5,6,7,8,"9"})]])
test_equal([[array_sscanf("abc","%{%c%}")]],[[ ({ ({ ({'a'}), ({'b'}), ({'c'}) }) }) ]])

test_equal([[array_sscanf("\x7fffffab#", "%c%c")]], [[ ({ 0x7fffffab, '#' }) ]])
test_equal([[array_sscanf("\x7fffffab#", "%1c%1c")]], [[ ({  }) ]])

test_true([[array_sscanf("(02323) 23455 344","%{%*[^0-9]%[0-9]%}")]])

test_eq([[ array_sscanf(sprintf("%4c",16909060),"%4c")[0] ]],16909060)
test_eq([[ array_sscanf(sprintf("%-4c",16909060),"%-4c")[0] ]],16909060)
test_eq([[ array_sscanf(sprintf("%4c",16909060),"%+4c")[0] ]],16909060)
test_eq([[ array_sscanf(sprintf("%-4c",16909060),"%+-4c")[0] ]],16909060)
test_eq([[ array_sscanf(sprintf("%4c",-16909060),"%+4c")[0] ]],-16909060)
test_eq([[ array_sscanf(sprintf("%-4c",-16909060),"%+-4c")[0] ]],-16909060)

test_equal([[array_sscanf("\1000\1001\2000","%[\1000-\1111]%s")]],
	[[ ({ "\1000\1001", "\2000" }) ]])

test_equal([[array_sscanf("foo\1000\1001\1111\1110\2000","%s%[\1000-\1111]%s")]],
	[[ ({ "foo", "\1000\1001\1111\1110", "\2000" }) ]])

test_equal([[array_sscanf("\2000\1000\1111\1001\1110foo","%s%[\1000-\1111]%s")]],
	[[ ({  "\2000", "\1000\1111\1001\1110", "foo"}) ]])

test_equal([[ array_sscanf("02 00 DC 00 0B","%{%x%*[\0-/:-@]%}")[0] ]],
    [[ ({ ({2}), ({0}), ({220}),({0}), ({11}) }) ]])

test_equal([[ array_sscanf("\51726\30212\66610\30131", "%*[ \t]%s")[0] ]],
    [[ "\51726\30212\66610\30131" ]])

test_equal([[ array_sscanf("hej","%s") ]], [[ ({ "hej" }) ]])
test_equal([[ array_sscanf("hej","%s%n") ]], [[ ({ "hej", 3 }) ]])
test_eval_error([[ function f=array_sscanf; f("hej","%s% ") ]])

test_equal([[ array_sscanf("\x304b\x3066\x3044\x308a\x3087\x3046\x308a", "%[^\x3042\x3044\x3046\x3048\x304a]")[0] ]],
    [[ "\x304b\x3066" ]])

test_equal( array_sscanf("xfoox", "%sfoo%s"), ({ "x", "x" }) )
test_equal( array_sscanf("xfoox", "%sfo\400%s"), ({}) )
test_equal( array_sscanf("xfoox", "%sfo\200000%s"), ({}) )
test_equal( array_sscanf("xfo\400x", "%sfoo%s"), ({}) )
test_equal( array_sscanf("xfo\400x", "%sfo\400%s"), ({ "x", "x" }) )
test_equal( array_sscanf("xfo\400x", "%sfo\200000%s"), ({}) )
test_equal( array_sscanf("xfo\200000x", "%sfoo%s"), ({}) )
test_equal( array_sscanf("xfo\200000x", "%sfo\400%s"), ({}) )
test_equal( array_sscanf("xfo\200000x", "%sfo\200000%s"), ({ "x", "x" }) )

	
test_any([[
class Bar {
  string sum = "";
  void bar(string s) {
    sum += s;
  }
  string foo()
  {
    foreach(({ "foo ", "bar ", "baz " }), string s) {
      sscanf(s, "%*[\t ]%[^ \t]", s);
      switch(foo) {
      default:
        bar(s);
        break;
      }
    }
    return sum;
  }
};
  return Bar()->foo()
]], "foobarbaz")

// sscanf %O -------------------------------------------------------------

define(test_percent_o_raw, [[
   test_equal(array_sscanf(]]$3[[,]]$1[[),[[$2]])
]])
define(test_percent_o_fmt, [[
   test_percent_o_raw(]]$1[[,]]$2[[,sprintf(]]$1[[,@]]$2[[))
]])
define(test_percent_o_char, [[
dnl patsubst doesn't exist on all m4's (it's a gnuism?)
ifdef(patsubst,[[
  test_percent_o_raw("%O",({']]$1[['}),"']]patsubst($1,\\,\\\\)[['"))
  test_percent_o_raw("%O%s",({']]$1[[',"abc"}),"']]patsubst($1,\\,\\\\)[['abc"))
]])]])
ifdef(patsubst,[[
define(test_percent_o_string, [[
  test_percent_o_raw("%O",({"]]$1[["}),"\"]]patsubst($1,\\,\\\\)[[\""))
  test_percent_o_raw("%O%s",({"]]$1[[","abc"}),"\"]]patsubst($1,\\,\\\\)[[\"abc"))
]])]])

test_percent_o_fmt("%O",({10}))
test_percent_o_fmt("%O%s",({10,"abc"}))

test_percent_o_char([[a]])
test_percent_o_char([[\a]])
test_percent_o_char([[\123]])
test_percent_o_char([[\x4711]])
test_percent_o_char([[\d4711]])

test_percent_o_string([[a]])
test_percent_o_string([[\a]])
test_percent_o_string([[\123]])
test_percent_o_string([[\x4711]])
test_percent_o_string([[\d4711]])

test_percent_o_fmt("%O %O %O",({10,20,30}))
test_percent_o_fmt("%O %O %s",({10,20,"30"}))

// -------------------------------------------------------------



// Basics
test_true(1)
test_true("")
test_true(!0)
test_true(!(!1))
test_true(this_object())
test_true(a) // a is the test function
test_true(0.0)
test_true(([]))
test_true(({}))
test_true((<>))
test_true(object_program(this_object()))

// testing !
test_equal(!"",0)
test_equal(!this_object(),0)
test_equal(
#pike 7.0
!Simulate.this_function(),0)

// testing ==
test_true(1==1)
test_true(!(1==2))
test_true(""=="")
test_true(!(""=="foo"))
test_true(this_object()==this_object())
test_true(
#pike 7.0
Simulate.this_function()==a)
test_true(2.0==2.0)
test_true(({})==({}))

// testing !=
test_true(({1})!=({1}))
test_true(1!=2)
test_true(!(1==2))
test_true(!(""!=""))
test_true(""!="foo")

test_cmp3(1,2,3)
test_cmp3(1.0,2.0,3.0)
test_cmp3(1,2.0,3.6)
test_cmp3(1.0,2,4)
test_cmp3("a","b","c")
test_cmp3("","b","cc")
test_cmp3("\x0","\x100","\x10000")
test_cmp3("a\x10000","b\x100","c\x100")

// hex construction
test_eq(0,0x0)
test_eq(1,0x1)
test_eq(10,0xa)
test_eq(16,0x10)
test_eq(65535,0xffff)
test_eq(17*257*65537,0x11111111)

// octal construction
test_eq(0,00)
test_eq(1,01)
test_eq(8,010)
test_eq(64,0100)
test_eq(1073741824,010000000000)
test_eq((8+1)*(8*8+1)*(8*8*8*8+1),011111111)

// string construction tests
test_eq(16,"\20"[0])
test_eq(16,"\020"[0])
test_eq(255,"\377"[0])
test_eq(4,'\4')
test_true("\r"[0]!='r')
test_eq("\r"[0],'\r')
test_eq("\n"[0],'\n')

// testing +
test_eq(1+1,2)
test_eq(1+(-2),-1)
test_eq((-2)+(-2),-4)
test_eq("hi"+"there","hithere")
test_eq("human"+"number"+666,"humannumber666")
test_eq("human"+("number"+666),"humannumber666")
test_eq(("human"+"number")+666,"humannumber666")
test_eq(("human"+"number")+666+111,"humannumber666111")
test_eq("humannumber"+(666+111),"humannumber777")
test_eq("a"+"b"+"c"+"d"+"e"+"f"+"g"+"h"+"i"+"j"+"k"+"l"+"m"+"n"+"o"+"p"+"q"+"r"+"s"+"t"+"u"+"v"+"x"+"y","abcdefghijklmnopqrstuvxy")
test_eq(1.0+1.0,2.0)
test_eq(1.0+(-1.0),0.0)
test_eq((-1.0)+(-1.0),-2.0)
test_eq(1.0+1,2.0)
test_eq(1+1.0,2.0)
test_eq(1+(-1.0),0.0)
test_eq(1.0+(-1),0.0)
test_eq((-1)+(-1.0),-2.0)
test_eq((-1.0)+(-1),-2.0)
test_equal(({1,2,3})+({4,5,6}),({1,2,3,4,5,6}))
test_equal((<1,2,3,4>)+(<4,5,6>),(<1,2,3,4,4,5,6>))
test_equal(([0:1,3:6])+([5:2,3:6]),([0:1,3:6,3:6,5:2]))
test_eval_error(return this_object() + this_object())
test_any(return((1+2+3)-(1+2-3)), 6)


// testing -
test_eq(10-3,7)
test_eq(3-10,-7)
test_eq(10.0-3.0,7.0)
test_eq(3.0-10.0,-7.0)
test_eq(10-3.0,7.0)
test_eq(3-10.0,-7.0)
test_eq(10.0-3,7.0)
test_eq(3.0-10,-7.0)
test_eq(034567 - 10000,4711)
test_eq("foobargazonk"-"o","fbargaznk")
test_equal(({"foo","bar","gazonk"})-({"foo","gazonk"}),({"bar"}))
test_equal(({"c","foo","bar","gazonk","a","b",})-({"foo","gazonk"}),({"c","bar","a","b"}))
test_equal((<"foo","bar","gazonk">)-(<"foo","gazonk">),(<"bar">))
test_equal((["foo":3,"bar":4,"gazonk":5])-(["foo":3,"gazonk":8]),(["bar":4]))

test_any([[string s="\57070 abcdefghijklmnopqrstuvwxyz012345678"; return strlen(s-s[1..35])]],37-35)

// testing ~
test_eq(-1-4,~4)
test_eq(-1-627893874,~627893874)
test_eq(~1.0,-2.0)
test_eq(~"\x55","\xaa")

// testing *
test_eq(3*4,12)
test_eq(4*3,12)
test_eq(2*2*2*2*2,32)
test_eq(3.0*4.0,12.0)
test_eq(4.0*3.0,12.0)
test_eq(2.0*2.0*2.0*2.0*2.0,32.0)
test_eq(3*4.0,12.0)
test_eq(4*3.0,12.0)
test_eq(2*2.0*2.0*2.0*2.0,32.0)
test_eq(3.0*4,12.0)
test_eq(4.0*3,12.0)
test_eq(2.0*2*2.0*2*2.0,32.0)

test_eq([[({})*""]],"")
test_eq([[({"foo",0,"bar"})*"-"]],"foo-bar")
test_eq([[({1.0,"foo",0,"bar",this_object(),([])})*"-"]],"foo-bar")
test_eq([[({"f","o","o"})*""]],"foo")

test_eq(({"foo","bar","gazonk"})*"-","foo-bar-gazonk")
test_eq(({"f\777\777","bar","gaz\777nk"})*"-","f\777\777-bar-gaz\777nk")
test_eq(({"f\7777777\7777777","bar","gaz\7777777nk"})*"-","f\7777777\7777777-bar-gaz\7777777nk")

test_eq(({"foo","bar","gazonk"})*"\777","foo\777bar\777gazonk")
test_eq(({"f\777\777","bar","gaz\777nk"})*"\777","f\777\777\777bar\777gaz\777nk")
test_eq(({"f\7777777\7777777","bar","gaz\7777777nk"})*"\777","f\7777777\7777777\777bar\777gaz\7777777nk")

test_eq(({"foo","bar","gazonk"})*"\7777777","foo\7777777bar\7777777gazonk")
test_eq(({"f\777\777","bar","gaz\777nk"})*"\7777777","f\777\777\7777777bar\7777777gaz\777nk")
test_eq(({"f\7777777\7777777","bar","gaz\7777777nk"})*"\7777777","f\7777777\7777777\7777777bar\7777777gaz\7777777nk")


test_equal( ({ ({1}), ({2}), ({3}) })*({8}), ({1,8,2,8,3}))
test_equal( ({ 1 })*3, ({1,1,1}) )
test_equal( "foo"*3, "foofoofoo" )
test_equal( "foo"*2.5, "foofoofo" )
test_equal( "\1234oo"*2.5, "\1234oo\1234oo\1234o" )

test_equal( ({1,2,3})*1.5, ({1,2,3,1,2}))
test_equal( ({1,2,3})*1.4, ({1,2,3,1}))
test_equal( ({1,2,3})*0.0, ({}))
test_equal( ({})*3.0, ({}))



// testing /
test_eq(12/3,4)
test_eq(13/3,4)
test_eq(14/3,4)
test_eq(15/3,5)
test_eq(-2/4,-1)
test_eq(-12/3,-4)
test_eq(-13/3,-5)
test_eq(-14/3,-5)
test_eq(-15/3,-5)
test_eval_error(return 15/0)
test_eq(12.0/3.0,4.0)
test_eq(14.0/4.0,3.5)
test_eq(15.0/3.0,5.0)
test_eq(12/3.0,4.0)
test_eq(14/4.0,3.5)
test_eq(15/3.0,5.0)
test_eq(12.0/3,4.0)
test_eq(14.0/4,3.5)
test_eq(15.0/3,5.0)
test_eval_error(return 15.0/0.0)
test_equal("foo-bar-gazonk"/"-",({"foo","bar","gazonk"}))
test_equal("foobargazonk"/"",({"f","o","o","b","a","r","g","a","z","o","n","k"}))
test_equal(({1,0,1,2,1,2,2,2,1,1,1})/({2}),({ ({1,0,1}), ({1}), ({}), ({}), ({1,1,1}) }))
test_equal(({1,2,3,4})/({}),({ ({1}), ({2}), ({3}), ({4}) }))
test_equal(({1,0,1,2,1,2,2,2,1,1,1})/({2,1}),({ ({1,0,1}), ({2,2}), ({1,1}) }))
test_equal( ({1,2,3})/({2,3}), ({ ({1}), ({}) }) )
test_eq([[`/(20,2,2)]],5)
test_eq([[`/(13,2,3)]],2)
test_equal("foobargazonk"/1,"foobargazonk"/"")
test_equal("foobargazonk"/2,({"fo","ob","ar","ga","zo","nk"}))
test_equal("foobargazonk"/3,({"foo","bar","gaz","onk"}))
test_equal("foobargazonk"/4,({"foob","arga","zonk"}))
test_equal("foobargazonk"/5,({"fooba","rgazo"}))
test_equal("foobargazonk"/-6,({"foobar","gazonk"}))
test_equal("foobargazonk"/-7,({"rgazonk"}))

test_equal("foobargazonk"/5.0,({"fooba","rgazo","nk"}))
test_equal("foobargazonk"/-5.0,({"fo","obarg","azonk"}))
test_equal("foobargazonk"/2.5,({"foo","ba","rga","zo","nk"}))
test_equal("foo"/2.6,({"foo",""}))
test_equal("\1233oo"/2.6,({"\1233oo",""}))

test_equal("f\777\777bargaz\777nk"/1,"f\777\777bargaz\777nk"/"")
test_equal("f\777\777bargaz\777nk"/2,({"f\777","\777b","ar","ga","z\777","nk"}))
test_equal("f\777\777bargaz\777nk"/3,({"f\777\777","bar","gaz","\777nk"}))
test_equal("f\777\777bargaz\777nk"/4,({"f\777\777b","arga","z\777nk"}))
test_equal("f\777\777bargaz\777nk"/5,({"f\777\777ba","rgaz\777"}))
test_equal("f\777\777bargaz\777nk"/-6,({"f\777\777bar","gaz\777nk"}))
test_equal("f\777\777bargaz\777nk"/-7,({"rgaz\777nk"}))

test_equal("f\777\777bargaz\777nk"/5.0,({"f\777\777ba","rgaz\777","nk"}))
test_equal("f\777\777bargaz\777nk"/-5.0,({"f\777","\777barg","az\777nk"}))
test_equal("f\777\777bargaz\777nk"/2.5,({"f\777\777","ba","rga","z\777","nk"}))

test_equal(""/"hej", ({""}))
test_equal("hej"/"hej", ({"",""}))
test_equal("f\7777777\7777777bargaz\7777777nk"/1,"f\7777777\7777777bargaz\7777777nk"/"")
test_equal("f\7777777\7777777bargaz\7777777nk"/2,({"f\7777777","\7777777b","ar","ga","z\7777777","nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/3,({"f\7777777\7777777","bar","gaz","\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/4,({"f\7777777\7777777b","arga","z\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/5,({"f\7777777\7777777ba","rgaz\7777777"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/-6,({"f\7777777\7777777bar","gaz\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/-7,({"rgaz\7777777nk"}))

test_equal("f\7777777\7777777bargaz\7777777nk"/5.0,({"f\7777777\7777777ba","rgaz\7777777","nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/-5.0,({"f\7777777","\7777777barg","az\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/2.5,({"f\7777777\7777777", "ba","rga","z\7777777","nk"}))

test_equal(({1,2,3})/1,({ ({1}), ({2}), ({3}) }))
test_equal(({1,2,3})/2,({ ({1,2}) }))
test_equal(({1,2,3})/-2,({ ({2,3}) }))

test_equal(({1,2,3})/2.0,({ ({1,2}), ({3}) }))
test_equal(({1,2,3})/-2.0,({ ({1}), ({2,3}) }))
test_equal(({1,2,3})/1.5,({ ({1, 2}), ({3}) }))

// testing %
test_eq(12%3,0)
test_eq(13%3,1)
test_eq(14%3,2)
test_eq(15%3,0)
test_eq(2%17,2)
test_eq(2%-17,-15)
test_eq(-2%17,15)
test_eq(-2%-17,-2)
test_eq(-10%10,0)
test_eq(10%-10,0)
test_eq(-10%-10,0)
test_eq(10%10,0)
test_eval_error(return 15 % 0)
test_eq(12.0 % 3.0,0.0)
test_eq(13.0 % 3.0,1.0)
test_eq(14.0 % 3.0,2.0)
test_eq(14.5 % 3.0,2.5)
test_eq(15.0 % 3.0,0.0)
test_eq(13 % 3.0,1.0)
test_eq(14 % 3.0,2.0)
test_eq(13.0 % 3,1.0)
test_eq(14.0 % 3,2.0)
test_eq(14.5 % 3,2.5)
test_eval_error(return 15.0 % 0.0)

test_eq("foobargazonk"%5,"nk")
test_eq("foobargazonk"%-5,"fo")
test_eq("f\777\777bargaz\777nk"%5,"nk")
test_eq("f\777\777bargaz\777nk"%-5,"f\777")
test_eq("f\7777777\7777777bargaz\7777777nk"%5,"nk")
test_eq("f\7777777\7777777bargaz\7777777nk"%-5,"f\7777777")
test_equal(({1,2,3})%2,({3}))
test_equal(({1,2,3})%-2,({1}))


// testing &&
test_eq(0 && 1,0)
test_eq(1 && 0,0)
test_eq(0 && 0,0)
test_eq(1 && 1,1)
test_eq(78 && 1,1)
test_eq(78 && 99,99)
test_eq(78 && 99,99)

// testing ||
test_eq(0 || 1,1)
test_eq(1 || 0,1)
test_eq(0 || 0,0)
test_eq(1 || 1,1)
test_eq(78 || 1,78)
test_eq(78 || 0,78)

// testing |
test_eq(0 | 0,0)
test_eq(1 | 1,1)
test_eq(4 | 1,5)
test_eq(1 | 9,9)
test_eq([[ "\007" | "\023"]],"\027")
test_eq([[ "\177777x" | "ab" ]], "\177777z")
test_equal( ({1,2,3,4,4}) | ({3,5,6}), ({1,2,3,4,4,5,6}))
test_equal( (<4,5,6>) | (<5,5,5>), (<4,5,5,5,6>) )
test_equal( ([-4:8,8:7]) | ([3:3,8:3]), ([-4:8,8:3,3:3]) )
test_any([[
  class Foo {int `< (object o) {return 0;}};
  return sizeof (({Foo()}) | ({Foo()}));
]], 2)

// testing &
test_eq(0 & 0,0)
test_eq(1 & 1,1)
test_eq(4 & 1,0)
test_eq(1 & 9,1)
test_eq([[ "\007" & "\023"]],"\003")
test_eq([[ "\177777x" & "ab" ]], "a`")
test_equal( ({1,2,3,4,4}) & ({3,5,6}), ({3}))
test_equal( (<4,5,6>) & (<5,5,5>), (<5>) )
test_equal( ([-4:8,8:7]) & ([3:3,8:3]), ([8:3]) )
test_equal(({1,2,1}) & ({1,2}), ({1,2}))
test_equal(({2,1,2}) & ({1,2}), ({2,1}))
test_equal(({1,2,1,2,2}) & ({1,2}), ({1,2}))
test_equal(({2,1,2,1,2}) & ({1,2}), ({2,1}))

// testing ^
test_eq(0 ^ 0,0)
test_eq(1 ^ 1,0)
test_eq(4 ^ 1,5)
test_eq(1 ^ 9,8)
test_eq([[ "\007" ^ "\023"]],"\024")
test_eq([[ "\177777x" ^ "ab" ]], "\177636\32")
test_equal( ({1,2,3,4,4}) ^ ({3,5,6}) , ({1,2,4,4,5,6}))
test_equal( (<4,5,6>) ^ (<5,5,5>), (<4,5,5,6>) )
test_equal( ([-4:8,8:7]) ^ ([3:3,8:3]), ([-4:8,3:3]) )
test_equal(({1,3,3,3,4}) ^ ({2,3,3,5}), ({1,3,4,2,5}))
test_equal(({1,3,3,4}) ^ ({2,3,3,3,5}), ({1,4,2,3,5}))

// testing <<
test_eq(1<<0,1)
test_eq(1<<1,2)
test_eq(1<<10,1024)
test_eq(5<<3,40)
test_eval_error(return 17<<-10)

// testing >>
test_eq(9>>2,2)
test_eq(1>>1,0)
test_eq(1024>>10,1)
test_eq(47>>3,5)
test_eq(-10>>10000,-1)
test_eval_error(return 17>>-10)

// testing ? :
test_true(0?0:1)
test_true(1?1:0)
test_true(""?1:0)
test_true(!0?1:0)
test_true(!(!1)?1:0)
test_true(this_object()?1:0)
test_true(a?1:0) // a is the test function
test_true(0.0?1:0)
test_true(([])?1:0)
test_true(({})?1:0)
test_true((<>)?1:0)
test_true(object_program(this_object())?1:0)
test_eq(1 ? "a" : 1 ? "b" : 1, "a")
test_eq(0 ? "a" : 1 ? "b" : 1 ? "c" : 1, "b")
test_eq(0 ? "a" : 0 ? "b" : 1 ? "c" : 1, "c")

// testing indexing
test_eq("foo"[0],'f')
test_eq("foo"[1],'o')
test_eq("foo"[2],'o')
test_eq("foo"[-1],'o')
test_eq("foo"[-2],'o')
test_eq("foo"[-3],'f')

test_eq("f\777\777"[0],'f')
test_eq("f\777\777"[1],'\777')
test_eq("f\777\777"[2],'\777')
test_eq("f\777\777"[-1],'\777')
test_eq("f\777\777"[-2],'\777')
test_eq("f\777\777"[-3],'f')

test_eq("f\77777777\77777777"[0],'f')
test_eq("f\77777777\77777777"[1],'\77777777')
test_eq("f\77777777\77777777"[2],'\77777777')
test_eq("f\77777777\77777777"[-1],'\77777777')
test_eq("f\77777777\77777777"[-2],'\77777777')
test_eq("f\77777777\77777777"[-3],'f')

test_eq(({'f','o','o'})[0],'f')
test_eq(({'f','o','o'})[1],'o')
test_eq(({'f','o','o'})[2],'o')
test_eq(({'f','o','o'})[-1],'o')
test_eq(({'f','o','o'})[-2],'o')
test_eq(({'f','o','o'})[-3],'f')
test_eq(([0:'f',1:'o',2:'o'])[0],'f')
test_eq(([0:'f',1:'o',2:'o'])[1],'o')
test_eq(([0:'f',1:'o',2:'o'])[2],'o')
test_eq(([0:'f',1:'o',2:'o'])[3],0)
test_eq(([0:'f',1:'o',2:'o'])[-1],0)
test_eq((<'f','o','o'>)['o'],1)
test_eq((<'f','o','o'>)['f'],1)
test_eq((<'f','o','o'>)['b'],0)
test_eq((<'f','o','o'>)[-1],0)

test_eq([[class Z { mixed `->(mixed x) { return this_object()[x]; } int foo() { return 1; }}()->foo()]],1)

// index assigning
test_any(mixed a=({1}); a[0]=2; return equal(a,({2})),1)
test_any(mixed a=(<1>); a[1]=2; return equal(a,(<1>)),1)
test_any(mixed a=(<1>); a[0]=2; return equal(a,(<1,0>)),1)
test_any(mixed a=(<1>); a[1]=0; return equal(a,(<>)),1)
test_any(mixed a=(<1>); a[0]=0; return equal(a,(<1>)),1)
test_any(mixed a=([1:1]); a[0]=0; return equal(a,([1:1,0:0])),1)
test_any(mixed a=([1:1]); a[1]=0; return equal(a,([1:0])),1)

test_define_program(test,[[public int q,w,e,r; mixed t; mixed getw() { return w; } void setw(int _) { w=_; }]])
test_eq(test()->q,0)
test_eq(test()->w,0)
test_eq(test()->e,0)
test_eq(test()->r,0)
test_eq(test()->getw(),0)
test_any(object o=test(); o->setw(17); return o->w,17)
test_any(object o=test(); o->w=17; return o->getw(),17)

test_eq(test()["q"],0)
test_eq(test()["w"],0)
test_eq(test()["e"],0)
test_eq(test()["r"],0)
test_eq(test()["getw"](),0)
test_any(object o=test(); o["setw"](17); return o["w"],17)
test_any(object o=test(); o["w"]=17; return o["getw"](),17)
test_do(add_constant("test");)

// testing range
test_eq("foObar"[0..0],"f")
test_eq("foobargazonk"[3..5],"bar")
test_eq("foo"[1..10],"oo")
test_eq("foo"[-100..0],"f")
test_eq("foo"[-100..100],"foo")
test_eq("foo"[1..0],"")
test_eq("foo"[0..-100],"")
test_eq("foobargazonk"[0..],"foobargazonk")
test_eq("foobargazonk"[1..],"oobargazonk")
test_eq("foobargazonk"[5..],"rgazonk")
test_eq("foobargazonk"[..2],"foo")
test_eq("foobargazonk"[..5],"foobar")

test_eq("f\7777\7777bargaz\7777nk"[0..],"f\7777\7777bargaz\7777nk")
test_eq("f\7777\7777bargaz\7777nk"[1..],"\7777\7777bargaz\7777nk")
test_eq("f\7777\7777bargaz\7777nk"[5..],"rgaz\7777nk")
test_eq("f\7777\7777bargaz\7777nk"[..2],"f\7777\7777")
test_eq("f\7777\7777bargaz\7777nk"[..5],"f\7777\7777bar")

test_eq("f\77777777\77777777bargaz\77777777nk"[0..],"f\77777777\77777777bargaz\77777777nk")
test_eq("f\77777777\77777777bargaz\77777777nk"[1..],"\77777777\77777777bargaz\77777777nk")
test_eq("f\77777777\77777777bargaz\77777777nk"[5..],"rgaz\77777777nk")
test_eq("f\77777777\77777777bargaz\77777777nk"[..2],"f\77777777\77777777")
test_eq("f\77777777\77777777bargaz\77777777nk"[..5],"f\77777777\77777777bar")

test_equal(({1,2,3})[0..0],({1}))
test_equal(({1,2,3})[1..2],({2,3}))
test_equal(({1,2,3})[2..10],({3}))
test_equal(({1,2,3})[-100..0],({1}))
test_equal(({1,2,3})[-100..100],({1,2,3}))
test_equal(({1,2,3})[1..0],({}))
test_equal(({1,2,3})[0..-100],({}))

// casting
test_eq([[(int)1]],[[1]])
test_eq([[(int)-1]],[[-1]])
test_eq([[(int)1.0]],[[1]])
test_eq([[(int)-1.0]],[[-1]])
test_eq([[(int)"1"]],[[1]])
test_eq([[(int)"-1"]],[[-1]])
test_eq([[(int)"0x1"]],[[0]])
test_eq([[(int)"010"]],[[10]])
test_eq([[(float)"1"]],[[1.0]])
test_eq([[(float)"-1"]],[[-1.0]])
test_eq([[(float)"1.0"]],[[1.0]])
test_eq([[(float)"-1.0"]],[[-1.0]])
test_eq([[(float)1.0]],[[1.0]])
test_eq([[(float)-1.0]],[[-1.0]])
test_eq([[(float)1]],[[1.0]])
test_eq([[(float)-1]],[[-1.0]])
test_eq([[(string)1]],[["1"]])
test_eq([[(string)-1]],[["-1"]])
test_any([[
  array foo=({ 1 });
  return (string)sizeof(foo);
]], [["1"]])
test_any([[
  array foo=({ -1 });
  return (string)-sizeof(foo);
]], [["-1"]])
test_equal([[(array)(["1":1])]],[[ ({ ({"1", 1}) }) ]])
test_equal([[(array(int)) ({"1","4711",2.0,4})]],[[({1,4711,2,4})]])
test_equal([[(array(array))({({})})]],[[({({})})]])
test_equal([[ (array(array(int))) ({ ({"1","4711",2.0,4}) }) ]],[[ ({ ({1,4711,2,4}) }) ]])
test_equal([[ (array(array(array(int)))) ({ ({ ({"1","4711",2.0,4}) }) }) ]],[[ ({ ({ ({1,4711,2,4}) }) }) ]])
test_equal([[ (array(array(array(array(int))))) ({ ({ ({ ({"1","4711",2.0,4}) }) }) }) ]],[[ ({ ({ ({ ({1,4711,2,4}) }) }) }) ]])

test_equal([[(array)"foo"]],[[ values("foo") ]])
test_equal([[(array)(<1,2,3>)]],[[ indices( (<1,2,3>) )]])
test_equal([[sort(column((array)([1:2,3:4]),0))]],[[ sort(indices(([1:2,3:4])) )]])
test_equal([[sort(column((array)([1:2,3:4]),1))]],[[ sort(values(([1:2,3:4])))]])
test_true([[(array(array))([]) ]])
test_true([[(array(array))([1:2]) ]])
test_true([[(array(array))([1:2,3:4]) ]])
test_true([[(array(array))([1:2,3:4,5:6]) ]])
test_equal( [[ (multiset) ({1})]], [[ (< 1 >) ]] )
test_equal( [[ (multiset(string)) ({1})]], [[ (< "1" >) ]] )
test_eval_error([[return (mapping)""]])
test_equal([[ (mapping)({({1,2}),({3,4})})]], [[([1:2,3:4]) ]])
test_equal([[ ({({1,2})})]], [[(array)([1:2]) ]])
test_equal([[ (mapping)({})]], [[ ([]) ]])
test_equal([[ ({}) ]], [[ (array)([]) ]])
test_eval_error([[ mapping m=(mapping)({ ({1,2,3}), ({4,5,6}) }); ]])

// testing @
test_equal(({1,2,3}),lambda(mixed ... x) { return x; }(@a()))
test_equal("foo"/"",lambda(mixed ... x) { return x; }(@a()))
test_any([[array a=({1,2,3}); return lambda(mixed ... x) { return x; }(@a) !=a]],1)
test_any([[array z=({lambda(mixed x){return x;},17});return `()(@z);]],17)

// testing +=
test_any(int a=1; a+=10; return a,11)
// testing -=
test_any(int a=1; a-=10; return a,-9)
// testing &=
test_any(int a=3; a&=10; return a,2)
// testing |=
test_any(int a=3; a|=10; return a,11)
// testing ^=
test_any(int a=3; a^=10; return a,9)
// testing <<=
test_any(int a=3; a<<=2; return a,12)
// testing <<=
test_any(int a=12; a>>=2; return a,3)
// testing *=
test_any(int a=12; a*=2; return a,24)
// testing /=
test_any(int a=12; a/=2; return a,6)
// testing %=
test_any(int a=12; a%=7; return a,5)

// testing control structs
test_any(return 1,1)
test_any(return lambda(){return 1;} (),1 )
test_any(if(0) return 0; else return 1,1)
test_any(if(0) return 0; return 1,1)
test_any(if(1) return 1; else return 0,1)
test_any(if("") return 1; else return 0,1)
test_any(if(!0) return 1; else return 0,1)
test_any(if(!(!1)) return 1; else return 0,1)
test_any(if(this_object()) return 1; else return 0,1)
test_any(if(a) return 1; else return 0,1) dnl a is the test function
test_any(if(0.0) return 1; else return 0,1)
test_any(if(([])) return 1; else return 0,1)
test_any(if(({})) return 1; else return 0,1)
test_any(if((<>)) return 1; else return 0,1)
test_any(if(object_program(this_object())) return 1; else return 0,1)

// break
test_any(while(1) break; return 1,1)
test_any(while(1) if(1) break; return 1,1)

// for
test_program(
array(int) ia=({1,2,3,4,5,6});

int a()
{
  int i;
  for (i=0; i<sizeof(ia); i++)
    {
      if (ia[i]==3)
	{
	  ia=ia[..i-1]+ia[i+1..];
	  --i;
	}
    }
  return 1;
}
)
test_any(int e; for(e=0;e<10;e++) break; return e,0)
test_any(int e; for(e=0;e<10;e++) continue; return e,10)
test_any(int e;string t=""; for(e=0;e<10;e++) t+=e; return t,"0123456789")
test_any(int e;string t=""; for(e=0;e<=10;e++) t+=e; return t,"012345678910")
test_any(int e;string t=""; for(e=9;e>0;e--) t+=e; return t,"987654321")
test_any(int e;string t=""; for(e=9;e>=0;e--) t+=e; return t,"9876543210")
test_any(int e;string t=""; for(e=9;e!=0;e--) t+=e;  return t,"987654321")
test_any(int e;string t=""; for(e=2;e!=10;e++) t+=e; return t,"23456789")
test_any(int e;string t=""; for(e=0;e>-10;e--) t+=e; return t,"0-1-2-3-4-5-6-7-8-9")

// foreach
test_any([[int e;string t=""; foreach(({7,6,3,8}),e) t+=e; return t]],"7638")
test_any([[
  /* FIXME: This test needs to be proofed against the optimizer. */
  string s;if(1) foreach(({}),s); else foreach(({}),s); return 1
]],1)

test_any([[
  int ret;
  foreach( ([1:2,3:5,7:11,13:17]) ; int a ; int b) ret+=a*b;
  return ret;
]],315)

test_any([[
  int ret;
  foreach( ([1:2,3:5,7:11,13:17]) ; ; int b) ret+=b;
  return ret;
]],35)

test_any([[
  int ret;
  foreach( ([1:2,3:5,7:11,13:17]) ; int a; ) ret+=a;
  return ret;
]],24)

test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; ; int b) ret+=b;
  return ret;
]],4)

test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; int a; ) ret+=a;
  return ret;
]],24)

test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; ; ) ret++;
  return ret;
]],4)


test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; int a; int b) ret+=a+b;
  return ret;
]],24+4)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; int a; ) ret+=a;
  return ret;
]],6)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; ; int b) ret+=b;
  return ret;
]],35)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; int a; int b) ret+=a*b;
  return ret;
]],78)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; ; ) ret++;
  return ret;
]],4)

test_any([[
  int ret;
  foreach( "foobar" ; int a; int b) ret+=a*b;
  return ret;
]],1585)

test_any([[
  int ret;
  foreach( "foobar" ; int a;) ret+=a;
  return ret;
]],15)

test_any([[
  int ret;
  foreach( "foobar" ; ; int b) ret+=b;
  return ret;
]],633)

test_any([[
  mapping m=([1:2,3:5,7:11,13:17]);
  foreach(m  ; int a ; int b) m_delete(m,a);
  return sizeof(m);
]],0)

test_any([[
  mapping m=([1:2,3:5,7:11,13:17]);
  int ret;
  foreach(m  ; int a ; int b) { m_delete(m,a); ret+=a*b; }
  return ret;
]],315)

test_eval_error([[
  int i;
  foreach (class{}(); mixed a; mixed b) i++;
  return i;
]])

test_any([[
  String.Iterator iter = String.Iterator ("foo");
  foreach (iter; int idx;)
    if (idx != iter->index()) return 1;
  return 0;
]], 0)

// do-while
test_any(int e;string t=""; e=0; do{ t+=e; }while(++e<6); return t,"012345";)

// while
test_any(int e;string t=""; e=8; while(--e) t+=e; return t,"7654321";)
test_any(int e;string t=""; e=8; while(e--) t+=e; return t,"76543210";)
test_any(int e;string t=""; e=0; while(++e<6) t+=e; return t,"12345";)
test_any(int e=1;string t=""; while(e<20){t+=e;e*=2;} return t,"124816";)

// Switch
test_any(switch((mixed)"") { case -1: case "gazonk": return 0; } return 1,1)
test_any(switch((mixed)"") { case -2: case "gazonk": return 0; } return 1,1)
test_any(switch((mixed)"") { case 0: case "gazonk": return 0; } return 1,1)
test_any(switch((mixed)"") { case "gazonk": case 0: return 0; } return 1,1)
test_any(switch((mixed)0) { case 0: case "gazonk": return 0; } return 1,0)
test_any(switch((mixed)"gazonk") { case "gazonk": case 0: return 0; } return 1,0)
test_any(switch((mixed)0) { case "": } return 1,1)
test_any(switch((mixed)1) { case 1: return 1; default: } return 0,1)
test_any(switch((mixed)2) { case 1: return 0; default: return 1;} return 0,1)
test_any(switch((mixed)1) { default: return 0; case 1: return 1; } return 0,1)
test_any(switch((mixed)2) { default: return 1; case 1: return 0; } return 0,1)
test_any(switch((mixed)0) { case "apa": case 1.0: return 0; }  return 1,1)
test_any(switch((mixed)"apa") { case "apa": return 1; case 1.0: }  return 0,1)
test_any(switch((mixed)1.0) { case "apa": return 0; case 1.0: return 1; } return 0,1)
test_any(switch((mixed)"sune") { case "gunnel": return 0; case "gunnar": return 1; case "sune": case "gusten": return 0; } return 0,0)
test_any(switch((mixed)"a") { case "a": return 1; case "b": case "c": case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)"b") { case "a": return 0; case "b": return 1; case "c": case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)"c") { case "a": case "b": return 0; case "c": return 1; case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)"d") { case "a": case "b": case "c": return 0; case "d": return 1; case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)'a') { case "a": case "b": case "c": case "d": return 0; case 'a': return 1; case '1': case '0': default: } return 0,1)
test_any(switch((mixed)'1') { case "a": case "b": case "c": case "d": case 'a': return 0; case '1': return 1; case '0': default: } return 0,1)
test_any(switch((mixed)'0') { case "a": case "b": case "c": case "d": case 'a': case '1': return 0; case '0': return 1; default: } return 0,1)
test_any(switch((mixed)"a") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,1)
test_any(switch((mixed)"b") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,2)
test_any(switch((mixed)"c") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,3)
test_any(switch((mixed)"d") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,4)
test_any(switch((mixed)'a') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,5)
test_any(switch((mixed)'1') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,6)
test_any(switch((mixed)'0') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,7)
test_any(switch((mixed)'9') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,8)

test_program([[
void bar() {}
int a()
{
  foreach( ({1}), int n)
  {
    switch(n)
    {
      default:
      bar();
      break;
    }
  }
  return 1;
}
]])


define(test_switch0,[[
test_any(switch((mixed)$1) { $2; $3; $4; $5; } return 0,$6)
test_any(switch((mixed)$1) { default: return 0; $2; $3; $4; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; default: return 0; $3; $4; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; $3; default: return 0; $4; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; $3; $4; default: return 0; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; $3; $4; $5; default: return 0; } return -1,$6)
]])

define(test_switch1,[[
test_switch0($1, $2,$3,$4,$5, $6)
test_switch0($1, $2,$3,$5,$4, $6)
]])

define(test_switch2,[[
test_switch1($1, $2,$3,$4,$5, $6)
test_switch1($1, $2,$4,$3,$5, $6)
test_switch1($1, $2,$5,$4,$3, $6)
]])

define(test_switch3,[[
test_switch2($1,case $2:return 2,case $3:return 3,case $4:return 4,case $5:return 5,$6)
test_switch2($1,case $3:return 3,case $2:return 2,case $4:return 4,case $5:return 5,$6)
test_switch2($1,case $4:return 4,case $3:return 3,case $2:return 2,case $5:return 5,$6)
test_switch2($1,case $5:return 5,case $3:return 3,case $4:return 4,case $2:return 2,$6)
]])

define(test_switch4,[[
test_switch3($1,$2,$3,$4,$5,0)
test_switch3($2,$2,$3,$4,$5,2)
test_switch3($3,$2,$3,$4,$5,3)
test_switch3($4,$2,$3,$4,$5,4)
test_switch3($5,$2,$3,$4,$5,5)
]])

test_switch4(17,18,19,20,21)
test_switch4("a","b","c","d","e")
test_switch4("a",0,"c","d","e")
test_switch4(1.0,2.0,3.0,4.0,5.0)
test_switch4(this_object(),"",0,4.0,1)

test_any(int e;string t=""; for(e=0;e<10;e++) switch(e) { default: t+=e; case 4..8: } return t,"01239")

// use sprintf here; the sums aren't totally equal for doubles (error~=1e-16)
test_any([[float e,q; q=0.0; for(e=0.1;e<10.0;e+=1.0) switch(e) { default: q+=e; case 4.0..8.0: } return sprintf("%.6f",q)]],[[sprintf("%.6f",0.1+1.1+2.1+3.1+8.1+9.1)]])

test_compile_error([[switch (1) {case 1: break; case 1: break;}]])
test_compile_error([[switch (1) {case 1: break; case 0..2: break;}]])
test_compile_error([[switch (1) {case 1..2: break; case 0..3: break;}]])
test_compile_error([[switch (1) {case 1..3: break; case 0..2: break;}]])
test_compile_error([[switch (1) {case 1..2: break; case 0..: break;}]])
test_compile_error([[switch (1) {case 1..2: break; case ..3: break;}]])
test_compile_error([[switch (1) {case 1..: break; case ..3: break;}]])
test_compile_error([[switch (1) {case ..: break;}]])
test_compile_error([[switch (1) {case "x"..: break;}]])
test_compile_error([[switch (1) {case .."y": break;}]])
test_compile_error([[switch (1) {case "x".."y": break;}]])

define(test_switch_ranges,[[
  test_any_equal([[
    int f (int i) {{$1;} return 0;};
    array res = ({});
    for (int i = -3; i <= 3; i++) res += ({f (i)});
    return res;
  ]], $2)
]])

test_switch_ranges([[
  switch (i) {case 1..2: return 2; case -2..-1: return 1;}
]], ({0, 1, 1, 0, 2, 2, 0}))
test_switch_ranges([[
  switch (i) {case 1..2: return 2; case -2..0: return 1;}
]], ({0, 1, 1, 1, 2, 2, 0}))
test_switch_ranges([[
  switch (i) {case 1..2: return 2; case -2..-1: return 1; case 0: return 3;}
]], ({0, 1, 1, 3, 2, 2, 0}))
test_switch_ranges([[
  switch (i) {case 1..2: return 2; case ..-1: return 1; case 0: return 3;}
]], ({1, 1, 1, 3, 2, 2, 0}))
test_switch_ranges([[
  switch (i) {case 1..: return 2; case -2..-1: return 1; case 0: return 3;}
]], ({0, 1, 1, 3, 2, 2, 2}))
test_switch_ranges([[
  switch (i) {case 1..: return 2; case ..-1: return 1; case 0: return 3;}
]], ({1, 1, 1, 3, 2, 2, 2}))

// Breaks and continues with labels
test_compile_error([[break;]])
test_compile_error([[continue;]])
test_compile_error([[foo: break;]])
test_compile_error([[foo: continue;]])
test_compile_error([[break foo;]])
test_compile_error([[continue foo;]])
test_any([[foo: break foo; return 1;]], 1)
test_compile_error([[foo: continue foo;]])
test_compile_error([[int a; foo: if (a++) a++; else foo: a++;]])
test_compile_error([[int a; foo: foo: if (a++) a++; else a++;]])
test_compile([[int a; foo: if (a++) a++; foo: a++;]])
test_compile_error([[int a; do if (a++) break foo; while (0);]])
test_compile([[int a; do foo: if (a++) break foo; while (0);]])
test_compile([[int a; foo: do if (a++) break foo; while (0);]])
test_compile_error([[int a; do foo: if (a++) continue foo; while (0);]])
test_compile([[int a; foo: do if (a++) continue foo; while (0);]])
test_any([[
  int i;
  for (i = 1; i <= 4; i++)
    foo: break;
  return i;
]], 1);
test_any([[
  int i;
  for (int j = 1; j <= 4; j++) {
    foo: continue;
    i = j;
  }
  return i;
]], 0);
test_any([[
  int i;
  for (i = 1; i <= 4; i++)
    foo: {
      if (i > 5) break foo;
      break;
    }
  return i;
]], 1);
test_any_equal([[
  int a, b;
foo:
  for (int i = 1; i <= 4; i++) {
    a = i;
    switch (1) {
      case 1:
	if (i >= 3) break foo;
	if (i >= 2) continue foo;
    }
    b = i;
  }
  return ({a, b});
]], ({3, 1}));
test_any_equal([[
  int a, b;
foo: {
    for (int i = 1; i <= 4; i++) {
      a = i;
      switch (1) {
	case 1:
	  if (i >= 3) break foo;
      }
      b = i;
    }
  }
  return ({a, b});
]], ({3, 2}));
test_any_equal([[
  array res = ({});
  foreach (({1, 2, 3}), int x) {
    res += ({-x});
  foo:
    foreach (({1, 2, 3, 4}), int i) {
      res += ({i});
      foreach (({1, 2}), int y) {
	if (i >= 3) break foo;
	if (i >= 2) continue foo;
      }
      res += ({i});
    }
  }
  return res;
]], ({-1, 1, 1, 2, 3, -2, 1, 1, 2, 3, -3, 1, 1, 2, 3}));
test_any_equal([[
  int a, b;
foo:
  for (int i = 1; i <= 4; i++) {
    a = i;
    catch {
      catch {
	if (i >= 3) break foo;
	if (i >= 2) continue foo;
      };
    };
    b = i;
  }
  return ({a, b});
]], ({3, 1}));
test_any_equal([[
  int a, b;
foo:
  for (int i = 1; i <= 4; i++) {
    a = i;
    catch {
      catch {
	if (i >= 3) break;
	if (i >= 2) continue;
      };
    };
    b += i;
  }
  return ({a, b});
]], ({4, 8}));
test_any([[
foo:
  if (stringp (catch {int q=1; break foo;}) + 1) return 1;
  else return 2;
  return 3;
]], 3);
test_any([[
foo:
  do {
    if ((3*time() + 5) + stringp (catch {int q=1; break foo;})) return 1;
    else return 2;
  } while (0);
  return 3;
]], 3);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (1,2,3, gauge {break foo;},4,5);
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@indices (all_constants()), gauge {break foo;});
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (1,2,3, catch {int q=1; break foo;},4,5);
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@indices (all_constants()), catch {int q=1; break foo;});
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@({1,2,3,4,5}), catch {int q=1; break foo;});
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@indices (all_constants()), @allocate (511, 1), catch {int q=1; break foo;});
]]);
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@allocate (511, 1), @indices (all_constants()), catch {int q=1; break foo;});
]]);
test_compile_error([[
foo: {
    @indices (all_constants());
    break foo;
  }
]]);
test_do([[
  // Note: This is valid <= 7.0 code.
  foreach (({1,2,3}), int j)
    do
      if (17 + j + gauge {break;}) return 0;
    while (0);
]]);
test_do([[
  int gnu (mixed... args) {};
  gnu(@indices (all_constants()), gauge {
    foreach (({1,2,3}), int j)
      do
        if (gnu(@indices (all_constants()),
		17 + gauge {break;}))
	  return 0;
      while (0);
  });
]]);
test_do([[
  int gnu (mixed... args) {};
foo:
  gnu(@indices (all_constants()), gauge {
    foreach (({1,2,3}), int j)
      do
        if (gnu(@indices (all_constants()),
		17 + gauge {break foo;}))
	  return 0;
      while (0);
  });
]]);

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]])

test_compile_any([[import Stdio.Readline; mapping x=([]);]]);

// testing preprocessor
test_eq([[cpp("#define FOO(X,Y) (X) (Y)\nFOO( (A),(B) )")]],"# 1 \"-\"\n\n( (A) ) ( (B) )")
test_eq([[cpp("#define F 'F'\nF")]],"# 1 \"-\"\n\n'F'")
test_eq([[cpp("#define MAX(X,Y) ((X)>(Y)?(X):(Y))\n#define MAX3(X,Y,Z) MAX(MAX(X,Y),Z)\nMAX3(1,2,3)")]],"# 1 \"-\"\n\n\n(( (( 1 )>( 2 )?( 1 ):( 2 )) )>( 3 )?( (( 1 )>( 2 )?( 1 ):( 2 )) ):( 3 ))")
test_eq([[cpp("foo\xfeff""bar \xfeff gazonk")]],[[cpp("foobar  gazonk")]])
test_eq([[cpp("#define A(X) #X\n#define B(Y) A(Y)\nB(foo)")]],
	"# 1 \"-\"\n\n\n \"foo\" ")
test_eq([[cpp("#define FOO(X) X\nFOO(\"\\\n\")\n")]], "# 1 \"-\"\n\n\n \"\" \n");
test_eq([[cpp("#define FOO(X) X\r\nFOO(\"\\\r\n\")\r\n")]], "# 1 \"-\"\n\n\n \"\"  \n" /* Note: Added extra space for \r. */);
test_equal([[compile_string("#define FOO(X) X\nstring s=FOO(\"\\\n\\\n\");\nmixed f() {return ({__LINE__, backtrace()[-1][1]});}\n")()->f()]], ({5, 5}));
test_equal([[compile_string("#define FOO(X) X\nstring s=FOO(#\"\n\n\");\nmixed f() {return ({__LINE__, backtrace()[-1][1]});}\n")()->f()]], ({5, 5}));
// The following two tests are in triplicate to force testing in all shifts.
test_do([[
#define FOO(X) X
string s = FOO (#"a
b
c");
]]);
test_do([[
#define FOO(X) X
string s = FOO (#"a
b
c");
]]);
test_do([[
#define FOO(X) X
string s = FOO (#"a
b
c");
]]);
test_any([[
#define FOO(X) X
FOO ("\
\
");
return __LINE__;
]], 6);
test_any([[
#define FOO(X) X
FOO ("\
\
");
return __LINE__;
]], 6);
test_any([[
#define FOO(X) X
FOO ("\
\
");
return __LINE__;
]], 6);

test_eq([[compile_string(#"
#define Y(y) #y
#define X(x) x(z)
string a() {return X(Y);}
")()->a()]], "z")
test_eq([[compile_string(#"
#define Y() \"z\"
#define X(x) x()
string a() {return X(Y);}
")()->a()]], "z")
test_compile_error([[
#define Y(y) y
#define X(x) x()
X(Y)
]])
test_compile_error([[
#define Y() y
#define X(x) x(z)
X(Y)
]])
test_true([[compile_string(#"
#define Y() z
#define X(x) x()
int z() {return 0;}
mixed a() {return functionp(X(Y));}
")()->a()]])
test_false([[compile_string(#"
#define Y z
#define X(x) x()
int z() {return 0;}
mixed a() {return functionp(X(Y));}
")()->a()]])

test_do([[
  Stdio.write_file("testsuite_test.pmod", "syntax error");
  object orig_master = master();
  replace_master(object_program(orig_master)());
  mixed err = catch {
    compile_string(#"
#ifdef NONEXISTING_DEFINE
#error Not expected
#if constant (.testsuite_test)
#error Not expected either
#endif
#endif", "testsuite_test");
  };
  replace_master(orig_master);
  if (err) throw (err);
]]);

test_do([[
  Stdio.write_file("testsuite_test.pmod", "syntax error");
  object orig_master = master();
  replace_master(object_program(orig_master)());
  mixed err = catch {
    compile_string(#"
#if defined (NONEXISTING_DEFINE) && constant (.testsuite_test)
#error Not expected
#endif", "testsuite_test");
  };
  replace_master(orig_master);
  if (err) throw (err);
]]);

test_any([[
  class handler {mapping get_predefines() {return (["x": "1", "y": "", "z": 0]);}};
  return cpp ("x y z p", "-", 0, handler());
]], "# 1 \"-\"\n1   p");
test_eval_error([[
  class handler {mixed get_predefines() {return (<"x">);}};
  cpp ("x y z", "-", 0, handler());
]]);
test_eval_error([[
  class handler {mapping get_predefines() {return ([0: 0]);}};
  cpp ("x y z", "-", 0, handler());
]]);
test_eval_error([[
  class handler {mapping get_predefines() {return (["": 1]);}};
  cpp ("x y z", "-", 0, handler());
]]);
test_eval_error([[
  class handler {mapping get_predefines() {return (["x": 1]);}};
  cpp ("x y z", "-", 0, handler());
]]);

test_true( Stdio.write_file("conftest.h", "return 17;\n") )

test_any([[
#include "conftest.h"
]],17)
dnltest_any([[
dnl#include <conftest.h>
dnl]],17)

test_true( rm("conftest.h") )

test_true(intp(__LINE__))
test_true(stringp(__FILE__))
test_true(stringp(__DATE__))
test_true([[ sscanf(__DATE__, "%3s %d %d", string m, int d, int y) == 3 &&
	     search(({"Jan", "Feb", "Mar", "Apr", "May", "Jun",
		      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}), m) != -1 &&
	     intp(d) && d>0 && d<32 && intp(y) ]])
test_true(stringp(__TIME__))
test_true([[ sscanf(__TIME__, "%d:%d:%d", int h, int m, int s) == 3 &&
	     intp(h) && intp(m) && intp(s) &&
	     h>=0 && m>=0 && s>=0 &&
	     h<24 && m<60 && s<61 ]])
test_true(floatp(__VERSION__))
test_true(floatp(__REAL_VERSION__))
test_true(intp(__MAJOR__))
test_true(intp(__REAL_MAJOR__))
test_true(intp(__MINOR__))
test_true(intp(__REAL_MINOR__))
test_true(intp(__BUILD__))
test_true(intp(__REAL_BUILD__))
test_eq(__PIKE__,1)

test_eq( compile_string("string a=#\"a\nb\";")()->a, "a\nb" )
test_eq( compile_string("string a=#\"a\r\nb\";")()->a, "a\nb" )
test_eq( compile_string("string a=#\"a\n\rb\";")()->a, "a\nb" )

// #define
test_any([[
#define FOOa 1
return FOOa;
]],1)

test_any([[
#define FOOa array
FOOa(int) b;
return 1;
]],1)

test_any([[
#define FOOb 17
#undef FOOb
#define FOOb 1
return FOOb;
]],1)

test_compile_error([[
#define FOOc FOOc FOO
FOO
]])

test_any([[
#define FOOa(X) (X)
return FOOa(2);
]],2)

test_any([[
#define FOOa(X) \
(X)
return FOOa(2);
]],2)

test_any([[
#define FOOa(X) \
(X)
return FOOa(3);
]],3)

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3);
]],({3}))

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3,4);
]],({3,4}))

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3,4,5);
]],({3,4,5}))

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3,4,5,6);
]],({3,4,5,6}))

test_any([[
#define FOOa(X) "bar\
gazonk"
return FOOa(3);
]],"bargazonk")

test_any([[
#define FOOa(X) "bar\
gazonk"
return FOOa(3);
]],"bargazonk")


// /* */
test_any([[
/* return 99; * /  /* */
return 1;
]],1)

test_any([[
/* return 99; // */
return 1;
]],1)

// //
test_any([[
// return 99;
return 1; // return 47;
]],1)

// #!
test_any([[
#! int i=4;
int i=3;
#! i=5;
return i;
]],3)

// #if
define(test_if_true,[[test_any([[
#if $1
return 1;
#else
return 0;
#endif
]],1)]])
define(test_if_false,[[test_any([[
#if $1
return 1;
#else
return 0;
#endif
]],0)]])

test_if_true(1)
test_if_false(0)

// #if ==
test_if_true(1==1)
test_if_false(1==2)

// #if !=
test_if_true(1!=2)
test_if_false(1!=1)

// #if ( )
test_if_true( (((1))==1) )
test_if_false( ((1)==(2)) )

// #if -1
test_if_true( -1 )
test_if_true( (-1) )
test_if_true( (-1==0-1) )

// #if ~
test_if_true( (-1-1==~1) )

// #if ?:
test_if_true( 17 == ( 1 ? 17 : 18 ) )
test_if_true( 18 == ( 0 ? 17 : 18 ) )

// #if ||
test_if_true( 10 == ( 10 || 20 ) )
test_if_true( 20 == ( 0 || 20 ) )

// #if &&
test_if_true( 0 == ( 0 && 20 ) )
test_if_true( 20 == ( 10 && 20 ) )

// #if |
test_if_true( 3 == ( 1 | 2 ) )
test_if_true( 2 == ( 2 | 2 ) )

// #if ^
test_if_true( 0 == ( 2 ^ 2 ) )
test_if_true( 3 == ( 1 ^ 2 ) )

// #if &
test_if_true( 0 == ( 1 & 2 ) )
test_if_true( 2 == ( 2 & 7 ) )

// #if <= >= < > ! strings, floats

define(test_if_cmp,[[
test_if_true($1<$2)
test_if_true(!($1>$2))
test_if_true($2>$1)
test_if_true(!($2<$1))
test_if_true($1<=$2)
test_if_true(!($1>=$2))
test_if_true($2>=$1)
test_if_true(!($2<=$1))
test_if_true($2<=$2)
test_if_true($1>=$1) ]])

test_if_cmp(1,2)
test_if_cmp(1.0,2.0)
test_if_cmp("a","b")

// #if <<
test_if_true(1<<10==1024)
test_if_true(5<<3==40)

// #if >>
test_if_true(1024>>10==1)
test_if_true(47>>3==5)

// #if +
test_if_true(1024+10==1034)
test_if_true(47+3==50)

// #if -
test_if_true(1024-10==1014)
test_if_true(47-3==44)

// #if *
test_if_true(1024*10==10240)

// #if /
test_if_true(47/3==15)

test_compile_error([[
#if 1/0
return 1;
#else
return 0;
#endif
]])

// #if %
test_if_true(47%3==2)
test_compile_error([[
#if 1%0
return 1;
#else
return 0;
#endif
]])

// #if [ ]
test_if_true("foo"[0]=='f')

// #if defined
test_any([[
#define FOOe 0
#if defined(FOOe)
return 1;
#else
return 0;
#endif
]],1)

// #if define < x
test_any([[
#define FOOf 1
#if FOOf < 2
return 1;
#else
return 0;
#endif
]],1)

// #if define < x
test_any([[
#define FOOg 1
#if FOOg < 0
return 0;
#else
return 1;
#endif
]],1)

// #if x < define
test_any([[
#define FOOh 1
#if 0 < FOOh
return 1;
#else
return 0;
#endif
]],1)

// #if x < define
test_any([[
#define FOOi 1
#if 2 < FOOi
return 0;
#else
return 1;
#endif
]],1)

// #if efun
// see test for add_constant()

// #if /* */
test_any([[
#if 1 /* trying to be mean //  * / */ /* /* */
return 1;  /* */
#define foo
# 1 "---"
#undef foo
#else /* trying to be mean //  * / */ /* /* */
return 0;  //
#endif /* trying to be mean //  * / */ /* /* */
]],1)

test_any([[
#if 0 /* trying to be mean //  * / */ /* /* */
return 0; /* */
#define foo
# 1 "---"
#undef foo
#else /* trying to be mean //  * / */ /* /* */
return 1; //
#endif /* trying to be mean //  * / */ /* /* */
]],1)

// #if //
test_any([[
#if 1 //* trying to be mean //  */ */
return 1;
#else //* trying to be mean //  */ */
return 0;
#endif //* trying to be mean //  */ */
]],1)

test_any([[
#if 0 //* trying to be mean //  */ */
return 0;
#else //* trying to be mean //  */ */
return 1;
#endif //* trying to be mean // */ */
]],1)

test_any([[
#define FOOj
#if defined(FOOj)
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if defined(FOOk)
return 0;
#else
return 1;
#endif
]],1)

// #if constant
test_any([[
#if constant(Foo.Bar)
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if constant(Foo) && constant(Bar)
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if constant(String.Buffer)
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if constant(String.Bar)
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if constant(String) && constant(String.Bar)
return 0;
#else
return 1;
#endif
]],1)

// #ifdef
test_any([[
#ifdef FOOl
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#define FOOm
#ifdef FOOm
return 1;
#else
return 0;
#endif
]],1)

// #ifndef
test_any([[
#define FOOo
#ifndef FOOo
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#ifndef FOOp
return 1;
#else
return 0;
#endif
]],1)

// #else
test_any([[
#if 1
return 1;
#else
FEL
#if 0
FEL
#else
FEL
#endif
return 0;
#endif
]],1)

test_any([[
#if 0
FEL
#if 0
FEL
#else
FEL
#if 1
FEL
#else
FEL
#endif
#endif
return 0;
#else
return 1;
#endif
]],1)

// #elif
test_any([[
#if 0
return 0;
#elif 0
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if 0
return 0;
#elif 1
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if 1
return 1;
#elif 1
return 0;
#else
return 0;
#endif
]],1)

// #elseif
test_any([[
#if 0
return 0;
#elseif 0
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if 0
return 0;
#elseif 0
return 0;
#elseif 1
return 1;
#elseif 0
return 0;
#elseif 0
return 0;
#else
FEL
#endif
]],1)

test_any([[
#if 0
return 0;
#elseif 1
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if 1
return 1;
#elseif 1
return 0;
#else
return 0;
#endif
]],1)

// #pragma
// FIXME: add tests for real pragmas
test_any([[
#pragma whatever
return 1;
]],1)

// #include
test_compile_any([[
#pike 7.0
#include <simulate.h>
]])

// #error
test_compile_error([[
#error Gurgel
]])

// #warning
test_compile_warning([[
#warning Gurgel
]])

// <<<<<<<
test_eval_error( cpp("<<<<<<<") )
test_compile_error([[
#if 0
<<<<<<<
#endif
]])



define(do_test_cpp_string,[[
test_eq([[ (({""}) + (string)indices("."*256)/"" + ({""})) * $1]],
	[[ Stdio.write_file("testsuite.tmp",a()),compile_string("string s=#string \"testsuite.tmp\";")()->s ]])
]])

do_test_cpp_string([["0"]])
do_test_cpp_string([["1"]])
do_test_cpp_string([["2"]])
do_test_cpp_string([["3"]])
do_test_cpp_string([["4"]])
do_test_cpp_string([["5"]])
do_test_cpp_string([["6"]])
do_test_cpp_string([["7"]])
do_test_cpp_string([["8"]])
do_test_cpp_string([["9"]])
do_test_cpp_string([["a"]])
do_test_cpp_string([["A"]])
do_test_cpp_string([["\\"]])
do_test_cpp_string([["\\\\"]])
do_test_cpp_string([["\\\\\\"]])
do_test_cpp_string([["\""]])

// #undef inside an evaluation of the macro.
test_compile_error([[
#define LOCALE(X,Y) (Y)
#define DEFVAR(X, Y) ret[(X)]=my_defvar((X),(Y),vars)

  DEFVAR("cm_wa",
         Sitebuilder.SBConnect()->
         ChooseWorkareaVariable(LOCALE(0, "Work area") + LOCALE(0, "Work area"),
                                LOCALE(0, "the"));

  DEFVAR("cr_startpage",
         Variable.URLList(LOCALE(0, "Crawling behaviour") + LOCALE(0, "Start pages"), ""));

#undef DEFVAR

constant cif_defines = #"
   <input align='&_.img-align;' type='image' name='&_.name;' value='&_.contents;' src='&var.url;' border='0' />
</define>";
]])

// foop
define(do_test_foop,[[
test_eq($1 (17), !($2))
test_eq($1 (1.7), !($2-1))
test_eq($1 ("17"), !($2-2))
test_eq($1 (this_object()), !($2-3))
test_eq($1 (a), !($2-4)) // a is the test function
test_eq($1 (({})), !($2-5))
test_eq($1 (([])), !($2-6))
test_eq($1 ((<>)), !($2-7))
test_eq($1 (object_program(this_object())), !($2-8))
test_eq($1 (typeof(1)), 0)
]])

do_test_foop(intp,0)
do_test_foop(floatp,1)
do_test_foop(stringp,2)
do_test_foop(objectp,3)
do_test_foop(functionp,4)
do_test_foop(arrayp,5)
do_test_foop(mappingp,6)
do_test_foop(multisetp,7)
do_test_foop(programp,8)

// add_constant
test_do(add_constant("foobar",lambda() { return 1; }))
test_any([[
#if efun(foobar)
return 1;
#else
return 0;
#endif
]],1)
test_eq(foobar(),1)
test_do(add_constant("foobar"))
test_any([[
#if efun(foobar)
return 1;
#else
return 0;
#endif
]],0)


// ####  Test everything in all_constants.

// - __automap__
// - __empty_program
// - __null_program
// - __parse_pike_type
// - __placeholder_object
// - _describe_program
// - _disable_threads
// - _do_call_outs
// - _exit
// - _gc_status
// - _leak
// - _memory_usage
// - _next
// - _prev
// - _refs
// - _static_modules
// - _typeof

// - _verify_internals
cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]])

// - `!
// - `!=
// - `%
// - `&
// - `()
// - `*

// - `+
test_eq(`+(1,1),2)
test_eq(`+(1,-2),-1)
test_eq(`+(-2,-2),-4)
test_eq(`+("hi","there"),"hithere")

test_eq(`+("hi\777","there"),"hi\777there")
test_eq(`+("hi","there\777"),"hithere\777")

test_eq(`+("hi\7777777","there"),"hi\7777777there")
test_eq(`+("hi","there\7777777"),"hithere\7777777")

test_eq(`+("human","number",666),"humannumber666")
test_eq(`+("human","number",666),"humannumber666")
test_eq(`+("human","number",666),"humannumber666")
test_eq(`+("human","number",666,111),"humannumber666111")
test_eq(`+("humannumber",`+(666+111)),"humannumber777")
test_eq(`+("a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","x","y"),"abcdefghijklmnopqrstuvxy")
test_eq(`+(1.0+1.0),2.0)
test_eq(`+(1.0,-1.0),0.0)
test_eq(`+(-1.0,-1.0),-2.0)
test_equal(`+(({1,2,3}),({4,5,6})),({1,2,3,4,5,6}))
test_equal(`+((<1,2,3,4>),(<4,5,6>)),(<1,2,3,4,4,5,6>))
test_equal(`+(([0:1,3:6]),([5:2,3:6])),([0:1,3:6,3:6,5:2]))

// - `-
// - `->
// - `->=
// - `/
// - `<
// - `<<
// - `<=
// - `==
// - `>
// - `>=
// - `>>
// - `[]
// - `[]=
// - `^
// - `|
// - `~

// - abs
// - acos
// Tested in _math

// - add_constant
test_compile_error(int a=grunk(5);)
test_do(add_constant("grunk",abs))
test_do(int a=grunk(5);)
test_do(add_constant("grunk"))
test_compile_error(int a=grunk(5);)

// - add_include_path
// - add_module_path
// - add_program_path
// Tested in lib

// - aggregate
test_equal(aggregate(),({}))
test_equal(aggregate(1,2,3,4),({1,2,3,4}))

// - aggregate_multiset
test_equal(aggregate_multiset(), (<>))
test_equal(aggregate_multiset(1,1), (<1,1>))
test_equal(aggregate_multiset(1,2,"3"), (<1,2,"3">))

// - aggregate_mapping
test_equal(aggregate_mapping(), ([]))
test_equal(aggregate_mapping(1,2,3,4), ([1:2,3:4]))
test_eval_error(aggregate_mapping(1,2,3))

// - alarm

// - all_constants
test_true(mappingp(all_constants()))
test_eq(all_constants()["all_constants"],all_constants)

// - all_threads
cond([[all_constants()->thread_create]],
[[
  test_true(arrayp(all_threads()))
  test_true(sizeof(all_threads()))
  test_true(objectp(all_threads()[0]))
]])

// - allocate
test_equal(allocate(0),({}))
test_equal(allocate(2),({0,0}))
test_false(allocate(2)==({0,0}))
test_equal(allocate(2,2),({2,2}))
test_true(allocate(65536,random))

// - array_sscanf

// - arrayp
// Tested in foop

// - asin
// - atan
// - atan2
// Tested in _math

// - atexit

// - backtrace
test_true(arrayp(backtrace()))
test_eq(backtrace()[-1][2],a)

// - basename
// Tested in lib

// - basetype
test_eq(basetype(0),"int")
test_eq(basetype(0.0),"float")
test_eq(basetype(""),"string")
test_eq(basetype(({})),"array")
test_eq(basetype(({1})),"array")
test_eq(basetype((<>)),"multiset")
test_eq(basetype(([])),"mapping")
test_eq(basetype(class {}),"program")
test_eq(basetype(class {}()),"object")
test_eq(basetype(abs),"function")
test_eq(basetype(lambda(){}),"function")
test_eq(basetype(typeof(0)),"type")

// - call_function
test_eq(1,call_function(a))
test_eq(1,call_function(lambda(int a){ return a; },1))
test_eq(1,call_function(intp,1))

// - call_out
// - call_out_info

// - callablep
test_true( callablep(time) )
test_true( callablep(String.capitalize) )
test_true( callablep(CommonLog.read) )
test_true( callablep(ADT.Stack) )
test_true( callablep(String.Buffer) )
test_true( callablep( class { void `()() { } }() ) )
test_false( callablep(String.Buffer()) )
test_true( callablep( ({}) ) )
test_true( callablep( ({ 0,0 }) ) )
test_false( callablep( ({ 0,1 }) ) )
test_true( callablep( ({ time }) ) )
test_true( callablep( ({ time, 0 }) ) )
test_false( callablep( ({ "a", time }) ) )
test_false( callablep( ({ "" }) ) )
test_false( callablep( "" ) )
test_false( callablep( 3.14 ) )
test_false( callablep( (< time >) ) )
test_false( callablep( 0 ) )
test_false( callablep( 7 ) )


// - cd

// - ceil
// Tested in _math

// - chmod
// - chown
// - chroot
// - cleargroups

// - new/clone
test_true([[
#pike 7.2
objectp(new(compile_string("int foo() { return 17; }"))) ]])
test_eq([[
#pike 7.2
new(compile_string("int foo() { return 17; }"))->foo() ]],17)
test_true([[
#pike 7.2
objectp(clone(compile_string("int foo() { return 17; }"))) ]])
test_eq([[
#pike 7.2
clone(compile_string("int foo() { return 17; }"))->foo() ]],17)

// - closelog

// - column
test_equal([[column(({({1,2,3}),({5,6,7}),({8,9,0})}),0)]],[[({1,5,8})]])
test_equal([[column(({({1,2,3}),({5,6,7}),({8,9,0})}),1)]],[[({2,6,9})]])
test_equal([[column(({({1,2,3}),({5,6,7}),({8,9,0})}),2)]],[[({3,7,0})]])
test_any_equal([[
  array a = ({({(["foo": 17])})});
  mixed res = column (a, "foo"); // Avoid constant optimization.
  return res && a[0][0];
]], (["foo": 17]))

// - combine_path
test_eq([[combine_path("/foo/bar/gazonk/","..")]],"/foo/bar")
test_eq([[combine_path("/foo/bar/gazonk","..")]],"/foo/bar")
test_eq([[combine_path("/foo/bar/", "gazonk")]],"/foo/bar/gazonk")
test_eq([[combine_path("/foo/bar", "gazonk")]],"/foo/bar/gazonk")
test_eq([[combine_path("/.../","sune")]],"/.../sune")
test_eq([[combine_path("/",".")]],"/")
test_eq([[combine_path("/","foo/.../sune")]],"/foo/.../sune")
test_eq([[combine_path("/./foo/bar//gazonk/","../")]],"/foo/bar/")
test_eq([[combine_path("/","/foo/./bar/gazonk/..")]],"/foo/bar")
test_eq([[combine_path("/","/foo/bar/gazonk/../../")]],"/foo/")
test_eq([[combine_path("/","/foo//bar/gazonk/../..")]],"/foo")
test_eq([[combine_path("/","/foo/bar/./gazonk/../../..")]],"/")
test_eq([[combine_path("/","/foo/../bar//./gazonk/../..")]],"/")
test_eq([[combine_path("/","/foo/././/bar/gazonk/../../../..")]],"/")
test_eq([[combine_path("/","..")]],"/")
test_eq([[combine_path("./","..")]],"..")
test_eq([[combine_path("./.","..")]],"..")
test_eq([[combine_path("/","../../foo")]],"/foo")
test_eq([[combine_path("./foobar/.","..")]],".")
test_eq([[combine_path("/","foo","bar","gazonk")]],"/foo/bar/gazonk")
test_eq([[combine_path("/", "foo", "")]], "/foo/")

test_eq([[combine_path("/","/foo/bar/ga\11111zonk/../../")]],"/foo/")
test_eq([[combine_path("/","/fo\1111/bar/ga\11111zonk/../../")]],"/fo\1111/")
test_eq([[combine_path("/","/fo\1111/bar/gazonk/../../")]],"/fo\1111/")

test_eq([[combine_path("foo", "../bar")]],"bar")
test_eq([[combine_path("foo/", "../bar")]],"bar")
test_eq([[combine_path("foo/", "../bar/")]],"bar/")
test_eq([[combine_path("foo/.", "../bar")]],"bar")
test_eq([[combine_path("foo", "..")]],".")
test_eq([[combine_path("foo/", "..")]],".")
test_eq([[combine_path("foo/.", "..")]],".")
test_eq([[combine_path(".", "bar")]],"bar")
test_eq([[combine_path("./", "bar")]],"bar")
test_eq([[combine_path(".", "../bar")]],"../bar")
test_eq([[combine_path("./", "../bar")]],"../bar")

// - combine_path_nt
test_eq([[combine_path_nt("/","/fo\1111/bar/gazonk/../../")]],"/fo\1111/")
test_eq([[combine_path_nt("a:/","/fo\1111/bar/gazonk/../../")]],"a:/fo\1111/")
test_eq([[combine_path_nt("a:/", "/foo","bar")+combine_path_nt("/foo","bar")]],
	  "a:/foo/bar/foo/bar")

// - combine_path_unix
test_eq([[combine_path_unix("/","/fo\1111/bar/gazonk/../../")]],"/fo\1111/")

// - compile
// - compile_file

// - compile_string
// see test for clone()

cond([[all_constants()->thread_create]],
[[
  test_any([[
    string file = #"
/*
 * Attempt to trig the lex.current_file == NULL bug.
 *
 * Henrik Grubbström 1999-07-01
 */

string file = Stdio.File(__FILE__, \"r\")->read();

void thread_func()
{
  int i;

  for (i=0; i < 1000; i++) {
    compile_string(file);
  }
}

int main(int argc, array(string) argv)
{
  array(object) a = allocate(10, thread_create)(thread_func);

  a->wait();

  return 0;
}

";
  allocate(10, thread_create)(lambda() {
    int i;
    for(i = 0; i < 1000; i++) {
      compile_string(file);
      if (!(i%10))
        __signal_watchdog();
    }
  } )->wait();

  return 0;
  ]], 0)
]])

// - copy_value
test_eq(copy_value(1),1)
test_eq(copy_value(""),"")
test_eq(copy_value(1.0),1.0)
test_eq(copy_value(this_object()),this_object())
test_eq(copy_value(a),a)
define(do_test_copy_value,[[
test_any([[mixed x=$1; return x==x]],1)
test_any([[mixed x=$1; return copy_value(x)!=x]],1)
test_any([[mixed x=$1; return equal(copy_value(x),x)]],1)]])
do_test_copy_value( ({1}) )
do_test_copy_value( ([]) )
do_test_copy_value( (<>) )
do_test_copy_value( (< ([]), ({1}) ,"" , 1.0 >) )
test_true(get_weak_flag(copy_value(set_weak_flag(({17}), 1))))
test_true(get_weak_flag(copy_value(set_weak_flag((<17>), 1))))
test_true(get_weak_flag(copy_value(set_weak_flag(([17:17]), 1))))
test_true(get_weak_flag(copy_value(set_weak_flag(([17:({17})]), 1))))
test_any([[
  array x = ({0});
  x[0] = x;
  return equal (copy_value (x), x);
]], 1)
test_any([[
  mapping x = ([]);
  x[x] = x;
  return equal (copy_value (x), x);
]], 1)
test_any([[
  multiset x = (<>);
  x[x] = 1;
  return equal (copy_value (x), x);
]], 1)
test_any([[
   array a=({0,0,0});
   array b=copy_value(a); b[0]=17; b[1]=42; b[2]=128;
   return equal( ({0,0,0}), a) && equal( ({17,42,128}), b);
]], 1)

// - cos
// Tested in _math

// - cpp

// - crypt
test_true(stringp(crypt("hej")))
test_true(crypt("hej",crypt("hej")))
test_true(crypt("hej","Oz5i0K.16qkgA"))
test_true(crypt("hej","buf8/Z7taE6qs"))
test_true(crypt("123456789", crypt("123456780")))
test_false(crypt("hej","hej"))
test_false(crypt("h","hej"))
test_false(crypt("hej","buf8/Z7taE6qst"))
test_false(crypt("hej","buf8/Z7taE6q"))

// - ctime
test_eq(ctime(0)[-1],'\n')
test_do([[int t = -1; catch(ctime(t));]])

// - decode_value
// - delay
// - describe_backtrace
// - describe_error

// - destruct
test_do(add_constant("PROG",compile_string("int foo() { return 1; }")));
test_any([[object o=PROG(); destruct(o); return o]],0);
test_any([[object o=PROG(); destruct(o); return objectp(o)]],0);
test_any([[array(object) o=({PROG()}); destruct(o[0]); return o-({0}) ]],({}));
test_any([[mapping o=(["foo":PROG()]); destruct(o["foo"]); return o["foo"]; ]],0);
dnl test_any([[object t; mapping o=([t=PROG():"foo"]); destruct(t); return sizeof(o)]],0);
test_do([[object t; array(object) o=({}); o+=({t=PROG()}); destruct(t); o=({});]]);
test_do(add_constant("PROG"))

// - dirname
// Tested in lib

// - encode_value
// - encode_value_canonic
// - endgrent
// - endpwent

// - enumerate
// Tested in lib

// - equal
// equal is already tested by this script

// - errno

// - error
// Tested in lib

// - exece
// - exit

// - exp
// Tested in _math

// - explode_path
// - file_stat
// - file_truncate
// - filesystem_stat

// - filter
// Tested in lib/modules

// - find_call_out

// - floatp
// Tested in foop

// - floor
// Tested in _math

// - fork

// - function_name
test_eq(function_name(a),"a")
test_eq(function_name(function_name),0)

// - function_object
test_eq(function_object(a),this_object())
test_eq(function_name(function_object),0)

// - function_program

// - functionp
// Tested in foop

// - gc
// gc is already tested above

// - get_all_groups
ifefun(get_all_groups,[[
  test_true(arrayp(get_all_groups()))
  test_any([[
    foreach(get_all_groups(), array group)
      foreach(group; int pos; array(string)|int|string value)
        switch(pos) {
          case 0: case 1:
            if(!stringp(value)) return 0;
            break;
          case 2:
            if(!intp(value)) return 0;
            break;
          case 3:
            if(!arrayp(value)) return 0;
            foreach(value, string user)
              if(!stringp(user)) return 0;
            break;
        }
    return 1;
  ]], 1)
]])

// - get_all_users
ifefun(get_all_users,[[
  test_true(arrayp(get_all_users()))
  test_any([[
    foreach(get_all_users(), array user)
      foreach(user; int pos; int|string value)
        switch(pos) {
          case 0: case 1: case 4: case 5: case 6:
            if(!stringp(value)) return 0;
            break;
          case 2: case 3:
            if(!intp(value)) return 0;
            break;
        }
    return 1;
  ]], 1)
]])

// - get_dir
test_do(Stdio.recursive_rm("get_dir_test"))
test_do(mkdir("get_dir_test"))
test_equal(get_dir("get_dir_test"),({}))
test_do(Stdio.write_file("get_dir_test/x", "x"));
test_equal(get_dir("get_dir_test"),({"x"}))
test_do(Stdio.recursive_rm("get_dir_test"))

// - get_groups_for_user
// - get_weak_flag

// - getcwd
test_true(stringp(getcwd()))
test_true(sizeof(getcwd()))
test_do(Stdio.recursive_rm("getcwd_test"))
test_do(mkdir("getcwd_test"))
test_any([[
  string a = getcwd();
  cd("getcwd_test");
  string b = getcwd();
  cd("..");
#ifdef __NT__
  return a==getcwd() && b==a+"\\getcwd_test";
#else
  return a==getcwd() && b==a+"/getcwd_test";
#endif
]], 1)
test_do(Stdio.recursive_rm("getcwd_test"))

// - getegid
ifefun(getegid,[[
  test_true(intp(getegid()))
  test_true(getegid()==getegid())
]])

// - getenv

// - geteuid
ifefun(geteuid,[[
  test_true(intp(geteuid()))
  test_true(geteuid()==geteuid())
]])

// - getgid
ifefun(getgid,[[
  test_true(intp(getgid()))
  test_true(getgid()==getgid())
]])

// - getgrent
// - getgrgid
// - getgrnam
// - getgroups
// - gethostbyaddr
// - gethostbyname

// - gethostname
test_true(stringp(gethostname()))
test_true(sizeof(gethostname()))

// - gethrtime
// See time

// - gethrvtime

// - getpgrp
ifefun(getpgrp,[[
  test_true(intp(getpgrp()))
  test_true(getpgrp()==getpgrp())
]])

// - getpid
ifefun(getpid,[[
  test_true(intp(getpid()))
  test_true(getpid()==getpid())
]])

// - getppid
ifefun(getppid,[[
  test_true(intp(getppid()))
  test_true(getppid()==getppid())
]])

// - getpwent
// - getpwnam
// - getpwuid

// - getsid
ifefun(getsid,[[
  test_true(intp(getsid()))
  test_true(getsid()==getsid())
]])

// - getuid
ifefun(getuid,[[
  test_true(intp(getuid()))
  test_true(getuid()==getuid())
]])

// - glob
test_false(glob("","a"))
test_false(glob("a",""))
test_false(glob("?",""))
test_true(glob("*",""))
test_false(glob("foo","bar"))
test_true(glob("foo","foo"))
test_true(glob("f?o","foo"))
test_true(glob("f??","foo"))
test_true(glob("?o?","foo"))
test_true(glob("f*","foo"))
test_true(glob("*o","foo"))
test_true(glob("*<<<*","<<<"))
test_true(glob("*<<<*","<<<foo"))
test_false(glob("*f","foo"))
test_false(glob("o*","foo"))
test_false(glob("?f?","foo"))
test_equal([[glob("?f?",({"ff","ffff","off","fff",""}))]],[[({"off","fff"})]])
test_equal([[glob("foo*bar",({"foobar","foobargazonk","","foofoobar","fobar","fooar"}))]],[[({"foobar","foofoobar"})]])
test_eval_error([[
  array a=({"a","b",3});
  return glob("*", a);
]])

// - gmtime
cond([[all_constants()->localtime && all_constants()->mktime]],[[
  test_do([[int t = -1; catch(gmtime(t));]])
]])

// - hardlink

// - has_index
define(test_has_index,[[test_any([[mixed foo=$1; return has_index(foo,$2)==$3;]], 1)]])
test_has_index([[ ({}) ]],0,0)
test_has_index([[ ({}) ]],"foo",0)
test_has_index([[ ({ "a" }) ]],-1,0)
test_has_index([[ ({ "a" }) ]],"a",0)
test_has_index([[ ({ "a" }) ]],0,1)
test_has_index([[ ({ "a" }) ]],1,0)
test_has_index([[ ({ "a", "b" }) ]],1,1)
test_has_index([[ ([ "a":"A" ]) ]],4711,0)
test_has_index([[ ([ "a":"A" ]) ]],"a",1)
test_has_index([[ ([ "a":"A" ]) ]],"A",0)
test_has_index([[ ([ "a":"A", "b":"B", "c":"C" ]) ]],"b",1)
test_has_index([[ ([ "a":"A", "b":"B", "c":"C" ]) ]],"B",0)
test_has_index([[ (< "a" >) ]],4711,0)
test_has_index([[ (< "a" >) ]],"a",1)
test_has_index([[ (< "a" >) ]],"A",0)
test_has_index([[ (< "a", "b", "c" >) ]],"b",1)
test_has_index([[ (< "a", "b", "c" >) ]],"B",0)
test_has_index([[ class {}() ]],"foo",0)
test_has_index([[ (class{array _indices(){return({"a","b"});}})() ]],"b",1)

// - has_prefix
test_true(has_prefix("abc","a"))
test_false(has_prefix("abc","b"))
test_true(has_prefix("abc",""))
test_true(has_prefix("",""))
test_false(has_prefix("","abc"))
test_true(has_prefix("\666abc","\666a"))

// - has_suffix
test_true(has_suffix("cba","a"))
test_false(has_suffix("cba","b"))
test_true(has_suffix("abc",""))
test_true(has_suffix("",""))
test_false(has_suffix("","abc"))
test_true(has_suffix("cba\666","a\666"))

// - has_value
define(test_has_value,[[test_true([[mixed foo=$1; return has_value(foo,$2)==$3;]])]])
test_has_value([[ ({}) ]],0,0)
test_has_value([[ ({}) ]],"foo",0)
test_has_value([[ ({ "a" }) ]],-1,0)
test_has_value([[ ({ "a" }) ]],"a",1)
test_has_value([[ ({ "a" }) ]],0,0)
test_has_value([[ ({ "a", "b" }) ]],"b",1)
test_has_value([[ ([ "a":"A" ]) ]],4711,0)
test_has_value([[ ([ "a":"A" ]) ]],"a",0)
test_has_value([[ ([ "a":"A" ]) ]],"A",1)
test_has_value([[ ([ "a":"A", "b":"B", "c":"C" ]) ]],"B",1)
test_has_value([[ ([ "a":"A", "b":"B", "c":"C" ]) ]],"b",0)
test_has_value([[ class {}() ]],"foo",0)
test_has_value([[ (class{array _values(){return({"a","b"});}})() ]],"b",1)

// - hash
test_eq(hash("foo"),2091538203)
test_eq(hash("foo",10),3)
test_eq(hash("bar"),2091518428)
test_eq(hash("bar",10),8)
test_eq(hash("b\666arqwerty1234"),1829582221)
test_eq(hash(""),0)
test_eval_error( return hash("foo",0) )
test_eval_error( return hash("foo",-1) )

// - hash_7_4
define(test_hash_7_4, [[
  test_any([[
    int i = hash_7_4($1);
    return ]]dnl
ifelse([[$3]],,, [[((i==$2)||(i==$3))?$2:]])dnl
[[i;
  ]], $2)
  test_any([[
#pike 7.4
    int i = hash($1);
    return ]]dnl
ifelse([[$3]],,, [[((i==$2)||(i==$3))?$2:]])dnl
[[i;
  ]], $2)
]])
test_hash_7_4("foo",2091538203)
test_hash_7_4([["foo",10]],3)
test_hash_7_4("bar",2091518428)
test_hash_7_4([["bar",10]],8)
test_hash_7_4("b\666arqwerty1234", 2142487018, 1858424874)
test_hash_7_4("",0)
test_eval_error( return hash_7_4("foo",0) )

// - hash_7_0
define(test_hash_7_0, [[
  test_any([[
    int i = hash_7_0($1);
    return ]]dnl
ifelse([[$3]],,, [[((i==$2)||(i==$3))?$2:]])dnl
[[i;
  ]], $2)
  test_any([[
#pike 7.0
    int i = hash($1);
    return ]]dnl
ifelse([[$3]],,, [[((i==$2)||(i==$3))?$2:]])dnl
[[i;
  ]], $2)
]])
test_hash_7_0("foo",27734)
test_hash_7_0([["foo",10]],4)
test_hash_7_0("bar",26689)
test_hash_7_0([["bar",10]],9)
test_hash_7_0("b\666arqwerty1234", 2142487018, 1858424874)
test_hash_7_0("",0)
test_eval_error( return hash_7_0("foo",0) )

// - indices
test_equal(indices("foo"),({0,1,2}))
test_equal(indices(({'f','o','o'})),({0,1,2}))
test_equal(Array.sort_array(indices(([7:3,8:9,99:12]))),({7,8,99}))
test_equal(Array.sort_array(indices((<7,8,99>))),({7,8,99}))
test_equal(mkmultiset(indices(class{constant a="a"; constant b="b";}())),
	   (<"a","b">))

// - initgroups
// - innetgrp

// - int2char
// - int2hex
// Tested in String

// - intp
// Tested in foop

// - is_absolute_path
// Tested in lib

// - kill
// - load_module

// - localtime
cond([[all_constants()->localtime]],[[
  test_true(mappingp(localtime(0)))
  test_do([[int t = -1; catch(localtime(t));]])
]])
cond([[all_constants()->localtime && all_constants()->mktime]],
[[
  test_any([[int x=time(); return mktime(localtime(x)) == x;]], 1)
  test_any([[int x=time(); for(int y=0;y<100;y++) if(mktime(localtime(x+y)) != x+y) return x+y; return 0;]], 0)
]])


// - log
// Tested in _math

// - lower_case
test_equal(lower_case("foo"),"foo")
test_equal(lower_case("Foo"),"foo")
test_equal(lower_case("Foo1234-*~\n"),"foo1234-*~\n")
test_equal(lower_case("foo\x3000"),"foo\x3000")
test_equal(lower_case("Foo\x3000"),"foo\x3000")
test_equal(lower_case("Foo1234-*~\n\x3000"),"foo1234-*~\n\x3000")
test_equal(lower_case("foo\x13000"),"foo\x13000")
test_equal(lower_case("Foo\x13000"),"foo\x13000")
test_equal(lower_case("Foo1234-*~\n\x13000"),"foo1234-*~\n\x13000")
test_equal(lower_case("Foo\x178"),"foo\xff")
test_equal(lower_case("Foo\x39c"),"foo\x3bc")
test_equal(lower_case((string) ({
// These characters correspond to the cases in case_info.h
// Please update this and the corresponding upper_case table
// when UnicodeData.txt is changed.
// Part 1: 0x0000 - 0x0FFF
0x0000, 0x0041, 0x005b, 0x0061, 0x007b, 0x00b5, 0x00b6, 0x00c0,
0x00d7, 0x00d8, 0x00df, 0x00e0, 0x00f7, 0x00f8, 0x00ff, 0x0100,
0x0130, 0x0131, 0x0132, 0x0138, 0x0139, 0x0149, 0x014a, 0x0178,
0x0179, 0x017f, 0x0180, 0x0181, 0x0182, 0x0186, 0x0187, 0x0189,
0x018b, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0193, 0x0194,
0x0195, 0x0196, 0x0197, 0x0198, 0x019a, 0x019c, 0x019d, 0x019e,
0x019f, 0x01a0, 0x01a6, 0x01a7, 0x01a9, 0x01aa, 0x01ac, 0x01ae,
0x01af, 0x01b1, 0x01b3, 0x01b7, 0x01b8, 0x01ba, 0x01bc, 0x01be,
0x01bf, 0x01c0, 0x01c4, 0x01c5, 0x01c7, 0x01c8, 0x01ca, 0x01cb,
0x01dd, 0x01de, 0x01f0, 0x01f1, 0x01f2, 0x01f6, 0x01f7, 0x01f8,
0x0220, 0x0221, 0x0222, 0x0234, 0x0253, 0x0254, 0x0255, 0x0256,
0x0258, 0x0259, 0x025a, 0x025b, 0x025c, 0x0260, 0x0261, 0x0263,
0x0264, 0x0268, 0x0269, 0x026a, 0x026f, 0x0270, 0x0272, 0x0273,
0x0275, 0x0276, 0x0280, 0x0281, 0x0283, 0x0284, 0x0288, 0x0289,
0x028a, 0x028c, 0x0292, 0x0293, 0x0345, 0x0346, 0x0386, 0x0387,
0x0388, 0x038b, 0x038c, 0x038d, 0x038e, 0x0390, 0x0391, 0x03a0,
0x03a2, 0x03a3, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03c0, 0x03c2,
0x03c3, 0x03cc, 0x03cd, 0x03cf, 0x03d0, 0x03d1, 0x03d2, 0x03d5,
0x03d6, 0x03d7, 0x03d8, 0x03f0, 0x03f1, 0x03f2, 0x03f3, 0x03f4,
0x03f5, 0x03f6, 0x03f7, 0x03f9, 0x03fa, 0x03fc, 0x0400, 0x0410,
0x0420, 0x0430, 0x0440, 0x0450, 0x0460, 0x0482, 0x048a, 0x04c0,
0x04c1, 0x04cf, 0x04d0, 0x04f6, 0x04f8, 0x04fa, 0x0500, 0x0510,
0x0531, 0x0557, 0x0561, 0x0587,
})), (string) ({
0x0000, 0x0061, 0x005b, 0x0061, 0x007b, 0x00b5, 0x00b6, 0x00e0, 
0x00d7, 0x00f8, 0x00df, 0x00e0, 0x00f7, 0x00f8, 0x00ff, 0x0101, 
0x0069, 0x0131, 0x0133, 0x0138, 0x013a, 0x0149, 0x014b, 0x00ff, 
0x017a, 0x017f, 0x0180, 0x0253, 0x0183, 0x0254, 0x0188, 0x0256, 
0x018c, 0x018d, 0x01dd, 0x0259, 0x025b, 0x0192, 0x0260, 0x0263, 
0x0195, 0x0269, 0x0268, 0x0199, 0x019a, 0x026f, 0x0272, 0x019e, 
0x0275, 0x01a1, 0x0280, 0x01a8, 0x0283, 0x01aa, 0x01ad, 0x0288, 
0x01b0, 0x028a, 0x01b4, 0x0292, 0x01b9, 0x01ba, 0x01bd, 0x01be, 
0x01bf, 0x01c0, 0x01c6, 0x01c6, 0x01c9, 0x01c9, 0x01cc, 0x01cc, 
0x01dd, 0x01df, 0x01f0, 0x01f3, 0x01f3, 0x0195, 0x01bf, 0x01f9, 
0x019e, 0x0221, 0x0223, 0x0234, 0x0253, 0x0254, 0x0255, 0x0256,
0x0258, 0x0259, 0x025a, 0x025b, 0x025c, 0x0260, 0x0261, 0x0263, 
0x0264, 0x0268, 0x0269, 0x026a, 0x026f, 0x0270, 0x0272, 0x0273, 
0x0275, 0x0276, 0x0280, 0x0281, 0x0283, 0x0284, 0x0288, 0x0289, 
0x028a, 0x028c, 0x0292, 0x0293, 0x0345, 0x0346, 0x03ac, 0x0387, 
0x03ad, 0x038b, 0x03cc, 0x038d, 0x03cd, 0x0390, 0x03b1, 0x03c0, 
0x03a2, 0x03c3, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03c0, 0x03c2, 
0x03c3, 0x03cc, 0x03cd, 0x03cf, 0x03d0, 0x03d1, 0x03d2, 0x03d5, 
0x03d6, 0x03d7, 0x03d9, 0x03f0, 0x03f1, 0x03f2, 0x03f3, 0x03b8,
0x03f5, 0x03f6, 0x03f8, 0x03f2, 0x03fb, 0x03fc, 0x0450, 0x0430,
0x0440, 0x0430, 0x0440, 0x0450, 0x0461, 0x0482, 0x048b, 0x04c0,
0x04c2, 0x04cf, 0x04d1, 0x04f6, 0x04f9, 0x04fa, 0x0501, 0x0510,
0x0561, 0x0557, 0x0561, 0x0587, 
}))
test_equal(lower_case((string) ({
// These characters correspond to the cases in case_info.h
// Please update this and the corresponding upper_case table
// when UnicodeData.txt is changed.
// Part 2: 0x1000 -
0x1e00, 0x1e96, 0x1e9b, 0x1e9c, 0x1ea0, 0x1efa, 0x1f00, 0x1f08,
0x1f10, 0x1f16, 0x1f18, 0x1f1e, 0x1f20, 0x1f28, 0x1f30, 0x1f38,
0x1f40, 0x1f46, 0x1f48, 0x1f4e, 0x1f51, 0x1f52, 0x1f53, 0x1f54,
0x1f55, 0x1f56, 0x1f57, 0x1f58, 0x1f59, 0x1f5a, 0x1f5b, 0x1f5c,
0x1f5d, 0x1f5e, 0x1f5f, 0x1f60, 0x1f68, 0x1f70, 0x1f72, 0x1f76,
0x1f78, 0x1f7a, 0x1f7c, 0x1f7e, 0x1f80, 0x1f88, 0x1f90, 0x1f98,
0x1fa0, 0x1fa8, 0x1fb0, 0x1fb2, 0x1fb3, 0x1fb4, 0x1fb8, 0x1fba,
0x1fbc, 0x1fbd, 0x1fbe, 0x1fbf, 0x1fc3, 0x1fc4, 0x1fc8, 0x1fcc,
0x1fcd, 0x1fd0, 0x1fd2, 0x1fd8, 0x1fda, 0x1fdc, 0x1fe0, 0x1fe2,
0x1fe5, 0x1fe6, 0x1fe8, 0x1fea, 0x1fec, 0x1fed, 0x1ff3, 0x1ff4,
0x1ff8, 0x1ffa, 0x1ffc, 0x1ffd, 0x2126, 0x2127, 0x212a, 0x212b,
0x212c, 0x2160, 0x2180, 0x24b6, 0x24d0, 0x24ea, 0xff21, 0xff3b,
0xff41, 0xff5b,
0x010400, 0x010428, 0x010450,
})), (string) ({
0x1e01, 0x1e96, 0x1e9b, 0x1e9c, 0x1ea1, 0x1efa, 0x1f00, 0x1f00, 
0x1f10, 0x1f16, 0x1f10, 0x1f1e, 0x1f20, 0x1f20, 0x1f30, 0x1f30, 
0x1f40, 0x1f46, 0x1f40, 0x1f4e, 0x1f51, 0x1f52, 0x1f53, 0x1f54, 
0x1f55, 0x1f56, 0x1f57, 0x1f58, 0x1f51, 0x1f5a, 0x1f53, 0x1f5c,
0x1f55, 0x1f5e, 0x1f57, 0x1f60, 0x1f60, 0x1f70, 0x1f72, 0x1f76, 
0x1f78, 0x1f7a, 0x1f7c, 0x1f7e, 0x1f80, 0x1f80, 0x1f90, 0x1f90, 
0x1fa0, 0x1fa0, 0x1fb0, 0x1fb2, 0x1fb3, 0x1fb4, 0x1fb0, 0x1f70, 
0x1fb3, 0x1fbd, 0x1fbe, 0x1fbf, 0x1fc3, 0x1fc4, 0x1f72, 0x1fc3, 
0x1fcd, 0x1fd0, 0x1fd2, 0x1fd0, 0x1f76, 0x1fdc, 0x1fe0, 0x1fe2, 
0x1fe5, 0x1fe6, 0x1fe0, 0x1f7a, 0x1fe5, 0x1fed, 0x1ff3, 0x1ff4, 
0x1f78, 0x1f7c, 0x1ff3, 0x1ffd, 0x03c9, 0x2127, 0x006b, 0x00e5, 
0x212c, 0x2170, 0x2180, 0x24d0, 0x24d0, 0x24ea, 0xff41, 0xff3b, 
0xff41, 0xff5b, 
0x010428, 0x010428, 0x010450, 
}))

// - m_delete
// - map

// - mappingp
// Tested in foop

// - master

// - max
// - min
// Tested in _math

// - mkdir

// - mkmapping
test_equal(mkmapping(({}),({})), ([]))
test_equal(mkmapping(({0}),({0})), ([0:0]))
test_any_equal([[
  array a=({"a"});
  return mkmapping(a,a);
]], (["a":"a"]))
test_equal(mkmapping( ({({})}),({({})}) )[ ({}) ], ({}))

// - mkmultiset
test_equal(mkmultiset(({})), (<>))
test_equal(mkmultiset(({0})), (<0>))
test_equal(mkmultiset(({(<>)})), (<(<>)>))

// - mktime
cond([[all_constants()->mktime]],
[[
  test_true([[mktime( ([
  "sec":58,
  "isdst":1,
  "year":98,
  "mon":3,
  "mday":26,
  "hour":1,
  "min":51
]))]])

  test_eq([[mktime(58,51,1,26,3,98,1,0)]],[[mktime( ([
  "sec":58,
  "isdst":1,
  "year":98,
  "mon":3,
  "mday":26,
  "hour":1,
  "min":51,
  "timezone":0,
]) ) ]])

  test_any([[foreach(({1075550400,94691300,220921700,347152100,473382500,
		       599612900,725843300,852073700,978304100,1104534500,
		       1230764900,1356995300,1483225700,1609456100,1735686500,
		       1861916900,1988147300,2114377700
		      }),int t) if(mktime(gmtime(t))!=t) return t; return 0;]], 0)

]])

// - multisetp
// Tested in foop

// - mv

// - next_object
test_true(objectp(next_object()) || intp(next_object()) && next_object())
test_any([[
  object o=next_object();
  for(int e=0; e<10000 && (objectp(o) || intp(o) && o); e++)
    o=next_object(o);
  return o;
]], 0)

// - normalize_path
// Tested in lib

// - object_program
test_true(programp(object_program(this_object())))

// - object_variablep
// - openlog

// - pow
// Tested in _math

// - programp
// Tested in foop

// - putenv
// Tested in lib

// - query_num_arg
test_eq(lambda(int ... q) { return query_num_arg(); }(),0)
test_eq(lambda(int ... q) { return query_num_arg(); }(1),1)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1),2)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1,1),3)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1,1,1),4)

// - random
test_any([[int e,d;for(e=0;e<1000;e++){d=random(10); if(d<0 || d>=10) return 0;} return 1]],1)
test_eq([[ random( ({11,21,31,41}) ) % 10 ]], 1)
test_eq([[ random( ({11,21,31,41}) ) % 10 ]], 1)
test_eq([[ random( ({11,21,31,41}) ) % 10 ]], 1)
test_eq([[ random( ({11,21,31,41}) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ random( (<11,21,31,41>) ) % 10 ]], 1)
test_eq([[ `-( @random( ([11:21,31:41]) )) ]], -10)
test_eq([[ `-( @random( ([11:21,31:41]) )) ]], -10)
test_eq([[ `-( @random( ([11:21,31:41]) )) ]], -10)
test_eq([[ `-( @random( ([11:21,31:41]) )) ]], -10)
test_eval_error([[ return random( ({}) ) ]])
test_eval_error([[ return random( (<>) ) ]])
test_eval_error([[ return random( ([]) ) ]])
test_eq([[ random( class() { int _random() { return 17; }}()) ]], 17)

// - random_seed
test_do(int p; foreach(({1,2,3,4,5}),p) random_seed(p))
test_eq([[random_seed(17),random(20000)]],[[random_seed(17),random(20000)]])
test_eq([[random_seed(18),random(20000)]],[[random_seed(18),random(20000)]])
test_eq([[random_seed(19),random(20000)]],[[random_seed(19),random(20000)]])
test_equal([[random_seed(4711),map(allocate(10,1000), random)]],
	   [[({598,11,331,991,383,553,997,53,272,381})]])

// - random_string
test_eq( sizeof(random_string(47)), 47 )
test_eq( random_string(0), "" )
test_eval_error( return random_string(-1); )

// - readlink
// - remove_call_out

// - remove_include_path
// - remove_module_path
// - remove_program_path
// Tested in lib

// - replace
test_eq(replace("foo","f","\x9999"),"\x9999oo")
test_eq(replace("foo",({"f"}),({"\x9999"})),"\x9999oo")
test_eq([[replace("11013",({"1","100","108","13","1069","1067","106","10"}),
	({"A","B","C","D","E","F","G","H"}))]],"AHD")
test_eq([[replace("1264412124",({"126","124","12","122","1260"}),
         ({"13333","13335","883","13329","226709"}))]],"133334488313335")
test_eq(replace("foobargazonk","o","-"),"f--bargaz-nk")
test_eq(replace("foobargazonk",({"o","a"}),({"()","<>"})),"f()()b<>rg<>z()nk")
test_eq(replace("f--barf--",({"f--","f--bar"}),({"f--bar","f--"})),"f--f--bar")
test_eq(replace("f--barf--",({"f--bar","f--"}),({"f--","f--bar"})),"f--f--bar")
test_eq(replace("test\ntest\n\ntest\ntest",({"\n","\n\n"}),({" ","<p>"})),"test test<p>test test")
test_eq(replace("test\ntest\n\ntest\ntest",({"\n\n","\n"}),({"<p>"," "})),"test test<p>test test")
test_eq(replace("\xfffffff0", ({ "\xfffffff0" }), ({ "" })), "")
test_eq([[ replace("abcdefg", ([ "a":"x", "d":"y", "h":"z" ])) ]], "xbcyefg")

test_eq("123\000456""890"-"\0", "123\456""890")
test_eq("123\456000""890"-"\0", "123\456000""890")

test_any([[
  array a=({ 1 });
  replace(a,1,2);
  return a[0];
]], 2)

test_any([[
  mapping a=([ 1:1 ]);
  replace(a,1,2);
  return a[1];
]], 2)

test_any([[
function reference=lambda(string x, array(string) a, array(string) b)
{
  string ret="";
  for(int pos=0;pos<strlen(x);)
  {
    int best=-1;
    int bestlen=-1;
    for(int e=0;e<sizeof(a);e++)
    {
      if(strlen(a[e])>bestlen)
      {
	if(x[pos..pos+strlen(a[e])-1] == a[e])
	{
	  best=e;
	  bestlen=strlen(a[e]);
	}
      }
    }

    if(best==-1)
    {
      ret+=x[pos..pos];
      pos++;
    }else{
      ret+=b[best];
      pos+=bestlen;
    }
  }
  return ret;
};

  for(int e=0;e<10000;e++)
  {
    array(string) base=(array(string)) ( (({random})*(1+random(10)))(20) );

    for(int d=0;d<random(random(40));d++)
      base+=({ base[ random(sizeof(base))] + random(10) });

    base=Array.uniq(base);
    array(string) to=(array(string))Array.map(base,hash);

    string text="";
    for(int d=0;d<1+random(random(50));d++)
    {
      if(random(2))
	text+=base[ random(sizeof(base))];
      else
	text+=sprintf("%2d",random(100));
    }

    string r1=replace(text,base,to);
    string r2=reference(text,base,to);

    if(r1 != r2)
    {
      werror("\nFailure:\n");
      werror("Text: %O\n",text);
      werror("From: %O\n",base);
      werror("To  : %O\n",to);
      werror("Builtin: %O\n",r1);
      werror("Ref    : %O\n",r2);
      return -1;
    }
  }
  return 1;
]],1)

test_eq(replace("f\777\777bargaz\777nk","\777","-"),"f--bargaz-nk")
test_eq(replace("f\777\777bargaz\777nk",({"\777","a"}),({"()","<>"})),"f()()b<>rg<>z()nk")
test_eq(replace("f\777\777barf\777\777",({"f\777\777","f\777\777bar"}),({"f\777\777bar","f\777\777"})),"f\777\777f\777\777bar")
test_eq(replace("f\777\777barf\777\777",({"f\777\777bar","f\777\777"}),({"f\777\777","f\777\777bar"})),"f\777\777f\777\777bar")

test_eq(replace("f\7777777\7777777bargaz\7777777nk","\7777777","-"),"f--bargaz-nk")
test_eq(replace("f\7777777\7777777bargaz\7777777nk",({"\7777777","a"}),({"()","<>"})),"f()()b<>rg<>z()nk")
test_eq(replace("f\7777777\7777777barf\7777777\7777777",({"f\7777777\7777777","f\7777777\7777777bar"}),({"f\7777777\7777777bar","f\7777777\7777777"})),"f\7777777\7777777f\7777777\7777777bar")
test_eq(replace("f\7777777\7777777barf\7777777\7777777",({"f\7777777\7777777bar","f\7777777\7777777"}),({"f\7777777\7777777","f\7777777\7777777bar"})),"f\7777777\7777777f\7777777\7777777bar")

test_equal(replace(({1,2,3,4,5,1,2,3,4}),3,-1),({1,2,-1,4,5,1,2,-1,4}))
test_equal(replace(([1:2,3:4,5:1,2:3]),3,-1),([1:2,3:4,5:1,2:-1]))

test_eval_error([[
  mapping a = ([ "a":"b", 3:"c" ]);
  return replace("bar", a);
]])
test_eval_error([[
  mapping a = ([ "a":"b", "c":3 ]);
  return replace("bar", a);
]])
test_eval_error([[
  return replace("bar", ({"a"}), ({"b","c"}));
]])

// - replace_master

// - reverse
test_eq(reverse("reverse"),"esrever")
test_eq(reverse("r\777v\777rs\777"),"\777sr\777v\777r")
test_eq(reverse("r\7777777v\7777777rs\7777777"),"\7777777sr\7777777v\7777777r")
test_eq(reverse(""),"")
test_eq(reverse("a"),"a")
test_equal(reverse(({1,5,9})),({9,5,1}))
test_equal(reverse(({})),({}))
test_equal(reverse(({42})),({42}))
test_equal(reverse(({42,4711})),({4711,42}))
test_equal(reverse(0x12345678),0x1e6a2c48)

// - rm

// - round
// Tested in _math

// - rows
test_equal([[rows(({1,2,3,4,5,6,7,8,9}),({6,7,2}))]],[[({7,8,3})]])
test_equal([[rows(({1,2,3,4,5,6,7,8,9}),({0,4,1}))]],[[({1,5,2})]])
test_equal([[rows(({1,2,3,4,5,6,7,8,9}),({8,3,5}))]],[[({9,4,6})]])

// - search
test_eval_error(return search("foolbar","o",-10))
test_eval_error(return search("foolbar","o",2983742))
test_eq(search("foolbar","gazonk"),-1)
test_eq(search("qowiueproqiuweproiwqueoplkjljlklksjjriwueproiuwerowieu","lkjljlklksjj"),24)
test_eq(search("lkjljlklksjjriwueproiuwerlskjdvlaskjfowieu","lkjljlklksjj"),0)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj","lkjljlklksjj"),24)

// Search cache is initialized with 10 slots.
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj1","lkjljlklksjj1"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj2","lkjljlklksjj2"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj3","lkjljlklksjj3"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj4","lkjljlklksjj4"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj5","lkjljlklksjj5"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj6","lkjljlklksjj6"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj7","lkjljlklksjj7"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj8","lkjljlklksjj8"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj9","lkjljlklksjj9"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj0","lkjljlklksjj0"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjjx","lkjljlklksjjx"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj","lkjljlklksjj"),24)

test_eq(search("foobargazonk","oo"),1)
test_eq(search("foobargazonk","o",3),9)
test_eq(search("foobargazonk","o",9),9)
test_eq(search("foobargazonk","o",10),-1)
test_eq(search("foobargazonk","x",9),-1)
test_eq(search(({56,8,2,6,2,7,3,56,7}),8),1)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,0),0)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,1),7)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,7),7)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,8),-1)
test_eq(search(({"foo"}),"foo"),0)
test_eq(search("fo-obar|gazonk"/"|","fo-obar"),0)
test_eq(search("fo-obar|gazonk"/"|","gazonk"),1)
test_eq(search(([1:2,3:4,5:6,7:8]),4),3)
test_true(zero_type(search(([1:2,3:4,5:6,7:8]),(int)3)))
test_eq(search(([1:2,3:4,5:6,7:8]),8),7)
test_eq(search("foo",""),0)
test_any([[
  mapping m=([]);
  m+=(["x":([])]);
  m->x->y++;
  m=([]);
  m+=(["x":([])]);
  return m->x->y;
]], 0)

test_do([[
  class C
  {
    mapping m;
    
    int `==()
    {
      foreach(indices(m), mixed x)
  	m_delete(m, x);
      return 0;
    }
  
    void create(mapping _m)
    {
      m = _m;
    }
  };
  
  mapping m = ([ ]);
  C o = C(m);
  
  for(int i = 0; i < 100; i++)
    m[i] = o;
  
  return search(m, 4711);
]])

test_any_equal([[
  mapping m = (["foo": "bar", "bar": "gnu", "gnu": "bar"]);
  array a = ({});
  a += ({search (m, "bar")});
  a += ({search (m, "bar", a[-1])});
  a += ({search (m, "bar", a[-1])});
  return sort (a);
]], sort(({0, "foo", "gnu"})))

// test large searches (find string, size, pattern)
define(test_search,[[
test_eq(sprintf($1+"%'"+$3+"'*n",$2)[..strlen($1)-1],$1)
test_eq(search(sprintf($1+"%'"+$3+"'*n",$2),$1),0)
test_eq(search(sprintf("%'"+$3+"'*n" ,$2),$1),-1)
test_eq(search(sprintf("%'"+$3+"'*n"+$1,$2),$1),$2)
test_eq(search(sprintf("%'"+$3+"'*n"+$1+"%'"+$3+"'*n",$2,$2),$1),$2)
]])

define(test_search2,[[dnl
test_search($1,$2,$3)
test_search($1,$2+1,$3)
test_search($1,$2+2,$3)
test_search($1,$2+3,$3)
test_search($1,$2+4,$3)
test_search($1,$2+5,$3)
]])

define(test_search3,[[dnl
test_search2($1,10,$2)
test_search2($1,1000,$2)
test_search2($1,100000,$2)
]])

define(test_search4,[[dnl
test_search3($1,"+-*")
test_search3($1,($1[..strlen($1)-2]))
test_search3($1,($1[..strlen($1)-3]))
test_search3($1,($1[1..]))
]])

dnl some m4's don't handle 8 bit characters...
test_search4("SUNE")
test_search4("kapit\344l>")
test_search4("-------------------+")
test_search4("\345-------------------")
test_search4(sprintf("%'argel-bargel glop-glyf?'2000n"))
test_search4("\34567-------------------")
test_search4("\345677777-------------------")
test_search4("kapit\3333l>")
test_search4("kapit\3333333l>")

// - rusage
test_true(
#pike 7.4
arrayp(rusage()))
test_true(
#pike 7.4
sizeof(rusage())>28)

// - set_priority
// - set_weak_flag
// - setegid
// - seteuid
// - setgid
// - setgrent
// - setgroups
// - setpgrp
// - setpwent
// - setresgid
// - setresuid
// - setsid
// - setuid

// - sgn
// Tested in _math

// - signal
// - signame
// - signum

// - sin
// Tested in _math

// - sizeof
test_eq(sizeof("felbar"),6)
test_eq(sizeof(({"fulbar","gazonk",7})),3)
test_eq(sizeof(([8:3,6:6,7:0])),3)
test_eq(sizeof((<8,7,6,5,4,7>)),6)
test_eq([[ sizeof( class { int _sizeof() { return 17; } }() ) ]], 17)

// - sleep
test_do(sleep(1))
test_do(sleep(0.5))
test_any([[int x=time(); sleep(2); return x!=time()]],1)
test_any([[int x=time(); sleep(2); return x!=time()]],1)

// - sort
test_equal(sort(({1,3,2,4})),({1,2,3,4}))
test_equal(sort(({4,3,2,1})),({1,2,3,4}))
test_equal([[lambda() {array(int) a=({1,2,3,4}); sort(({4,3,2,1}),a); return a; }()]],[[({4,3,2,1})]] )
test_equal([[lambda() {array(int) a=({1,2,3,4}), b=a+({}); sort(({4,3,2,1}),a,b); return b; }()]],[[({4,3,2,1})]] )
test_equal([[sort("a,A,å,Å,ä,*A,[A"/",")]],[["*A,A,[A,a,Å,ä,å"/","]])
test_equal([[sort(sprintf("%c",enumerate(256)[*]))]],
  [[sprintf("%c",enumerate(256)[*])]])
test_equal([[sort(sprintf("%c",enumerate(1024)[*]))]],
  [[sprintf("%c",enumerate(1024)[*])]])
test_equal(sort(({})),({}))
test_equal(sort(({1.0,2.0,4.0,3.0})),({1.0,2.0,3.0,4.0}))
test_any_equal([[
  // sort() on one arg should be stable.
  class C (int id) {int `< (mixed x) {return 0;}};
  return sort (({C(2), C(6), C(1), C(4), C(3), C(5)}))->id;
]], ({2, 6, 1, 4, 3, 5}))
test_any_equal([[
  // sort() on several args should be stable.
  array a = ({2, 6, 1, 4, 3, 5});
  sort (({1, 1, 1, 1, 1, 1}), a);
  return a;
]], ({2, 6, 1, 4, 3, 5}))
test_any_equal([[
  // sort() on several args should be stable.
  array a = ({2, 6, 1, 4, 3, 5});
  sort (({1, 2, 1, 2, 1, 2}), a);
  return a;
]], ({2, 1, 3, 6, 4, 5}))
test_any([[
  class foo {
    int x=random(100);
    int `<(object o) {return x < o->x;}
  };
  array(object) o=allocate(100,foo)();
  sort(o);
  for(int e=1;e<100;e++)
    if(o[e-1]->x > o[e]->x)
      return e;
  return -1;
]],-1)
test_equal(sort (({(<2>), (<1>)})), ({(<1>), (<2>)}))

dnl missing tests for objects, arrays, multisets and mappings

// - sprintf
// Tested in sprintf

// - sqrt
// Tested in _math

// - strerror
test_true(stringp(strerror(0)))
test_true(stringp(strerror(1)))
test_true(stringp(strerror(-1)))

// - string_to_unicode, unicode_to_string
test_eq(string_to_unicode(""), "")
test_eq(string_to_unicode("foo"), "\0f\0o\0o")
test_eq(string_to_unicode("blä"), "\0b\0l\0ä")
test_eq(string_to_unicode("\77077"), "\176\77")
test_eq(string_to_unicode("\777077"), "\330\277\336\77")
test_eq(string_to_unicode("\777077foo\77077\777077blä\777077"), "\330\277\336\77\0f\0o\0o\176\77\330\277\336\77\0b\0l\0ä\330\277\336\77")
test_eq(unicode_to_string(""), "")
test_eq(unicode_to_string("\330\277\336\77\0f\0o\0o\176\77\330\277\336\77\0b\0l\0ä\330\277\336\77"), "\777077foo\77077\777077blä\777077")
test_eq(unicode_to_string("\330\277\336\77"), "\777077")
test_eq(unicode_to_string("\176\77"), "\77077")
test_eq(unicode_to_string("\0b\0l\0ä"), "blä")
test_eq(unicode_to_string("\0f\0o\0o"), "foo")
test_eq(unicode_to_string("\xfe\xff\330\277\336\77\0f\0o\0o\176\77\330\277\336\77\0b\0l\0ä\330\277\336\77"), "\777077foo\77077\777077blä\777077")
test_eq(unicode_to_string("\xfe\xff\330\277\336\77"), "\777077")
test_eq(unicode_to_string("\xfe\xff\176\77"), "\77077")
test_eq(unicode_to_string("\xfe\xff\0b\0l\0ä"), "blä")
test_eq(unicode_to_string("\xfe\xff\0f\0o\0o"), "foo")
test_eq(unicode_to_string("\xff\xfe\277\330\77\336f\0o\0o\0\77\176\277\330\77\336b\0l\0ä\0\277\330\77\336"), "\777077foo\77077\777077blä\777077")
test_eq(unicode_to_string("\xff\xfe\277\330\77\336"), "\777077")
test_eq(unicode_to_string("\xff\xfe\77\176"), "\77077")
test_eq(unicode_to_string("\xff\xfe""b\0l\0ä\0"), "blä")
test_eq(unicode_to_string("\xff\xfe""f\0o\0o\0"), "foo")

test_eval_error(return string_to_unicode("\7077077"))
test_eval_error(return string_to_unicode("\xffff\x10000"))
test_eval_error(return unicode_to_string(" "))

// - string_to_utf8, utf8_to_string
test_eq(string_to_utf8("foo"), "foo")
test_eq(string_to_utf8("blä"), "bl\303\244")
test_eq(string_to_utf8("\77077"), "\347\270\277")
test_eq(string_to_utf8("\7077077"), "\367\207\270\277")
test_eq(string_to_utf8("\77077077"), "\370\277\207\270\277")
test_eq(string_to_utf8("\7077077077"), "\374\270\277\207\270\277")
test_eq(string_to_utf8("\77077077077", 1), "\376\203\270\277\207\270\277")
test_eq(utf8_to_string("\376\203\270\277\207\270\277", 1), "\77077077077")
test_eq(utf8_to_string("\374\270\277\207\270\277"), "\7077077077")
test_eq(utf8_to_string("\370\277\207\270\277"), "\77077077")
test_eq(utf8_to_string("\367\207\270\277"), "\7077077")
test_eq(utf8_to_string("\347\270\277"), "\77077")
test_eq(utf8_to_string("bl\303\244"), "blä")
test_eq(utf8_to_string("foo"), "foo")

test_eval_error(return string_to_utf8("\77077077077"))
test_eval_error(return utf8_to_string("\376\203\270\277\207\270\277"))
test_eval_error(return utf8_to_string("\277"));
test_eval_error(return utf8_to_string("\377"));
test_eval_error(return utf8_to_string("\376\203\270\277\207\270", 1));
test_eval_error(return utf8_to_string("\374\270\277\207\270"));
test_eval_error(return utf8_to_string("\370\277\207\270"));
test_eval_error(return utf8_to_string("\367\207\270"));
test_eval_error(return utf8_to_string("\347\270"));
test_eval_error(return utf8_to_string("\303"));
test_eval_error(return utf8_to_string("\376\203\270\277\207\270a"));
test_eval_error(return utf8_to_string("\374\270\277\207\270a"));
test_eval_error(return utf8_to_string("\370\277\207\270a"));
test_eval_error(return utf8_to_string("\367\207\270a"));
test_eval_error(return utf8_to_string("\347\270a"));
test_eval_error(return utf8_to_string("\303a"));

// - stringp
// Tested in foop

// - strlen
test_eq(strlen, sizeof)

// - symlink
// - syslog

// - tan
// Tested in _math

// - this_object and this
test_true(objectp(this_object()))
test_true(objectp(this))
test_true(objectp(global::this))
test_true(this_object() == this)
test_true([[typeof(this) == typeof(this_object())]])
test_true([[typeof(this) == typeof(global::this)]])
test_true([[typeof(this_program) == typeof(object_program(this_object()))]])
test_true([[typeof(this_program) == typeof(object_program(global::this))]])

test_program_eq([[
  string _sprintf() {return "g";}
  class A {
    string _sprintf() {return "A";}
    class B {
      string _sprintf() {return "B";}
      mixed f() {
	return sprintf ("%O%O%O%O%O",
			global::this, A::this, B::this, this_program::this, this);
      }
    }
  }
  string a() {return A()->B()->f();}
]], "gABBB")

test_program_eq([[
  string _sprintf() {return "g";}
  class A {
    string _sprintf() {return "A";}
    class B {
      string _sprintf() {return "B";}
      mixed f() {
	return sprintf ("%O%O%O%O",
			this_object (2), this_object (1), this_object (0), this_object());
      }
    }
  }
  string a() {return A()->B()->f();}
]], "gABB")

test_program_eq([[
  string _sprintf() {return "g";}
  class A {
    string _sprintf() {return "A";}
    class B {
      string _sprintf() {return "B";}
      mixed f() {
	return map (({2, 1, 0}), lambda (int l) {
				   return sprintf ("%O", this_object (l));
				 }) * "";
      }
    }
  }
  string a() {return A()->B()->f();}
]], "gAB")

test_program_eq([[
  string _sprintf() {return "g";}
  class A {
    string _sprintf() {return "A";}
    class B {
      string _sprintf() {return "B";}
      mixed f() {
	return sprintf ("%O%O%O%O%O",
			global::this, A::this, B::this, this_program::this, this);
      }
    }
    constant this = 7;
  }
  string a() {return A()->B()->f();}
]], "g7BB7")

test_compile_error([[
  this = 17;
]])

test_compile_error([[
  class A {
    class B {
      void f() {A::this = 17;}
    }
  };
]])

test_any([[
  class A {
    class B {
      A parent() {return A::this;}
    }
  };
  A a = A();
  A.B b = a->B();
  destruct (a);
  return zero_type (b->parent());
]], 2)

test_eval_error([[
  class A {
    class B {
      class C {
	A grandparent() {return A::this;}
      }
    }
  };
  A.B b = A()->B();
  A.B.C c = b->C();
  destruct (b);
  b->grandparent();
]], 2)

test_program_eq([[
  string _sprintf() {return "g";}
  class A {
    string _sprintf() {return "A";}
    mixed f() {
      return sprintf ("%O%O", global::this, A::this);
    }
  }
  class B {
    string _sprintf() {return "B";}
    class C {
      inherit A;
      string _sprintf() {return "C";}
      mixed f() {
	return A::f() + sprintf ("%O%O%O%O",
				 global::this, B::this, this_program::this, this);
      }
    }
  }
  string a() {return B()->C()->f();}
]], "gCgBCC")

test_program_eq([[
  string _sprintf() {return "g";}
  class A {
    string _sprintf() {return "A";}
    mixed f() {
      return sprintf ("%O%O%O%O",
		      global::this, A::this, this_program::this, this);
    }
  }
  class B {
    string _sprintf() {return "B";}
    class C {
      inherit A;
      string _sprintf() {return "C";}
      mixed f() {
	return A::f() + "|" +
	  sprintf ("%O%O%O%O%O",
		   global::this, B::this, C::this, this_program::this, this);
      }
    }
  }
  string a() {return B()->C()->f();}
]], "gCCC|gBCCC")

test_program([[
  class A {
    class B {
      mixed f() {
	return typeof (A::this) != typeof (B::this);
      }
    }
  }
  int a() {return A()->B()->f();}
]])

test_program([[
  class A {
    class B {
      mixed f() {
	return typeof (this_object (1)) != typeof (this_object (0));
      }
    }
  }
  int a() {return A()->B()->f();}
]])

test_program([[
  class A {
    class B {
      mixed f() {
	return typeof (A::this_program) != typeof (B::this_program);
      }
    }
  }
  int a() {return A()->B()->f();}
]])

test_program_eq([[
  object ao = compile_string(#"
    string id() {return \"A\";}
    class B {
      string id() {return \"B\";}
      string foo()
      {
	return this->id() + id() + local::id() + global::this->id() + global::id();
      }
    }")();

  class Handler
  {
    mixed resolv (string id, void|string file, void|object handler)
    {
      if (id == "B") return ao->B;
      return master()->resolv (id, file, handler);
    }
  }

  string a()
  {
    object c = compile_string(#"
      string id() {return \"C\";}
      class D {
	inherit B;
	string id() {return \"D\";}
	string foo()
	{
	  return ::foo() + \"|\" +
	    this->id() + id() + B::id() + global::this->id() + global::id();
	}
      }", 0, Handler())();

    return c->D()->foo();
  }
]], "DDBAA|DDBCC")

test_program_eq([[
  class X
  {
    object parent() {return global::this;}
  }

  class Handler
  {
    mixed resolv (string id, void|string file, void|object handler)
    {
      if (id == "X") return X;
      return master()->resolv (id, file, handler);
    }
  }

  object a()
  {
    object o = compile_string ("inherit X;", 0, Handler())();
    return o->parent();
  }
]], this_object())


// - this_thread
// - thread_create
// - thread_local

// - throw
test_eq(20,catch(throw(a())))

// - time
test_true(time())
test_true(time(1))
test_true(intp(time()))
test_true(intp(time(1)))
test_true(floatp(time(2)))

// gethrtime() may gethrtime(), RDTSC or gettimeofday
// sleep uses a combination of select/poll and the above
// time() uses gettimeofday
test_any([[
   float tts=2.0;

   int t0=time();
   float t1=time(t0);
   int hrt1=gethrtime();
   sleep(tts);
   int hrt2=gethrtime();
   float t2=time(t0);
   
   float e=(hrt2-hrt1)*1e-6;
   float f=t2-t1;

   array r=({});
   if (e<tts-0.1 || e>tts+0.1) 
      r+=({sprintf("hrtime %.6f, %+.6f",e,e-tts)});

   if (f<tts-0.1 || f>tts+0.1) 
      r+=({sprintf("timeofday %.6f, %+.6f",f,f-tts)});

   if (sizeof(r)) return r*" / ";
   return "no error";
]],"no error")

// - trace
test_do(trace(0))
test_eq(trace(0),0)

// - ualarm
// - umask
// - uname

// - unicode_to_string
// See string_to_unicode

// - upper_case
test_equal(upper_case("fooq"),"FOOQ")
test_equal(upper_case("FooR"),"FOOR")
test_equal(upper_case("Foo1234-*~\n"),"FOO1234-*~\n")
test_equal(upper_case("fooq\x3000"),"FOOQ\x3000")
test_equal(upper_case("FooR\x3000"),"FOOR\x3000")
test_equal(upper_case("Foo1234-*~\n\x3000"),"FOO1234-*~\n\x3000")
test_equal(upper_case("fooq\x13000"),"FOOQ\x13000")
test_equal(upper_case("FooR\x13000"),"FOOR\x13000")
test_equal(upper_case("Foo1234-*~\n\x13000"),"FOO1234-*~\n\x13000")
test_equal(upper_case("Foo\xff"),"FOO\x178")
test_equal(upper_case("Foo\xb5"),"FOO\x39c")
test_equal(upper_case((string) ({
// These characters correspond to the cases in case_info.h
// Please update this and the corresponding lower_case table
// when UnicodeData.txt is changed.
// Part 1: 0x0000 - 0x0FFF
0x0000, 0x0041, 0x005b, 0x0061, 0x007b, 0x00b5, 0x00b6, 0x00c0,
0x00d7, 0x00d8, 0x00df, 0x00e0, 0x00f7, 0x00f8, 0x00ff, 0x0100,
0x0130, 0x0131, 0x0132, 0x0138, 0x0139, 0x0149, 0x014a, 0x0178,
0x0179, 0x017f, 0x0180, 0x0181, 0x0182, 0x0186, 0x0187, 0x0189,
0x018b, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0193, 0x0194,
0x0195, 0x0196, 0x0197, 0x0198, 0x019a, 0x019c, 0x019d, 0x019e,
0x019f, 0x01a0, 0x01a6, 0x01a7, 0x01a9, 0x01aa, 0x01ac, 0x01ae,
0x01af, 0x01b1, 0x01b3, 0x01b7, 0x01b8, 0x01ba, 0x01bc, 0x01be,
0x01bf, 0x01c0, 0x01c4, 0x01c5, 0x01c7, 0x01c8, 0x01ca, 0x01cb,
0x01dd, 0x01de, 0x01f0, 0x01f1, 0x01f2, 0x01f6, 0x01f7, 0x01f8,
0x0220, 0x0221, 0x0222, 0x0234, 0x0253, 0x0254, 0x0255, 0x0256,
0x0258, 0x0259, 0x025a, 0x025b, 0x025c, 0x0260, 0x0261, 0x0263,
0x0264, 0x0268, 0x0269, 0x026a, 0x026f, 0x0270, 0x0272, 0x0273,
0x0275, 0x0276, 0x0280, 0x0281, 0x0283, 0x0284, 0x0288, 0x0289,
0x028a, 0x028c, 0x0292, 0x0293, 0x0345, 0x0346, 0x0386, 0x0387,
0x0388, 0x038b, 0x038c, 0x038d, 0x038e, 0x0390, 0x0391, 0x03a0,
0x03a2, 0x03a3, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03c0, 0x03c2,
0x03c3, 0x03cc, 0x03cd, 0x03cf, 0x03d0, 0x03d1, 0x03d2, 0x03d5,
0x03d6, 0x03d7, 0x03d8, 0x03f0, 0x03f1, 0x03f2, 0x03f3, 0x03f4,
0x03f5, 0x03f6, 0x03f7, 0x03f9, 0x03fa, 0x03fc, 0x0400, 0x0410,
0x0420, 0x0430, 0x0440, 0x0450, 0x0460, 0x0482, 0x048a, 0x04c0,
0x04c1, 0x04cf, 0x04d0, 0x04f6, 0x04f8, 0x04fa, 0x0500, 0x0510,
0x0531, 0x0557, 0x0561, 0x0587,
})), (string) ({
0x0000, 0x0041, 0x005b, 0x0041, 0x007b, 0x039c, 0x00b6, 0x00c0, 
0x00d7, 0x00d8, 0x00df, 0x00c0, 0x00f7, 0x00d8, 0x0178, 0x0100, 
0x0130, 0x0049, 0x0132, 0x0138, 0x0139, 0x0149, 0x014a, 0x0178, 
0x0179, 0x0053, 0x0180, 0x0181, 0x0182, 0x0186, 0x0187, 0x0189, 
0x018b, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0193, 0x0194, 
0x01f6, 0x0196, 0x0197, 0x0198, 0x019a, 0x019c, 0x019d, 0x0220, 
0x019f, 0x01a0, 0x01a6, 0x01a7, 0x01a9, 0x01aa, 0x01ac, 0x01ae, 
0x01af, 0x01b1, 0x01b3, 0x01b7, 0x01b8, 0x01ba, 0x01bc, 0x01be, 
0x01f7, 0x01c0, 0x01c4, 0x01c5, 0x01c7, 0x01c8, 0x01ca, 0x01cb, 
0x018e, 0x01de, 0x01f0, 0x01f1, 0x01f2, 0x01f6, 0x01f7, 0x01f8, 
0x0220, 0x0221, 0x0222, 0x0234, 0x0181, 0x0186, 0x0255, 0x0189, 
0x0258, 0x018f, 0x025a, 0x0190, 0x025c, 0x0193, 0x0261, 0x0194, 
0x0264, 0x0197, 0x0196, 0x026a, 0x019c, 0x0270, 0x019d, 0x0273, 
0x019f, 0x0276, 0x01a6, 0x0281, 0x01a9, 0x0284, 0x01ae, 0x0289, 
0x01b1, 0x028c, 0x01b7, 0x0293, 0x0399, 0x0346, 0x0386, 0x0387, 
0x0388, 0x038b, 0x038c, 0x038d, 0x038e, 0x0390, 0x0391, 0x03a0, 
0x03a2, 0x03a3, 0x0386, 0x0388, 0x03b0, 0x0391, 0x03a0, 0x03a3, 
0x03a3, 0x038c, 0x038e, 0x03cf, 0x0392, 0x0398, 0x03d2, 0x03a6, 
0x03a0, 0x03d7, 0x03d8, 0x039a, 0x03a1, 0x03f9, 0x03f3, 0x03f4, 
0x0395, 0x03f6, 0x03f7, 0x03f9, 0x03fa, 0x03fc, 0x0400, 0x0410,
0x0420, 0x0410, 0x0420, 0x0400, 0x0460, 0x0482, 0x048a, 0x04c0,
0x04c1, 0x04cf, 0x04d0, 0x04f6, 0x04f8, 0x04fa, 0x0500, 0x0510,
0x0531, 0x0557, 0x0531, 0x0587, 
}))
test_equal(upper_case((string) ({
// These characters correspond to the cases in case_info.h
// Please update this and the corresponding lower_case table
// when UnicodeData.txt is changed.
// Part 2: 0x1000 -
0x1e00, 0x1e96, 0x1e9b, 0x1e9c, 0x1ea0, 0x1efa, 0x1f00, 0x1f08,
0x1f10, 0x1f16, 0x1f18, 0x1f1e, 0x1f20, 0x1f28, 0x1f30, 0x1f38,
0x1f40, 0x1f46, 0x1f48, 0x1f4e, 0x1f51, 0x1f52, 0x1f53, 0x1f54,
0x1f55, 0x1f56, 0x1f57, 0x1f58, 0x1f59, 0x1f5a, 0x1f5b, 0x1f5c,
0x1f5d, 0x1f5e, 0x1f5f, 0x1f60, 0x1f68, 0x1f70, 0x1f72, 0x1f76,
0x1f78, 0x1f7a, 0x1f7c, 0x1f7e, 0x1f80, 0x1f88, 0x1f90, 0x1f98,
0x1fa0, 0x1fa8, 0x1fb0, 0x1fb2, 0x1fb3, 0x1fb4, 0x1fb8, 0x1fba,
0x1fbc, 0x1fbd, 0x1fbe, 0x1fbf, 0x1fc3, 0x1fc4, 0x1fc8, 0x1fcc,
0x1fcd, 0x1fd0, 0x1fd2, 0x1fd8, 0x1fda, 0x1fdc, 0x1fe0, 0x1fe2,
0x1fe5, 0x1fe6, 0x1fe8, 0x1fea, 0x1fec, 0x1fed, 0x1ff3, 0x1ff4,
0x1ff8, 0x1ffa, 0x1ffc, 0x1ffd, 0x2126, 0x2127, 0x212a, 0x212b,
0x212c, 0x2160, 0x2180, 0x24b6, 0x24d0, 0x24ea, 0xff21, 0xff3b,
0xff41, 0xff5b,
0x010400, 0x010428, 0x010450,
})), (string) ({
0x1e00, 0x1e96, 0x1e60, 0x1e9c, 0x1ea0, 0x1efa, 0x1f08, 0x1f08, 
0x1f18, 0x1f16, 0x1f18, 0x1f1e, 0x1f28, 0x1f28, 0x1f38, 0x1f38, 
0x1f48, 0x1f46, 0x1f48, 0x1f4e, 0x1f59, 0x1f52, 0x1f5b, 0x1f54, 
0x1f5d, 0x1f56, 0x1f5f, 0x1f58, 0x1f59, 0x1f5a, 0x1f5b, 0x1f5c, 
0x1f5d, 0x1f5e, 0x1f5f, 0x1f68, 0x1f68, 0x1fba, 0x1fc8, 0x1fda, 
0x1ff8, 0x1fea, 0x1ffa, 0x1f7e, 0x1f88, 0x1f88, 0x1f98, 0x1f98, 
0x1fa8, 0x1fa8, 0x1fb8, 0x1fb2, 0x1fbc, 0x1fb4, 0x1fb8, 0x1fba, 
0x1fbc, 0x1fbd, 0x0399, 0x1fbf, 0x1fcc, 0x1fc4, 0x1fc8, 0x1fcc, 
0x1fcd, 0x1fd8, 0x1fd2, 0x1fd8, 0x1fda, 0x1fdc, 0x1fe8, 0x1fe2, 
0x1fec, 0x1fe6, 0x1fe8, 0x1fea, 0x1fec, 0x1fed, 0x1ffc, 0x1ff4, 
0x1ff8, 0x1ffa, 0x1ffc, 0x1ffd, 0x2126, 0x2127, 0x212a, 0x212b, 
0x212c, 0x2160, 0x2180, 0x24b6, 0x24b6, 0x24ea, 0xff21, 0xff3b, 
0xff21, 0xff5b,
0x010400, 0x010400, 0x010450, 
}))

// - utf8_to_string
// See string_to_utf8

// - utime

// - values
test_equal(values("foo"),({'f','o','o'}))
test_equal(values(({'f','o','o'})),({'f','o','o'}))
test_equal(Array.sort_array(values(([7:3,8:9,99:12]))),({3,9,12}))
test_equal(values((<7,8,99>)),({1,1,1}))
test_equal(mkmultiset(values(class{ constant a="a"; constant b="b";}())),
           (<"a","b">))

// - version
test_equal(version(), "Pike v"+__REAL_MAJOR__+"."+__REAL_MINOR__+" release "+__REAL_BUILD__)

// - werror
// - write

// - zero_type
test_eq(zero_type(0),0)
test_eq(zero_type(([])[7]),1)
test_eq(zero_type(UNDEFINED), 1)

test_true([[lambda (int|void a) { return zero_type(a); }()]])
test_true([[lambda () {mixed a; return zero_type(a = ([])[0]);}()]])
test_true([[lambda () {mapping a=([]); return zero_type(a[0] = ([])[0]);}()]])
test_true([[zero_type (lambda () {return ([])[0];}())]])




test_program(int b=10; mixed a() { return 1; })
test_program(mixed b=10; mixed a() { return 1;})
test_define_program(test,[[int q,w,e,r,t; mixed foo() { return 10; }]])

test_program(inherit test; mixed a() { return foo()==10; })
test_program(inherit test; mixed a() { return test::foo()==10; })
test_program(inherit test : bar; mixed a() { return bar::foo()==10; })

test_define_program(test2,[[int z,x,c,v,b; mixed bar() { return 11; }]])
test_program(inherit test; inherit test2; mixed a() { return foo()==10 && bar()==11; })
test_program(inherit test2; inherit test; mixed a() { return foo()==10 && bar()==11; })

test_define_program(test,[[int q,w,e,r; mixed t; mixed getw() { return w; } void setw(int _) { w=_; }]])
test_define_program(test2,[[int z,x,c,v,b; mixed getb() { return b; } void setb(int _) { b=_; }]])

test_program(inherit test; inherit test2; mixed a() { w=20; b=22; return getw()==20 && getb()==22; })
test_program(inherit test; inherit test2; mixed a() { setw(20); setb(22); return w==20 && b==22; })
test_program(inherit test2; inherit test; mixed a() { w=20; b=22; return getw()==20 && getb()==22; })
test_program(inherit test2; inherit test; mixed a() { setw(20); setb(22); return w==20 && b==22; })

test_do(add_constant("test"))
test_do(add_constant("test2"))

test_eval_error(return class c{int i;void foo(){ destruct(this_object());i=0;return i;}}()->foo())

// - get_function (actually in simulate.pike)
test_eq(a,
#pike 7.0
Simulate.get_function(this_object(),"a"))
test_eq(a,this_object()->a)

// - catch
test_false([[class X { string test(string foo) { catch { return lower_case(foo); }; return foo; }}()->test(0); ]])
test_true([[catch (1.0 / 0.0)]])
test_true([[catch {float f = 1.0 / 0.0;}]])


// Pike modules

// - this failed in Calendar.Timezone

test_compile( 
[[
   array tz_ux(int ux)
   {
      if (ux<-0x80000000 || ux>0x7fffffff)
	 error("bah\n");
      return ({}); 
   };
]]);

// string[]=
test_any([[string s="foo"; s[2]='t'; s[0]--; return s;]],"eot")
test_any([[string s="foo"; s[2]=0777; s[1]--; return s;]],"fn\777")
test_any([[string s="foo"; s[2]=07777777; s[1]--; return s;]],"fn\7777777")
test_any([[string s="foo"; s[2]='t'; catch (s[10]='x'); return s;]], "fot")

cond([[all_constants()->_verify_internals]],
[[
  test_do(_verify_internals())
]])

test_tests([[
array a()
{
  Stdio.File p = Stdio.File();
  object pid = Process.create_process(RUNPIKE_ARRAY +
				      ({ "]]SRCDIR[[/test_resolve.pike" }),
				      ([ "stdout":p->pipe(Stdio.PROP_IPC) ]));
  __signal_watchdog();
  string results = lower_case(p->read());
  __signal_watchdog();
  int err = pid->wait();
  int ok;
  int failed;
  if (((sscanf(results, "%*sok:%d", ok) != 2) +
       (sscanf(results, "%*sfailed:%d", failed) != 2)) == 2) {
    // No "ok", and no "failed".
    return ({ err, results });
  }
  return ({ ok, failed });
}
]])

// - modifiers, compile time type checks

test_compile_any(class A {int v;} class B {inherit A; int v;})
test_compile_error_any(class A {int v;} class B {inherit A; float v;})
dnl test_compile_error_any(class A {int v;} class B {inherit A; mixed v;})
dnl test_compile_error_any(class A {mixed v;} class B {inherit A; int v;})
dnl test_compile_error_any(class A {public int v;} class B {inherit A; mixed v;})
dnl test_compile_error_any(class A { public { int v; } } class B {inherit A; mixed v;})
dnl test_compile_error_any(class A {public mixed v;} class B {inherit A; int v;})
test_compile_error_any(class A {static int v;} class B {inherit A; float v;})
dnl test_compile_error_any(class A {static int v;} class B {inherit A; mixed v;})
dnl test_compile_error_any(class A {static mixed v;} class B {inherit A; int v;})
test_compile_any(class A {private int v;} class B {inherit A; float v;})
dnl test_compile_any(class A {private int v;} class B {inherit A; mixed v;})
dnl test_compile_any(class A {private mixed v;} class B {inherit A; int v;})
test_compile_error_any(class A {final int v;} class B {inherit A; int v;})
test_compile_error_any(class A {final int v;} class B {inherit A; final int v;})
test_compile_error_any(class A {nomask int v;} class B {inherit A; int v;})
test_compile_error_any(class A {nomask int v;} class B {inherit A; nomask int v;})
test_compile_any(class A {local int v;} class B {inherit A; float v;})
test_compile_any(class A {local int v;} class B {inherit A; mixed v;})
test_compile_any(class A {local mixed v;} class B {inherit A; int v;})
test_compile_any(class A {inline int v;} class B {inherit A; float v;})
test_compile_any(class A {inline int v;} class B {inherit A; mixed v;})
test_compile_any(class A {inline mixed v;} class B {inherit A; int v;})

test_compile_any(class A {int f(){}} class B {inherit A; int f(){}})
test_compile_any(class A {int f(){}} class B {inherit A; float f(){}})
test_compile_any(class A {int f(){}} class B {inherit A; mixed f(){}})
test_compile_any(class A {mixed f(){}} class B {inherit A; int f(){}})
test_compile_any(class A {void f(){}} class B {inherit A; void f(int a){}})
test_compile_any(class A {void f(int a){}} class B {inherit A; void f(float a){}})
test_compile_any(class A {void f(int a){}} class B {inherit A; void f(mixed a){}})
test_compile_any(class A {void f(mixed a){}} class B {inherit A; void f(int a){}})
test_compile_error_any(class A {final int f(){}} class B {inherit A; int f(){}})
test_compile_error_any(class A {final int f(){}} class B {inherit A; final int f(){}})
test_compile_error_any(class A {nomask int f(){}} class B {inherit A; int f(){}})
test_compile_error_any(class A {nomask int f(){}} class B {inherit A; nomask int f(){}})

test_compile_warning(class A {int v;}; class B {inherit A; int v(){}})
test_compile_warning(class A {public int v;}; class B {inherit A; int v(){}})
test_compile_warning(class A {static int v;}; class B {inherit A; int v(){}})
test_compile_any(class A {private int v;} class B {inherit A; int v(){}})
test_compile_error_any(class A {final int v;} class B {inherit A; int v(){}})
test_compile_error_any(class A {nomask int v;} class B {inherit A; int v(){}})
test_compile_any(class A {local int v;} class B {inherit A; int v(){}})
test_compile_any(class A {inline int v;} class B {inherit A; int v(){}})

test_compile_error_any(class A {int f(){}} class B {inherit A; int f;})
test_compile_error_any(class A {public int f(){}} class B {inherit A; int f;})
test_compile_error_any(class A {static int f(){}} class B {inherit A; int f;})
test_compile_any(class A {private int f(){}} class B {inherit A; int f;})
test_compile_error_any(class A {final int f(){}} class B {inherit A; int f;})
test_compile_error_any(class A {nomask int f(){}} class B {inherit A; int f;})
test_compile_any(class A {local int f(){}} class B {inherit A; int f;})
test_compile_any(class A {inline int f(){}} class B {inherit A; int f;})

// - modifiers, compile time access properties

test_compile_error_any(class A {} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {public int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {static int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_error_any(class A {private int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {final int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {nomask int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {local int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {inline int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {public int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {static int f(){}} class B {inherit A; void g(){f();}})
test_compile_error_any(class A {private int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {final int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {nomask int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {local int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {inline int f(){}} class B {inherit A; void g(){f();}})

test_compile_any(class A {int v;} class B {public inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {static inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {private inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {final inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {nomask inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {local inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {inline inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int f(){}} class B {public inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {static inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {private inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {final inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {nomask inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {local inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {inline inherit A; void g(){f();}})

test_compile_error_any(class A {} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {public int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {static int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_error_any(class A {private int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {final int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {nomask int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {local int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {inline int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {public int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {static int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_error_any(class A {private int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {final int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {nomask int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {local int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {inline int f(){}} class B {inherit A; void g(){A::f();}})

test_compile_any(class A {int v;} class B {public inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {static inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {private inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {final inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {nomask inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {local inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {inline inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int f(){}} class B {public inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {static inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {private inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {final inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {nomask inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {local inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {inline inherit A; void g(){A::f();}})

test_compile_error_any(class A {} class B {inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {public inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {static inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_error_any(class A {int v;} class B {private inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {final inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {nomask inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {local inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {inline inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int f(){}} class B {inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {public inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {static inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_error_any(class A {int f(){}} class B {private inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {final inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {nomask inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {local inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {inline inherit A;} class C {inherit B; void g(){B::f();}})

// - modifiers, run time access properties

test_eval_error(return class {}()->f())
test_do(class {int f(){}}()->f())
test_do(class {public int f(){}}()->f())
test_eval_error(return class {static int f(){}}()->f())
test_eval_error(return class {private int f(){}}()->f())
test_do(class {final int f(){}}()->f())
test_do(class {nomask int f(){}}()->f())
test_do(class {local int f(){}}()->f())
test_do(class {inline int f(){}}()->f())
test_do(class {class A {}}()->A())
test_do(class {public class A {}}()->A())
test_eval_error(return class {static class A {}}()->A())
test_eval_error(return class {private class A {}}()->A())
test_do(class {final class A {}}()->A())
test_do(class {nomask class A {}}()->A())
test_do(class {local class A {}}()->A())
test_do(class {inline class A {}}()->A())

test_equal(indices(class {}()), ({}))
test_equal(indices(class {int v;}()), ({"v"}))
test_equal(indices(class {public int v;}()), ({"v"}))
test_equal(indices(class {static int v;}()), ({}))
test_equal(indices(class {private int v;}()), ({}))
test_equal(indices(class {final int v;}()), ({"v"}))
test_equal(indices(class {nomask int v;}()), ({"v"}))
test_equal(indices(class {local int v;}()), ({"v"}))
test_equal(indices(class {inline int v;}()), ({"v"}))
test_equal(indices(class {int f(){}}()), ({"f"}))
test_equal(indices(class {public int f(){}}()), ({"f"}))
test_equal(indices(class {static int f(){}}()), ({}))
test_equal(indices(class {private int f(){}}()), ({}))
test_equal(indices(class {final int f(){}}()), ({"f"}))
test_equal(indices(class {nomask int f(){}}()), ({"f"}))
test_equal(indices(class {local int f(){}}()), ({"f"}))
test_equal(indices(class {inline int f(){}}()), ({"f"}))

test_equal(indices(class {class A {} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {public int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {static int v;} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {private int v;} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {final int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {nomask int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {local int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {inline int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {public int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {static int f(){}} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {private int f(){}} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {final int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {nomask int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {local int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {inline int f(){}} class B {inherit A;}}()->B()), ({"f"}))

test_equal(indices(class {class A {int v;} class B {public inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {static inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int v;} class B {private inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int v;} class B {final inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {nomask inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {local inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {inline inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int f(){}} class B {public inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {static inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int f(){}} class B {private inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int f(){}} class B {final inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {nomask inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {local inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {inline inherit A;}}()->B()), ({"f"}))

test_equal(indices(class {class A {} class B {inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int v;} class B {inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {public inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {static inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int v;} class B {private inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int v;} class B {final inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {nomask inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {local inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {inline inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int f(){}} class B {inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {public inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {static inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int f(){}} class B {private inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int f(){}} class B {final inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {nomask inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {local inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {inline inherit A;} class C {inherit B;}}()->C()), ({"f"}))

// - modifiers, binding and redefinition properties with compile time access

test_any(class A {int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {public int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {static int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {private int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_compile_error_any(class A {final int v=1;}; class B {inherit A; int v=2;};)
test_compile_error_any(class A {nomask int v=1;}; class B {inherit A; int v=2;};)
test_any(class A {local int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {inline int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {public int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {static int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {private int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_compile_error_any(class A {final int f(){return 1;}}; class B {inherit A; int f(){return 2;}};)
test_compile_error_any(class A {nomask int f(){return 1;}}; class B {inherit A; int f(){return 2;}};)
test_any(class A {local int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {inline int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)

test_any(class A {int v=1;}; class B {public inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {static inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {private inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_compile_error_any(class A {int v=1;}; class B {final inherit A; int v=2;};)
test_compile_error_any(class A {int v=1;}; class B {nomask inherit A; int v=2;};)
test_any(class A {int v=1;}; class B {local inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inline inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {public inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {static inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {private inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_compile_error_any(class A {int f(){return 1;}}; class B {final inherit A; int f(){return 2;}};)
test_compile_error_any(class A {int f(){return 1;}}; class B {nomask inherit A; int f(){return 2;}};)
test_any(class A {int f(){return 1;}}; class B {local inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inline inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)

test_any(class A {int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; public int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; static int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; private int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; final int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; nomask int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; local int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; inline int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; public int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; static int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; private int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; final int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; nomask int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; local int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return local::f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; inline int f(){return 2;} int t(){return f();}}; return B()->t(), 2)

test_any(class A {int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 2)
test_any(class A {public int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 2)
test_any(class A {static int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 2)
test_any(class A {private int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 1)
test_any(class A {local int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 1)
test_any(class A {inline int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 2)
test_any(class A {public int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 2)
test_any(class A {static int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 2)
test_any(class A {private int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)
test_any(class A {local int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return local::f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)
test_any(class A {inline int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)

test_any(class A {int v=1; int t(){return v;}}; class B {inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {public inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {static inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {private inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {local inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int v=1; int t(){return v;}}; class B {inline inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {public inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {static inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {private inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {local inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {inline inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 1)

test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x003)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; public int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x003)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; private int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x021)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; static int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x003)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; local int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x021)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; inline int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x021)

// - modifiers, binding and redefinition properties with run time access

test_any(class A {int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {public int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {static int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {private int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {local int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {inline int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {public int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {static int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {private int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {local int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {inline int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)

test_any(class A {int v=1;}; class B {public inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {static inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {private inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {local inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inline inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int f(){return 1;}}; class B {public inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {static inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {private inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {local inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inline inherit A; int f(){return 2;}}; return B()->f(), 2)

test_any(class A {int v=1;}; class B {inherit A; public int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; static int v=2;}; return B()->v, 0)
test_any(class A {int v=1;}; class B {inherit A; private int v=2;}; return B()->v, 0)
test_any(class A {int v=1;}; class B {inherit A; final int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; nomask int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; local int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; inline int v=2;}; return B()->v, 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; public int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; static int f(){return 2;}}; return B()->f, 0)
test_any(class A {int f(){return 1;}}; class B {inherit A; private int f(){return 2;}}; return B()->f, 0)
test_any(class A {int f(){return 1;}}; class B {inherit A; final int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; nomask int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; local int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; inline int f(){return 2;}}; return B()->f(), 2)

// - modifiers, misc checks

test_program([[
  class A {int i = 17;}
  class B {
    private inherit A;
    class C {
      int f() {return i;}
    }
  }
  int a() {return B()->C()->f() == 17;}
]])

test_any([[
class Fnord
{
  array gnzpp() { }
  constant fNord = 4711;

  class Bzonk
  {
    int xxxxx=17;
    int yyyyy=17;
    int zzzzz=17;

  }

  class Zboink
  {
    int pphfiztzz=1;
    inherit Bzonk;
    constant floingngg=fNord;
    array Zpfoooinginoooo() {}
    
    int t()
      {
	return fNord + fNord;
      }
    int z()
      {
	return floingngg + floingngg;
      }
  }
};
return Fnord()->Zboink()->t() + Fnord()->Zboink()->z();
]],4711 * 4)

test_any([[
  class Foo
  {
    string s = "a";

    int|string foo()
    {
      int i;
      for (; i < strlen(s); i++) {
        if (!strlen(s) && i) {
          return "Optimizer error!";
        }
        s = "";
        i = 0;
      }
      return 0;
    }
  };
  return Foo()->foo();
]], 0)

// - call_out, call_out_info, remove_call_out, find_call_out
test_do(add_constant("call_out_cb", a))
test_do(call_out(call_out_cb,100000))
test_true(call_out(lambda() {},1000.0))
test_true(remove_call_out(call_out(lambda() {},1000.0)) != -1)
test_true(find_call_out(call_out(lambda() {},1000.0)) > 990)
test_false(zero_type(remove_call_out(call_out(lambda() {},1000.0))))
test_true(arrayp(call_out_info()))
test_true(sizeof(call_out_info()) > 0)
test_true(call_out_info()[-1][0] > 1)
test_eq(find_call_out(call_out_info()[-1][2]), call_out_info()[-1][0])
test_eq(find_call_out(a),-1)
test_true(zero_type(find_call_out(a)))
test_true(!sizeof(call_out_info()) || function_name(call_out_info()[-1][2])!="call_out_cb")
test_do(remove_call_out(call_out_info()[-1][2]))
test_do(add_constant("call_out_cb"))
test_do(_do_call_outs())
test_any([[
  object pid = Process.create_process(RUNPIKE_ARRAY +
				      ({ "]]SRCDIR[[/test_co.pike" }));
  int i;
  for (i=0; i < 120; i++) {
    if (pid->status()>0) break;
    __signal_watchdog();
    sleep(1);
  }
  if (pid->status() <= 0) {
    pid->kill(9);
    return "Killed";
  }
  return pid->wait();
]], 0)
test_do_([[ catch { _do_call_outs(); }]])

// - varargs
test_any_equal([[
  mixed test(int a, mixed ... b) {
    return b;
  };
  return test(1);
]],[[ ({}) ]])
test_any_equal([[
  mixed test(int a, mixed ... b) {
    return b;
  };
  return test(1,2);
]],[[ ({2}) ]])
test_any_equal([[
  mixed test(int a, mixed ... b) {
    return b;
  };
  return test(1,2,3);
]],[[ ({2,3}) ]])
test_any_equal([[
  mixed test(int a, mixed ... b) {
    return b;
  };
  return test(1,2,3);
]],[[ ({2,3}) ]])
test_compile_error([[
  mixed test(int a, mixed ... b) {
    return b;
  };
  return test();
]])
test_any_equal([[
  mixed test(void|int a, mixed ... b) {
    return b;
  };
  return test();
]],[[ ({}) ]])
test_any_equal([[
  mixed test(int a, mixed ... b) {
    if(a) return test(0);
    return b; 
  };
  return test(1,2);
]],[[ ({}) ]])
test_any_equal([[
  class X {
    mixed test(int a, mixed ... b) {
      if(a) return test(0);
      return b;
    }
  };
  return X()->test(1,2);
]],[[ ({}) ]])
END_MARKER

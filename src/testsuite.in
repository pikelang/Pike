START_MARKER

// This triggered a bug only if run sufficiently early.
test_compile_any([[#pike 7.6]])
test_compile_any([[#pike 7.8]])
test_compile_any([[#pike 8.0]])
test_compile_any([[#pike 8.1]])
test_compile_any([[#pike 8.2]])

ifefun(_verify_internals,
[[
  test_do(_verify_internals())
]]);
test_eq(1e1,10.0);
test_eq(1E1,10.0);
test_eq(1e+1,10.0);
test_eq(1.1e1,11.0);
test_eq(1e-1,0.1);
test_eq('\x20',32);
test_eq("\x20","\040");
test_eq("\d32","\x20");
test_eq('Å',"Å"[0]);
test_eq('\7777',"\7777"[0]);
test_eq('\77777777',"\77777777"[0]);
test_eq("\x10000","\x10000");
test_eq(0x80000000-0x80000000, 0);
test_eq(0xf0000000-0xf0000000, 0);
test_eq(0x80000001-0x80000000, 1);
test_eq(0x80000000-0x80000001,-1);
test_eq(-2147483648*-1, -2147483648/-1);
test_eq(0x8000000000000000-0x8000000000000000, 0);
test_eq(0xf000000000000000-0xf000000000000000, 0);
test_eq(0x8000000000000001-0x8000000000000000, 1);
test_eq(0x8000000000000000-0x8000000000000001,-1);
test_eq(-9223372036854775808*-1, -9223372036854775808/-1);
test_true([[1.0e-40]]);
test_eq([[#"foo
bar"]],[["foo\nbar"]]);
test_eq([[# "foo
bar"]],[["foo\nbar"]]);
test_eq([[#"foo\
bar"]],[["foobar"]]);
test_eq([[#(foo
bar#) - "\r"]],[["foo\nbar"]]);
test_eq([[# (foo
bar#) - "\r"]],[["foo\nbar"]]);
test_eq([[#(foo\
bar#) - "\r"]],[["foo\\\nbar"]]);
test_eq([[#[foo
bar#] - "\r"]],[["foo\nbar"]]);
test_eq([[# [foo
bar#] - "\r"]],[["foo\nbar"]]);
test_eq([[#[foo\
bar#] - "\r"]],[["foo\\\nbar"]]);
test_eq([[#{foo
bar#} - "\r"]],[["foo\nbar"]]);
test_eq([[# {foo
bar#} - "\r"]],[["foo\nbar"]]);
test_eq([[#{foo\
bar#} - "\r"]],[["foo\\\nbar"]]);
test_true([[stringp(#string "Makefile")]]);
test_any([[class Bar { array(int) foo = ({}); };
	   class Foo { inherit Bar; array(int) foo = ({1}); };
	   return sizeof(Foo()->foo);]],1);

test_eq([["(" + 0x7fffffff + ")"]], "(2147483647)")
test_eq([["(" + -0x80000000 + ")"]], "(-2147483648)")
test_eq([["(" + 0x7fffffffffffffff + ")"]], "(9223372036854775807)")
test_eq([["(" + -0x8000000000000000 + ")"]], "(-9223372036854775808)")
test_eq([["(" + Int.NATIVE_MAX + ")"]], [[sprintf ("(%d)", Int.NATIVE_MAX)]])
test_eq([["(" + Int.NATIVE_MIN + ")"]], [[sprintf ("(%d)", Int.NATIVE_MIN)]])
test_eq([[Int.NATIVE_MAX]], [[(int) (Int.NATIVE_MAX + "")]])
test_eq([[Int.NATIVE_MIN]], [[(int) (Int.NATIVE_MIN + "")]])
test_eq([[(string) Int.NATIVE_MAX]], [[Int.NATIVE_MAX + ""]])
test_eq([[(string) Int.NATIVE_MIN]], [[Int.NATIVE_MIN + ""]])
test_eq([[(string) Int.NATIVE_MAX]], [[sprintf ("%d", Int.NATIVE_MAX)]])
test_eq([[(string) Int.NATIVE_MIN]], [[sprintf ("%d", Int.NATIVE_MIN)]])

test_any_equal([[
  array res = ({});
  array ops = ({ `+, `-, `*, `/, `%, `<<, `>>, `&, `|, `^ });
  array nums_a = ({ 0, 1, -1, 0xffffffff, 0xffffffffffffffff });
  array nums_b = ({ 0, 1, -1 });

  foreach(ops;; function op)
    foreach(nums_a;; int a)
      foreach(nums_b;; int b)
      {
        mixed err = catch {
          res += ({ op(a,b) });
        };
        if( err ) res += ({ "E" });
      }

  return res;

]],[[ ({

// +
0, 1, -1, 1, 2, 0, -1, 0, -2, 0xffffffff, 0x100000000, 0xfffffffe, 0xffffffffffffffff, 0x10000000000000000, 0xfffffffffffffffe,

// -
0, -1, 1, 1, 0, 2, -1, -2, 0, 0xffffffff, 0xfffffffe, 0x100000000, 0xffffffffffffffff, 0xfffffffffffffffe, 0x10000000000000000,

// *
0, 0, 0, 0, 1, -1, 0, -1, 1, 0, 0xffffffff, -0xffffffff, 0, 0xffffffffffffffff, -0xffffffffffffffff,

// /
"E", 0, 0, "E", 1, -1, "E", -1, 1, "E", 0xffffffff, -0xffffffff, "E", 0xffffffffffffffff, -0xffffffffffffffff,

// %
"E", 0, 0, "E", 0, 0, "E", 0, 0, "E", 0, 0, "E", 0, 0,

// <<
0, 0, "E", 1, 2, "E", -1, -2, "E", 0xffffffff, 0x1fffffffe, "E", 0xffffffffffffffff, 0x1fffffffffffffffe, "E",

// >>
0, 0, "E", 1, 0, "E", -1, -1, "E", 0xffffffff, 0x7fffffff, "E", 0xffffffffffffffff, 0x7fffffffffffffff, "E",

// &
0, 0, 0, 0, 1, 1, 0, 1, -1, 0, 1, 0xffffffff, 0, 1, 0xffffffffffffffff,

// |
0, 1, -1, 1, 1, -1, -1, -1, -1, 0xffffffff, 0xffffffff, -1, 0xffffffffffffffff, 0xffffffffffffffff, -1,

// ^
0, 1, -1, 1, 0, -2, -1, -2, 0, 0xffffffff, 0xfffffffe, -0x100000000, 0xffffffffffffffff, 0xfffffffffffffffe, -0x10000000000000000,
}) ]])

# __func__
test_eq(__func__, "a")
test_eq("b", __func__)

test_eq(8, 0b1000);
test_eq(-8, -0b1000);
test_eq(16, 0b10000);
test_eq(-16, -0b10000);

test_true(1e-100000000000000000000000000000000000000000000000000000000000<=1e-10000)
test_true(1e-10000<=1e-1000)
test_true(1e-1000<=1e-100)
test_true(1e-100<=1e-10)
test_true(1e-10<=1e-1)
test_true(1e-1<=1e1)
test_true(1e1<=1e10)
test_true(1e10<=1e100)
test_true(1e100<=1e1000)
test_true(1e1000<=1e10000)
test_true(1e10000<=1e100000000000000000000000000000000000000000000000000000000000)

test_compile_error('\3434523423423523423423423423')
test_compile_error("\3434523423423523423423423423")
test_compile_error("\d109827346981234561823743412654")
test_compile_error('\d109827346981234561823743412654')
test_compile_error("\x109a27bc69e256c83deaa34c26b4")
test_compile_error('\x109a27bc69e256c83deaa34c26b4')
test_compile_error('\u17fo')
test_compile_error("\u17fo")

test_eq('012456789abcdefghijklmnopqrstuvwxyz'->digits(256),
        "012456789abcdefghijklmnopqrstuvwxyz")
test_eq('\uu117f', 0x5c7531313766)
test_eq("\uuuu17fo", "\\uuu17fo")
test_eq('\u117f', 0x117f)
test_eq("\u117foo", "\10577oo")
test_eq("\u1117foo", "\10427foo")
test_eq("\uuuu117foo", "\\uuu117foo")
test_compile_error('\U117f')
test_compile_error("\U117f")
test_compile_error("\UdEaDbEaT")
test_eq("\UUdEaDbEaT", "\\UdEaDbEaT")
test_eq('\UDeaDBeEF', -559038737)
test_eq("\UDeaDBeEFFF", "\33653337357FF")
test_eq("\UUDeaDBeEFFF", "\\UDeaDBeEFFF")

test_do([[
  // bug 2677
  int x;
  if (time())
    x = 1;
  else
    foo: break foo;
]])

test_any([[
  // bug 2690
  array(function) foo(void|int b)
  {
    int add() { return b++; };
    return ({ add, add });
  };
  array(function) bar = foo();
  return equal(({`==(@bar),@bar()}), ({ 1, 0, 1 }));
]], 1)

test_any([[
  int f (int i) {i = 0; return i;};
  return f (1);
]],0)

test_any([[
  // Test that F_TAIL_RECUR and RECUR work properly.
  class X
  {
    int Ack(int M, int N) {
      if (M == 0) return( N + 1 );
      if (N == 0) return( Ack(M - 1, 1) );
      return( Ack(M - 1, Ack(M, (N - 1))) );
    }
  };

  return X()->Ack(3,5);
]],253)

test_any([[
  // Test that F_COND_RECUR works properly.
  // This test forces F_COND_RECUR to fail.
  class X
  {
    int Ack(int M, int N) {
      if (M == 0) return( N + 1 );
      if (N == 0) return( Ack(M - 1, 1) );
      return( Ack(M - 1, Ack(M, (N - 1))) );
    }
  };

  class Y { inherit X;
    int Ack(int M, int N) { return ::Ack(M, N); }
  };

  return Y()->Ack(2,2);
]],7)

test_any([[
  // Test that F_RECUR et al are not used for inlined functions
  // where the scope is in use.
  class X {
    inline function(int:int) foo(int x, int y)
    {
      if (y) return foo(x+y, y-1);
      return lambda(int z) { return x+z; };
    }
  };
  return X()->foo(10, 3)(5);
]], 21)

test_any([[
  // Test that loop optimizer isn't too aggressive.
  // Thanks to Alexander Demenshin <aldem-pike@aldem.net>
  int x,y,a;
  for(;x<10000;x++) {
    y += (x - a++);
  }
  return a;
]], 10000)

test_any([[
  // Test that loop optimizer isn't too aggressive.
  // Thanks to Alexander Demenshin <aldem-pike@aldem.net>
  mapping m = ([]);
  for(;m->x<10000;m->x++) {
    m->y += (m->x - m->a++);
  }
  return m->a;
]], 10000)

test_any([[
  // Test that loop optimizer isn't too aggressive.
  // Thanks to me.  / Marcus
  for(int i=0; i<3.0; i++)
    if(i>4.0)
      return -1;
  return 0;
]], 0)

test_any([[
  // Test that optimizer notes side effects in arguments to `!=
  // Thanks to Marcus Agehall
  int j = 20, i;
  string end = "17";
  for( ; i < j ; i++)
    if(sscanf(end, "%d%s", j, end) != 2)
      cd(".");
  return i;
]], 17)

test_any([[
  for(int i; i<10; i++) ;
  return 1;
]], 1)

test_any([[
  // Another over-optimization test.
  string x(string i) { return i; };
  return x("")+1+1;
]], "11")

test_any([[
  /* don't save parent */
  // Check that parent pointers aren't added unnecessarily [bug 2672].
  class I {};

  class X
  {
    // Neither the inherit nor the variable type should add
    // a parent pointer requirement.
    inherit I;
    I i;
  };

  X x = ((program) X)(); // Error: Parent lost, cannot clone program.
  return 0;
]], 0)

test_any([[
  /* don't save parent */
  // Check that parent pointers aren't added unnecessarily [bug 2672].
  class I {};

  class X
  {
    // The cloning of I makes X need its parent usually,
    // but note that since we're nested in a function
    // scope by the testsuite, I will not be overloadable,
    // and thus we won't need the parent.
    inherit I;
    I i = I();
  };

  X x = ((program) X)(); // Error: Parent lost, cannot clone program.
  return 0;
]], 0)

test_eval_error([[
  class Wrapper {
    // Check that parent pointers aren't added unnecessarily [bug 2672].
    class I {}

    class X
    {
      // The cloning of I makes X need its parent.
      inherit I;
      I i = I();
    }
  };

  object x = ((program) (Wrapper()->X))(); // Error: Parent lost, cannot clone program.
  return 0;
]], 0)

test_any([[
  // Check that parent pointers aren't added unnecessarily [LysLysKOM 18781511].

  class Foo {
    final constant const_val = 1;
    class Bar
    {
      int func()
      {
        // parent-pointer not needed, since const_val is final.
        return const_val;
      };
    }
  };

  return !Foo.Bar;

]], 0)

test_compile_any([[
  mixed foo()
  {
    Stdio.File bar(int x, int y)
    {
      return 0;
    };
    return bar;
  }
]])

test_compile_any([[
  string foo (string a, string b, string c, string d, string e, string f, string g)
  {
    string out;
    if (a)
      out = "foo";
    else
      out = "bar";
    return out;
  }
]])

test_compile_any([[
  mixed foo()
  {
    array a;
    array b = a->f("b")->?b;
    return b;
  }
]])

test_eq((["answer":42])->?answer, 42)

test_do([[
  add_constant("FOO",
               ([ "a": ([ "x" : ([ "i": ([]), "j": 0 ]), "y": 0 ]), "b": 0,
                  "d": lambda(){},
               ]));
]])

define(test_chain_op, [[
  test_any_equal([[
    return describe_error(catch {
      // Make FOO not a constant...
      mapping FOO = predef::FOO;
      mixed x = $1;
      if (undefinedp(x)) return "UNDEFINED";
      return x;
    });
  ]], $2)
]])

define(test_chain_op2, [[
  text_chain_op([[$1]], [[$2]])
  test_any_equal([[
    return describe_error(catch {
      // Test the constant case.
      mixed x = $1;
      if (undefinedp(x)) return "UNDEFINED";
      return x;
    });
  ]], $2)
]])

test_chain_op2(FOO->a->x->i, ([]))
test_chain_op2(FOO->?a->x->i, ([]))
test_chain_op2(FOO->a->?x->i, ([]))
test_chain_op2(FOO->?a->?x->i, ([]))
test_chain_op2(FOO->a->x->?i, ([]))
test_chain_op2(FOO->?a->x->?i, ([]))
test_chain_op2(FOO->a->?x->?i, ([]))
test_chain_op2(FOO->?a->?x->?i, ([]))
test_chain_op2(FOO->a->x->j, 0)
test_chain_op2(FOO->a->x->k, "UNDEFINED")
test_chain_op2(FOO->a->y->i, "Indexing the NULL value with \"i\".\n")
test_chain_op2(FOO->a->y->?i, 0)
test_chain_op2(FOO->a->z->i, "Indexing the NULL value with \"i\".\n")
test_chain_op2(FOO->a->z->?i, "UNDEFINED")
test_chain_op2(FOO->b->x->i, "Indexing the NULL value with \"x\".\n")
test_chain_op2(FOO->b->?x->i, 0)
test_chain_op2(FOO->b->?x->?i, 0)
test_chain_op2(FOO->c->x->i, "Indexing the NULL value with \"x\".\n")
test_chain_op2(FOO->c->?x->i, "UNDEFINED")
test_chain_op2(FOO->c->?x->?i, "UNDEFINED")

test_chain_op2(FOO["a"]["x"]["i"], ([]))
test_chain_op2(FOO[?"a"]["x"]["i"], ([]))
test_chain_op2(FOO["a"][?"x"]["i"], ([]))
test_chain_op2(FOO[?"a"][?"x"]["i"], ([]))
test_chain_op2(FOO["a"]["x"][?"i"], ([]))
test_chain_op2(FOO[?"a"]["x"][?"i"], ([]))
test_chain_op2(FOO["a"][?"x"][?"i"], ([]))
test_chain_op2(FOO[?"a"][?"x"][?"i"], ([]))
test_chain_op2(FOO["a"]["x"]["j"], 0)
test_chain_op2(FOO["a"]["x"]["k"], "UNDEFINED")
test_chain_op2(FOO["a"]["y"]["i"], "Indexing the NULL value with \"i\".\n")
test_chain_op2(FOO["a"]["y"][?"i"], 0)
test_chain_op2(FOO["a"]["z"]["i"], "Indexing the NULL value with \"i\".\n")
test_chain_op2(FOO["a"]["z"][?"i"], "UNDEFINED")
test_chain_op2(FOO["b"]["x"]["i"], "Indexing the NULL value with \"x\".\n")
test_chain_op2(FOO["b"][?"x"]["i"], 0)
test_chain_op2(FOO["b"][?"x"][?"i"], 0)
test_chain_op2(FOO["c"]["x"]["i"], "Indexing the NULL value with \"x\".\n")
test_chain_op2(FOO["c"][?"x"]["i"], "UNDEFINED")
test_chain_op2(FOO["c"][?"x"][?"i"], "UNDEFINED")

// NB: Constant-folding will cause compilation errors due to detecting
//     the zeroes in the constant case.
test_chain_op(FOO->a->x->j(), "Attempt to call the NULL-value.\n")
test_chain_op2(FOO->a->x->j(?), 0)
test_chain_op(FOO->a->x->k(), "Attempt to call the NULL-value.\n")
test_chain_op2(FOO->a->x->k(?), "UNDEFINED")
test_chain_op(FOO->a->y()->i, "Attempt to call the NULL-value.\n")
test_chain_op2(FOO->a->y(?)->i, 0)
test_chain_op(FOO->a->z()->i, "Attempt to call the NULL-value.\n")
test_chain_op2(FOO->a->z(?)->i, "UNDEFINED")
test_chain_op(FOO->b()->x->i, "Attempt to call the NULL-value.\n")
test_chain_op2(FOO->b(?)->x->i, 0)
test_chain_op2(FOO->b(?)->x(?)->i, 0)
test_chain_op(FOO->c()->x->i, "Attempt to call the NULL-value.\n")
test_chain_op2(FOO->c(?)->x->i, "UNDEFINED")
test_chain_op2(FOO->c(?)->x(?)->i, "UNDEFINED")
test_chain_op2(FOO->c(?)()->x->i, "UNDEFINED")
test_chain_op2(FOO->c(?)()->x(?)->i, "UNDEFINED")
test_chain_op(FOO->d()()->x->i, "Attempt to call the NULL-value.\n")
test_chain_op2(FOO->d()(?)->x->i, 0)

test_do(add_constant("FOO");)

define(test_string_range,[[
    test_any([[
        string s = (string) ({ $1, $1 });
        if (!arrayp(String.range(s))) return "huh?"; // dont optimize this, it forces string range check
        return search(s, $1);
    ]], 0)
]])

test_string_range(254);
test_string_range(255);
test_string_range((1<<16)-1);
test_string_range((1<<16)+1);
test_string_range((1<<29)-1);
test_string_range((1<<29)+1);
test_string_range((1<<31)-1);
test_string_range(-(1<<31));

dnl number of variables/scope, number of scopes, expect_compiler_error
define(test_scopes,[[
  test_any([[
    log_status("Testing scoped variables $1:$2%s...",
	       $3?" expecting a compilation error":"");
    string line = sprintf("#line %d %O\n", __LINE__, __FILE__);
    string s = "{\n" +
      (map(indices(allocate($1)), lambda(int no) {
		     no++;
		     return sprintf("    int var_%d;\n"
				    "    if (var_%d)\n"
				    "      error(\"Variable var_%d not \"\n"
				    "            \"initialized to zero: \"\n"
				    "            \"%%O\\n\",\n"
				    "            var_%d);\n"
				    "    var_%d = %d;\n",
				    no, no, no, no, no, no);
	           }) +
       map(indices(allocate($1)), lambda(int no) {
		     no++;
		     return sprintf("    if (var_%d != %d)\n"
				    "      error(\"Variable var_%d was \"\n"
				    "            \"clobbered with %%O.\\n\",\n"
				    "            var_%d);\n",
				    no, no, no, no);
		   })) * "" +
       "}\n";
    program p;
    if ($3) master()->set_inhibit_compile_errors (1);
    mixed err = catch {
      p = compile_string("int a() {\n" + line + (s * $2) +
			 "  return 0;\n"
			 "}\n");
    };
    if ($3) {
      master()->set_inhibit_compile_errors (0);
      if (err) return 0;
      error("Expected a compilation error for $1 variables in $2 scope%s.\n",
            ($2>1)?"s":"");
    }
    if (err) throw(err);
    return p()->a();
  ]], 0)
]])

test_scopes(255, 1, 0)
test_scopes(256, 1, 1)
test_scopes(16, 17, 0)
test_scopes(17, 16, 0)

dnl sscanf("", ...) triggers this warning.
ignore_warning("Indexing the empty string.", [[
test_any([[
  // LysLysKOM 14180500
  if (1) {
    string var = "Reinitialization error.";
  }
  sscanf("", "%d", int zero);
  return zero;
]], 0);

test_any([[
  // LysLysKOM 14189033
  int i;
  for (i = 0; i < 4; i++) {
    sscanf("", "%d", int test);
    if (test) return test;
    test = i+1;
  }
  return 0;
]], 0)
]])

dnl FIXME: Add test that local and local:: in combination
dnl        with recursion works correctly.

test_eval_error([[mixed x; return mkmapping(x,x)]]);

test_eval_error([[class Foo {
  void bar() {}
  void foo() {destruct(this);bar();}
};
  Foo()->foo();
]])

test_do([[
  void foo (int i) {
    multiset res = (<>);
    if (i) res = res;
  };
  foo (1);
]])

test_any([[
  array tmp=({});
  tmp=({([])})+tmp;
  tmp->foo=7;
  tmp=({([])})+tmp;
  return sizeof(tmp[0]);
]], 0)

test_any([[
  // Bug 4537.
  void fiddle(array(int) a)
  {
    a += ({ 2 });
  };

  array(int) a = ({ 1 });
  fiddle(a);
  return sizeof(a);
]], 1)

test_eval_error([[
  // [Bug 5911]
  class X {
    string s;
  };
  X()->s = (mixed) X();
]])

test_any([[
  // Bug 6062
  class C { mapping options = ([ 1:1 ]); };
  C c = C();
  c->options[3] = 3;
  c = C();
  return sizeof(c->options) == 1;
]], 1)

test_any([[
  // Bug 6063
  class A { extern string s; string q() { return s; } };
  class B { inherit A; string s = "s"; };
  class C { inherit B; };
  class D { inherit C; };
  return ({ B(), C(), D() })->q() * "";
]], "sss")

test_any([[
  // bug 6065
  class A(string s) {};
  class B(string s) { inherit A; };
  return B("foo")->s;
]], "foo")

test_any_equal([[
  class A{ constant sym = 1; }
  class B{ constant sym = 2; inherit A; }
  return indices(B);
]], ({ "sym" }))

test_any_equal([[
  class A{ constant sym = 1; }
  class B{ inherit A; constant sym = 2; }
  return indices(B);
]], ({ "sym" }))

test_any_equal([[
  class A{ constant sym = 1; }
  class B{ constant sym = 2; inherit A; }
  return values(B);
]], ({ 2 }))

test_any_equal([[
  class A{ constant sym = 1; }
  class B{ inherit A; constant sym = 2; }
  return values(B);
]], ({ 2 }))

test_any_equal([[
  class A{ constant sym = 1; }
  class B{ constant sym = 2; inherit A; }
  return indices(B());
]], ({ "sym" }))

test_any_equal([[
  class A{ constant sym = 1; }
  class B{ inherit A; constant sym = 2; }
  return indices(B());
]], ({ "sym" }))

test_any_equal([[
  class A{ constant sym = 1; }
  class B{ constant sym = 2; inherit A; }
  return values(B());
]], ({ 2 }))

test_any_equal([[
  class A{ constant sym = 1; }
  class B{ inherit A; constant sym = 2; }
  return values(B());
]], ({ 2 }))

test_any_equal([[
  // Test constant expression in inherit.
  class A { constant sym = 1; }
  class B { constant sym = 2; }
  class C { inherit ([ "A":A, "B":B ])["A"]; }
  class D { inherit ([ "A":A, "B":B ])["B"]; }
  return ({ A, B, C, D })->sym;
]], ({ 1, 2, 1, 2 }))

dnl Tests of generic types.

test_compile_any([[
// Bug #10151
//   Bad argument 1 to create.
//   Expected: { T = { T = (<object(implements G):$0>) } }.
//   Got     : object(implements program(B)).
class G (<T>) {
  class GG (<T = T>) (T t) {}
}
class B {
  inherit G.GG;
  protected void create()
  {
    GG::create(this);	// Bang!
  }
}
]])

dnl Generator function tests.

dnl Trivial generator function.
test_any_equal([[
  class Foo {
    __generator__ int foo(int start, int end)
    {
      while (start < end)
	continue return start++;
      return start;
    }
  }

  function(:int) f = Foo()->foo(4,8);

  array(int) ret = ({});
  int i;
  while (!zero_type(i = f())) {
    ret += ({ i });
  }
  return ret;
]], ({ 4, 5, 6, 7, 8 }))

dnl Generator function with stack.
test_any_equal([[
  class Foo {
    __generator__ int|float foo(int end)
    {
      return 1000.0 + gauge {
	  int i = 0;
	  for (i = 0; i < end; i++) {
	    continue return i;
	  }
	};
    }
  }

  function(:int|float) f = Foo()->foo(4);

  array(int) ret = ({});
  int i;
  while (!zero_type(i = f())) {
    ret += ({ (int)i });
  }
  return ret;
  // NB: We assume that the loop executes in under a second.
]], ({ 0, 1, 2, 3, 1000 }))

dnl Generator function with catch.
test_any_equal([[
  class Foo {
    __generator__ int|string foo(int end)
    {
      return describe_error(catch {
	  int i = 0;
	  for (i = 0; i < end; i++) {
	    continue return i;
	  }
	  error("End of stream.\n");
	});
    }
  }

  function(:int|string) f = Foo()->foo(4);

  array(int|string) ret = ({});
  int|string i;
  while (!zero_type(i = f())) {
    ret += ({ i });
  }
  return ret;
]], ({ 0, 1, 2, 3, "End of stream.\n" }))

dnl Generator function with catch and global variable.
test_any_equal([[
  class Foo {
    int start = 1;
    __generator__ int|string foo(int end)
    {
      return describe_error(catch {
	  int i;
	  for (i = start; i < end; i++) {
	    continue return i;
	  }
	  error("End of stream.\n");
	});
    }
  }

  function(:int|string) f = Foo()->foo(4);

  array(int|string) ret = ({});
  int|string i;
  while (!zero_type(i = f())) {
    ret += ({ i });
  }
  return ret;
]], ({ 1, 2, 3, "End of stream.\n" }))

dnl Trivial local generator function.
test_any_equal([[
  __generator__ int foo(int start, int end)
  {
    while (start < end)
      continue return start++;
    return start;
  }

  function(:int) f = foo(4,8);

  array(int) ret = ({});
  int i;
  while (!zero_type(i = f())) {
    ret += ({ i });
  }
  return ret;
]], ({ 4, 5, 6, 7, 8 }))

dnl Local generator function with stack.
test_any_equal([[
  __generator__ int|float foo(int end)
  {
    return 1000.0 + gauge {
	int i = 0;
	for (i = 0; i < end; i++) {
	  continue return i;
	}
      };
  }

  function(:int|float) f = foo(4);

  array(int) ret = ({});
  int i;
  while (!zero_type(i = f())) {
    ret += ({ (int)i });
  }
  return ret;
  // NB: We assume that the loop executes in under a second.
]], ({ 0, 1, 2, 3, 1000 }))

dnl Local generator function with catch.
test_any_equal([[
  __generator__ int|string foo(int end)
  {
    return describe_error(catch {
	int i = 0;
	for (i = 0; i < end; i++) {
	  continue return i;
	}
	error("End of stream.\n");
      });
  }

  function(:int|string) f = foo(4);

  array(int|string) ret = ({});
  int|string i;
  while (!zero_type(i = f())) {
    ret += ({ i });
  }
  return ret;
]], ({ 0, 1, 2, 3, "End of stream.\n" }))

dnl Local generator function with catch and external variable.
test_any_equal([[
  int start = 1;
  __generator__ int|string foo(int end)
  {
    return describe_error(catch {
	int i;
	for (i = start; i < end; i++) {
	  continue return i;
	}
	error("End of stream.\n");
      });
  }

  function(:int|string) f = foo(4);

  array(int|string) ret = ({});
  int|string i;
  while (!zero_type(i = f())) {
    ret += ({ i });
  }
  return ret;
]], ({ 1, 2, 3, "End of stream.\n" }))

dnl Trivial generator lambda.
test_any_equal([[
  function(:int) f = __generator__ lambda(int start, int end)
  {
    while (start < end)
      continue return start++;
    return start;
  }(4,8);

  array(int) ret = ({});
  int i;
  while (!zero_type(i = f())) {
    ret += ({ i });
  }
  return ret;
]], ({ 4, 5, 6, 7, 8 }))

dnl Generator lambda with stack.
test_any_equal([[
  function(:int|float) f = __generator__ lambda(int end)
  {
    return 1000.0 + gauge {
        int i = 0;
        for (i = 0; i < end; i++) {
          continue return i;
        }
      };
  }(4);

  array(int) ret = ({});
  int i;
  while (!zero_type(i = f())) {
    ret += ({ (int)i });
  }
  return ret;
  // NB: We assume that the loop executes in under a second.
]], ({ 0, 1, 2, 3, 1000 }))

dnl Generator lambda with catch.
test_any_equal([[
  function(:int|string) f = __generator__ lambda(int end)
  {
    return describe_error(catch {
        int i = 0;
        for (i = 0; i < end; i++) {
          continue return i;
        }
        error("End of stream.\n");
      });
  }(4);

  array(int|string) ret = ({});
  int|string i;
  while (!zero_type(i = f())) {
    ret += ({ i });
  }
  return ret;
]], ({ 0, 1, 2, 3, "End of stream.\n" }))

dnl Generator lambda with catch and external variable.
test_any_equal([[
  int start = 1;
  function(:int|string) f = __generator__ lambda(int end)
  {
    return describe_error(catch {
        int i;
        for (i = start; i < end; i++) {
          continue return i;
        }
        error("End of stream.\n");
      });
  }(4);

  array(int|string) ret = ({});
  int|string i;
  while (!zero_type(i = f())) {
    ret += ({ i });
  }
  return ret;
]], ({ 1, 2, 3, "End of stream.\n" }))

dnl Asynchronous function tests.

dnl Trivial async function awaiting success.
test_any_equal([[
  class Foo {
    __async__ int foo(Concurrent.Future f)
    {
      return await(f) + 10;
    }
  }

  Concurrent.Promise p = Concurrent.Promise();
  Concurrent.Future res = Foo()->foo(p->future());

  int done;
  int ret = -1;
  res->on_success(lambda(int val) {
    ret = val;
    done = 1;
  });
  res->on_failure(lambda(mixed err) {
    master()->handle_error(err);
    done = 1;
  });

  p->success(1);

  for (int i = 0; !done && i < 10; i++) {
    if (!Pike.DefaultBackend(0.1)) break;
  }

  return ret;
]], 11)

dnl Trivial async function awaiting failure.
test_any_equal([[
  class Foo {
    __async__ int foo(Concurrent.Future f)
    {
      int val = catch {
        int val = await(f);

        error("await() succeeded (val: %O)!\n", val);
      };
      return val + 10;
    }
  }

  Concurrent.Promise p = Concurrent.Promise();
  Concurrent.Future res = Foo()->foo(p->future());

  int done;
  int ret = -1;
  res->on_success(lambda(int val) {
    ret = val;
    done = 1;
  });
  res->on_failure(lambda(mixed err) {
    master()->handle_error(err);
    done = 1;
  });

  p->failure(1);

  for (int i = 0; !done && i < 10; i++) {
    if (!Pike.DefaultBackend(0.1)) break;
  }

  return ret;
]], 11)

dnl Trivial async function awaiting and passing failure.
test_any_equal([[
  class Foo {
    __async__ int foo(Concurrent.Future f)
    {
      return await(f) + 10;
    }
  }

  Concurrent.Promise p = Concurrent.Promise();
  Concurrent.Future res = Foo()->foo(p->future());

  int done;
  int ret = -1;
  res->on_success(lambda(int val) {
    werror("await() failure did not propagate!\n");
    done = 1;
  });
  res->on_failure(lambda(mixed err) {
    ret = 11;
    done = 1;
  });

  p->failure(1);

  for (int i = 0; !done && i < 10; i++) {
    if (!Pike.DefaultBackend(0.1)) break;
  }

  return ret;
]], 11)

dnl Trivial local async function.
test_any_equal([[
  __async__ int foo(Concurrent.Future f)
  {
    return await(f) + 10;
  }

  Concurrent.Promise p = Concurrent.Promise();
  Concurrent.Future res = foo(p->future());

  int done;
  int ret = -1;
  res->on_success(lambda(int val) {
    ret = val;
    done = 1;
  });
  res->on_failure(lambda(mixed err) {
    master()->handle_error(err);
    done = 1;
  });

  p->success(1);

  for (int i = 0; !done && i < 10; i++) {
    if (!Pike.DefaultBackend(0.1)) break;
  }

  return ret;
]], 11)

dnl Trivial async lambda.
test_any_equal([[
  Concurrent.Promise p = Concurrent.Promise();
  Concurrent.Future res = __async__ lambda(Concurrent.Future f)
  {
    return await(f) + 10;
  }(p->future());

  int done;
  int ret = -1;
  res->on_success(lambda(int val) {
    ret = val;
    done = 1;
  });
  res->on_failure(lambda(mixed err) {
    master()->handle_error(err);
    done = 1;
  });

  p->success(1);

  for (int i = 0; !done && i < 10; i++) {
    if (!Pike.DefaultBackend(0.1)) break;
  }

  return ret;
]], 11)

dnl Async with multiple inherit.
dnl cf https://git.lysator.liu.se/pikelang/pike/-/issues/10144#note_11251
test_do([[
  class http_endpoint {
    void dummy_function() { }
  }

  class websocket_handler {
    __async__ mapping get_state(int group) {
      return ([]);
    }

    __async__ void _send_updates(array(object) socks, int group,
                                 mapping|void data) {
      Concurrent.Future f = get_state(group);
      if (!data) data = await(f);
    }

    protected void create(string name) { }
  }

  class http_websocket {
    inherit http_endpoint;
    inherit websocket_handler;

    __async__ mapping get_state(int group) {
      return ([ "group": group ]);
    }
  }

  add_constant("testsuite_http_websocket", http_websocket);
]])
test_do([[
  class Boom {
    inherit testsuite_http_websocket;
    protected void create() {
      _send_updates(({ }), 42);
    }
  }

  return Boom();
]])
test_do([[
  add_constant("testsuite_http_websocket");
]])

dnl Async in nested inherit.
dnl cf https://git.lysator.liu.se/pikelang/pike/-/issues/10144#note_11254
test_do([[
  class EventSub {
    protected void create() {
      build_signer();
    }
    __async__ void build_signer() { }
  }
  add_constant("testsuite_EventSub", EventSub);
]])
test_do([[
  class EventSubSpecial() {
    inherit testsuite_EventSub;
    protected void create() {
      ::create();
    }
  }

  return EventSubSpecial();
]])
test_do([[
  add_constant("testsuite_EventSub");
]])

dnl Function with default value.
test_any_equal([[
  class A {
    string foo(string bar = "foo") { return bar; }
  }

  A o = A();
  return ({ o->foo(), o->foo(UNDEFINED), o->foo(0), o->foo("bar") });
]], ({ "foo", "foo", "foo", "bar" }))
test_any_equal([[
  class A {
    int foo(int bar = 17) { return bar; }
  }

  A o = A();
  return ({ o->foo(), o->foo(UNDEFINED), o->foo(0), o->foo(18) });
]], ({ 17, 17, 0, 18 }))

dnl Generator with default value.

dnl Lambda with default value.
test_any_equal([[
  function(string|void:string) f = lambda(string bar = "foo") { return bar; };
  return ({ f(), f(UNDEFINED), f(0), f("bar") });
]], ({ "foo", "foo", "foo", "bar" }))
test_any_equal([[
  function(int|void:int) f = lambda(int bar = 17) { return bar; };
  return ({ f(), f(UNDEFINED), f(0), f(18) });
]], ({ 17, 17, 0, 18 }))

dnl Local function with default value.
test_any_equal([[
  string f(string bar = "foo") { return bar; };
  return ({ f(), f(UNDEFINED), f(0), f("bar") });
]], ({ "foo", "foo", "foo", "bar" }))
test_any_equal([[
  int f(int bar = 17) { return bar; };
  return ({ f(), f(UNDEFINED), f(0), f(18) });
]], ({ 17, 17, 0, 18 }))

dnl Local generator with default value.

dnl Named class with implicit create with default value.
test_any_equal([[
  class foo(string bar = "foo") {
    protected void create(string blag = bar) { bar += blag; }
  }

  return ({ foo(), foo(UNDEFINED), foo(0), foo("bar"), foo("bar", UNDEFINED),
	    foo("bar", 0), foo(0, "bar"), foo(UNDEFINED, UNDEFINED), foo(0, 0),
            foo("bar", "baz"), foo(UNDEFINED, "bar") })->bar;
]], ({ "foofoo", "foofoo", "foofoo", "barbar", "barbar",
       "barbar", "foobar", "foofoo", "foofoo",
       "barbaz", "foobar" }))
test_any_equal([[
  class foo(int bar = 17) {
    protected void create(int blag = bar) { bar += blag; }
  }

  return ({ foo(), foo(UNDEFINED), foo(0), foo(18), foo(18, UNDEFINED),
	    foo(18, 0), foo(0, 18), foo(UNDEFINED, UNDEFINED), foo(0, 0),
            foo(18, 19), foo(UNDEFINED, 18) })->bar;
]], ({ 34, 34, 0, 36, 36,
       18, 18, 34, 0,
       37, 35 }))

dnl Anonymous class with implicit create with default value.
test_any_equal([[
  program foo = class(string bar = "foo") {
      protected void create(string blag = bar) { bar += blag; }
    };

  return ({ foo(), foo(UNDEFINED), foo(0), foo("bar"), foo("bar", UNDEFINED),
	    foo("bar", 0), foo(0, "bar"), foo(UNDEFINED, UNDEFINED), foo(0, 0),
            foo("bar", "baz"), foo(UNDEFINED, "bar") })->bar;
]], ({ "foofoo", "foofoo", "foofoo", "barbar", "barbar",
       "barbar", "foobar", "foofoo", "foofoo",
       "barbaz", "foobar" }))
test_any_equal([[
  program foo = class(int bar = 17) {
      protected void create(int blag = bar) { bar += blag; }
    };

  return ({ foo(), foo(UNDEFINED), foo(0), foo(18), foo(18, UNDEFINED),
	    foo(18, 0), foo(0, 18), foo(UNDEFINED, UNDEFINED), foo(0, 0),
            foo(18, 19), foo(UNDEFINED, 18) })->bar;
]], ({ 34, 34, 0, 36, 36,
       18, 18, 34, 0,
       37, 35 }))

dnl Multi-assign in function calls.
test_any([[
  class Foo {
    // Lifted from issue #10098.
    int add([int a, int b], int c) { return a + b + c; }
  }
  return Foo()->add(({ 1, 2 }), 3);
]], 6)
test_any([[
  // Lifted from issue #10098.
  int add([int a, int b], int c) { return a + b + c; }
  return add(({ 1, 2 }), 3);
]], 6)
test_equal([[
  lambda(int a, [int b, int c, [int e, int f] ], int d){
    return ({ a, b, c, d, e, f });
  }(1, ({ 3, 4, ({ 5, 6 }) }), 7);
]], ({ 1, 3, 4, 7, 5, 6 }))
test_equal([[
  lambda(int a, [int b, int c], int d){
    return ({ a, b, c, d });
  }(1, ({ 2, 3 }), 4);
]], ({ 1, 2, 3, 4 }))
test_equal([[
  lambda(int a, [int b, int c] = ({ 5, 6 }), int d = 10){
    return ({ a, b, c, d });
  }(1, ({ 2, 3 }), 4);
]], ({ 1, 2, 3, 4 }))
test_equal([[
  lambda(int a, [int b, int c] = ({ 5, 6 }), int d = 10){
    return ({ a, b, c, d });
  }(1, ({ 2, 3 }));
]], ({ 1, 2, 3, 10 }))
test_equal([[
  lambda(int a, [int b, int c] = ({ 5, 6 }), int d = 10){
    return ({ a, b, c, d });
  }(1);
]], ({ 1, 5, 6, 10 }))

dnl bug in for loop optimization in combination with +=
test_any([[
array v=({1,2,3});
  for (int i=0; i<sizeof(v); i++)
    for (int j=0; j<i; j++)
    {
       v+=({1+i});
       if (i==17) { i=10000; break; }
    }
    return sizeof(v); // if buggy, will be 6 and not 140
]], 140);

test_any([[
array v=({1,2,3});
  for (int i=0; i<sizeof(v); i++)
    for (int j=0; j<i; j++)
    {
       v=v+({1+i});
       if (i==17) { i=10000; break; }
    }
    return sizeof(v); // not buggy, will be 140
]], 140);

test_any([[int a=0xffffffff; return a+17]], 0x100000010);
test_any([[int a=0xffffffff; return a-17]], 0xffffffee);
test_any([[int a=0xffffffff; return a*17]], 0x10ffffffef);
test_any([[int a=0xffffffff; return a^17]], 0xffffffee);
test_any([[int a=0xffffffff; return a&17]], 17);
test_any([[int a=0xffffffff; return a|17]], 0xffffffff);
test_any([[int a=0xffffffff; return a<<17]], 0x1fffffffe0000);

test_any([[ int a=0xffffffff; return a/17 ]],
	 [[ (0xffffffff == -1)?-1:0x0f0f0f0f ]]);
test_any([[ int a=0xffffffff; return a%17 ]],
	 [[ (0xffffffff == -1)?16:0 ]]);
test_any([[ int a=0xffffffff; return a>>17 ]],
	 [[ (0xffffffff == -1)?-1:0x7fff ]]);

dnl Check the derived return type of sprintf().
test_equal([[ typeof(sprintf("%1H", "foo")); ]],
	   [[ typeof([string(8bit)](mixed)""); ]]);
test_equal([[ typeof(sprintf("foo")); ]],
	   [[ typeof([string(102..111)](mixed)""); ]]);
test_equal([[ typeof(sprintf("foo%c", 17)); ]],
	   [[ typeof([string(17 | 102..111)](mixed)""); ]]);
test_equal([[ typeof(sprintf("%2c\n", 'a')); ]],
	   [[ typeof([string(8bit)](mixed)""); ]]);
dnl Note the following tests the return type of int2char().
test_equal([[ typeof(sprintf("%c",  1023)); ]],
	   [[ typeof([string(1023)](mixed)""); ]]);
test_equal([[ typeof(sprintf("%c\n",  1023)); ]],
	   [[ typeof([string(10 | 1023)](mixed)""); ]]);
dnl The following is due to (string & sprintf_result) == sprintf_result.
test_equal([[ typeof(sprintf("%c\n",  Stdio)); ]],
	   [[ sprintf_result; ]]);
test_equal([[ typeof(sprintf("%4[0]c", 17)); ]],
	   [[ typeof([string(8bit)](mixed)"") ]]);
test_equal([[ typeof(sprintf("%[0]n", 17)); ]],
	   [[ typeof("") ]]);
test_equal([[ typeof(sprintf("%4[1]c", 0, 17)); ]],
	   [[ typeof([string(8bit)](mixed)"") ]]);
test_equal([[ typeof(sprintf("%[1]n", 0, 17)); ]],
	   [[ typeof("") ]]);

test_equal([[ typeof(aggregate("foo"));]],
	   [[ typeof([array(string(3: 102..111))](mixed)({})) ]]);
test_any([[int a; return sprintf("%O", typeof(aggregate(a)));]], "array(int)");
test_any([[int|string a;
	   string s = sprintf("%O", typeof(aggregate(a)));
	   return (< "array(string) | array(int)", "array(string | int)", "array(int | string)" >)[s];]], 1);
test_any([[return sprintf("%O", typeof(aggregate()));]], "array(zero:)");
test_any([[int i; return (< "int", "int | zero", "zero | int", "int(0..)" >)
                          [sprintf("%O", typeof(max(i,0)))];]], 1)

test_any([[array(string) a; return sprintf("%O", typeof(a[0])); ]], "string")

test_any([[class foo { string a; };
	   object(foo) bar;
           return sprintf("%O", typeof(bar->a));]], "zero | string");

test_any([[class foo { string a; };
	   array(object(foo)) bar;
           return sprintf("%O", typeof(bar[0]->a));]], "zero | string");

test_any([[function(:string)|function(int:int) f;
	   return sprintf("%O", typeof(f())); ]],
	 "string")

test_any([[function(:string)|function(int:int) f;
	   return sprintf("%O", typeof(f(1))); ]],
	 "int")

test_any([[function(:string)|function(mixed, mixed...:int) f;
	  return sprintf("%O", typeof(f())); ]],
	 "string")

test_any([[function(:string)|function(mixed, mixed ...:int) f;
	  return sprintf("%O", typeof(f(1))); ]],
	 "int")

test_any([[mapping(object:string)|mapping(string:int) f;
          return sprintf("%O", typeof(f[class{}()])); ]],
         "zero | string")

test_any([[mapping(object:string)|mapping(string:int) f;
	  return sprintf("%O", typeof(f[""])); ]],
	 "int")

test_any([[mapping(object:string)|mapping(string:int) f;
          return sort((sprintf("%O", typeof(f[(mixed)0])) - " ")/"|")*"|"; ]],
	 "int|string")

test_any([[class Foo { protected string `[](mixed y) {return "";} };
	  object(Foo) foo;
          return sprintf("%O", typeof(foo[0])); ]],
         "string")

test_any([[class Foo { protected array(int) _indices() {return ({0});} };
	  object(Foo) foo;
          return sprintf("%O", typeof(indices(foo))); ]],
         "array(int)")

test_any([[class Foo { protected array(string) _values() {return ({""});} };
	  object(Foo) foo;
          return sprintf("%O", typeof(values(foo))); ]],
         "array(string)")

test_any([[mapping(string:int) foo;
	  array(string) bar;
	  return sprintf("%O", typeof(rows(foo, bar))); ]],
	 "array(int)")

// basic auto tests.
test_any([[
  class Toplevel {
  class Foo {
    auto a = 10;
    auto b = typeof(a);
  };
  string test() {
     return sprintf("a%Ob%O", typeof(Foo()->a),typeof(Foo()->b));
  };
};
  return Toplevel()->test();
]], "aint(10)btype(int(10))");

test_any([[{
  class Toplevel {
    class Foo {
      auto test(){ return 10;return 20;return 30; };
    };
    string test() {
      return sprintf("%O", typeof(Foo()->test));
    }
  };
  return Toplevel()->test()-" ";
}]], "function(:int(10)|int(20)|int(30))");

test_any([[{
  class Foo
  {
    mixed m;
  };
  class Bar
  {
    inherit Foo;
    string m;
    Foo b;
    mixed f() {
      return typeof(b->m);
    }
  };
  Foo c;
  Bar d;
  return sprintf("%O$%O$%O$%O",
                 Bar()->f(), typeof(c->m), typeof(d->m), typeof(d->b->m));
}]], "mixed$mixed$zero | string$mixed")

// las.c:find_return_type() checks.
test_eq([[
  // Test case from Robert J. Budzynski <Robert.Budzynski@fuw.edu.pl>.
  // When broken the return type will be mixed.
  sprintf("%O", typeof(lambda(string s){
    return Charset.decoder("utf-8")->feed(s)->drain();
  }))
]], [[ "function(string : string)" ]])

// Test implicit lambda.
test_eq([[
  `()(){ return 1; }
]], 1)

test_equal([[
  lambda(array a, function f) { return f(@a); }
	(({ 0, 1, 2, 3 })){ return __ARGS__; }
]], ({ 0, 1, 2, 3}))

// Issue #10133 (aka LysLysKOM 26044077).
test_any_equal([[
  array call(function cb) { return cb(42); }
  array f() {
    return call() {
      array ret = __ARGS__;
      mixed value = 1234;	// NB: Scoped variable.
      function ff = lambda() { return value; };
      return ret;
    };
  }

  return f();
]], ({ 42 }))

// Argument checking

// Test new_check_call.
test_any([[
  constant foo = 5;

  // Test that it survives a F_ARG_LIST with CAR == CDR.
  return foo%foo;
]], 0)

// Test get_all_args.
test_eval_error([[
  // A trick to get some svalues to freed refcounted stuff on the stack.
  lambda (mixed a, mixed b, mixed c) {} (({time()}), ({time()}), ({time()}));
  // set_weak_flag is chosen since it calls get_all_args with an
  // argument spec that contains two arguments of different types.
  ([function] set_weak_flag)();
]])
test_eval_error([[
  lambda (mixed a, mixed b, mixed c) {} (({time()}), ({time()}), ({time()}));
  ([function] set_weak_flag) (17);
]])
test_eval_error([[
  lambda (mixed a, mixed b, mixed c) {} (({time()}), ({time()}), ({time()}));
  ([function] set_weak_flag) ("foo");
]])
test_eval_error([[
  lambda (mixed a, mixed b, mixed c) {} (({time()}), ({time()}), ({time()}));
  ([function] set_weak_flag) (17, "foo");
]])

// Check that write() and error() with one argument are not
// incorrectly subjected to sprintf() argument
test_compile([[write("%\u2323");]])
test_compile([[error("%\u2323");]])

// type checks

define(test_type_error, [[
   test_compile_error([[ $1 x; x=$3; ]])
   test_compile_error_any([[ class ErrBa { $1 x() { return $3; } } ]])
   test_compile_error_any([[ class ErrBa { $1 x() { $2 a=$3; return a; } } ]])
]])

test_type_error(int,float,17.23)
test_type_error(int,array,({1,2,3}))
test_type_error(int,mapping,([1:2,3:4]))
test_type_error(int,multiset,(<1,2,3>))
test_type_error(int,function,lambda() { return 17; })
test_type_error(int,program,this_program)
test_type_error(int,object,this)

test_type_error(float,int,17)
test_type_error(float,array,({1,2,3}))
test_type_error(float,mapping,([1:2,3:4]))
test_type_error(float,multiset,(<1,2,3>))
test_type_error(float,function,lambda() { return 17; })
test_type_error(float,program,this_program)
test_type_error(float,object,this)

test_type_error(array,int,17)
test_type_error(array,float,17.23)
test_type_error(array,mapping,([1:2,3:4]))
test_type_error(array,multiset,(<1,2,3>))
test_type_error(array,function,lambda() { return 17; })
test_type_error(array,program,this_program)
test_type_error(array,object,this)

test_type_error(mapping,int,17)
test_type_error(mapping,float,17.23)
test_type_error(mapping,array,({1,2,3}))
test_type_error(mapping,multiset,(<1,2,3>))
test_type_error(mapping,function,lambda() { return 17; })
test_type_error(mapping,program,this_program)
test_type_error(mapping,object,this)

test_type_error(multiset,int,17)
test_type_error(multiset,float,17.23)
test_type_error(multiset,array,({1,2,3}))
test_type_error(multiset,mapping,([1:2,3:4]))
test_type_error(multiset,function,lambda() { return 17; })
test_type_error(multiset,program,this_program)
test_type_error(multiset,object,this)

test_type_error(function,int,17)
test_type_error(function,float,17.23)
test_type_error(function,array,({1,2,3}))
test_type_error(function,mapping,([1:2,3:4]))
test_type_error(function,multiset,(<1,2,3>))

test_type_error(program,int,17)
test_type_error(program,float,17.23)
test_type_error(program,array,({1,2,3}))
test_type_error(program,mapping,([1:2,3:4]))
test_type_error(program,multiset,(<1,2,3>))

test_type_error(object,int,17)
test_type_error(object,float,17.23)
test_type_error(object,array,({1,2,3}))
test_type_error(object,mapping,([1:2,3:4]))
test_type_error(object,multiset,(<1,2,3>))

test_any_equal([[
  // This code caused a NULL dereference in Pike 7.8.306 and earlier.
  indices foo;
  return typeof(foo);
]], typeof(indices((mixed)0)))

// Check that complex function types survive soft casting to function.
ignore_warning("Soft cast of scope(0,*) to function* is a noop.", [[
  test_eq(typeof([function]`+), typeof(`+))
]])

test_compile_error([[ static_assert(0, "Fail."); ]])
test_any([[ static_assert(1, "Ok."); ]], 0)

test_any([[
  /* Detect bug in modify_shared_string().
   *
   * Note: For proper operation this test depends on HASH_PREFIX being
   *       <= 128, and the initial string in test having a single ref.
   */
  string prefix = "A"*128;
  string suffix = "B"*128;

  string test = prefix + "C" + suffix;
  string match = prefix + "D" + suffix;

  if (test == match) return("Early match!");

  test[128] = 'D';

  if (test != match) return("Late mismatch!");
]], 0)

test_compile_error([[ string a="abcb"; a=a/"b"; ]])
test_compile_error([[ string a="abcb"; a/="b"; ]])
test_compile_error([[ string a="abcb"; string b="b"; a=a/b; ]])
test_compile_error([[ string a="abcb"; string b="b"; a/=b; ]])
test_compile_error([[ string a="x"; int b; b="x"*17; ]])
test_compile_error([[ string a="x"; array b; b="x"*17; ]])
test_compile_error([[ int b=17; string a = ""; a=b*42; ]])
test_compile_error([[ int b=17; float c=42.0; b=b/c; ]])
test_compile_error([[ int b=17; float c=42.0; b/=c; ]])
test_compile_error([[ int b=17; float c=42.0; b=b*c; ]])
test_compile_error([[ int b=17; float c=42.0; b*=c; ]])
test_compile_error([[ int b=17; float c=42.0; b=b+c; ]])
test_compile_error([[ int b=17; float c=42.0; b+=c; ]])
test_compile_error([[ int b=17; float c=42.0; b=b-c; ]])
test_compile_error([[ int b=17; float c=42.0; b-=c; ]])
test_compile_error([[ float b=17.0; string a; a=b*42; ]])
test_compile_error([[ float b=17.0; string a; a=b*42.0; ]])

test_compile_error([[class F {inherit master()->dirnode;};]]);

test_any([[
  class A {
    constant i = -1;
    string f() {
      return ([1: "foo"])[i] || "bar"; // No warning here. C.f. lyslys 16630665.
    }
  };
  class B {
    inherit A;
    constant i = 1;
  };
  return B()->f();
]], "foo")

// Warnings

dnl test_compile_warning([[ [mixed]1 ]])
test_compile_warning([[
 class A { int a = 6; };
 class B {
   constant a = 5;
   inherit A;
 };
]])

test_compile_warning([[
  class A {
    int foo;
    protected void create(int foo)
    {
      // Intentional common typo below.
      this:foo = foo;
    }
  };
]])
//

test_compile_warning([[
  // Warning: Compat: Substituting destroy() for _destruct().
  class A {
    protected void destroy() {}
  }
]])
test_compile_any([[
#pragma no_deprecation_warnings
  class A {
    protected void destroy() {}
  }
]])
test_compile_any([[
  class A {
    protected void _destruct() {}
    protected void destroy() {}
  }
]])
test_compile_any([[
  class A {
    protected void destroy() {}
    protected void _destruct() {}
  }
]])

test_any([[
  // Test Pike.InhibitDestruct.
  class Foo {
    inherit Pike.InhibitDestruct;
    /* Make the symbols visible outside. */
    void inhibit_destruct() { ::inhibit_destruct(); }
    void permit_destruct() { ::permit_destruct(); }
  }
  object o = Foo();
  destruct(o);
  if (o) return 1;

  o = Foo();
  o->inhibit_destruct();
  o->permit_destruct();
  if (!o) return 2;
  destruct(o);
  if (o) return 3;

  o = Foo();
  o->inhibit_destruct();
  destruct(o);
  if (!o) return 4;
  o->inhibit_destruct();
  if (!o) return 5;
  o->permit_destruct();
  if (!o) return 6;
  o->permit_destruct();
  if (o) return 7;
  return 0;
]], 0)

test_any([[
  class Foo {
    constant zero = 0;
    mapping(string:array(int)) m;
    string foo() { return sprintf("%O", typeof(m[""][zero])); }
  };
  return Foo()->foo();
]], "int")

test_compile_any([[
  class Foo { ; }
]])

test_compile_any([[
  class Foo { ; ; }
]])

test_compile_any([[
  class Foo { ; constant c = 0; }
]])

test_compile_any([[
  class Foo { mixed a() {  constant c = 17; return c; }
	      mixed b() {  constant c = 17; return c; }  }
]])

test_compile_any([[
  constant FOO = 0;
  mapping(int:string) foo = ([FOO: "foo"]);
]])

test_compile_error([[
  function(...:int) foo;
]]);

test_compile_error([[
  function(,...:int) foo;
]]);

test_compile_error([[
  function(string,...:int) foo;
]]);

test_compile_any([[
  // #pragma strict_types
  void x (void|mapping(string:string) args)
  {
    if (args)
      foreach (indices (args), string a)
	werror ("%O\n", a);
  }
]])

// For some reason, the test above doesn't generate the warning (about
// the type from indices (args)) if it comes after the one below.
// Also, if it is repeated it doesn't generate the warning the second
// time. Not very reassuring.. /mast

test_any([[return class {
string bonk() { return "oiff"; }

class A
{
  string bonk_me() { return bonk(); }
}

class B { inherit A; }

class C
{
  string oiff() { return "bonk"; }
  class D { inherit B; }
}
}()->C()->D()->bonk_me()]],"oiff")

test_any_equal([[
  // Test hiding of inherited symbols with protected.
  class A {
    local mixed a() {}
    mixed b();
    mixed c;
    local mixed d;
    extern mixed e;
    local mixed f;
    local mixed g() {}
    mixed h();
    this_program get_a() { return this_program::this; }
  };
  class B {
    inherit A;
    protected mixed a() {}
    protected mixed b() {}
    protected mixed c = a();
    protected mixed d = b();
    protected mixed e = a();
    protected local mixed f = b();
    protected mixed g();
    protected mixed h();
    this_program get_b() { return this_program::this; }
  };
  class C {
    inherit B;
    this_program get_c() { return this_program::this; }
  };
  class D {
    inherit C;
    this_program get_d() { return this_program::this; }
  };
  object(D) d = D();
  return ({ "A", sort(indices(d->get_a())),
            "B", sort(indices(d->get_b())),
            "C", sort(indices(d->get_c())),
            "D", sort(indices(d->get_d())) });
]], ({ "A", ({ "a", "b", "c", "d", "e", "f", "g", "get_a", "h" }),
       "B", ({ "get_a", "get_b" }),
       "C", ({ "get_a", "get_b", "get_c" }),
       "D", ({ "get_a", "get_b", "get_c", "get_d" }) }))

test_any_equal([[
  // Test hiding of inherited symbols with private.
  class A {
    local mixed a() {}
    mixed b();
    mixed c;
    local mixed d;
    extern mixed e;
    local mixed f;
    this_program get_a() { return this_program::this; }
  };
  class B {
    inherit A;
    private mixed a() {}
    private mixed b() {}
    private mixed c = a();
    private mixed d = b();
    private mixed e = a();
    private local mixed f = b();
    this_program get_b() { return this_program::this; }
  };
  class C {
    inherit B;
    this_program get_c() { return this_program::this; }
  };
  class D {
    inherit C;
    this_program get_d() { return this::this; }
  };
  object(D) d = D();
  return ({ "A", sort(indices(d->get_a())),
            "B", sort(indices(d->get_b())),
            "C", sort(indices(d->get_c())),
            "D", sort(indices(d->get_d())) });
]], ({ "A", ({ "a", "b", "c", "d", "e", "f", "get_a" }),
       "B", ({ "get_a", "get_b" }),
       "C", ({ "get_a", "get_b", "get_c" }),
       "D", ({ "get_a", "get_b", "get_c", "get_d" }) }))

test_any([[
  class O {
    string foo() { return "O"; };
    class A { string foo() { return "A"; } };
    class B { string foo() { return "B"; } };
    class C {
      inherit A;
      inherit B;
      string foo() {
        return "C" + ::this_function() * ":" +
               "C" + A::this_function() +
               "C" + B::this_function() +
               "C" + O::this_function() + "C"; }
    };
  };
  return O()->C()->foo();
]], "CA:BCACBCOC")

test_any([[
  // Test that backtraces with prototypes are rendered correctly by
  // describe_backtrace() et al. These backtraces have caused both
  // "Bad offset" and "Identifier reference index out of range".
  class A { void foo(); };
  class B { int gazonk; inherit A; void bar() { foo(); } };
  return sizeof(describe_backtrace(catch { B()->bar(); })) > 0;
]], 1)

test_any([[
  // Test that backtraces with event handlers are rendered correctly.
  // These backtraces have caused SEGV's due to function pointers
  // out of bounds. cf [bug 6156].
  return sizeof(describe_backtrace(catch {
      Builtin.__Backtrace_Tester__();
    })) > 0;
]], 1)

test_any([[
  // Test that backtraces with event handlers are rendered correctly.
  // These backtraces have caused SEGV's due to function pointers
  // out of bounds. cf [bug 6156].
  return catch { Builtin.__Backtrace_Tester__(); }[1][-1][2];
]], Builtin.__Backtrace_Tester__)

test_any_equal([[
  // Test that filename and line numbers in backtraces are correct.
  // This specific test used to trigger two different bugs.
  // cf [LysLysKOM 22997909].
  int whee(string w)
  {
#line 8 "whee-before"
    int x = 0;
    error("whee!\n");
#line 11 "whee-after"
    string q = "wq";
    q += "21";
    return sizeof(q + w);
  };
#line 16 "test"
  mixed err = catch { whee("foo"); };
  return ({ err[1][-1][0], err[1][-1][1] });
]], ({ "whee-before", 9 }))

test_compile_warning([[
  class A { static int foo = 1; int bar() { return foo; } }
]])

test_any([[
  // Test multiple inherit of same symbol,
  // where later symbol is protected.
  class A { constant foo = 1; };
  class B { constant foo = 2; };
  class C { inherit A; protected inherit B; };
  return C()->foo;
]], 1)

test_any([[
  // Test multiple inherit of same symbol,
  // where later symbol is protected.
  class A { constant foo = 1; };
  class B { protected constant foo = 2; };
  class C { inherit A; inherit B; };
  return C()->foo;
]], 1)

test_any_equal([[
  // Test that extern works as intended.
  class A { extern mixed foo; };
  class B { inherit A; mixed foo; object get_a() { return A::this; } };
  object(B) b = B();
  b->foo = 17;
  array res = ({ b->foo, b->get_a()->foo });
  b->get_a()->foo = 10;
  return res + ({ b->foo, b->get_a()->foo });
]], ({ 17, 17, 10, 10 }))

test_eval_error([[
  // Test that extern works as intended.
  class A { extern mixed foo; };
  class B { inherit A; mixed bar; };
  object(B) b = B();
  b->bar = 17;
  b->foo = 10;
  return b->foo;
]])

test_compile_error([[
 class A { constant q = "x"; }
 class B { inherit A; string z="z"; constant q="x"+z; }
]])

test_compile_any([[
  class A
  {
     object x(int y)
     {
        return B(y);
     }
  }

  class B
  {
     protected void create(int y)
     {
     }
  }
]])

// Test that prototypes are equal() to zero.
test_any_equal([[
  class Foo {int foo();};
  return Foo()->foo;
]], 0)
test_any_equal([[
  class Foo {int foo();};
  return indices(Foo());
]], ({"foo"}))
test_any_equal([[
  class Foo {int foo();};
  return values(Foo());
]], ({0}))
test_any_equal([[
  class Foo
  {
    int foo();
    function f()
    {
      return foo;
    }
  };
  return Foo()->f();
]], 0)
test_any([[
  class Foo
  {
    int foo();
    int(0..1) f()
    {
      return functionp(foo);
    }
  };
  class Bar
  {
    inherit Foo;
    int foo() {}
  };
  return Bar()->f();
]], 1)

dnl equal() on functions.
test_any([[
  class A { int a(){} }
  return equal(A()->a, A()->a);
]], 1)
test_any([[
  class A { int a(){} }
  class B { inherit A; }
  return equal(A()->a, B()->a);
]], 1)
test_any([[
  class A { int a(){} }
  class B { inherit A; int a(){} }
  return equal(A()->a, B()->a);
]], 0)

test_do([[
class Foo
{
  inherit Stdio.File;

  protected void create() {  }
};

class Bar
{
  int y;


  class Gazonk
  {
    inherit Foo;


    protected void create(Stdio.File f)
      {
	assign(f);
      }
  }

  protected void create()
    {
      Gazonk(Stdio.stdin);
    }
};

Bar();

]])

test_any([[
  object f = class {
      array recursive(mixed func, array data, mixed ... args)
      {
	array ret=({});

	foreach(data, mixed foo)
	{
	  if(arrayp(foo))
	  {
	    ret+=({ recursive(func, foo, @args) });
	  }else{
	    ret+=({ foo });
	  }
	}

	return func(ret, @args);
      };
    }();

  mixed x = ({ "A", ({}) });
  x = f->recursive(replace, x, "B", ({}));

  for(int i = 0; i < sizeof(x); i++) {
    if (!stringp(x[i]) && !arrayp(x[i])) return 0;
  }
  return 1;
]], 1);

test_compile_error( [[
  // This triggs a compiler bug on old Pike 7.3.
  non_existant(17) {
    return 0;
  }
]])

test_compile_error( [[
  // This triggs a segfault on Pike 7.4.
  void f()
  {
    constant days =
      ([ "1" : "Sunday"
	 "2" : "Monday" ]);
  }
]])

test_compile_error( [[
  // This triggs a compiler bug on old Pike 7.5.
  return lambda(object (([mixed]a)->syntax_error) { return 0; }(0);
]])

test_compile_error( [[
  // [bug 4362] This triggs a segfault on some versions of Pike 7.7.
  mixed x = all_constants()[undefined_identifier];
]])

test_compile_warning([[
  #pragma strict_types
  // NB: This case used to leak the type function(:string).
  string x (string s) {return s;};
  void y (string|int s) {x (s);};
]])

test_compile_any([[
  #pragma strict_types
  array(string) x = ({"A", "B"});
  mixed a() {return map (x, lower_case);}
]])

test_compile_any([[
  class X {
    X bar();
  }
  class Y {
    constant X = global::X;
    X foo();
  }
]])

test_any( [[
// bug [1996] ------------------------------------------------------------
// http://community/crunch/show_bug.cgi?id=1996
class Implementation
{
   int foo() { return 1; }
};
class Prototype
{
   int foo();
   int bar() { return foo(); }
};
class Test
{
   inherit Implementation;
   inherit Prototype;
   int test() { return bar(); }
};
return Test()->test();
]], 1 );

test_any( [[
// bug [721] -------------------------------------------------------------
// http://community/crunch/show_bug.cgi?id=721
int res=0;
catch
{
add_constant("test_a",compile_string("int foo();","test_a"));
add_constant("test_b",compile_string("int foo();","test_b"));
add_constant("test_c",compile_string(
 "inherit test_a;\n"
 "inherit test_b;\n"
 "final int foo() { return 1; }\n","test_c"));
 res=compile_string("inherit test_c;\n","test_d")()->foo();
};
return res;
	]],1);
test_do(add_constant("test_a"))
test_do(add_constant("test_b"))
test_do(add_constant("test_c"))

test_any( [[
// bug [1858] ------------------------------------------------------------
// http://community/crunch/show_bug.cgi?id=1858
string s=#"
   constant foo=({this});
   int|string test()
   {
      if (!foo[0]) return sprintf(\"foo is %O\\n\",foo)-\"\\n\";
      if (foo[0]==this) return 1;
      return sprintf(\"foo is %O\\n\",foo)-\"\\n\";
   }
";
class handler { void compile_error(string file, int line, string err) { }};
catch {
  program p=compile_string(s,"test",handler());
  return p()->test();
};
return 1; // compile error is ok
	]],1);

// -----------------------------------------------------------------------



// This test checks for excessive recursion in
// destruct_objects_to_destruct, and also that it keeps the destruct
// order sane.
test_do([[
  class Top
  {
    int count = 0;

    class Foo
    {
      int c;
      object|zero foo;
      protected void create(object|zero o)
      {
	foo = o;
	c = count++;
      }

      protected void _destruct()
      {
	count--;
	if (count != c)
	  error ("Destruct out of sequence, "
		 "%d destructed when %d should be.\n", c, count);
	object|zero x = foo && Foo(0);
	x = 0;
	// Cause call to destruct_objects_to_destruct.
	for (int j = 0; j < 10; j++) write ("");
      }
    }

    mixed eat_stack(int|void probe)
    {
      // Avoid eating as much C-stack by releasing the
      // catch at every level.
      if (probe) return 1;
      if (catch(eat_stack(1))) return 1;
      mixed err = 1;
      if ((err = eat_stack()) != 10)
	return intp(err) && err > 0 ? err + 1 : err;
      if (err = catch {

	Foo foo;
	for(int i=0; i < 10000; i++)
	  foo = Foo(foo);
	foo = 0;
	// Cause call to destruct_objects_to_destruct.
	for (int j = 0; j < 10; j++) write ("");

      }) return err;
    }

    protected void create()
    {
      if (mixed err = eat_stack()) {
	catch (err[1] = err[1][sizeof (err[1]) - 50..]);
	throw (err);
      }
    }
  };

  Top();
]]);

// Testing stack popping wrt the various function call opcodes
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    object key = monitor::lock();
    return f (1); // F_CALL_LFUN_AND_RETURN
  };
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  mixed g = f;
  int a()
  {
    object key = monitor::lock();
    return g (1); // F_CALL_FUNCTION_AND_RETURN
  }
]]);
test_program([[
  Thread.Mutex monitor = Thread.Mutex();
  int f (int x)
  {
    if(monitor->trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    add_constant ("f", f);
    add_constant ("monitor", monitor);
    return compile_string(#"
      int g()
      {
	object key = monitor->lock();
	return f (1); // F_APPLY_AND_RETURN
      }")()->g();
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int dummy;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    object key = monitor::lock();
    int res = this->f (1); // F_CALL_OTHER (no `->)
    dummy = random (res);
    return res;
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  protected mixed `-> (string what) {return this[what];}
  int dummy;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    object key = monitor::lock();
    int res = this->f (1); // F_CALL_OTHER (with `->)
    dummy = random (res);
    return res;
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int res = 0;
  void f (int x)
  {
    if(monitor::trylock(1))
      res = 0;
    else
      res = x;
  };
  int a()
  {
    object key = monitor::lock();
    this->f (1); // F_CALL_OTHER_AND_POP (no `->)
    return res;
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  protected mixed `-> (string what) {return this[what];}
  int res = 0;
  void f (int x)
  {
    if(monitor::trylock(1))
      res = 0;
    else
      res = x;
  };
  int a()
  {
    object key = monitor::lock();
    this->f (1); // F_CALL_OTHER_AND_POP (with `->)
    return res;
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    object key = monitor::lock();
    return this->f (1); // F_CALL_OTHER_AND_RETURN (no `->)
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  protected mixed `-> (string what) {return this[what];}
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    object key = monitor::lock();
    return this->f (1); // F_CALL_OTHER_AND_RETURN (with `->)
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (iter == 1) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      object key = monitor::lock();
      iter = 1;
      return a (1); // F_COND_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      object key = monitor::lock();
      iter = 2;
      return a (1); // F_TAIL_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      object key = monitor::lock();
      iter = 2;
      int res = a (1); // F_RECUR
      iter = -1;
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	iter = 0;
      iter = x;
    }
    else {
      object key = monitor::lock();
      iter = 2;
      a (1); // F_RECUR_AND_POP
      return iter;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    foreach (({1, monitor::lock()}), mixed m)
      return f (m); // F_CALL_LFUN_AND_RETURN
  };
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  mixed g = f;
  int a()
  {
    foreach (({1, monitor::lock()}), mixed m)
      return g (m); // F_CALL_FUNCTION_AND_RETURN
  }
]]);
test_program([[
  Thread.Mutex monitor = Thread.Mutex();
  int f (int x)
  {
    if(monitor->trylock(1))
      return 0;
    return x;
  }
  int a()
  {
    add_constant ("f", f);
    add_constant ("monitor", monitor);
    return compile_string(#"
      int g()
      {
	foreach (({1, monitor->lock()}), mixed m)
	  return f (m); // F_APPLY_AND_RETURN
      }")()->g();
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int dummy;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    int res;
    foreach (({1, monitor::lock()}), mixed m) {
      res = this->f (m); // F_CALL_OTHER (no `->)
      dummy = random (res);
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  protected mixed `-> (string what) {return this[what];}
  int dummy;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    int res;
    foreach (({1, monitor::lock()}), mixed m) {
      res = this->f (m); // F_CALL_OTHER (with `->)
      dummy = random (res);
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int res = 0;
  void f (int x)
  {
    if(monitor::trylock(1))
      res = 0;
    else
      res = x;
  };
  int a()
  {
    foreach (({1, monitor::lock()}), mixed m) {
      this->f (m); // F_CALL_OTHER_AND_POP (no `->)
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  protected mixed `-> (string what) {return this[what];}
  int res = 0;
  void f (int x)
  {
    if(monitor::trylock(1))
      res = 0;
    else
      res = x;
  };
  int a()
  {
    foreach (({1, monitor::lock()}), mixed m) {
      this->f (m); // F_CALL_OTHER_AND_POP (with `->)
      return res;
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    foreach (({1, monitor::lock()}), mixed m)
      return this->f (m); // F_CALL_OTHER_AND_RETURN (no `->)
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  protected mixed `-> (string what) {return this[what];}
  int f (int x)
  {
    if(monitor::trylock(1))
      return 0;
    return x;
  };
  int a()
  {
    foreach (({1, monitor::lock()}), mixed m)
      return this->f (m); // F_CALL_OTHER_AND_RETURN (with `->)
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (iter == 1) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      iter = 1;
      foreach (({1, monitor::lock()}), mixed m)
	return a (m); // F_COND_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      iter = 2;
      foreach (({1, monitor::lock()}), mixed m)
	return a (m); // F_TAIL_RECUR
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	return 0;
      return x;
    }
    else {
      iter = 2;
      int res;
      foreach (({1, monitor::lock()}), mixed m) {
	res = a (m); // F_RECUR
	iter = random (res);
	return res;
      }
    }
  }
]]);
test_program([[
  inherit Thread.Mutex : monitor;
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      if (monitor::trylock(1))
	iter = 0;
      iter = x;
    }
    else {
      iter = 2;
      foreach (({1, monitor::lock()}), mixed m) {
	a (m); // F_RECUR_AND_POP
	return iter;
      }
    }
  }
]]);
test_do(add_constant("f"))
test_do(add_constant("monitor"))

// Testing scoped frames wrt the various function call opcodes
test_program([[
  int f (int x)
  {
    return x;
  }
  int a (void|int x)
  {
    function s = lambda () {return x;};
    return f (1); // F_CALL_LFUN_AND_RETURN
  };
]]);
test_program([[
  int f (int x)
  {
    return x;
  };
  mixed g = f;
  int a (void|int x)
  {
    function s = lambda () {return x;};
    return g (1); // F_CALL_FUNCTION_AND_RETURN
  }
]]);
test_program([[
  int f (int x)
  {
    return x;
  }
  int a()
  {
    add_constant ("f", f);
    return compile_string(#"
      int g (void|int x)
      {
        function s = lambda () {return x;};
	return f (1); // F_APPLY_AND_RETURN
      }")()->g();
  }
]]);
test_program([[
  int dummy;
  int f (int x)
  {
    return x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    int res = this->f (1); // F_CALL_OTHER (no `->)
    dummy = random (res);
    return res;
  }
]]);
test_program([[
  protected mixed `-> (string what) {return this[what];}
  int dummy;
  int f (int x)
  {
    return x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    int res = this->f (1); // F_CALL_OTHER (with `->)
    dummy = random (res);
    return res;
  }
]]);
test_program([[
  int res = 0;
  void f (int x)
  {
    res = x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    this->f (1); // F_CALL_OTHER_AND_POP (no `->)
    return res;
  }
]]);
test_program([[
  protected mixed `-> (string what) {return this[what];}
  int res = 0;
  void f (int x)
  {
    res = x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    this->f (1); // F_CALL_OTHER_AND_POP (with `->)
    return res;
  }
]]);
test_program([[
  int f (int x)
  {
    return x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    return this->f (1); // F_CALL_OTHER_AND_RETURN (no `->)
  }
]]);
test_program([[
  protected mixed `-> (string what) {return this[what];}
  int f (int x)
  {
    return x;
  };
  int a (void|int x)
  {
    function s = lambda () {return x;};
    return this->f (1); // F_CALL_OTHER_AND_RETURN (with `->)
  }
]]);
test_program([[
  int iter = 0;
  int a (void|int x)
  {
    if (iter == 1) {
      return x;
    }
    else {
      function s = lambda () {return x;};
      iter = 1;
      return a (1); // F_COND_RECUR
    }
  }
]]);
test_program([[
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      return x;
    }
    else {
      function s = lambda () {return x;};
      iter = 2;
      return a (1); // F_TAIL_RECUR
    }
  }
]]);
test_program([[
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      return x;
    }
    else {
      function s = lambda () {return x;};
      iter = 2;
      int res = a (1); // F_RECUR
      iter = -1;
      return res;
    }
  }
]]);
test_program([[
  int iter = 0;
  int a (void|int x)
  {
    if (!iter) {
      iter = 1;
      return a (x);
    }
    else if (iter == 2) {
      iter = x;
    }
    else {
      function s = lambda () {return x;};
      iter = 2;
      a (1); // F_RECUR_AND_POP
      return iter;
    }
  }
]]);
test_do(add_constant("f"))

test_false([[object_variablep(class { int y; int z() { return 1; }}(),"foo")]])
test_false([[object_variablep(class { int y; int z() { return 1; }}(),"z")]])
test_true([[object_variablep(class { int y; int z() { return 1; }}(),"y")]])

test_any([[ int a,b; [a,b]=({1,2}); return a]],1)
test_any([[ int a,b; [a,b]=({1,2}); return b]],2)
test_any([[ int a,b; [ [a],b]=({ ({ 1 }) ,2}); return a]],1)
test_any([[ int a,b; [ [a],b]=({ ({ 1 }) ,2}); return b]],2)
test_any([[ int a; catch { [a]=({1,2}); return 0; }; return 1]],1)
test_compile_error([[ int a,b; catch { [a,b]=({1}); return 0; }; return 1]],1)
test_any([[ int a,b; catch { [a,b]=lambda(){ return ({1}); }(); return 0; }; return 1]],1)
test_any([[ mapping m=([]); m[m]=m; return stringp(sprintf("%O",m)); ]],1)
dnl test_any([[
dnl // don't know if this /should/ be valid  /Mirar
dnl // remove if it shouldn't
dnl
dnl // I see no reason this should be allowed - Hubbe
dnl
dnl array a=({});
dnl []=a; return 1; ]],1)

test_any([[
  int q() { throw(1); };
  catch {
     return q();
  };
  return 17;
]],17)

test_any([[
 return class
 {
   int q() { throw(1); };
   int p() {
     catch {
        return q();
     };
     return 17;
   }
 }()->p();
]],17)

test_compile_error([[
  protected function foo(string ...:object);
  int bar()
  {
    return 17;
  }
]])
test_compile_error([[
  array a;
  a = path_info[..(sizeof(path_info)-2]*"/";
]])
test_compile_error([[ default ; ]])
test_compile_error([[ 0999; ]])
test_compile_error([[ int a,b; [a,b]++; ]])
test_compile_error([[
array(int) x;

string foo()
{
 return "foo "+(array(string) x) * ",";
}

int main()
{
  return 0;
}
]])

dnl
dnl this_program
dnl

test_true(this_program)
test_any([[int this_program; return this_program;]], 0)
test_any([[class A { int a() { return this_program == A; }}; return A()->a();]], 1)
test_program([[
  class A (int v)
  {
    this_program clone() {return this_program (v);}
  }
  int a() {return A (4)->clone()->v == 4;}
]])
test_program([[
  int i = 17, j = 18;
  class A (int v)
  {
    this_program clone() {return this_program (i);}
  }
  int a() {return A (4)->clone()->v == 17;}
]])
test_program([[
  class A (int v)
  {
    this_program clone() {return this_program (j);}
  }
  int i = 17, j = 18;
  int a() {return A (4)->clone()->v == 18;}
]])
test_program([[
  int i = 17, v;
  this_program clone() {return this_program (i);}
  protected void create (int v_) {v = v_;}
  int a() {return clone()->v == 17;}
]])
test_program([[
  this_program clone() {return this_program (i);}
  int i = 17, v;
  protected void create (int v_) {v = v_;}
  int a() {return clone()->v == 17;}
]])
test_program([[
  class A {this_program clone() {return this_program();}}
  class B {inherit A;}
  int a() {return object_program (B()->clone()) == B;}
]])
test_program([[
  class A {this_program clone() {return this_program();}}
  class B {inherit A;}
  int a() {return typeof(B()->clone()) <= B;}
]])

test_program([[
  class A {
    class B {
      mixed f() {
	return ({global::this_program,
		 A::this_program, // Works, but not really useful.
		 B::this_program, // Ditto.
		 this_program});
      }
    }
  }
  int a() {
    return equal (A()->B()->f(), ({object_program (this), A, A.B, A.B}));
  }
]])

test_compile_error([[
  mixed x() {
    return ::x;
  }
]])

test_program([[
  class A {
    class B {
      constant this_program = "foo";
      mixed f (int this_program) {
	return ({A::this_program, B::this_program, this_program});
      }
    }
  }
  int a() {
    return equal (A()->B()->f (1), ({A, "foo", 1}));
  }
]])

test_program([[
  class I {
    string this_program = "foo";
  }
  class A {
    class B {
      inherit I;
      mixed f (int this_program) {
	return ({A::this_program, B::this_program, this_program});
      }
    }
  }
  int a() {
    return equal (A()->B()->f (1), ({A, "foo", 1}));
  }
]])

test_program([[
  string this_program = "foo";
  class A {
    class B {
      mixed f() {
	return ({A::this_program, B::this_program, this_program});
      }
    }
  }
  int a() {
    return equal (A()->B()->f(), ({A, A.B, "foo"}));
  }
]])

test_compile_error_any([[
  class A {}
  class B {
    inherit A:C;
    mixed f() {return A::this_program;}
  }
]])

test_any([[
  class A {};
  class B {
    inherit A:C;
    mixed f() {return C::this_program;}
  };
  return B()->f() == A;
]], 1)

test_any([[
  class A {
    class Nested {
      constant nested = 1;
    }
  };
  class B {
    inherit A;
    class Nested {
      inherit ::this_program;
      constant other = 2;
    }
  };
  object n = B()->Nested();
  return n->nested + n->other;
]], 3)

dnl test_compile_error(0())
test_compile_error(1())
test_compile_error(""())
test_compile_error(([])())
test_compile_error(([])())
test_any([[ class X { int y; class Z { protected void _destruct() { y++; } } }; X x=X(); destruct(x->Z()); return x->y;]],1)

test_eval_error([[ class Z { protected int _destruct() { return 1/y; } }(); ]])

test_any([[ class X { int y; class Z { protected void _destruct() { y++; } } }; X x=X(); destruct(x->Z()); return x->y;]],1)
test_any([[ class X { int y; class Z { protected void create() { y++; } } }; X x=X(); destruct(x->Z()); return x->y;]],1)

ifefun(_debug,
[[
  test_do(_debug(_debug(0)))
]])
test_do(indices(_static_modules))
test_compile_any([[import Stdio; class x { string y() { read_file("foo"); } }]])

dnl ----------------------------------------------------------------
dnl backtrace/linenumber tests
dnl ----------------------------------------------------------------

test_any([[
  program p=compile_string(
"int foo()\n"
"{\n"
"  error(\"test error\\n\"); // line 3\n"
"  return 17;\n"
"}","test");
  mixed err=catch { p()->foo(); };
  if (err[1][-1][1]!=3)
  {
     werror("backtrace is:\n"+master()->describe_backtrace(err));
  }
  return err[1][-1][1];
]],3);

// Bug 2660
test_any([[
  int foo(mixed a, mixed ... b) {
    return sizeof(backtrace()[-1]) - (3 + 1 + sizeof(b));
  };
  return foo(1,2,3,4)|foo(1);
]], 0)

define(test_backtrace_line_charset, [[
test_any([[
  program p=compile_string(
Charset.encoder("]]$1[[")->feed(
"#charset ]]$1[[\n"
"int foo()\n"
"{\n"
"  error(\"test error\\n\"); // line 3\n"
"  return 17;\n"
"}")->drain(),"test");
  mixed err=catch { p()->foo(); };
  if (err[1][0][1]!=3)
  {
     werror("backtrace is:\n"+master()->describe_backtrace(err));
  }
  return err[1][0][1];
]],3);
]])
dnl test_backtrace_line_charset(utf-7)

test_program([[
  class X
  {
    protected void create (int i)
    {
      if (i)
	error ("foo\n"); // Line 7
    }
  }

  int f()
  {
    X (0);
    X (1); // Line 14
  }

  int a()
  {
    array bt = catch (f())[1];
    int ok = 0;
    foreach (reverse (bt), object ent)
      switch (functionp (ent[2]) && function_name (ent[2])) {
	case "create": if (ent[1] == 7) ok++; break;
	case "f": if (ent[1] == 14) ok++; break;
      }
    return ok == 2;
  }
]])

test_program([[// [bug 3060]
  void x (mixed val)
  {
  }

  class X
  {
    protected void create() {error ("foo\n");} // Line 8
  }

  object rx = class {}();

  int y()
  {
    x (rx->x);
    rx = X(); // Line 16
  }

  int a()
  {
    mixed bt = catch (y())[1];
    int ok = 0;
    foreach (reverse (bt), object ent)
      switch (functionp (ent[2]) && function_name (ent[2])) {
	case "create": if (ent[1] == 8) ok++; break;
	case "y": if (ent[1] == 16) ok++; break;
      }
    return ok == 2;
  }
]])

test_any([[
  // Test a lot of code without a relative pc update in it. There must
  // not be any labels in it since the pc counting is reset then.
  int a = 1, b = 1, c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c; c=a+b,a=b,b=c;
  return __LINE__ == backtrace()[-1][1];
]], 1)

dnl Note: This line number error tend to go away with more debug.
test_program([[
  int x = 0;
  int y = [int] backtrace()[-1][1];
  int a() {return y == 3;}
]])

dnl This test used to get the last line of the else block
test_any([[
  int expected_line;
  void foo(object|zero o)
  {
    expected_line = __LINE__ + 1;
    if (o->a && b) {
      o->a = o->b;
    } else if (o->b) {
      o->b = o->a;
    }
  };
  mixed err = catch { foo(UNDEFINED); };
  return err[1][-1][1] - expected_line;
]], 0)

dnl ----------------------------------------------------------------
dnl scopes and stuff
dnl ----------------------------------------------------------------

test_program([[
  class A {
    string f() {return "A";}
  }
  class B {
    string f() {return "B";}
  }
  class C {
    inherit B;
  }
  class D {
    inherit A;
    inherit C;
    string g() {return f();}
  }
  int a() {
    return D()->g() == "B";
  }
]])
test_program([[
  class A {
    string f() {return "A";}
  }
  class B {
    string f() {return "B";}
  }
  class C {
    inherit B;
  }
  class D {
    inherit C;
    inherit A;
    string g() {return f();}
  }
  int a() {
    return D()->g() == "A";
  }
]])
test_program([[
  class A {
    string f() {return "A";}
  }
  class B {
    string f() {return "B";}
  }
  class C {
    inherit B;
  }
  class D {
    string f() {return "D";}
    inherit A;
    inherit C;
    string g() {return f();}
  }
  int a() {
    return D()->g() == "D";
  }
]])

test_compile_any([[
class Bar
{
  int f() {return 17;}

  class Foo {
    int g() {return f();}
  }

  inherit Foo;
}
]])
test_compile_any([[
class Bar
{
  int f() {return 17;}

  class Foo {
    int g() {return f();}
  }
}

class Gnu
{
  inherit Bar;
  inherit Foo;
}

]])

dnl Bug 2571
test_any([[
  int var;
  void x() {var++;};
  lambda () {x();}();
  return var;
]], 1);

test_do([[
  // Save our constants for future use...
  add_constant("__saved_constants", ([]) + all_constants());
]])

test_any([[
 Stdio.write_file("testsuite_test.pmod",
	#"
// this crashes Pike /Mirar 2001-05-19
// I haven't been able to minimize it futher,
// and it needs to be in a separate module.
//
// This triggers a placeholder object needing to
// be destructed in compiler pass 2 due to the
// type checking error. The original issue was
// likely fixed 2001-05-23. /grubba 2024-03-11

mapping es=0;

string efoo(string e)
{
   if (!es)
   {
      mapping res=([]);

      string l;

      if (sscanf(l,\"%s%s\",string ext,string type)==4 &&
	  ext!=\"\" && ext[0]!=\"#\") // note the type error
	 res[ext]=type;

      es=res;
   }
}
	");

 // Compilation handler that hides compilation errors.
 class handler
 {
   void compile_error(string file, int line, string err)
   {
     // log_msg("file: %O, line: %O, err: %O\n", file, line, err);
   }
 };

 // turn this on when the bug is found
 // master()->set_inhibit_compile_errors(lambda(){});

 //_optimizer_debug(2);
 //_assembler_debug(20);

 object orig_master = master();
 replace_master(object_program(orig_master)());
 catch {
   compile_string("import \".\";\n"
                  "int foo() { testsuite_test.efoo; }\n",
		  "testsuite_test", handler());
 };
 replace_master(orig_master);
 return 0;
]],0);

test_any([[
 Stdio.write_file("testsuite_test.pmod",
#"
// Bug 10130 and 10131.
// This crashed pike due to broken error recovery.

class Bang(pang) {
  void bang() {}
}
");

 // Compilation handler that hides compilation errors.
 class handler
 {
   void compile_error(string file, int line, string err)
   {
     // log_msg("file: %O, line: %O, err: %O\n", file, line, err);
   }
 };

 catch {
   compile_string(".testsuite_test.Bang bang;\n", "testsuite_test", handler());
 };
 return 0;
]],0);

test_any([[
// infokom:350113
 Stdio.recursive_rm("testsuite_test_dir.pmod");
 mkdir("testsuite_test_dir.pmod");
 Stdio.write_file("testsuite_test_dir.pmod/module.pmod",
	#"
    .A a() {return 0;}
	");
 Stdio.write_file("testsuite_test_dir.pmod/A.pike",
	#"
    void create (.X x) {.y();}
	");

 // Compilation handler that hides compilation errors.
 class handler
 {
   void handle_error(array(mixed)|object trace) { }
   void compile_error(string file, int line, string err) { }
   void compile_warning(string file, int line, string err) { }
 };

  object orig_master = master();
  replace_master(object_program(orig_master)());
  master()->set_inhibit_compile_errors(handler());
  mixed err = catch {
     compile_string("import \".\"; "
	"int foo() { testsuite_test_dir.a(); }",
	"test",handler());
  };
  master()->set_inhibit_compile_errors(0);
  replace_master(orig_master);
  if(err)
  {
    Stdio.recursive_rm("testsuite_test_dir.pmod");
    return 0;
  }

 return 1;
]],0);

test_do([[
 Stdio.recursive_rm("testsuite_test_dir.pmod");
 mkdir("testsuite_test_dir.pmod");

 Stdio.write_file("testsuite_test_dir.pmod/module.pmod",
	#"
    .A a();
    class X {}
	");
 Stdio.write_file("testsuite_test_dir.pmod/A.pike",
	#"
    .X f() {return 0;}
	");

 object orig_master = master();
 replace_master(object_program(orig_master)());
 mixed err = catch {
   compile_string("import \".\"; "
		  "int foo() { testsuite_test_dir.A(); }",
		  "test");
 };
 replace_master(orig_master);
 if (err) throw (err);

 Stdio.recursive_rm("testsuite_test_dir.pmod");
]]);

test_do([[
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/module.pmod", #"\
    .B b();
    class X {}");
  Stdio.write_file ("testsuite_test_dir.pmod/A.pike", #"\
    int f() {return 0;}");
  Stdio.write_file ("testsuite_test_dir.pmod/B.pike", #"\
    inherit .A;
    .X g() {return f() && .X();}");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed err = catch {
      compile_string ("import \".\";\n"
		      "int foo() { testsuite_test_dir.B(); }",
		      "test");
    };
  replace_master (orig_master);
  if (err) throw (err);

  Stdio.recursive_rm ("testsuite_test_dir.pmod");
]]);

test_do([[
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/module.pmod", #"\
    .B.B b();
    class X {}");
  Stdio.write_file ("testsuite_test_dir.pmod/A.pike", #"\
    int f() {return 0;}");
  Stdio.write_file ("testsuite_test_dir.pmod/B.pmod", #"\
    class B {
      inherit .A;
      .X g() {return f() && .X();}
    }");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed err = catch {
      compile_string ("import \".\";\n"
		      "int foo() { testsuite_test_dir.B.B(); }",
		      "test");
    };
  replace_master (orig_master);
  if (err) throw (err);

  Stdio.recursive_rm ("testsuite_test_dir.pmod");
]]);

test_do([[
  // Problem: The expression .B.c in module.pmod is resolved during
  // compilation pass 1 of B.pike, but it's only declared then and
  // doesn't yet have any value.
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/module.pmod", #"\
    mixed x = .B.c;
    class A {}");
  Stdio.write_file ("testsuite_test_dir.pmod/B.pike", #"\
    constant c = .A();"); // Should give a "not constant" compile error.

  // Compilation handler that hides compilation errors.
  class handler
  {
    void handle_error(array(mixed)|object trace) { }
    void compile_error(string file, int line, string err) { }
    void compile_warning(string file, int line, string err) { }
  };

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed err = catch {
      compile_string (#"\
	mixed foo() {return .testsuite_test_dir.A;}",
        "test", handler());
    };
  replace_master (orig_master);
  if (!err) error ("Expected compile error.\n");
  if (!objectp (err) || !err->is_compilation_error) throw (err);

  Stdio.recursive_rm("testsuite_test_dir.pmod");
]]);

test_any_equal([[
  // Problem: module.pmod is in pass 1 when it tries to resolve the
  // .B.c constant and is therefore temporarily interned as a
  // placeholder object. The (<>) in B.pike is equivalent to
  // aggregate_multiset, which due to the import is looked up in the
  // placeholder object and therefore resolved as a nonconstant
  // placeholder object.
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/module.pmod", #"\
    mixed x = .B.C;
    mixed foo() {return x->c;}");
  Stdio.write_file ("testsuite_test_dir.pmod/B.pike", #"\
    import \".\";
    class C {
      constant c = (<>);
    }");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed res;
  mixed err = catch {
      res = compile_string (#"\
	mixed foo() {return .testsuite_test_dir.foo();}",
        "test")()->foo();
    };
  replace_master (orig_master);
  if (err) throw (err);
  Stdio.recursive_rm("testsuite_test_dir.pmod");
  return res;
]], (<>));

test_do([[
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/A.pmod", #"\
    string pof() {return testsuite_test_dir.A.bingo();}
    string bingo () {return \"17\";}");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  master()->add_module_path (getcwd());
  mixed err = catch {
      compile_string (#"\
	string foo() {
	  return testsuite_test_dir.A.pof();
	}", "test");
    };
  replace_master (orig_master);
  if (err) throw (err);

  Stdio.recursive_rm ("testsuite_test_dir.pmod");
]])

test_do([[
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/module.pmod", #"\
    .Foo.C x;");
  Stdio.write_file ("testsuite_test_dir.pmod/Foo.pmod", #"\
    import \".\";
    class C
    {
      int f (array x)
      {
	return lambda() {
		 // 'sizeof' below will be a placeholder object in
		 // pass 1. That shouldn't cause a type error.
		 int i = sizeof (x);
		 return i;
	       }();
      }
    }");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed err = catch {
      compile_string (#"\
	mixed foo() {return .testsuite_test_dir.x;}",
        "test");
    };
  replace_master (orig_master);
  if (err) throw (err);
  Stdio.recursive_rm("testsuite_test_dir.pmod");
]]);

test_do([[
  Stdio.write_file ("testsuite_test_a.pmod", #"
    class a {}
    testsuite_test_b.b2 foo() {return testsuite_test_b.b2 (17);}");

  Stdio.recursive_rm ("testsuite_test_b.pmod");
  mkdir ("testsuite_test_b.pmod");
  Stdio.write_file ("testsuite_test_b.pmod/b1.pike", #"
    protected void create() {}");
  Stdio.write_file ("testsuite_test_b.pmod/b2.pike", #"
    inherit testsuite_test_b.b1;
    constant a = testsuite_test_a.a;
    protected void create (int i) {}");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  master()->add_module_path (getcwd());
  mixed err = catch {
      compile_string ("inherit testsuite_test_b.b2;");
    };
  replace_master (orig_master);
  if (err) throw (err);

  Stdio.recursive_rm ("testsuite_test_a.pmod");
  Stdio.recursive_rm ("testsuite_test_b.pmod");
]])

cond(0,[[
test_do([[
  // This is a case of cyclic references I think should work, but
  // afaict it's not possible without changing the resolve methods
  // thoroughly. /mast
  Stdio.recursive_rm ("testsuite_test_dir.pmod");
  mkdir ("testsuite_test_dir.pmod");

  Stdio.write_file ("testsuite_test_dir.pmod/A.pmod", #"\
    .B.B b() {}
    class A {}
    class Ab {int ai() {return 4711;}}
    class Ad {inherit .B.Bb; int ai() {return bi() + 1;}}");
  Stdio.write_file ("testsuite_test_dir.pmod/B.pmod", #"\
    .A.A a() {}
    class B {}
    class Bb {int bi() {return 17;}}
    class Bd {inherit .A.Ab; int bi() {return ai() - 1;}}");

  object orig_master = master();
  replace_master (object_program (orig_master)());
  mixed err = catch {
      compile_string (#"\
	import \".\";
	int foo() {
	  testsuite_test_dir.A.Ad();
	  testsuite_test_dir.B.Bd();
	}", "test");
    };
  replace_master (orig_master);
  if (err) throw (err);

  Stdio.recursive_rm ("testsuite_test_dir.pmod");
]]);
]]);

test_do([[
  // Restore constants that were zapped by the various masters used above.
  foreach(__saved_constants; string const_name; mixed val) {
    add_constant(const_name, val);
  }
  add_constant("__saved_constants");
]])

test_compile_any([[int log() { return 17; } class Greta { int hanna() { return log(); } }]])
test_compile_any([[int kajsa(int a,int b) { return 17; } class Jenny { int kajsa() { return 17; } class Greta { int hanna() { return kajsa(); } } }]])
test_any([[add_constant("kajsa",lambda(int a,int b) { return 17; }); return compile_string("int kajsa() { return 17; } class Greta { int hanna() { return kajsa(); } }")()->kajsa()]],17)
test_do(add_constant("kajsa"))

test_compile([[Stdio.File foo=Stdio.File();]])
test_compile([[  string|multiset(string) foo;
  array(string) gazonk;
  array(string) bar = indices(foo)-gazonk;
]])
test_compile([[class { Stdio.File foo=Stdio.File(); }]])
test_compile_any([[void foo(Stdio.FILE f) {}]])
test_compile_any([[void foo(array(Stdio.FILE) f) {}]])
test_compile_any([[void foo(array(Stdio.FILE) f) {}]])
test_compile_any([[Stdio.File foo(array(Stdio.FILE) f) { return f[0]; }]])
test_compile_any([[
class a {
  protected int `== (mixed x) {
    return 0;
  }
}

class b {
  inherit a;
  class c {
    int d (string x, string y) {
      return x==y;
     }
  }
}
]])
test_compile([[Stdio.File foo=Stdio.FILE();]])

dnl variant
test_any([[
  class A {
    variant string a() { return "A:a()"; }
    variant string a(string s) { return sprintf("A:a(%q)", s); }
  };
  class B {
    inherit A;
    variant string a(int i) { return local::a() + ":" + local::a((string)i) + ":" + ::a((string)i); }
    variant string a(string s) { return sprintf("B:a(%q)", s); }
  };
  class C {
    inherit B;
    string a() { return "C:a()"; }
    variant string a(string s) { return ::a(sizeof(s)) + "|" + ::a(s) + "|" + a(); }
  };
  return C()->a("foo");
]], "A:a():B:a(\"3\"):A:a(\"3\")|B:a(\"foo\")|C:a()")

test_any([[
  class A {
    string a() { return "A"; }
    variant string a(int i) { return "B"+i+"B"; }
  };
  return A()->a() + A()->a(1);
]], "AB1B")

test_any([[
  class A {
    string a(int i) { return "B"+i+"B"; }
    variant string a() { return "A"; }
  };
  return A()->a() + A()->a(1);
]], "AB1B")

test_compile_warning([[
  class A {
    string a() { return "A"; }
    variant string a(int|void i) { return "B"+i+"B"; }
  };
  return A()->a() + A()->a(1);
]])

dnl test_any([[
dnl   class A {
dnl     string a(int|void i) { return "A" + i + "A"; }
dnl     variant string a(int i) { return "B"+i+"B"; }
dnl   };
dnl   return A()->a() + A()->a(1);
dnl ]], "A0AB1B")

test_compile_warning([[
  class A {
    string a(int i) { return "A"+i+"A"; }
    variant string a(int|void i) { return "B"+i+"B"; }
  };
  return A()->a() + A()->a(1);
]])

dnl test_any([[
dnl   class A {
dnl     string a(int|void i) { return "A" + i + "A"; }
dnl     variant string a(int i, int|void j) { return "B"+i+"C"+j+"C"+"B"; }
dnl   };
dnl   return A()->a() + A()->a(1) + A()->a(2, 3);
dnl ]], "A0AB1C0CBB2C3CB")

test_compile_warning([[
  class A {
    string a(int i) { return "A"+i+"A"; }
    variant string a(int i, int|void j) { return "B"+i+"C"+j+"C"+"B"; }
  };
  return A()->a(1) + A()->a(2, 3);
]])

test_any([[
  class A { string a(){ return "A"; } };
  class B { int a(){ return 17; } };
  class C {
    string c(A a) { return "C" + a->a() + "C"; }
    variant string c(B b) { return "CB" + b->a() + "BC"; }
  };
  A a = A();
  B b = B();
  C c = C();
  return c->c(a) + c->c(b);
]], "CACCB17BC")

test_compile_warning([[
  // Bug 7812.
  class A { string a(){ return "A"; } };
  class B { int a(){ return 17; } };
  class C {
    string c(array(A) a) { return "C" + (a->a() * "C") + "C"; }
    variant string c(array(B) b) { return "CB" + `+(0, @b->a()) + "BC"; }
  };
  A a = A();
  B b = B();
  C c = C();
  return c->c(({a,a})) + c->c(({b,b}));
]])

test_any([[
  // Test the __weak__ modifier.
  class A {
    class Q{};
    __weak__ Q q_w = Q();
    __weak__ mixed m_w = Q();
    Q q = Q();
    mixed m = Q();
  };
  A a = A();
  gc();
  return !a->q_w && !a->m_w && a->q && a->m && 1;
]], 1)

test_any([[
  // Test symbol lookup for inherit in multi-pass.
  // LysLysKOM 16472935
  // An old pike will attempt to lookup X in the innermost X
  // during the second pass and thus fail with a compilation error.
  class X {
    constant foo = "outer";
    class X {
      constant foo = "middle";
      class X {
        constant foo = "inner";
      }
    }
  };
  class Y {
    inherit X.X;
  };
  return Y()->foo;
]], "middle")

test_any([[
  // Test external symbol lookup in las.c:eval_low_safe_and_stupid().
  // LysLysKOM 18285732
  // An old pike will fail with the fatal
  // "Identifier out of range, loc->parent_identifer=-1!"
  // during __INIT().

  class A
  {
    protected string foo = "bar";
  };

  string to_compile=#"
    constant fum = \"gazonk\";

    class B()
    {
       inherit A;
       int fi()
       {
          return fum?1:0;
       }
    }
  ";

  add_constant("A",A);
  compile_string(to_compile);
  add_constant("A");
  return 0;
]], 0)

test_any_equal([[
  // Test automap combined with splice. [LysLysKOM 23258037]
  array ret = ({});
  for (int x = 0; x < 10; x++) {
    array a = ({ x, });
    ret += `+(a[*], @a);
  }
  return ret;
]], ({ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18 }))

test_any([[
  // Test eval_low() on seemingly constant expressions, that
  // attempt to access variables in the fake object. [Bug 5273]
  // An old pike (with RTL debug) will fail with the fatal
  // "Invalid type 33896 in svalue at 891e510."
  // during compilation.

  class Test
  {
    protected object foo;

    protected mixed `-> (mixed what)
    {
      return foo;
    }

    int bar ()
    {
      return (this->gazonk == "foo") ? 1 : 0;
    }
  };

  return Test()->bar;
]], 0)

test_compile_error([[
  class {
  int a() { }
  void b() { return a(); }
  }
]])

test_do([[
  class {
  void a() { }
  void b() { return a(); }
  }
]])

test_any([[string gurk="bozo"; string b(int x) { return (x?b(x-1)+gurk:""); }; return b(5)]],[["bozo"*5]])

dnl this should really work...
dnl test_compile_any([[void foo(int,string,...);]])

dnl This test doesn't run out of stack anymore, freaky
dnl test_eval_error([[class X { int create() { create(); } }();]])
test_compile_error([[ int float; ]])
test_compile_error([[ int array; ]])
test_compile_error([[ int function; ]])
test_compile_error([[ int int; ]])
test_compile_error([[ int mapping; ]])
test_compile_error([[ int multiset; ]])
test_compile_error([[ int object; ]])
test_compile_error([[ int string; ]])
test_compile_error([[ int void; ]])
test_compile_error([[ int inline; ]])
test_compile_error([[ int local; ]])
test_compile_error([[ int predef; ]])
test_compile_error([[ int private; ]])
test_compile_error([[ int protected; ]])
test_compile_error([[ int public; ]])
test_compile_error([[ int static; ]])
test_compile_error([[ int final; ]])
test_compile_error([[ int do; ]])
test_compile_error([[ int else; ]])
test_compile_error([[ int return; ]])
test_compile_error([[ int constant; ]])
test_compile_error([[ int import; ]])
test_compile_error([[ int inherit; ]])
test_compile_error([[ int catch; ]])
test_compile_error([[ float gauge; ]])
test_compile_error([[ int lambda; ]])
test_compile_error([[ int sscanf; ]])
test_compile_error([[ int switch; ]])
test_compile_error([[ int typeof; ]])
test_compile_error([[ int break; ]])
test_compile_error([[ int case; ]])
test_compile_error([[ int continue; ]])
test_compile_error([[ int default; ]])
test_compile_error([[ int for; ]])
test_compile_error([[ int foreach; ]])
test_compile_error([[ int if; ]])
test_compile_error([[ int float = 0; ]])
test_eval_error([[ return 0.0[0]; ]])
test_eval_error([[ return 0[0]; ]])
test_compile_error([[constant x=class {}(); ]])

test_compile_error_any([[
 mixed foo;
 mapping query_variables() { return ([]); };
 mixed foo(mixed bar) { return 1/foo; }
]])

test_compile_error_any([[
  class A {int wrong = "bogus"; void create() {}}
  class B {inherit A;}
]])

test_any([[
#pragma dynamic_dot
  // Test dynamic module indexing.
  object protocols = Protocols;
  return protocols.HTTP.get_url_data;
]], [[ Protocols.HTTP.get_url_data ]])

test_compile([[float x=(gauge { return; },1.0);]])
test_compile_error([[object x = Gmp.mpz(17); constant y = x;]])
test_any([[object(Stdio.File) f; f=Stdio.File(); return 1]],1)
test_compile([[float t=gauge { string foo; foo; };]])
test_compile_any([[class Foo { object(Stdio.FILE) f; protected void create() { f=Stdio.FILE(); }}]])
test_eq([[compile_string("#define A(X) (X)\nint x() { return A \n\t(1); }")()->x()]],1)

test_any([[class G { mapping t=([]);
 class tO { void init(string name) { t[name]=this; }}
 class W { inherit tO; protected void create() { init("foo"); }}
}; object x=G(); x->W(); return objectp(x->t->foo)]],1)

test_program([[class foo { program x() { return class {}; }}; class bar { inherit foo; program x() { return class {}; }} int a() { return foo()->x != bar()->x(); }]])

test_any([[
  class A {
    constant gurka = 2;
    int foo = gurka;
  };
  class B {
    protected inherit A;
    constant gurka = 1;
    int bar;

    protected void create() { bar = foo; }
  };
  return B()->bar;
]], 1)

test_any([[
  class A {
    constant gurka = 2;
    int foo = gurka;
  };
  class B {
    protected inherit A;
    constant gurka = 1;
    int bar;
    int baz = 3;

    protected void create() { bar = baz + foo; }
  };
  return B()->bar;
]], 4)

test_any([[
  class A {
    constant gurka = 1;
    int foo = gurka;
  };
  class B {
    constant banan = 2;
    int foo = banan;
  };
  class C {
    protected inherit A;
    protected inherit B;
    constant gurka = 3;
    constant banan = 4;
    int bar;
    int baz = 5;

    protected void create() { bar = baz + A::foo + B::foo; }
  };
  return C()->bar;
]], 12)

test_any([[
  class A { int a = 1; };
  class B { int b = 2; };
  class C {
    inherit A;
    inherit B;
    int c = 4;
  };
  class D {
    inherit C;
  };
  object d = D();
  return d->a + d->b + d->c;
]], 7)

test_compile_error_any([[
  class AScope
  {
     int gurka;
     class A
     {
  	int func() { return gurka; }
     }
  }

  class CScope
  {
     string hohum;
     class C
     {
  	inherit AScope.A;
     }
  }

]])

test_program([[
class A
{
  constant x = 1.0;
}

class B
{
  inherit A;
  class C
  {
    constant y = x+2.0;
  }
}

mixed a()
{
  return 3.0 == B()->C()->y;
}
]])

test_program_eq([[
  constant x = X;
  class X {constant c = "right";}

  constant y = Y;
  class Y {constant c = "wrong";}

  string a()
  {
    return ::`[]("x")->c;
  }
]], "right")

test_program_eq([[
  class A {
    string x = "x";
    class B {
      string f() {return x;}
    }
  }
  class C {
    inherit A;
    constant D = A::B;
  }
  string a() {
    return C()->D()->f();
  }
]], "x")

test_program_eq([[
  class A {
    string x = "x";
    class B {
      string f() {return x;}
    }
  }
  class C {
    inherit A;
    string x = "y";
    constant D = A::B;
  }
  string a() {
    return C()->D()->f();
  }
]], "y")

test_program_eq([[
  class A {
    local string x = "x";
    class B {
      string f() {return x;}
    }
  }
  class C {
    inherit A;
    string x = "y";
    constant D = A::B;
  }
  string a() {
    return C()->D()->f();
  }
]], "x")

test_program_eq([[
  class A {
    local string x = "x";
    class B {
      void set (string new) {x = new;}
      string f() {return x;}
    }
  }
  class C {
    inherit A;
    string x = "y";
    constant D = A::B;
  }
  string a() {
    C c = C();
    C.D d = c->D();
    d->set ("bar");
    c->x = "foo";
    return d->f();
  }
]], "bar")


dnl Come back when we decide that this should be possible
dnl test_do([[
dnl  class A {
dnl    constant i = 5;
dnl  };
dnl  class B {
dnl    inherit A;
dnl    int i = 17;
dnl  };
dnl  B();
dnl ]])


test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(D,A);
]],1)

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(A,D);
]],0)

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(A,C);
]],0)

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherits(C,A);
]],1)

test_any_equal([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherit_list(D);
]],[[ ({ C }) ]] )

test_any_equal([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit A; inherit B; inherit C; };
 return Program.inherit_list(D);
]],[[ ({ A,B,C }) ]])

test_any_equal([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return Program.inherit_tree(D);
]],[[  ({D, ({C, ({B, ({A})})})}) ]])

test_any([[
 class A {};
 class B { inherit A; };
 class C { inherit B; };
 class D { inherit C; };
 return sizeof( Program.all_inherits(D) - ({A,B,C}) );
]],0)

test_any_equal([[
  class A {
    class C {}
  };
  class B {
    class C {}
  };
  return ({A <= B, A >= B});
]], ({1, 1}))

test_tests([[

int errors;
int tests;

int maxdepth;

class Codec {
  string nameof(mixed x)
  {
    return ([ trace:"efun:trace", write:"efun:write", `+:"efun:`+" ])[x];
  }

  function functionof(string x)
  {
    return ([ "efun:trace":trace, "efun:write":write, "efun:`+":`+ ])[x] ||
      0;
  }

  mixed encode_object (object o) {}
  void decode_object (object o, mixed d) {}
}

void low_generate(int depth,
		  array(string) code,
		  string acc,
		  string ans,
		  int cnt)
{
  mixed tmp;
  if(--depth<0)
  {
    string res="None";
    tests++;

    if(!(tests & 63))
    {
      __signal_watchdog();
      log_status("Testing vtables and scope access: %d:%d",maxdepth,tests);
    }

    string test=code*"\n"+"\n"
      "mixed Q() { return "+acc+"();}\n"
      "int main() { trace(9); write(\"%O\\n\","+acc+"()); }\n"
      ;

    mixed tmp, x;
    mixed err=catch {
      tmp=compile_string(test)();
      res=tmp->Q();
      if(res != ans)
	throw("Test failed");
      res = "None";
      tmp = decode_value(encode_value(tmp, Codec()), Codec());
      res=tmp->Q();
      if(res != ans)
	throw("Test failed for encode/decode.");
      x=Program.inherit_list(object_program(tmp));
    };
    if(err)
    {
      errors++;
      log_msg("Test failed:\n"
	      "----------------------------------\n"
	      "%s\n"
	      "---------------------------------\n"
	      "expected answer: %O\n"
	      "Answer received: %O\n",test,ans,res);
      if(!stringp(err) || !has_prefix(err, "Test failed"))
      {
	string tmp=master()->describe_backtrace(err);
	array s=tmp/"\n";
	s=s[..20];
	log_msg("%s\n",s*"\n");
      }
      if (res == "None") {
        // Probable decode error; try to get some debug.
	catch {
	  log_msg("Encoding...\n");
	  string encoded = ((function)encode_value)(tmp, Codec(), 6);
	  log_msg("Decoding...\n");
          tmp = ((function)decode_value)(encoded, Codec(), 6);
	  log_msg("Strange... No error thrown...\n");
        };
      }
      return;
    }
  }else{
    low_generate(depth,
		 code+
		 ({sprintf("string F%d(){ return %s()+\"F%d\"; }",cnt,acc,cnt)}),
		 sprintf("F%d",cnt),
		 sprintf("%sF%d",ans,cnt),
		 cnt+1);

    for(int e=0;e<sizeof(code);e++)
    {
      low_generate(depth,
		   code[..e-1]+({
		     sprintf("class C%d {\n%s\n};",cnt,code[e..]*"\n")
		       }),
		   sprintf("C%d()->%s",cnt,acc),
		   ans,cnt+1);
    }


    if(sscanf(acc,"%s()->%s",string classname,string rest))
    {
      low_generate(depth,
		   code+({sprintf("inherit %s;",classname) }),
		   rest,
		   ans,
		   cnt);
    }
  }
}

array(int) a()
{
  int total_tests;
  for(maxdepth=1;maxdepth<9 && !errors;maxdepth++)
  {
    low_generate(maxdepth,
		 ({ "string X(){return \"X\";}" }),
		 "X",
		 "X",0);

    total_tests+=tests;
    tests=0;
  }

  return ({ total_tests-errors, errors });
}

]])




test_true([[Program.implements( class { int x; string y = ""; void foo(int x) {} },
	class { void foo(mixed z) {} int x; })]])
test_false([[Program.implements( class { int x; string y = ""; void foo(int x) {} },
	class { void foo(mixed z) {} string x = ""; })]])

test_eq([[object_program(master())]],[[(program)"/master"]])
test_compile([[object("master") m = master();]])
test_any([[if(int x=1,y=2) return x;]],1)
test_any([[int x; x++; if(x) return x; return -1;]],1)
test_any([[int x; if(x) return x; return -1;]],-1)
test_any([[int x,y; if(x==y || x==1) return 2; return 0;]],2);
test_any([[int x,y; if(x==y && x==0) return 2; return 0;]],2);
test_any([[int x,y=1; if(x==y || x==1) return 2; return 0;]],0);
test_any([[int x,y=1; if(x==y && x==0) return 2; return 0;]],0);
test_any([[int x = 1; x = x + (x = 0, 1); return x;]], 2);


test_any([[
return class { int i=17; }()["i"]
]],17)

test_any([[
return class { int i=17; protected mixed `[](string foo) { return i; }}()[""]
]],17)

test_any([[
return class { int i=17; protected mixed `[](string foo) { return ::`[]("i"); }}()[""]
]],17)

test_any([[
return class { int i=17; protected mixed `[](string foo) { return ::`[]; }}()[""]("i")
]],17)

test_any([[
return class { int i=17; protected mixed `[](string foo) { return ::`[]; }}()[""]("y")
]],0)

test_any([[
object o=class {
  int i=17;
  protected mixed `[](string foo) { return ::`[]=; }
  protected mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
object o=class {
  int foo=7;
  int bar=11;
  int i=17;
  int gazonk=12;
  protected mixed `[](string foo) { return ::`[]=; }
  protected mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
class Fonk {
  int foo=1;
  int bar=2;
  int i=17;
  int gazonk=3;
};

object o=class
{
  inherit Fonk;
  protected mixed `[](string foo) { return ::`[]=; }
  protected mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
class Fonk {
  int foo=1;
  int bar=2;
  int i=17;
  int gazonk=3;
};

object o=class
{
  inherit Fonk : zonk;
  protected mixed `[](string foo) { return zonk::`[]=; }
  protected mixed `[]=(string ind, mixed foo) {}
}();

o[""]("i",99);
return o->i;
]],99)

test_any([[
  class A {int foo() {return bar();} int bar();};
  class B {int bar() {return 1;}};
  class C {inherit A; inherit B; int bar() {return B::bar();}};
  return C()->foo();
]], 1)

test_compile_any([[
  class X { void hej() {} }
  class Y { inherit X:banan; void hopp() { banan::hej(); } }
]])


test_compile_any([[
  class X { protected void hej() {} }
  class Y { inherit X:banan; void hopp() { ::hej(); } }
]])

test_compile_any([[
  class X { protected void hej() {} }
  class Y { inherit X; void hopp() { X::hej(); } }
]])

test_compile_any([[
  class X { protected void hej() {} }
  class Y { public inherit X:banan; void hopp() { banan::hej(); } }
]])

test_compile_any([[
  class X { protected void hej() {} }
  class Y { inherit X:banan; void hopp() { banan::hej(); } }
]])

// Testing hidden identifier lookup with ::

test_program([[
  class X {
    int i = 17;
    class Y {
      constant i = 18;
      mixed f (int i) {return ({i, Y::i, X::i});}
    }
  }
  int a() {return equal (X()->Y()->f (19), ({19, 18, 17}));}
]])


test_compile_error_any([[
  class X {
    constant i = 18;
    mixed f() {return Y::i;}
  }
]])

test_program([[
  class A {
    int i = 17;
  }
  class X {
    inherit A: Y;
    class Y {
      constant i = 18;
      mixed f() {return Y::i;}
    }
  }
  int a() {return X()->Y()->f() == 18;}
]])

ignore_warning("Attempt to override a non local variable s with a non-variable.",[[
test_program([[
  class A {
    string s = "A";
  }
  class B {
    constant s = "B";
  }
  class X {
    constant s = "X";
    inherit A;
    class Y {
      inherit B: A;
      constant s = "Y";
      mixed f() {return X::s + X::A::s + Y::s + Y::A::s + A::s;}
    }
  }

  int a() {
    return X()->Y()->f() == "XAYBB";
  }
]])
]])

test_program([[
  class A {
    string s = "A";
  }
  inherit A;
  class X {
    constant s = "X";
    mixed f (string s) {return s + X::s + A::s;}
  }
  int a() {return X()->f("L") == "LXA";}
]])

test_program([[
  class A {
    string f() {return "A";}
    string g() {return A::f();}
  }
  class B {
    inherit A;
    string f() {return "B";}
  }
  int a() {return B()->g() == "B";}
]])

test_program([[
  class A {
    string g() {return A::f();}
    string f() {return "A";}
  }
  class B {
    inherit A;
    string f() {return "B";}
  }
  int a() {return B()->g() == "B";}
]])

test_program([[
  class A {
    string f() {return "A";}
    string g() {return A::f();}
  }
  class B {
    string f() {return "B";}
    inherit A;
  }
  int a() {return B()->g() == "B";}
]])

test_program([[
  class A {
    string f() {return "A";}
    class I {
      string g() {return A::f();}
    }
  }
  class B {
    inherit A;
    string f() {return "B";}
  }
  int a() {return B()->I()->g() == "B";}
]])

// Testing 'global::'

test_equal([[
  compile_string (#"
    string p = \"g\";
    mixed f (string p) {return ({global::p, p});}")()->f ("l");
]], ({"g", "l"}))

test_compile_error([[
  string pp = "g";
  mixed f (string p) {return global::p;}
]])

test_equal([[
  compile_string (#"
    int x = 23;
    class A {
      constant x = 24;
    }
    inherit A;
    class X {
      int x = 32;
      mixed f (int x) {return ({global::x, global::A::x, X::x, x});}
    }")()->X()->f (33);
]], ({23, 24, 32, 33}))

// Testing 'global.'

test_compile([[
  mixed a() {return global.Parser.HTML;}; a;
]], 0);

test_any([[
  if (!programp (Parser.HTML)) error ("This test uses the existence of Parser.HTML.\n");
  return compile_string (#"
    class Parser {constant HTML = 1;}
    mixed foo() {return programp (Parser.HTML);}")()->foo();
]], 0);

test_any([[
  if (!programp (Parser.HTML)) error ("This test uses the existence of Parser.HTML.\n");
  return compile_string (#"
    mixed foo() {return programp (Parser.HTML);}
    class Parser {constant HTML = 1;}")()->foo();
]], 0);

test_any([[
  if (!programp (Parser.HTML)) error ("This test uses the existence of Parser.HTML.\n");
  return compile_string (#"
    class Parser {constant HTML = 1;}
    mixed foo() {return programp (global.Parser.HTML);}")()->foo();
]], 1);

test_any([[
  if (!programp (Parser.HTML)) error ("This test uses the existence of Parser.HTML.\n");
  return compile_string (#"
    mixed foo() {return programp (global.Parser.HTML);}
    class Parser {constant HTML = 1;}")()->foo();
]], 1);

// testing virtual overloading
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],2)

// testing 'local'
test_any([[
class fnord
{
  local int ber() { return 1; }
  int goo() { return ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],1)

// testing 'local::'
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return local::ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],1)
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return local::ber()+ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],3)
test_any([[
class fnord
{
  int ber() { return 1; }
  int goo() { return ber()+local::ber(); }
};

class blorg
{
  inherit fnord;
  int ber() { return 2; }
};
return blorg()->goo();
]],3)

test_compile_error_any([[class X {int x; int f() {return local::x;}}]])

// Testing the 'inline' keyword
test_program([[class foo { inline int c() { return time(); } int d() { return c(); } }; class bar { inherit foo; int c() { return 0; } } int a() { return bar()->d(); }]],0)

test_compile_any([[
  class top
  {
     class the_class
     {
     }
  }

  class inherit_top
  {
     inherit top:top;

     constant top_the_class=top::the_class;

     class the_other_class
     {
        inherit top_the_class;
     }
  }
]])

// Identity of nested programs.
test_program([[
  class A {int i; class X {int j;};}
  class B {inherit A;}
  int a() {return A()->X == B()->X;}
]])
test_program([[
  class A {int i; class X {int j;};}
  class B {inherit A;}
  int a() {return A.X == B.X;}
]])
test_program([[
  class A {int i; class X {int j = i;};}
  class B {inherit A;}
  int a() {return A()->X != B()->X;}
]])
test_program([[
  class A {int i; class X {int j = i;};}
  class B {inherit A;}
  int a() {return A.X == B.X;}
]])

// Testing __INIT
test_any([[
  class X { int x = 1; int zz = 1; int zzz=8; int xx=16; };
  class Y { int y = 2; int xx; };
  class Z { inherit X; inherit Y; int z = 4; int zz = 0; int zzz; };
  object zz = Z();
  return zz->x + zz->y + zz->z + zz->zz + zz->zzz + zz->xx;
]], 15)

test_any([[
  // Test __INIT with forward references to programs needing their parents.
  class X {
    program y = Y;
    local class Y {
      program z = y;
    };
  };
  object x = X();
  return x->y == x->Y;
]], 1)

// Testing getter/setters
test_any([[
  // Trivial case.
  class X {
    int `->x() { return 5; }
  };
  return X()->x;
]], 5)

test_any([[
  // Strange behaviour getter & setter.
  class X {
    int y = 2;
    int `->x() { return y*3; }
    void `->x=(int z) { y += z*5; }
  };
  X x = X();
  x->x = 2;
  return x->x;
]], 36)

test_any([[
  // Multiple inheritance.
  class X {
    int y = 0;
    int `->x() { return y; }
    void `->x=(int z) { y = z; }
  };
  class Y {
    inherit X:x1;
    inherit X:x2;
    int `->x1() { return x1::x; }
    void `->x1=(int z) { x1::x = z; }
    int `->x2() { return x2::x; }
    void `->x2=(int z) { x2::x = z; }
  };
  Y y = Y();
  y->x1 = 1;
  y->x2 = 2;
  return (y->x1 + y->x2) * y->x;
]], 6)

test_any([[
  // Triggered fatal error "Getter/setter variable outside program!".
  class X {
    protected int xx;
    int `->x() { return xx; }
    void `->x=(int xxx) { xx = xxx; }
    protected void create(int xxx) {
      x = xxx;
    }
  };
  class Y {
    inherit X;
    protected void create(int yyy) {
      X::x = yyy + 2;
    }
  };
  return Y(5)->x;
]], 7)

dnl Issue #10154
test_any([[
  // Triggered infinite recursion.
  class A {
    string `prop() { return "A"; }
  }

  class B {
    inherit A;
    string `prop() { return ::prop + "B"; }
  }

  return B()->prop;
]], "AB")

dnl Issue #10154 fall-out
test_any([[
  // Overloading failed.
  class A {
    string `prop() { return "bad"; }
    string get_prop() { return prop; }
  }

  class B {
    inherit A;
    string `prop() { return "good"; }
  }

  return B()->get_prop();
]], "good")

test_any([[
  // Since the addition of F_APPEND_MAPPING in set_bar below
  // the setter is not being called anymore. Instead, the mapping
  // _data->foo is modified in place.
  class A(mapping _data) {
    mapping _modified = ([]);

    mixed `foo=(mixed v) {
      return _modified["foo"] = v;
    }

    mixed `foo() {
      return _data["foo"];
    }

    void set_bar(int v) {
      this->foo += ([ "bar" : v ]);
    }
  };

  object a = A(([ "foo" : ([]) ]));

  a->set_bar(2);

  return has_index(a->_modified, "foo");
]], 1)

test_any([[
  // Since the addition of F_APPEND_MAPPING in set_bar below
  // the setter is not being called anymore. Instead, the mapping
  // _data->foo is modified in place.
  class A(mapping foo) {
    mapping _modified = ([]);

    protected mixed `->=(string sym, mixed v) {
      return _modified[sym] = v;
    }

    void set_bar(int v) {
      this->foo += ([ "bar" : v ]);
    }
  };

  object a = A(([ "foo" : ([]) ]));

  a->set_bar(2);

  return has_index(a->_modified, "foo");
]], 1)

test_any([[
  // Since the addition of F_APPEND_ARRAY the setter is not being
  // called anymore. Instead, the array _data is modified in place.
  class A(array _data) {
    int counter;

    void `foo=(mixed v) {
      counter += !!v;
      _data = v;
    }

    mixed `foo() {
      return _data;
    }
  };

  object a = A(({}));

  for (int i = 0; i < 6; i++) {
    a->foo += ({ i });
  }

  return a->counter;
]], 6)

test_any([[
  // Since the addition of F_APPEND_ARRAY the setter is not being
  // called anymore. Instead, the array _data is modified in place.
  class A(array foo) {
    int counter;

    protected void `->=(string sym, mixed v) {
      counter += !!v;
      ::`->=(sym, v);
    }
  };

  object a = A(({}));

  for (int i = 0; i < 6; i++) {
    a->foo += ({ i });
  }

  return a->counter;
]], 6)

test_any([[
  // Triggered fatal since object_equal_p did not handle
  // getter/setter identifier correctly
  class A {
    string `foo() { return "bar"; }
  };

  return equal(A(), A());
]], 1)

test_eval_error([[
  // Triggered infinite recursion and core dump.
  // cf LysLysKOM 18719518/Pike mailinglist 12047.
  object o = class{}();
  o->foo += "";
]])

test_compile_error([[
  class X {
    int x;
    int `->x() { return 0; }
  };
]])

test_compile_error([[
  class X {
    int `->x() { return 0; }
    int x;
  };
]])

test_compile_error([[
  class X {
    int x;
    void `->x=(int z) { }
  };
]])

test_compile_error([[
  class X {
    void `->x=(int z) { }
    int x;
  };
]])

test_compile_error([[
  class X {
    void `->x(int z) { }
  };
]])

// Disabled for now.
cond([[ 0 ]], [[
  test_compile_error([[
    class X {
      int `->x=() { }
    };
  ]])
]])

test_compile_warning([[
  class X {
    protected int `->x() { return 0; }
    private void `->x=(int x) { }
  };
]])

test_compile_warning([[
  class X {
    protected int `->x() { return 0; }
    void `->x=(int x) { }
  };
]])

test_compile_warning([[
  class Test {
    private string `private_getter() {
      return "private";
    }
  };
]]);

test_any([[
  // Bug #10136.
  class Test {
    private string `private_getter() {
      return "private";
    }

    string get() {
      return private_getter;
    }
  }

  return Test()->get();
]], "private");

test_do([[
  // bug 3006
  class X {
    constant foo = Foo;
    class Foo {}
    void bar()
    {
      foo f = Foo();
    }
  };
]])

test_program([[
  // Another variant of [bug 3006].
  class X {
    constant foo = Foo;
    class Foo {}
  }
  int a() {return programp (X.foo);}
]])

cond(0,[[
  test_program([[
    // This shows a case when on-demand resolving is required.
    class X {
      constant foo = a + 1;
      constant a = b + 1;
      constant b = c + 1;
      constant c = d + 1;
      constant d = 1;
    };
    int a() {return X.foo == 5;}
  ]])
  test_program([[
    // Reference case for the test above.
    class X {
      constant d = 1;
      constant c = d + 1;
      constant b = c + 1;
      constant a = b + 1;
      constant foo = a + 1;
    };
    int a() {return X.foo == 5;}
  ]])
]])

test_any([[
class X {
 protected string f() { return "p"; }
 protected class gazonk { protected void create() { f(); }};
 protected class g { object e() { return gazonk(); }};
 protected void create() { g()->e(); }}; return objectp(X()); ]],1)
test_any([[class A { int x=1; }; class B { protected inherit A; int foo() { return A::x; }}; return A()->x && !B()->x && B()->foo()==A()->x;]],1)
test_any([[class C { int q() { return p(); } int p() { return 17; }}; return C()->q();]],17)
test_any([[class C1 {
 class D { string id() { return "foo"; } };
 class Y { program YinD() { return D; }} };
 class C2 { inherit C1; class D { string id() { return "bar"; } } };
 return C2()->Y()->YinD()()->id()]],"bar")
test_any([[object o=class {int c;class bar{protected void create(){c++;};}}(); o->bar(); return o->c;]],1)
test_do([[add_constant("GURKA2",class { int c; class bar{protected void create() {c+=17;}}}()); ]])
test_any([[class { inherit GURKA2.bar; }(); return GURKA2->c;]],17)
test_any([[class { inherit GURKA2.bar; }(); return GURKA2->c;]],34)

test_do([[add_constant("GURKA2",class { int c; class bar{protected void create() { class { protected void create() {c+=17;}}(); }}}()); ]])
test_any([[class { inherit GURKA2.bar; }(); return GURKA2->c;]],17)
test_any([[class { inherit GURKA2.bar; }(); return GURKA2->c;]],34)
test_do([[add_constant("GURKA2");]]);

test_eq(class { protected int foo=17; }()->foo,0)
test_eval_error(class c { protected int foo=17; }()->foo=18;)
test_equal( [[ ({ (["foo":"bar"]), (<"foo">), ([]) })->foo ]], [[ ({"bar",1,0}) ]])
test_any([[mixed a=({([]),0}); a[1]=a; return a->foo[0];]],0)
test_eval_error([[return column(({0}),"foo");]])

test_equal([[ ((mixed)({ }))->foo ]], ({ }))
test_compile_error([[ ({})->foo; ]])
test_equal([[ `->(({ }), "foo") ]], ({ }))
test_equal([[ ((mixed)({ }))["foo"] ]], ({ }))
test_compile_error([[ ({})["foo"]; ]])

test_any([[
class A { constant a=0; int foo() { return a; } };
class B { inherit A; constant a=1; };
return B()->foo(); ]], 1)

test_any([[
class p1 { int foo() { return 1; }};
class p2 { int foo() { return 3; }};
class c1 { inherit p1; inherit p2; int foo() { return p1::foo()+p2::foo(); }};
class c2 { inherit c1; }; return c2()->foo();]],4)

test_any([[
class p1 { int foo() { return 1; } };
class p2 { int foo() { return 2; } };
class c1 { inherit p1; inherit p2; };
return c1()->foo();]],2)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b += 1;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b ++;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b=b+1;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)

test_any([[
  mixed ret=({});
  int a, b = 3;
  for (a = 0; a < b; a++) {
     ret+=({a,b});
    if (a % 2) b-=-1;
  }
  return equal(ret,({0,3,1,3,2,4,3,4,4,5}));
]],1)


test_compile_error([[void foo() { 1++; }]])
dnl test_compile_error([[void foo() { return destruct(this); }]])
test_any([[class foo { constant x=17; }; class bar { inherit foo; constant x=18; }; return bar()->x;]],18)
test_program([[inline string foo(string s){ while(s[0] == ' ' || s[0] == '\t') s = s[1..]; return(s); } string a() { return foo("   bar"); }]])


// lambda function tests

test_true([[lambda(int x) { return lambda() { return x; };}]])
test_eq([[lambda(int x) { return lambda() { return x; };}(4)()]],4)
test_eq([[lambda(int x) { return lambda() { return x; };}(17)()]],17)
test_eq([[lambda(int x) { return lambda() { return lambda() { return x; };};}(17)()()]],17)

// trampoline tests
test_do([[{
    function trampoline =
      lambda() {
	int i = 17;
	return lambda () {
		 error ("Trampoline called.\n");
		 return i;
	       };
      }();

    // Now find the trampoline object. Pike tries very hard to hide
    // it, so we have to do it the hard way..
    object obj;
  find_trampoline_object: {
      for (obj = Debug.next_object();
	   objectp (obj) ||		// It's a normal object.
	   (intp (obj) && obj);		// It's a bignum object.
	   obj = Debug.next_object (obj))
	if (obj->`() == trampoline) break find_trampoline_object;
      error ("Trampoline object not found.\n");
    }

    if (!obj) error ("Trampoline object false.\n");
    if (!stringp (sprintf ("%O", obj)))
      // The important part is to try to call the _sprintf lfun in the
      // trampoline object, not to check what sprintf() returns.
      error ("Failed to describe trampoline object.\n");
  }]])

// local function tests
test_eq(120,
        [[ lambda()
           {
             int f(int i) { return i == 0 ? 1 : i*f(i-1); };
             return f(5);
           }(); ]])

test_eq([[function f;
	for(int i = 0; i < 2; i++)
	  { {int _i = i; f = lambda(int j) { return _i+j; }; } }
	return f(17);]],
	[[function f;
	for(int i = 0; i < 2; i++)
	  { {int _i = i; f = lambda(int j) { return _i+j; }; } int FEL; FEL; }
	return f(17);]]);

test_any([[
  int x,y,z;
  function p;
  void foo() { y+=7; };
  void bar()
  {
    foo();
    void gazonk()
    {
      foo();
      void quux()
      {
        foo();
        y+=4711;
      };
      p=quux;
    };

    gazonk();
    gazonk();
  };
  foo();
  bar();
  p();
  return y; x; z;
]], 7 * 5 + 4711 )

test_any([[
   int x=1;
   void for10(function f) { for(int e=0;e<10;e++) f(); };
   for10(lambda() { x++; });
   return x;
]], 11)

// implicit lambda tests
test_any([[
   int x=1;
   void for10(function f) { for(int e=0;e<10;e++) f(); };
   for10() { x++; };
   return x;
]], 11)

test_compile_error([[
   int x=1;
   void for10(function f) { for(int e=0;e<10;e++) f(); };
   for10() { x++; }
   return x;
]])

test_any([[
  int x;
  for(int i=5; i < 10; i++) x++;
  return x;
]], 5)

test_true([[lambda(function f) {return 1;}(this_program);]])
test_any([[
  function my_lambda;

  {
    string foo = "foo", bar = "bar";
    my_lambda = lambda() { return foo; };
  }

  int really_magic_var;
  return my_lambda(); really_magic_var;
]],"foo")

test_eq([[class { protected int `()(){ return 4711; } }()(); ]],4711)
teste_eval_error(mixed foo=({}); sort(@foo); )
test_compile_error([[int foo() { return 1} ; constant foo=(["foo":foo]); return foo->foo();]])
test_compile_error([[class T{void p(object e,object f){lambda::create(f);}}]])
test_eval_error(array foo=({}); return mkmapping(foo,({1})); )
test_compile_error([[mapping (string:array(string:string)) foo=([]); ]])
test_compile_error([[int a() { switch(random(2)) { case 3: if(random(2)) { case 0: return 1; } else { case 1: return 2; } } }]])

test_true(encode_value(0)[0]=='\266')
define(test_encode, [[ test_equal($1, decode_value(encode_value($1)))
		       test_equal($1, decode_value(encode_value_canonic($1))) ]])
test_eq(replace("foobar","","X"),"fXoXoXbXaXr")
test_encode(0)
test_encode("")
test_encode(0.0)
test_encode(1.0)
test_encode(-1.0)
test_encode(12.0)
test_encode(100000.0)
test_encode(3.1875)
test_encode(0.0000019073486328125)
test_encode(({}))
// This should work both with and without bignums.
test_encode(({0xffffffff+1, 0xffffffff+2}))
test_encode(([]))
test_encode("foobar")
test_encode((<>))
test_encode("\7")
test_encode("\77")
test_encode("\777")
test_encode("\7777")
test_encode("\77777")
test_encode("\777777")
test_encode("\7777777")
test_encode("\77777777")
test_encode(({"en","sv","de"}))
test_encode((<"en","sv","de">))
test_encode((["en":1,"sv":2,"de":3]))
test_encode(({"s",1,0,-3.40625}))
test_encode((<"s",1,0,-3.40625>))
test_encode((["s":1,1:2,0:3,-3.40625:4]))
test_encode((<1, 2, 2, 3, 3, 3>))
test_encode(({ 1<<20, "foo", "foo" }))
test_encode(({ 1<<40, "foo", "foo" }))
test_encode(({ 1<<70, "foo", "foo" }))
test_eq(decode_value("\210\201"),1)
test_eq(decode_value("\210\011\001"),-1)
test_eq(decode_value("\206\200"),""))
test_equal(decode_value("\200\200"),({}))
test_equal(decode_value("\206\206\146\157\157\142\141\162"),"foobar")
test_any([[mixed a=({0}); a[0]=a; return equal(a, decode_value(encode_value(a)));]], 1)
test_any([[ int e; for(e=0;e<100000;e+=1+(e>>4)) if(decode_value(encode_value(e))!=e) return e; return -1;]], -1)
test_any([[ int e; for(e=0;e<100000;e+=1+(e>>4)) if(decode_value(encode_value(-e))!=-e) return e; return -1;]], -1)

test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346de~\200\335\1\362PO\35\242")]])
test_eval_error([[return decode_value("\266ke0\241\346abcpf\221\337v\37\224")]])
test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346def`\266\212\340\337\b\252\b")]])
test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346def`\266\264\22\330\207")]])
test_eval_error([[return decode_value("\266ke0\241\262\266\216\213{@\333|")]])
test_eval_error([[return decode_value("\266ke0\241\346a\211[\266SN\313\331")]])
test_eval_error([[return decode_value("\266ke0\241\346ab-\266""6\227}u\320\274\251\211")]])
test_eval_error([[return decode_value("\266ke0\241\346abc\b&\346de\276\266\364\30\251s\233UF\362")]])
test_eval_error([[return decode_value("\266ke0\241\346abcv\22C\246\264\264L"          )]])
test_eval_error([[return decode_value("\266ke0\241\260\303\rl")]])

test_equal(encode_value_canonic ((["en":1,"sv":2,"de":3])),
           encode_value_canonic ((["en":1,"de":3,"sv":2])))
test_equal(encode_value_canonic ((["en":1,"sv":2,"de":3])),
           encode_value_canonic ((["de":3,"sv":2,"en":1])))
test_equal(encode_value_canonic ((["en":1,"sv":2,"de":3])),
           encode_value_canonic ((["sv":2,"en":1,"de":3])))
test_equal(encode_value_canonic ((<"en","sv","de">)),
           encode_value_canonic ((<"en","de","sv">)))
test_equal(encode_value_canonic ((<"en","sv","de">)),
           encode_value_canonic ((<"de","sv","en">)))
test_equal(encode_value_canonic ((<"en","sv","de">)),
           encode_value_canonic ((<"sv","en","de">)))


test_any([[
// bug 3013
class Test
{
    class Resolver (array c)
    {
      mixed resolv (string id, string path, object|void handler)
      {
	if (id == "c") return c;
      }
    }

    class Codec
    {
      mixed fooof (string name) {return all_constants()[name];}
      function objectof = fooof;
      function functionof = fooof;
      function programof = fooof;

      string nameof (mixed what)
      {
	if (string name = search (all_constants(), what)) return name;
	return UNDEFINED;
      }

      mixed encode_object (object o) {}
      void decode_object (object o, mixed d) {}
    }

    mixed main()
    {
      array c = ({"subres"});
      object o = compile (
	#"string res() {return `+(@((array(function(:string)))c)());}
	string subres() {return \"foo\";}",
	Resolver (c))();
      for (int i = 0; i < sizeof (c); i++)
	if (stringp (c[i])) c[i] = o[c[i] ];
#ifdef DEBUG
#define D ,1
#else
#define D
#endif
      function e=encode_value;
      function d=decode_value;
      return d (e (o, Codec() D), Codec() D)->res();
    }
};
  return Test()->main();
]],"foo")

test_any([[
// bug 3014
class Test
{
    class Codec
    {
      mixed nameof (mixed what)
      {
	return UNDEFINED;
      }
      mixed encode_object (object o) {}
      void decode_object (object o, mixed d) {}
    }

    int main()
    {
      object o = compile_string (#"
	constant x = ({0});
	int f() {return 17;}
	int g() {return ((array(function(:int)))x)[0]();}
      ")();
      o->x[0] = o->f;
      function e=encode_value;
      function d=decode_value;
      o = d (e (o, Codec()), Codec());
      return function_object (o->x[0]) == o;
    }
};
  return Test()->main();
]],1);


test_any([[mixed s="foo"; return s++;]],"foo")
test_any([[mixed s="foo"; s++; return s;]],"foo1")
test_any([[mixed s="foo"; return ++s;]],"foo1")
test_any([[float p=2.0; return p--;]],2.0);
test_any([[float p=2.0; p--; return p;]],1.0)
test_any([[float p=2.0; return --p;]],1.0)
test_any([[mapping m=([0:2]); m[0]++; return m[0]++;]], 3);
test_any([[mapping m=([0:2]); ++m[0]; return ++m[0];]], 4);
test_any([[mapping m=([0:2]); m[0]--; return m[0]--;]], 1);
test_any([[mapping m=([0:2]); --m[0]; return --m[0];]], 0);

test_any_equal([[
  // Test that the type fields are cleared when the mapping is cleared.
  mapping m = (["a":"a"]);
  m_delete(m, "a");
  return m;
]], ([]))

test_compile_error(int foo() { LJjjjjJJJ ; })
test_true(class { constant i=1; }()->i)
test_true(class { constant i=0; protected mixed `->(string s) { if(s=="i") return 1; }}()->i)
test_true(class { constant i=1; protected mixed `->(string s) { return 0; }}()["i"])
test_true(class { constant i=0; protected mixed `[](string s) { if(s=="i") return 1; }}()["i"])
test_true(class { optional constant i=0; protected mixed `[](string s) { if(s=="i") return 1; }}()["i"])
test_true(class { protected mixed `[]=(mixed a, mixed b) { if(a!=b) throw(1); }}()[1]=1)
test_true(class { protected mixed `->=(mixed a, mixed b) { if(a!=b) throw(1); }}()->i="i")

test_do([[
#pragma strict_types
class A { int a; optional int x; };
class B { int a; };
A a = B();
return a;
]])

test_compile_error_any([[
#pragma strict_types
class A { int a; optional int x; };
class B { int b; };
A a = B();
return a;
]])

test_eq((["static":42])->static,42)
test_eq((["protected":42])->protected,42)

test_compile_any(class A {}; class B { inherit A; })

test_any([[
  // Check that indexing of objects works as expected.
  object m = master();
  array(mixed) val = values(m);
  foreach(indices(m); int i; string ind) {
    if (m[ind] != val[i]) {
      error("Indexing error: master()[%O]:%O != %O.\n",
	    ind, m[ind], val[i]);
    }
  }
]], 0)

// Automap tests

test_equal([[ ({10,20})[*] + 30  ]], [[ ({40, 50}) ]])
test_equal([[ 30 + ({10,20})[*]  ]], [[ ({40, 50}) ]])
test_equal([[ ({1,2})[*] + ({10,20})[*]  ]], [[ ({11, 22}) ]])


test_equal([[ ({ ({10,20}), ({30,40}) })[*][*] + 5  ]],
           [[ ({ ({15,25}), ({35,45}) }) ]])

test_equal([[ 5 + ({ ({10,20}), ({30,40}) })[*][*] ]],
           [[ ({ ({15,25}), ({35,45}) }) ]])

test_any_equal([[
  array a=({ ({10,20}), ({30,40}) });
  a[*][*] += 5;
  return a;
]],
[[ ({ ({15,25}), ({35,45}) }) ]])

test_any_equal([[
  mixed a=({1,2,3});
  a[*] += -2;
  return a;
]], [[ ({-1,0,1}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  a[*] += -1;
  return a;
]], [[ ({0,1,2}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  a[*] += 0;
  return a;
]], [[ ({1,2,3}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  a[*] += 1;
  return a;
]], [[ ({2,3,4}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  a[*] += 2;
  return a;
]], [[ ({3,4,5}) ]])


test_any_equal([[
  mixed a=({1,2,3});
  return a[*] += -2;
]], [[ ({-1,0,1}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  return a[*] += -1;
]], [[ ({0,1,2}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  return a[*] += 0;
]], [[ ({1,2,3}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  return a[*] += 1;
]], [[ ({2,3,4}) ]])

test_any_equal([[
  mixed a=({1,2,3});
  return a[*] += 2;
]], [[ ({3,4,5}) ]])

test_equal([[ "foo"[ ({ 2,0,1,2 })[*] ]  ]],
           [[ ({ 'o', 'f', 'o', 'o' }) ]])

test_equal([[ ({ ({1}), ({2}), ({3}) })[*][0] ]],
           [[ ({ 1,2,3 }) ]])

test_equal([[ ({ ({1,2}), ({3,4}), ({5,6}) })[*][ ({0,1,1})[*] ] ]],
           [[ ({ 1,4,6 }) ]])

// map tests
test_eq(map("abc", `+, 1), "bcd")
test_equal(map((["a":1,"b":2]), `+, 1), (["a":2,"b":3]))
test_equal(map((<1,2,3>), `+, 1), (<2,3,4>))
test_equal(map(({ lambda(){ return 1; }, lambda(){ return 0; }})), ({ 1, 0 }))
test_any_equal(class A { constant a=1; constant b=2; }; return map(A, `+ ,1);, (["a":2,"b":3]))
test_any_equal(class A { protected mixed cast(string t) { if(t=="mapping") return (["a":1,"b":2]);}}; return map(A(), `+, 1);, (["a":2,"b":3]))
test_any_equal(class A { protected mixed cast(string t) { if(t=="array") return ({1,2,3});}}; return map(A(), `+, 1);, ({2,3,4}))
test_any_equal(class A { protected mixed cast(string t) { if(t=="multiset") return (<1,2,3>);}}; return map(A(), `+, 1);, (<2,3,4>))
test_any_equal(array a = ({({1,0,0}),({1,1,0}),({0,1,1})}); return map(a,`[],1);,
               ({0,1,1}))
test_any_equal(array a = ({({1,0,0}),({1,1,0}),({0,1,1})}); map(a,`[]=,1,0); return a;,
               ({({1,0,0}),({1,0,0}),({0,0,1})}))
test_any_equal(array a = ({(<1>),(<1,2>),(<2,3>),(<1,3>)}); return map(a,`[],1);,
               ({1,1,0,1}))
test_any_equal(array a = ({(<1>),(<1,2>),(<2,3>),(<1,3>)}); map(a,`[]=,1,0); return a;,
               ({(<>),(<2>),(<2,3>),(<3>)}))
test_any_equal(array a = ({(<"a">),(<"b">),(<>)}); map(a,`->=,"a",1); return a;,
               ({(<"a">),(<"a","b">),(<"a">)}))
test_any_equal(array a = ({([1:10]),([1:11,2:12]),([2:13])}); return map(a,`[],1);,
               ({10,11,0}))
test_any_equal(array a = ({([1:10]),([1:11,2:12]),([2:13])}); map(a,`[]=,1,1); return a;,
               ({([1:1]),([1:1,2:12]),([1:1,2:13])}))
test_any_equal(array a = ({(["a":10]),(["b":11]),([])}); map(a,`->=,"a",1); return a;,
               ({(["a":1]),(["a":1,"b":11]),(["a":1])}))
test_any_equal(array a = ({(["i":1]),([])}); return a["i"];,
	       ({1,0}))
test_any_equal(array a = ({(["i":1]),([])}); a["i"] = 7; return a;,
	       ({(["i":7]),(["i":7])}))
test_any([[
  class A {local int i = 10; int ii(){return i;}};
  class B {inherit A;};
  class C {inherit A; int i = 11;};
  array a = ({A(),B(),C()});
  map(a,`[]=,"i",7);
  return equal(a->i,({7,7,7})) && equal(a->ii(),({7,7,10}));
]],1)
test_any([[
  class A {local int i = 10; int ii(){return i;}};
  class B {inherit A;};
  class C {inherit A; int i = 11;};
  array a = ({A(),B(),C()});
  a->i = 7;
  return equal(a->i,({7,7,7})) && equal(a->ii(),({7,7,10}));
]],1)
test_any([[
  class A {local int i = 10; int ii(){return i;}};
  class B {inherit A;};
  class C {inherit A; int i = 11;};
  array a = ({A(),B(),C()});
  map(a,`->=,"i",7);
  return equal(a->i,({7,7,7})) && equal(a->ii(),({7,7,10}));
]],1)
test_any_equal([[
  array a = ({({(["a":"b"]),([]),(["c":17])}),({(["a":"b"]),(["a":7])}),(["b":"d"])});
  a->a = 1;
  return a;
]], ({({(["a":1]),(["a":1]),(["a":1,"c":17])}),
      ({(["a":1]),(["a":1])}),
      (["a":1,"b":"d"])}))
test_any_equal([[
  array a = ({({(["a":"b"]),([]),(["c":17])}),({(["a":"b"]),(["a":7])}),(["b":"d"])});
  map(a,`->=,"a",1);
  return a;
]], ({({(["a":1]),(["a":1]),(["a":1,"c":17])}),
      ({(["a":1]),(["a":1])}),
      (["a":1,"b":"d"])}))


test_any_equal([[
  /* This test tests a wild program pointer in the object o. The bug can trig
     a coredump in a later test. */
  class A {
    array a = ({1});
    protected void `->= (string var, mixed val) {::`->= (var, val);}
  };
  class B {
    inherit A;
    protected void `->= (string var, mixed val) {if (var) ::`->= (var, val);}
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))

test_any_equal([[
  class A {
    array a = ({1});
    protected void `->= (string var, mixed val) {::`->= (var, val);}
  };
  class B {
    inherit A;
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))

test_any_equal([[
  class A {
    array a = ({1});
//    protected void `->= (string var, mixed val) {::`->= (var, val);}
  };
  class B {
    int z;
    inherit A;
    protected void `->= (string var, mixed val) { A::`->= (var, val);}
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))

test_any_equal([[
  class FOO
  {
    int q,w,z;
  };
  class A {
    array a = ({1});
  };
  class B {
    inherit FOO;
    int b,c,d,e,f,g;
    inherit A;
    protected void `->= (string var, mixed val) { A::`->= (var, val);}
  };
  object o = B();
  o->a += ({2});
  return o->a;
]], ({1,2}))


test_any_equal([[
  class A {
    array a = ({1});
  };
  class B {
    int z;
    inherit A : FNORD;

    class Q
    {
	protected mixed `-> (string var)
	{
	  return FNORD::`-> (var);
	}
        protected void `->= (string var, mixed val)
	{
	  FNORD::`->= (var, val);
	}
    }
  };
  object o = B();
  object o2=o->Q();
  o2->a += ({2});
  return o->a;
]], ({1,2}))


dnl // Undefined behaviour, don't do this - Hubbe
dnl test_any_equal([[
dnl   class A {
dnl    array a = ({1});
dnl    void `->= (string var, mixed val) {::`->= (var, val); a += ({17});}
dnl  };
dnl  class B {
dnl    inherit A;
dnl  };
dnl  object o = B();
dnl  o->a += ({2});
dnl  return o->a;
dnl ]], ({1,2,17}))

cond(0,[[
dnl This test is not really right, since ::`->= is defined to look up
dnl statically. Still, a variant of ::`->= that does a low-level dynamic
dnl lookup instead would be really useful in cases like this.
test_any_equal([[
  class A {
    int f;
    void `->= (string var, mixed val) {::`->= (var, val); f = 17;}
  };
  class B {
    inherit A;
    array a = ({1});
  };
  object o = B();
  o->a += ({2});
  return o->a + ({o->f});
]], ({1,2,17}))
]])

test_true(mappingp(_memory_usage()))
test_any([[
  int ret = 1;
  foreach(_memory_usage(); string type; int value)
    if(value<0)
    {
      werror("_memory_usage()->%s has value %d which is <0\n",
             type, value);
      ret = 0;
    }
  return ret;
]],1)

test_any([[
  object q=class {}();
  object o=Debug.next(this);
  while(zero_type(o)) o=Debug.next(o);  /* skip destructed */
  catch { if(objectp(o) || object_program(o)) return 1;  };
  o=Debug.prev(this);
  while(zero_type(o)) o=Debug.prev(o); /* skip destructed */
  catch { if(objectp(o) || object_program(o)) return 1;  };
  return 0;
]],1)

test_any([[object(Stdio.File) o=Stdio.File(); return objectp(o);]],1)
test_any([[class Test {}; object(Test) o=Test(); return object_program(o);]],Test)
test_define_program(test,[[constant foo = 1; int a() { return foo; }]])
test_true(test()->a())
test_program(inherit test;)
test_program(inherit test; int a() { return foo; } )
test_define_program(test,[[class TEST { int a() { return 1; } }]])
test_program(inherit test; inherit TEST; )
test_do(add_constant("test");)

test_any([[
  /* don't save parent */
  class Foo {  };
  return  (!function_object(object_program(Foo()))) &&
	  (function_program(object_program(Foo())) ==
	   this_program);
]], 1)

test_any([[
  class Foo {  };
  return function_name(object_program(Foo()));
]], "Foo")

test_any([[
  int q;
  return stringp(function_name( lambda() { return q; }));
]],1)

test_any([[
  // Named lambda.
  int foo(){};
  return function_name(foo);
]], "foo")

test_any([[
  // Named trampoline.
  int q;
  int foo() { return q; };
  return function_name(foo);
]], "foo")

test_any([[
  int q;
  return function_object( lambda() { return q; });
]],[[this]])


test_compile([[
  class {
    class foobar {};
    object(Stdio.File) foo = foobar();
  }]])
test_compile(class { object(Stdio.File) foo=class {} ();})
test_compile_error(class { object(Stdio.File) foo = class {float is_file;} ();})
test_compile(class { object(Stdio.File) foo = class { int is_file;} ();})
test_do(class { object foo; object(Stdio.File) bar=foo; })
test_do(class { object foo; Stdio.File bar=foo; })
test_do(class { object(Stdio.File) foo; object bar=foo; })
test_do(class { Stdio.File foo; object bar=foo; })
test_any(if(int i=1) return i; return 0;,1)
test_compile(for(int i=0;i<100;i++) return 0;)
test_compile(foreach(({}),mixed i){i;})

dnl sscanf("", ...) triggers this warning.
ignore_warning("Indexing the empty string.", [[
test_compile(sscanf("","%O",mixed foo);foo;)
test_compile_error(sscanf("","",mixed foo);)
test_compile_error(sscanf("","%f",float))
test_compile_error(sscanf("",float))
]])

// ++
test_any([[int e; e++; return e;]],1)
test_any([[int e; ++e; return e;]],1)
test_any([[int e; return e++;]],0)
test_any([[int e; return ++e;]],1)
test_any([[int e; if(e++) return 0; return e;]],1)
test_any([[string e=""; e++; return e;]],"1")

// --
test_any([[int e; e--; return e;]],-1)
test_any([[int e; --e; return e;]],-1)
test_any([[int e; return e--;]],0)
test_any([[int e; return --e;]],-1)
test_any([[int e; if(e--) return 0; return e;]],-1)

test_compile_error_any(master()->add_precompiled_program(\"/test\",compile_string(\"int foo() { return 17; }\",\"62\")))

test_any([[function f=time; int t; foreach(allocate(1),t) f(t); return 1;]],1)
test_compile([[while(0)if(0)continue;else;]])
test_compile([[do { break; } while (0);]])
test_program([[int b=1,c; int a() { c=b+2; return c==3; }]])
test_true([[ ("foobar"/"o") & ({ "foo" }) ]])
test_any([[ array a="foo bar"/" "; return sizeof(a & ({"foo"}))]],1)

ifefun(_verify_internals,
[[
  test_do(_verify_internals())
]])

cond_begin([[all_constants()->thread_create]])

// thread_create
  test_do(thread_create(lambda() { }))

// /precompiled/mutex
  test_true(Thread.Mutex())
  test_do(add_constant("_tmp_mutex",Thread.Mutex()))
  test_true(_tmp_mutex->lock())
  test_true(_tmp_mutex->lock())
  test_true(_tmp_mutex->trylock())
  test_true(_tmp_mutex->trylock())
  test_do(add_constant("_tmp_mutex_lock",_tmp_mutex->lock()))
  test_true(catch(_tmp_mutex->trylock()))
  test_do(add_constant("_tmp_mutex_lock"))
  test_true(_tmp_mutex->trylock())
  test_do(add_constant("_tmp_mutex"))

  test_any([[
    object m = Thread.Mutex();
    object k = m->lock();
    thread_create(lambda(object k){
		    sleep(10);
		    catch { destruct(k); };
		  }, k);
    if (catch{
	  m->lock();
	  return 0;
	}) {
      return 1;
    }
    return 0;
  ]],1)

  test_any([[
    array data=({0,Thread.Mutex(),Thread.Mutex(),0});
    data[3]=data[2]->lock();
    thread_create(lambda(array data) {
		    object o=data[1]->lock();
		    destruct(data[3]);
		    sleep(10);
		    data[0]=1;
		    destruct(o);
		  },data);
    object l=data[2]->lock(1);
    object ll=data[1]->lock();
    return data[0];
  ]],1)

  test_any([[
    array data=({1, Thread.Mutex(), Thread.Condition(), 0});
    object key = data[1]->lock();

    for(int e=0;e<3;e++) {
      data[3]++;
      thread_create(lambda(array data) {
        for(int e=0;e<1000;e++) {
          object o=data[1]->lock();
          data[0]*=2;
          for(int d=0;d<5;d++) {
            data[0]--;
            data[0]*=2;
          }
          data[0]--;
          destruct(o);
        }
	object o = data[1]->lock();
        data[3]--;
        data[2]->signal();
      }, data);
    }

    while(data[3])
      data[2]->wait(key);
    return data[0];
  ]],1)
  test_any([[
    object lock = Thread.Mutex()->lock();
    gc();
    return objectp (lock);
  ]], 1)

// /precompiled/condition
  test_true(Thread.Condition())
  test_do(Thread.Condition()->signal())
  test_do(Thread.Condition()->broadcast())

  test_true(objectp(Thread.Fifo()))
  test_true(objectp(Thread.Queue()))

  // Check that Thread.Queue works on the basic level.
  test_any([[
    Thread.Queue q = Thread.Queue();
    int to_write = 100000;
    int to_read = 0;
    while (to_write + to_read) {
      if (!to_write || random(4 * to_read)) {
        int val = q->read();
        if (val != (to_write + to_read))
	  return val + " != " + (to_write + to_read);
        to_read--;
      } else {
        q->write(to_write--);
	to_read++;
      }
    }
    return 0;
  ]], 0)

  test_any([[
    object o=Thread.Queue();
    thread_create(lambda(object f) {
		    for(int e=0;e<10000;e++)
		      f->write(random(4711));
		    f->write(-1);
		  },o);
    int tmp=0;
    while(o->read() != -1)
      tmp++;
    return tmp;
  ]],10000)

  test_any([[
    object o=Thread.Fifo();
    thread_create(lambda(object f) {
		    for(int e=0;e<10000;e++)
		      f->write(random(4711));
		    f->write(-1);
		  },o);
    int tmp=0;
    while(o->read() != -1)
      tmp++;
    return tmp;
  ]],10000)

dnl this will crash pike on out-of-address-space-related errors
dnl  test_any([[ catch { allocate(10000,thread_create)(lambda() { sleep(1); })->wait(); } ]])

  test_any_equal([[
    // Check the compiler for too aggressive constant folding.
#pragma dynamic_dot
    int test_thread() {
      return Thread.this_thread()->id_number() ==
	     Thread.this_thread().id_number();
    }
    return ({ Thread.Thread, Thread.Thread })(test_thread)->wait();
  ]], ({ 1, 1 }))

cond_end // thread_create
cond(0, [[
  test_any([[
    // Test that a loop relinquishes the interpreter lock every now and then.
    //
    // This test is unfortunately disabled since it fails too often.
    // The subthread does really yield in the loop, but the main
    // thread, which really is waiting, fails to run. My conclusion is
    // that the problem is the unreliability of th_yield() - we need
    // to replace it with something else. :(
    // /mast
    int count, stop, fail;
    Thread.thread_create (lambda() {
                            int t_start = time();
                            // Note: We need sub-second precision.
			    float stop_time = 1.0 + time(t_start);
			    while (!stop) {
			      count++;
			      if (time(t_start) > stop_time) {
				fail = 1;
				break;
			      }
			    }
			  });
    sleep (0.1);
    stop = 1;
    sleep (0.1);
    return fail ? -1 : count > 0;
  ]], 1)
]])
cond_begin([[all_constants()->thread_create]])

  // _disable_threads
  test_any_deprecated([[ // FIXME: Uses deprecated function Process.system
#ifndef __NT__
// Using a named pipe here to make open() block. That doesn't exist on NT.

object t = class {
void log (function f, string msg)
{
#if 0
  if (f == test) msg = "[T] " + msg;
  else if (f == thread_disabler) msg = " " * 20 + "[D] " + msg;
  else if (f == mutex_locker) msg = " " * 40 + "[L] " + msg;
  log_msg (msg);
#endif
}

mixed err;

string fifo = "/tmp/testpipe." + getpid();

int started;
Thread.Mutex start_lock = Thread.Mutex();
Thread.Mutex locker_lock = Thread.Mutex();
Thread.Mutex locked_mutex = Thread.Mutex();
object(Thread.MutexKey)|zero locked_mutex_key;

void mutex_locker()
{
  log (mutex_locker, "locker started\n");
  started++;
  object(Thread.MutexKey)|zero k = start_lock->lock();
  k = 0;

  k = locker_lock->lock();
  k = 0;

  log (mutex_locker, "locker running\n");
  err = catch (k = locked_mutex->lock());
  log (mutex_locker, "locker done, error: " + (err && describe_error (err)) + "\n");
  k = 0;
}

void thread_disabler()
{
  log (thread_disabler, "disabler started\n");
  object(Thread.MutexKey)|zero locker_key = locker_lock->lock();

  started++;
  object(Thread.MutexKey)|zero k = start_lock->lock();
  k = 0;

  sleep (0.1);
  log (thread_disabler, "disabling\n");
  locker_key = 0;
  // Race: Don't want mutex_locker to get the lock on locker_lock
  // until we're in _disable_threads.
  object|zero disable = _disable_threads();
  log (thread_disabler, "disabled\n");
  sleep (0.1);
  disable = 0;
  log (thread_disabler, "disabler done\n");
}

void test()
{
  locked_mutex_key = locked_mutex->lock();
  started = 0;

  object(Thread.MutexKey)|zero start_key = start_lock->lock();
  object disabler = thread_create (thread_disabler);
  object locker = thread_create (mutex_locker);
  while (started < 2) sleep (0.1);

  Process.Process writer = Process.create_process(
    RUNPIKE_ARRAY + ({
      "-e",
      sprintf ("sleep(0.5); "
	       "Stdio.File f = Stdio.File(%O, \"w\"); "
	       "sleep(0.5); "
	       "f->close();", fifo)
    }));

  log (test, "opening pipe\n");
  start_key = 0;
  Stdio.File f = Stdio.File (fifo, "r");
  log (test, "pipe opened\n");
  locked_mutex_key = 0;

  f->close();
  disabler->wait();
  locker->wait();
  writer->wait();
  log (test, "test done\n");
}
}();

  rm (t->fifo);
  Process.system ("mkfifo " + t->fifo);
  for (int i = 0; i < 5; i++) {
    t->test();
    if (t->err) return 0;
    t->log (0, "------------\n");
  }
  rm (t->fifo);

#endif
  return 1;
]], 1);

  test_do([[
    object l = _disable_threads();
    Thread.thread_create (lambda () {});
    destruct (l);
  ]])

  test_any([[
    int run = 1;

    mapping(string:int) rounds = ([]);

    void imutex_locker (string id)
    {
      while (run) {
#ifdef __NT__
	// Windows got an imutex in create_process. It doesn't have to
	// be successful.
	catch (Process.create_process (({""})));
#else
	// Unix systems don't have an imutex in create_process, but
	// they got the standard password functions.
	getpwuid (0);
#endif
	rounds[id]++;
	//werror (id);
      }
    };

    void threads_disabler (string id)
    {
      while (run) {
	object|zero l = _disable_threads();
	rounds[id]++;
	//werror (id);
	l = 0;
      }
    };

    array(Thread.Thread) t = ({
      Thread.thread_create (imutex_locker, "0"),
      Thread.thread_create (imutex_locker, "1"),
      Thread.thread_create (imutex_locker, "2"),
      Thread.thread_create (threads_disabler, "a"),
      Thread.thread_create (threads_disabler, "b"),
    });
    sleep (5);
    run = 0;
    t->wait();
    //werror ("%O\n", rounds);

    return 1;
  ]], 1)

  test_any_deprecated([[ // FIXME: Uses deprecated function Process.system
    Stdio.write_file ("testsuite_test.pike", #"\
      int main()
      {
	Thread.Mutex m = Thread.Mutex();
	Thread.MutexKey l = m->lock();
	Thread.thread_create (lambda () {m->lock(); exit (0);});
	call_out (destruct, 0, l);
	return -1;
      }");
    return Process.system (RUNPIKE +" testsuite_test.pike");
  ]], 0)

  test_eval_error([[
    Thread.thread_create(lambda(){
	// NB: It's currently not possible to inhibit the
	//     backtrace (without messing with the master).
	error("Ignore the following line.\n");
    })->wait();
  ]])

cond_end // thread_create

cond([[0]],
[[
  test_any([[
  // test if read() hangs when fd is closed by other thread
       object f=Stdio.File();
       object g=f->pipe();
       object t=thread_create(
    	  lambda()
    	  {
    	     g->read(4);
    	  });
       sleep(0.1); // yield
       g->close(); // close same side of pipe as we have in read above
       sleep(0.1); // yield
       if (!t->status()) return 0; // should be done now
	  // if not, there's no way to kill that thread
       return 1;]],1);

]])


// m_delete
test_any_equal([[ mapping m=([1:1]); m_delete(m,0); return m; ]],[[ ([1:1]) ]])
test_any_equal([[ mapping m=([1:1,0:3]); m_delete(m,0); return m; ]],[[ ([1:1]) ]])
test_any([[mapping a=([1:1]); return m_delete(a,1)]],1)
test_any([[mapping m=([]); m[1]++; return m[1];]],1)
test_any([[mapping m=([1:1]); m[1]++; return m[1];]],2)
test_any([[mapping m=([1:1]); m[1]++; return m[1]++;]],2)
test_any([[mapping m=([]); m[1]++; m[1]++; return m[1];]],2)

// multiset tests

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[e]=1;
  for(e=0;e<1000;e++) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[e]++;
  for(e=0;e<1000;e++) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[e]=1;
  for(e=999;e>=0;e--) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=999;e>=0;e--) m[e]=1;
  for(e=0;e<1000;e++) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=999;e>=0;e--) m[e]=1;
  for(e=999;e>=0;e--) if(!m[e]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e++) if(!m[reverse(e)]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=999;e>=0;e--) m[reverse(e)]=1;
  for(e=0;e<1000;e++) if(!m[reverse(e)]) return e;
  return -1;
]],-1)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e++) m[reverse(e)]=0;
  return sizeof(m);
]],0)

test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e+=2) m[reverse(e)]=0;
  for(e=0;e<1000;e+=2) if(m[reverse(e)]) return e;
  for(e=1;e<1000;e+=2) if(!m[reverse(e)]) return e;
  return -1;
]],-1)


test_any([[multiset m=(<>);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=1;
  for(e=0;e<1000;e++) m[reverse(e)]++;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=1) return e;
  return -1;
]],-1)


test_any([[multiset m = (<>); int e; int f;
  for (e = 0; e < 100;e++) {
    for (f = e; f < 100; f++) {
      m_add(m, f);
    }
  }
  for (e = 0; e < 100; e++) {
    f = -1;
    while (m_delete(m, e)) f++;
    if (f != e) return e;
  }
  return -1;
]], -1)

test_any([[multiset m = (<>); int e; int f;
  for (e = 0; e < 100;e++) {
    for (f = e; f < 100; f++) {
      m_add(m, e);
    }
  }
  for (e = 0; e < 100; e++) {
    f = e;
    while (m_delete(m, e)) f++;
    if (f != 100) return e;
  }
  return -1;
]], -1)


test_any([[multiset m=(<>);int e;
  mixed a;
  a=allocate(1000);
  for(e=0;e<1000;e++)
  {
    m[reverse(e)]=1;
    a[e]=reverse(e);
  }
  add_constant("mtest_m",m);
  add_constant("mtest_i",a);
  return 1;
]],1)

test_any([[
  multiset m = set_weak_flag((<>), 1);
  m[1] = 1;
  return sizeof(m);
]], 1)

test_true([[
  multiset m = set_weak_flag((<>), 1);
  m[1] = 1;
  return get_weak_flag(m);
]])

test_eq([[sizeof(mtest_m)]],sizeof(mtest_i))
test_equal(Array.sort_array(indices(mtest_m)),Array.sort_array(mtest_i))
test_equal(mtest_m,copy_value(mtest_m))

test_any([[multiset m=(<>);int e;
  mixed a;
  a=allocate(100);
  for(e=0;e<100;e++)
  {
    m[reverse(e-50)]=1;
    a[e]=reverse(e-50);
    if(sizeof(m)!=e+1) return e;
  }
  add_constant("mtest_m2",m);
  add_constant("mtest_i2",a);
  return -1;
]],-1)

test_any_equal([[
  class X (float i)
  {
    protected int `< (X o) {return i < o->i;}
    protected int id = ++all_constants()->cnt;
    protected string _sprintf() {return "X(" + i + ")[" + id + "]";}
  };
  X x1 = X(1.0), x2 = X(1.0);
  multiset m = (<x1, X(2.0), X(3.0)>);
  m[x2] = 1;
  add_constant ("cnt");
  return ({m[x1], m[x2], m[X(0.5)]});
]], [[({1, 1, 0})]])

test_any_equal([[
  class X (float i)
  {
    protected int `< (X o) {return i < o->i;}
    protected int id = ++all_constants()->cnt;
    protected string _sprintf() {return "X(" + i + ")[" + id + "]";}
  };
  X x1 = X(1.0), x2 = X(1.0);
  multiset m = (<x1, X(2.0), X(3.0)>);
  m[x2] = 1;
  add_constant ("cnt");
  return ({(m[x1] = 1, sizeof (m)),
	   (m[x2] = 1, sizeof (m)),
	   (m[X(0.5)] = 1, sizeof (m))});
]], [[({4, 4, 5})]])

test_do(add_constant("cnt");)
test_eq([[sizeof(mtest_m2)]],sizeof(mtest_i2))

test_any([[
  // Test subtraction of multisets of objects.
  class X(int a)
  {
    protected int `<(mixed o) { return objectp(o) && (a < o->a); }
    protected int `==(mixed o) { return objectp(o) && (a == o->a); }
  };
  multiset m = (< @map(allocate(5), X) >);
  return sizeof(m - (<0>));
]], 5)

test_any([[int e;multiset q=(<>),p=(<>); for(e=0;e<1000;e++) { p[reverse(e)]=1; q+=(<reverse(e)>); if(!equal(sort(indices(p)),sort(indices(q)))) return 0; } return 1;]],1)

test_equal(sort(indices(mtest_m|mtest_m2)),sort(mtest_i|mtest_i2))
test_equal(sort(indices(mtest_m&mtest_m2)),sort(mtest_i&mtest_i2))
test_equal(sort(indices(mtest_m-mtest_m2)),sort(mtest_i-mtest_i2))
test_equal(sort(indices(mtest_m^mtest_m2)),sort(mtest_i^mtest_i2))
test_equal(sort(indices(mtest_m2|mtest_m)),sort(mtest_i2|mtest_i))
test_equal(sort(indices(mtest_m2&mtest_m)),sort(mtest_i2&mtest_i))
test_equal(sort(indices(mtest_m2-mtest_m)),sort(mtest_i2-mtest_i))
test_equal(sort(indices(mtest_m2^mtest_m)),sort(mtest_i2^mtest_i))

test_do(add_constant("mtest_m"); add_constant("mtest_i"); )
test_do(add_constant("mtest_m2"); add_constant("mtest_i2"); )

define([[MTEST]],[[test_equal([[mkmultiset(indices(allocate($1)))]],[[mkmultiset(reverse(indices(allocate($1))))]])]])

MTEST(0)
MTEST(1)
MTEST(2)
MTEST(3)
MTEST(5)
MTEST(8)
MTEST(13)
MTEST(21)
MTEST(34)
MTEST(55)

define([[MTEST]])

test_equal([[lambda(multiset x){return ({x[17]++,x[17]++,x[17]++});}((<>))]],
		[[({0,1,1})]])

test_any([[
  object o1 = class{}(), o2 = class{}(), o3 = class{}();
  multiset m = (<o1, o2, o3, 17>);
  destruct (o1), destruct (o2), destruct (o3);
  return m[17];
]], 1);

test_any_equal([[
  object o1 = class{}(), o2 = class{}(), o3 = class{}();
  multiset m = (<o1, o2, o3, 17>);
  destruct (o1), destruct (o2), destruct (o3);
  return copy_value (m);
]], (<17>));

test_do([[
  multiset a = copy_value ((<(<1,2,3>), ({5,4}), ([1:2]), 1, ({}), (<1,2>), "foo">));
  foreach (a; mixed i;)
    if (!a[i]) error ("Can't find multiset member in itself: %O\n", i);
]])

test_any_equal([[
  multiset m=(<"Stone","2","%70">);
  foreach(m;string k;)
  {
      if(k=="%70")
      {
	  m[k]=0;
	  break;
      }
  }
  return sort ((array) (m - (<>)));
]], ({"2", "Stone"}))

test_any([[
  class X (int i) {
    protected int `< (mixed o) {return 0;}
    protected int `== (mixed o) {return 0;}
  };
  multiset m = (<X(2)>);
  m[X(4)] = 1;
  m[X(1)] = 1;
  m[X(3)] = 1;
  return sizeof (m);
]], 4)

// mapping tests

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[e]=e;
  for(e=0;e<1000;e++) if(m[e]!=e) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[e]=e;
  for(e=999;e>=0;e--) if(m[e]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=999;e>=0;e--) m[e]=e;
  for(e=0;e<1000;e++) if(m[e]!=e) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  for(e=999;e>=0;e--) m[e]=e;
  for(e=999;e>=0;e--) if(m[e]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=999;e>=0;e--) m[reverse(e)]=e;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=e) return 0;
  return 1;
]],1)


test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e++) m_delete(m,reverse(e));
  return sizeof(m);
]],0)

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e+=2) m_delete(m,reverse(e));
  for(e=0;e<1000;e+=2) if(m[reverse(e)]) return 0;
  for(e=1;e<1000;e+=2) if(m[reverse(e)]!=e) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  for(e=0;e<1000;e++) m[reverse(e)]=e;
  for(e=0;e<1000;e++) m[reverse(e)]++;
  for(e=0;e<1000;e++) if(m[reverse(e)]!=e+1) return 0;
  return 1;
]],1)

test_any([[mapping m=([]);int e;
  mixed a,b;
  a=allocate(1000);
  b=allocate(1000);
  for(e=0;e<1000;e++)
  {
    m[reverse(e)]=e;
    a[e]=reverse(e);
    b[e]=e;
  }
  add_constant("mtest_m",m);
  add_constant("mtest_i",a);
  add_constant("mtest_v",b);
  return 1;
]],1)


test_eq([[sizeof(mtest_m)]],sizeof(mtest_i))
test_equal(Array.sort_array(indices(mtest_m)),Array.sort_array(mtest_i))
test_equal(Array.sort_array(values(mtest_m)),Array.sort_array(mtest_v))
test_equal(mtest_m,copy_value(mtest_m))
test_any([[int e; for(e=0;e<1000;e++) if(!equal(mtest_m[mtest_i[e] ],mtest_v[e])) return 0; return 1;]],1)


test_any([[mapping m=([]);int e;
  mixed a,b;
  a=allocate(100);
  b=allocate(100);
  for(e=0;e<100;e++)
  {
    m[reverse(e-50)]=e-50;
    a[e]=reverse(e-50);
    b[e]=e-50;
  }
  add_constant("mtest_m2",m);
  add_constant("mtest_i2",a);
  add_constant("mtest_v2",b);
  return 1;
]],1)

test_any([[int e;mapping q=([]),p=([]); for(e=0;e<1000;e++) { p[reverse(e)]=e; q+=([reverse(e):e]); if(!equal(sort(indices(p)),sort(indices(q)))) return 0; } return 1;]],1)
test_any([[mapping m=([]); m+=(["foo":"bar"]); m+=(["bar":"foo"]); m+=(["foo":"foo"]); if(sizeof(m)==3) return 1; return m["foo"]=="foo" && m["bar"]=="foo"]],1)

test_equal(sort(indices(mtest_m|mtest_m2)),sort(mtest_i|mtest_i2))
test_equal(sort(indices(mtest_m&mtest_m2)),sort(mtest_i&mtest_i2))
test_equal(sort(indices(mtest_m-mtest_m2)),sort(mtest_i-mtest_i2))
test_equal(sort(indices(mtest_m^mtest_m2)),sort(mtest_i^mtest_i2))
test_equal(sort(indices(mtest_m2|mtest_m)),sort(mtest_i2|mtest_i))
test_equal(sort(indices(mtest_m2&mtest_m)),sort(mtest_i2&mtest_i))
test_equal(sort(indices(mtest_m2-mtest_m)),sort(mtest_i2-mtest_i))
test_equal(sort(indices(mtest_m2^mtest_m)),sort(mtest_i2^mtest_i))

test_equal(sort(values(mtest_m|mtest_m2)),sort(map(mtest_i|mtest_i2,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m&mtest_m2)),sort(map(mtest_i&mtest_i2,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m-mtest_m2)),sort(map(mtest_i-mtest_i2,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m^mtest_m2)),sort(map(mtest_i^mtest_i2,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m2|mtest_m)),sort(map(mtest_i2|mtest_i,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m2&mtest_m)),sort(map(mtest_i2&mtest_i,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m2-mtest_m)),sort(map(mtest_i2-mtest_i,mtest_m|mtest_m2)))
test_equal(sort(values(mtest_m2^mtest_m)),sort(map(mtest_i2^mtest_i,mtest_m|mtest_m2)))

test_do(add_constant("mtest_m"); add_constant("mtest_i"); add_constant("mtest_v");)
test_do(add_constant("mtest_m2"); add_constant("mtest_i2"); add_constant("mtest_v2");)

define([[MTEST]],[[test_equal([[mkmapping(indices(allocate($1)),reverse(indices(allocate($1))))]],[[mkmapping(reverse(indices(allocate($1))),indices(allocate($1)))]])]])

MTEST(0)
MTEST(1)
MTEST(2)
MTEST(3)
MTEST(5)
MTEST(8)
MTEST(13)
MTEST(21)
MTEST(34)
MTEST(55)

define([[MTEST]])

test_do([[

class X {
mapping gurka;

class Tomat
{
  protected int `==(mixed x)
    {
      /* make hash bigger */
      for(int e=sizeof(gurka);e<1000;e++) gurka[e]=e;
      return 0;
    }

  protected int __hash()
    {
      return 99999;
    }
};

class Sallad
{
  protected int __hash()
    {
      return 99999;
    }
};

protected void create()
{
  for(int x=1;x<255;x++)
  {
    gurka=([]);
    for(int e=0;e<x;e++) gurka[~e]=e;
    gurka[Sallad()]=-2;
    gurka[Tomat()]=-3;
  }
}
}
  X();

]])

test_any([[
    mapping m = ([ "foo" : 1 ]);
    class A {
	protected int __hash() { return hash_value("foo"); }
	protected int `==(mixed o) { return o == "foo"; }
    };
    if( !m[A()] )
      return (string)hash_value("foo");
    return 0;
]], 0)

test_any([[
    mapping m = ([ "foo" : 1 ]);
    class A {
	protected int __hash() { return hash_value("foo"); }
	protected int `==(mixed o) { return o == "foo"; }
    };
    if( sizeof(m - ([ A() : 1 ])) )
      return (string)hash_value("foo");
    return 0;
]], 0)

test_equal([[ `+( ([1:2]) )]],[[ ([1:2]) ]])
test_false( `+( ([1:2]) ) == ([1:2]) )
test_equal([[ `+( ([1:2]), ([1:2])  )]],[[ ([1:2]) ]])
test_equal([[ `+( ([1:2]), ([1:2]), ([2:3,4:5])  )]],[[ ([1:2,2:3,4:5]) ]])
test_equal([[ `+( ([1:2]), ([1:2]), ([2:3,4:5]), ([6:7,1:2])  )]],[[ ([1:2,2:3,4:5,6:7]) ]])
test_equal([[ `+( ([1:2]), ([1:2]), ([2:3,4:5]), ([6:7,1:2]),([8:9])  )]],[[ ([1:2,2:3,4:5,6:7,8:9]) ]] )

test_any([[mapping m=([1:2,3:2]); return search(m,2,search(m,2))!=-1;]],1)

test_any([[mapping m=([]); for(int e=0;e<1000;e++) m[e&3]+=({e}); return sizeof(m)==4 && sizeof(m[0])==250;]],1)

test_any([[
  mapping m = set_weak_flag (([1:1]), 1);
  m_delete (m, 1);
  return get_weak_flag (([]));
]], 0);

test_equal([[lambda(mapping x){return ({x[17]++,x[17]++,x[17]++});}(([]))]],
		[[({0,1,2})]])

test_equal([[([1:2, 3:4]) - (<0, 1, 2>)]], ([3:4]))
test_equal([[([1:2, 3:4]) - ({0, 1, 2})]], ([3:4]))
test_equal([[([1:2, 3:4]) & (<0, 1, 2>)]], ([1:2]))
test_equal([[([1:2, 3:4]) & ({0, 1, 2})]], ([1:2]))

// destructed indices
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]);
  destruct (o);
  return equal (m, ([])) && equal (m, ([]));
}]], 1)
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]), n = ([class{}(): 1]);
  destruct (o);
  return !equal (m, n) && !equal (m, n);
}]], 1)
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]);
  destruct (o);
  return sizeof (indices (m)) || sizeof (m);
}]], 0)
test_any([[{
  object o = class{}();
  mapping m = ([o: 1]);
  destruct (o);
  return sizeof (values (m)) || sizeof (m);
}]], 0)

// gc

  test_true(intp(gc()));
  test_true(mappingp (((function) Debug.gc_status)()))
  test_any([[ array|zero a=({0}); a[0]=a; gc(); a=0; return gc() > 0; ]],1);
  test_any([[mapping|zero m=([]); m[m]=m; gc(); m=0; return gc() > 0; ]],1);
  test_any([[multiset|zero m=(<>); m[m]=1; gc(); m=0; return gc() > 0; ]],1);
  test_any([[{
#if !constant (_debug)
    int _debug (int d) {return 0;};
#endif
    // Must turn off debug in this test or else we'll get extra
    // references to p in the backlog.
    int dlevel = _debug (0);
    program|zero p=compile_string("constant a=({0});");
    object|zero o=p();
    o->a[0]=p;
    gc();
    p=o=0;
    _debug (dlevel);
    return gc() > 0;
  }]], 1);

test_any([[
  object|zero o = class {function f; void foo() {}}();
  o->f = o->foo;
  gc();
  o = 0;
  return gc();
]], 0)
test_any([[
  object|zero o = class {object o;}();
  o->o = o;
  gc();
  o = 0;
  return gc();
]], 0)
test_any([[
  class X {function f; void foo() {}};
  object|zero o1 = X(), o2 = X();
  o1->f = o2->foo;
  o2->f = o1->foo;
  gc();
  o1 = o2 = 0;
  return gc();
]], 2)
test_any([[
  class X {object o;};
  object|zero o1 = X(), o2 = X();
  o1->o = o2;
  o2->o = o1;
  gc();
  o1 = o2 = 0;
  return gc();
]], 2)

  test_any([[gc();
      int q=lambda() { mixed foo; foo=lambda() { return foo; }; return 1; }();
      return gc()>0;
  ]],1)

  test_true([[
    object o = class{}();
    mapping m = ([class{}(): o, o: class{}()]);
    set_weak_flag (m, 1);
    gc();
    return !sizeof (m);
  ]])
  test_true([[
    object o = class{}();
    mapping m = ([class{}(): o, o: class{}()]);
    set_weak_flag (m, Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]])
  test_true([[
    object o = class{}();
    mapping m = ([class{}(): o, o: class{}()]);
    set_weak_flag (m, Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]])
  test_true([[
    object o = class{}();
    multiset m = (<o>);
    set_weak_flag (m, 1);
    m[class{}()] = 1;
    m[o] = 0;
    gc();
    return !sizeof (m);
  ]])

  test_do([[
    mixed eat_stack(int|void probe)
    {
      // Avoid eating as much C-stack by releasing the
      // catch at every level.
      if (probe) return 1;
      if (catch(eat_stack(1))) return 1;
      mixed err = 1;
      if ((err = eat_stack()) != 10)
	return intp(err) && err > 0 ? err + 1 : err;
      if (err = catch {
	class Foo
	{
	  object foo;
	  protected void create(object o) {foo = o;}
	};
	Foo foo;
	for(int i=0; i < 10000; i++)
	  foo = Foo(foo);
	gc();
      }) return err;
    };
    if (mixed err = eat_stack()) throw (err);
  ]])

  test_any([[
    mapping|zero m=([]);
    m->self=m;

    mapping q=(["foo":"bar","gazonk":1]);
    m->q=q;

    q+=([]);
    m=0;
    gc();
    return sizeof(q);
  ]],2)

  test_any([[
    int dummy;
    gc();
    function f = lambda() {
      object o = class{}();
      int i;
      return lambda() {return i;};
    }();
    lambda() {dummy++;}(); // Ensure refcount garbing is done.
    int n = gc();
    // n should be 0; o should be refcount garbed above, the frame for f
    // should be intact for use below.
    dummy += f();
    return n;
  ]], 0)

  test_any([[
    // Make sure we don't get trampoline garbage with (named) lambdas
    // that reference variables in the parent scope.
    gc();
    mapping m = ([]);
    class Refcounter()
    { mapping state;
      protected void create(mapping m) { state = m; state->refs++;}
      protected void _destruct() {state->refs--;}
    };
    int final_res;
    function foo()
    {
      object refc = Refcounter(m);
      final_res += m->refs; // Should add 1 here.
      int i = 1;
      int bar()
      {
        return i++;
      };
      return bar;
    };
    function|zero bar = foo();
    final_res += m->refs; // Should add 0 here.
    bar();
    bar = 0;
    final_res += m->refs; // Should add 0 here.
    final_res += gc(); // Should add 0 here.
    return final_res; // 1 expected.
  ]], 1)

  test_true([[
    class
    {
      object c;
      class A {object b;}
      class B {object a; protected void _destruct() {c = class{}();}}
      mixed test()
      {
	object|zero a = A(), b = B();
	a->b = b;
	b->a = a;
	a = b = 0;
	gc();
	return c;
      }
    }()->test();
  ]])

  test_any([[{
    array|zero a = ({({0})}); a[0][0] = a;
    gc(); a = 0; return gc() > 0;
  }]], 1)

  test_any([[{
    object o = class {}();
    mapping m = ([o: ({17})]);
    gc(); destruct (o); return gc() > 0;
  }]], 1)

  test_any([[{
    class Dead {object o;};
    object|zero o = Dead(); o->o = Dead(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Live {object o; protected void _destruct() {}};
    object|zero o = Live(); o->o = Live(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; protected void _destruct() {}};
    object|zero o = Dead(); o->o = Live(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; protected void _destruct() {}};
    object|zero o = Live(); o->o = Dead(); o->o->o = o;
    gc(); o = 0; return gc() > 0;
  }]], 1)

  test_any_equal([[{
    class Live {object o; protected void _destruct() {}};
    array a = set_weak_flag(({Live()}), 1);
    gc();
    return set_weak_flag(a, 0);
  }]], ({0}))
  test_any_equal([[{
    class Live {object o; protected void _destruct() {}};
    multiset l = set_weak_flag((<Live()>), 1);
    gc();
    return set_weak_flag(l, 0);
  }]], (<>))
  test_any_equal([[{
    class Live {object o; protected void _destruct() {}};
    mapping m = set_weak_flag(([0: Live()]), 1);
    gc();
    return set_weak_flag(m, 0);
  }]], ([]))
  test_any_equal([[{
    class Live {object o; protected void _destruct() {}};
    mapping m = set_weak_flag(([Live(): 0]), 1);
    gc();
    return set_weak_flag(m, 0);
  }]], ([]))
  test_any_equal([[{
    array a = set_weak_flag(({4711, 0x54325827a124*0x12348795482485425}), 1);
    gc();
    return set_weak_flag(a, 0);
  }]], ({4711, 0x54325827a124*0x12348795482485425}))

  test_any_equal([[{
    object|zero o = class {
      array g;
      array a = ({17});
      protected void create() {g = ({this});}
      protected void _destruct() {all_constants()->kablutt = a;}
    }();
    o = 0;
    gc();
    return all_constants()->kablutt;
  }]], ({17}));
  test_any([[{
    object|zero o = class {
      array g;
      array a = set_weak_flag (({({17})}), 1);
      protected void create() {g = ({this});}
      protected void _destruct() {
	if (!equal (a, ({({17})})))
	  error ("Contents in weak array zapped: %O.\n", a);
      }
    }();
    o = 0;
    return gc() >= 3;
  }]], 1);
  test_any_equal([[{
    object|zero o = class {
      array g;
      array a = set_weak_flag (({({17})}), 1);
      protected void create() {g = ({this});}
      protected void _destruct() {all_constants()->blatinka = a;}
    }();
    o = 0;
    gc();
    if (!equal (all_constants()->blatinka, ({({17})})))
      error ("Contents in saved weak array zapped: %O.\n",
	     all_constants()->blatinka);
    gc();
    return all_constants()->blatinka;
  }]], ({0}));

test_do(add_constant("kablutt");)
test_do(add_constant("blatinka");)

  test_any([[{
#if constant (_debug)
    // Temporarily disable debug so we don't get references to p in
    // the intepreter backlog.
    int old_debug = _debug (0);
#endif
    object|zero o = class {program p; object o;}();
    class Resolver(mixed x) {
      mixed resolv(string id, string filename, object handler) {return x;}
    };
    program|zero p = compile ("constant o = foo;", Resolver (o));
    o->p = p;
    o->o = p();
    gc();
    o = p = 0;
#if constant (_debug)
    _debug (old_debug);
#endif
    return gc() > 0;
  }]], 1)

  test_any([[{
    class Dead {object o;};
    object|zero o = Dead(); o->o = Dead();
    array a = set_weak_flag(({o}), 1);
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; protected void _destruct() {}};
    object|zero o = Live(); o->o = Dead();
    array a = set_weak_flag(({o}), 1);
    gc(); o = 0; return gc() > 0;
  }]], 1)
  test_any([[{
    class Dead {object o;};
    class Live {object o; protected void _destruct() {}};
    object|zero o = Dead(); o->o = Live();
    array a = set_weak_flag(({o}), 1);
    gc(); o = 0; return gc() > 0;
  }]], 1)

  test_do([[{
    object o = class {}();
    array a = ({o});
    destruct (o);
    gc();
  }]]);

  test_any([[{
    array|zero a = ({0}), b = ({a, set_weak_flag (({a}), 1)});
    array x = set_weak_flag (({a}), 1);
    a[0] = b;
    a = b = 0;
    gc();
    return !x[0];
  }]], 1);
  test_any([[{
    mapping|zero a = ([]), b = ([a:set_weak_flag (([a:a]), 1)]);
    mapping x = set_weak_flag (([a:2]), 1);
    a[b] = b;
    a = b = 0;
    gc();
    return !sizeof (x);
  }]], 1);
  test_any([[{
    multiset|zero a = (<>), b = (<a, set_weak_flag ((<a>), 1)>);
    multiset x = set_weak_flag ((<a>), 1);
    a[b] = 1;
    a = b = 0;
    gc();
    return !sizeof (x);
  }]], 1);

  test_any([[{
    class Foo {
      array(Foo) f = ({this});
      multiset(Foo) g = set_weak_flag((<this>), 1);
    };
    multiset(Foo) x = set_weak_flag ((<Foo()>), 1);
    gc();
    return !sizeof (x);
  }]], 1);
  test_any([[{
    class Foo {
      array(Foo) f = ({this});
      multiset(Foo) g = set_weak_flag((<this>), 1);
      protected void _destruct() {add_constant("beltbent_oblivion", 1);}
    };
    multiset(Foo) x = set_weak_flag ((<Foo()>), 1);
    gc();
    int res = all_constants()->beltbent_oblivion;
    add_constant("beltbent_oblivion");
    return res;
  }]], 1);

  test_any([[{
    gc();
    array|zero x = set_weak_flag (({0}), 1);
    x[0] = x;
    multiset b = set_weak_flag ((<x>), 1);
    array a = ({17});
    b[a] = 1;
    x = 0;
    return gc() >= 1;
  }]], 1);

  test_any([[{
    gc();
    array|zero a = set_weak_flag (({0, this}), 1);
    a[0] = a;
    a = 0;
    return gc() >= 1;
  }]], 1);

  test_any([[{
    gc();
    array|zero y = set_weak_flag (({0}), 1), z = set_weak_flag (({y}), 1);
    y[0] = z;
    y = z = 0;
    return gc() >= 2;
  }]], 1);

  test_any([[{
    class Live {
      array a;
      array g = ({this});
      protected void create()
      {
	a = set_weak_flag (({0}), 1);
	array b = set_weak_flag (({a}), 1);
	a[0] = b;
      }
      protected void _destruct()
      {
	if (!arrayp(a) || !arrayp(a[0]) || a[0][0] != a)
	  add_constant ("my_little_error", "GC garbed weak things too early.\n");
      }
    };
    gc();
    object|zero o = Live();
    o = 0;
    int res = gc() >= 3;
    if (all_constants()->my_little_error)
      error (all_constants()->my_little_error);
    return res;
  }]], 1);

  test_do([[{
    class Live
    {
      Foo f;
      protected void _destruct()
      {
	if (!f->l || !f->a || !f->a[0] || !f->a[1])
	  add_constant ("my_little_error", "GC garbed live things.\n");
      }
    };
    class Foo
    {
      int i;
      class Bar
      {
	int j = i++;		// Ensure parent pointer.
	array a = ({j});
      }
      Live l;
      protected void create (Live _l)
      {
	l = _l;
	l->f = this;
      }
      array a = allocate (2, Bar)();
    };
    object|zero o = Foo(Live());
    o = 0;
    gc(), gc();
    if (all_constants()->my_little_error)
      error (all_constants()->my_little_error);
  }]]);

  test_do([[{
  object|zero o = compile_string(#"
      class Foo
      {
	int i;
	class Bar
	{
	  int j = i++;		// Ensure parent pointer.
	}
	inherit Bar;
      }")();
    o = 0;
    gc();
  }]]);

  test_do([[{
    mapping a = ([1:({17}),2:3,4:5,6:7,8:9]), b = a + ([]);
    set_weak_flag (b, 1);
    gc();
  }]]);
  test_do([[{
    mapping a = ([1:({17})]), b = a + ([]);
    set_weak_flag (b, 1);
    gc();
  }]]);
  test_any([[{
    mapping a = ([17:({17})]);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    set_weak_flag (b, 1);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return sizeof (a) == 1 && sizeof (b) == 1;
  }]], 1);
  test_any([[{
    mapping a = ([17:({17})]);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    set_weak_flag (a, 1);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return sizeof (a) == 1 && sizeof (b) == 1;
  }]], 1);
  test_any([[{
    mapping a = ([17:({17})]);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    set_weak_flag (a, 1);
    set_weak_flag (b, 1);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return !sizeof (a) && !sizeof (b);
  }]], 1);
  test_any([[{
    mapping a = ([17:17]);
    set_weak_flag (a, 1);
    for (int i = 0; i < 10; i++) a[class{}()] = i;
    mapping b = a + ([]);
    foreach (indices (a), mixed o) if (objectp (o)) destruct (o);
    gc();
    return sizeof (a) == 1 && sizeof (b) == 1;
  }]], 1);
  test_any([[{
    mapping a = set_weak_flag (([17: set_weak_flag (({({17})}), 1)]), 1);
    return gc() >= 2 && !sizeof (a);
  }]], 1);

  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag ((["foo": o]), 1);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 1);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o1 = class{}(), o2 = class{}();
    mapping a = set_weak_flag (([o1: o2]), 1);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object|zero o = class{}();
    mapping a = set_weak_flag (([o: o]), 1);
    o = 0;
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([class{}(): o]), 1);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: class{}()]), 1);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    mapping a = set_weak_flag (([class{}(): class{}()]), 1);
    return gc() >= 2 && !sizeof (a);
  }]], 1);

  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag ((["foo": o]), 1);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 1);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([class{}(): o]), 1);
    destruct (o);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: class{}()]), 1);
    destruct (o);
    return gc() >= 1 && !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: o]), 0);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([class{}(): o]), 0);
    destruct (o);
    gc();
    return sizeof (a);
  }]], 1);
  test_any([[{
    object o = class{}();
    mapping a = set_weak_flag (([o: class{}()]), 0);
    destruct (o);
    gc();
    return !sizeof (a);
  }]], 1);

  test_any_equal([[{
    array a = set_weak_flag (({1, "foo", 3.14}), 1);
    gc();
    return set_weak_flag(a, 0);
  }]], ({1, "foo", 3.14}));
  test_any_equal([[{
    multiset a = set_weak_flag ((<1, "foo", 3.14>), 1);
    gc();
    return set_weak_flag(a, 0);
  }]], (<1, "foo", 3.14>));
  test_any_equal([[{
    mapping a = set_weak_flag (([1: 1, "foo": "foo", 3.14: 3.14]), 1);
    gc();
    return set_weak_flag(a, 0);
  }]], ([1: 1, "foo": "foo", 3.14: 3.14]));

  test_do([[{
    object|zero f = class
    {
      object o = class {}();
      array a = set_weak_flag (({o}), 1);
      object this = this;
      protected void create() {destruct (o);}
    }();
    f = 0;
    gc();
  }]]);
  test_do([[{
    object|zero f = class
    {
      object o = class {}();
      mapping m = set_weak_flag (([1:o]), 1);
      object this = this;
      protected void create() {destruct (o);}
    }();
    f = 0;
    gc();
  }]]);
  test_do([[{
    object|zero f = class
    {
      object o = class {}();
      mapping m = set_weak_flag (([o:1]), 1);
      object this = this;
      protected void create() {destruct (o);}
    }();
    f = 0;
    gc();
  }]]);
  test_do([[{
    object|zero f = class
    {
      object o = class {}();
      multiset m = set_weak_flag ((<o>), 1);
      object this = this;
      protected void create() {destruct (o);}
    }();
    f = 0;
    gc();
  }]]);

  test_tests([[inherit "]]SRCDIR[[/test_gc.pike";]])

  test_any([[mapping q=([ "t":class {} ()]); gc(); if(!objectp(q->t)) return -1; set_weak_flag(q,1); gc(); if(objectp(q->t)) return -2; return 0;]],0);

  test_do([[class bar { object foo; protected void create(void|object tmp) { foo=tmp; } };
             object|zero o=bar(),o2=o;
             for(int e=0;e<10000;e++) o=bar(o);
             o2->foo=o;
             o=o2=0;
             gc();
          ]])

  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    mapping m = set_weak_flag (([class{}(): "x"]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    mapping m = set_weak_flag (([class{}(): "x"]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    mapping m = set_weak_flag ((["x": class{}()]), Pike.WEAK_INDICES);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    mapping m = set_weak_flag ((["x": class{}()]), Pike.WEAK_VALUES);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object|zero o = class{}();
    mapping m = set_weak_flag (([o: o]), Pike.WEAK_INDICES);
    o = 0;
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object|zero o = class{}();
    mapping m = set_weak_flag (([o: o]), Pike.WEAK_VALUES);
    o = 0;
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object|zero o = class{}();
    mapping m = set_weak_flag (([o: o]), Pike.WEAK);
    o = 0;
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object|zero o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_INDICES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag (([o: "x"]), Pike.WEAK_VALUES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = ([o: "x"]);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_INDICES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 1)
  test_any([[
    object o = class{}();
    mapping m = set_weak_flag ((["x": o]), Pike.WEAK_VALUES);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 0)
  test_any([[
    object o = class{}();
    mapping m = (["x": o]);
    destruct (o);
    gc();
    return sizeof (m);
  ]], 1)

  test_do([[
    mapping m = set_weak_flag (([]), Pike.WEAK_INDICES);
    object|zero o = class {object o;}();
    m[o] = ({1});
    o->o = o;
    o = 0;
    gc();
  ]])

  test_do([[
    mapping m = set_weak_flag (([]), Pike.WEAK_INDICES);
    object|zero o = class {object o;}();
    m[o] = ({1});
    array a = set_weak_flag (({class (object o) {} (o)}), 1);
    o = 0;
    gc();
  ]])

  test_any([[
    return class {
      mapping x;
      int test()
      {
	object|zero o = class {
	    mapping a = ([1: this]);
	    protected void _destruct() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !x[1];
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      multiset x;
      int test()
      {
	object|zero o = class {
	    multiset a = (<this>);
	    protected void _destruct() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !sizeof (indices (x + (<>)));
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      array x;
      int test()
      {
	object|zero o = class {
	    array a = ({this});
	    protected void _destruct() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !x[0];
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      class Obj (object o) {protected void _destruct() {}}
      Obj x;
      int test()
      {
	object|zero o = class {
	    Obj a = Obj (this);
	    protected void _destruct() {x = a;}
	  }();
	o = 0;
	gc();
	return !x;
      }
    }()->test();
  ]], 1)
  test_any([[
    return class {
      class Obj (object o) {}
      Obj x;
      int test()
      {
	object|zero o = class {
	    Obj a = Obj (this);
	    protected void _destruct() {x = a;}
	  }();
	o = 0;
	gc();
	return x && !x->o;
      }
    }()->test();
  ]], 1)

// Pike.count_memory
test_do([[
  add_constant ("count_memory_stats",
    lambda (int|mapping opts, mixed... things) {
      if (intp (opts))
	opts = (["lookahead": opts, "collect_stats": 1]);
      else
	opts += (["collect_stats": 1]);
      Pike.count_memory (opts, @things);
      return sprintf ("i:%d,c:%d,e:%d,v:%d,r:%d,rnd:%d",
		      opts->internal, opts->cyclic, opts->external,
		      opts->visits, opts->revisits, opts->rounds);
    })
]])
// time(1) is used below to avoid constants with extra refs.
test_true([[Pike.count_memory (-1) == 0]])
test_true([[Pike.count_memory (-1, ({})) > 0]])
test_true([[Pike.count_memory (-1, ({time(1)})) > 0]])
test_true([[Pike.count_memory (-1, (<>)) > 0]])
test_true([[Pike.count_memory (-1, (<time(1)>)) >
	    Pike.count_memory (-1, (<>))]])
test_true([[Pike.count_memory (-1, (<time(1)>)) >
	    Pike.count_memory (-1, (<1>))]])
test_true([[Pike.count_memory (-1, ([])) > 0]])
test_true([[Pike.count_memory (-1, ([1: time(1)])) >
	    Pike.count_memory (-1, ([]))]])
test_true([[Pike.count_memory (-1, ([1: time(1)])) >
	    Pike.count_memory (-1, ([1: 2]))]])
test_true([[Pike.count_memory (-1, class {}) > 0]])
test_true([[Pike.count_memory (-1, class {float f;}) >
	    Pike.count_memory (-1, class {})]])
test_true([[Pike.count_memory (-1, class {constant f = 0.0;}) >
	    Pike.count_memory (-1, class {})]])
test_true([[Pike.count_memory (-1, class {}()) > 0]])
test_true([[Pike.count_memory (-1, class {float f;}()) >
	    Pike.count_memory (-1, class {}())]])
test_true([[Pike.count_memory (-1, class {constant f = 0.0;}()) ==
	    Pike.count_memory (-1, class {}())]])
test_true([[Pike.count_memory (-1, "foo") > 0]])
test_true([[Pike.count_memory (-1, typeof (map)) > 0]])
test_true([[Pike.count_memory (-1, 17) == 0]])
test_true([[Pike.count_memory (-1, ({"some string with no other ref in memory "+
				     Standards.UUID.make_version4()->str()})) ==
	    Pike.count_memory (-1, ({""}))]])
test_true([[Pike.count_memory (0, ({"some string with no other ref in memory " +
				    Standards.UUID.make_version4()->str()})) >
	    Pike.count_memory (0, ({""}))]])
test_true([[Pike.count_memory (-1, ({time(1)})) +
	    Pike.count_memory (-1, ([1: time(1)])) ==
	    Pike.count_memory (0, ({([1: time(1)])}))]])
test_true([[Pike.count_memory (0, class {mapping(this_program:array(int)) x;}) >
	    Pike.count_memory (0, class {int x;})]])
test_true([[Pike.count_memory (0, ({compile (
				      "constant x = ([1: " + time(1) +
				      "]);")})) >
	    Pike.count_memory (0, ({([1: time(1)])}))]])
test_eq([[count_memory_stats (-1, ({time(1)}))]],
	[["i:1,c:0,e:0,v:1,r:0,rnd:1"]])
test_eq([[count_memory_stats (-1, (<time(1)>))]],
	[["i:1,c:0,e:0,v:2,r:0,rnd:1"]])
test_eq([[count_memory_stats (-1, ([1: time(1)]))]],
	[["i:1,c:0,e:0,v:2,r:0,rnd:1"]])
test_eq([[count_memory_stats (-1, class {float f;})]],
	[["i:1,c:0,e:0,v:1,r:0,rnd:1"]])
test_eq([[count_memory_stats (-1, class {float f;}())]],
	[["i:1,c:0,e:0,v:1,r:0,rnd:1"]])
test_eq([[count_memory_stats (-1, "foo")]],
	[["i:1,c:0,e:0,v:1,r:0,rnd:1"]])
test_eq([[count_memory_stats (-1, typeof(all_constants()))]],
	[["i:1,c:0,e:0,v:1,r:0,rnd:1"]])
test_any([[
  array a1 = ({({time(1)})}), a2 = ({a1[0]});
  return Pike.count_memory (0, a1, a2) >
    Pike.count_memory (0, a1) + Pike.count_memory (0, a2);
]], 1)
test_any([[
  mapping m = ([1: time(1)]);
  return Pike.count_memory (0, ({m})) == Pike.count_memory (0, ({0}));
]], 1)
test_any([[
  array a = ({([1: time(1)])});
  return Pike.count_memory (0, a) > Pike.count_memory (0, ({([])}));
]], 1)
test_any([[
  program p = class {};
  return Pike.count_memory (0, p) > Pike.count_memory (0, p());
]], 1)
test_any([[
  class X (void|object a) {};
  X o = X (X());
  return count_memory_stats (0, o);
]], [["i:2,c:0,e:0,v:2,r:0,rnd:1"]])
test_any([[
  class X (void|object a) {};
  X o = X (X (X()));
  o->a->a->a = o;
  return count_memory_stats (0, o);
]], [["i:3,c:0,e:0,v:3,r:0,rnd:1"]])
test_any([[
  /* don't save parent */
  class X (void|object a) {};
  X o = X (X (X()));
  o->a->a->a = o->a;
  return count_memory_stats (2, o);
]], [["i:3,c:2,e:0,v:7,r:4,rnd:2"]])
test_any([[
  /* don't save parent */
  class X (void|object a) {};
  X o = X (X (X()));
  o->a->a->a = o->a;
  return count_memory_stats (1, o);
]], [["i:1,c:0,e:1,v:3,r:1,rnd:1"]])
test_any([[
  class X (void|object a) {};
  X o = X (X (X()));
  int size = Pike.count_memory (0, o);
  o->a->a->a = o->a;
  return Pike.count_memory ((["lookahead": 2]), o) == size;
]], 1)
test_any([[
  class X (void|object a) {};
  X o = X (X (X()));
  return count_memory_stats ((["block_objects": 1]), o);
]], [["i:3,c:0,e:0,v:3,r:0,rnd:1"]])
test_any([[
  class X (void|object a) {};
  X o = X (X (X()));
  o->a->a->a = o->a;
  return count_memory_stats ((["lookahead": 2, "block_objects": 1]), o);
]], [["i:1,c:0,e:0,v:1,r:0,rnd:1"]])
test_any([[
  /* don't save parent */
  class X (void|object a) {};
  X o = X (X (X()));
  o->a->a->a = o->a;
  X r = o->a->a;
  return count_memory_stats (10, o);
]], [["i:1,c:0,e:2,v:7,r:4,rnd:1"]])
test_any([[
  /* don't save parent */
  class X (void|object a) {};
  X o = X (X (X()));
  o->a->a->a = o->a;
  X r = o->a->a;
  return count_memory_stats (2, o);
]], [["i:1,c:0,e:2,v:7,r:4,rnd:1"]])
test_any([[
  /* don't save parent */
  class X (void|object a) {};
  X o = X (X (X()));
  o->a->a->a = o->a;
  X r = o->a;
  return count_memory_stats (2, o);
]], [["i:1,c:0,e:2,v:5,r:2,rnd:1"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {};
  X o = X (X (X (X (X (X ())))));
  o->a->b = o;
  o->a->a->b = o->a;
  o->a->a->a->b = o->a->a;
  o->a->a->a->a->b = o->a->a->a;
  o->a->a->a->a->a->b = o->a->a->a->a;
  return count_memory_stats (1, o);
]], [["i:1,c:0,e:1,v:3,r:1,rnd:1"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {};
  X o = X (X (X (X (X (X ())))));
  o->a->b = o;
  o->a->a->b = o->a;
  o->a->a->a->b = o->a->a;
  o->a->a->a->a->b = o->a->a->a;
  o->a->a->a->a->a->b = o->a->a->a->a;
  return count_memory_stats (2, o);
]], [["i:6,c:5,e:0,v:19,r:13,rnd:2"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {};
  X o = X (X (X (X (X (X ())))));
  o->a->b = o;
  o->a->a->b = o->a;
  o->a->a->a->b = o->a->a;
  o->a->a->a->a->b = o->a->a->a;
  o->a->a->a->a->a->b = o->a->a->a->a;
  X p = o->a->a->a->a;
  return count_memory_stats (2, o);
]], [["i:1,c:0,e:5,v:17,r:11,rnd:1"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {constant pike_cycle_depth = 2;};
  X o = X (X (X (X (X (X ())))));
  o->a->b = o;
  o->a->a->b = o->a;
  o->a->a->a->b = o->a->a;
  o->a->a->a->a->b = o->a->a->a;
  o->a->a->a->a->a->b = o->a->a->a->a;
  return count_memory_stats (0, o);
]], [["i:6,c:5,e:0,v:19,r:13,rnd:2"]])
test_any([[
  class X (void|object a, void|object b) {constant pike_cycle_depth = 1;};
  X o = X (X (X (X (X (X ())))));
  o->a->b = o;
  o->a->a->b = o->a;
  o->a->a->a->b = o->a->a;
  o->a->a->a->a->b = o->a->a->a;
  o->a->a->a->a->a->b = o->a->a->a->a;
  return count_memory_stats (0, o);
]], [["i:1,c:0,e:1,v:3,r:1,rnd:1"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {constant pike_cycle_depth = 0;};
  X o = X (X (X (X (X (X ())))));
  o->a->b = o;
  o->a->a->b = o->a;
  o->a->a->a->b = o->a->a;
  o->a->a->a->a->b = o->a->a->a;
  o->a->a->a->a->a->b = o->a->a->a->a;
  return count_memory_stats (2, o);
]], [["i:1,c:0,e:0,v:1,r:0,rnd:1"]])
test_any([[
  class X (void|object a, void|object b) {constant pike_cycle_depth = 2;};
  X o = X (X (X (X (X (X ())))));
  o->a->b = o;
  o->a->a->b = o->a;
  o->a->a->a->b = o->a->a;
  o->a->a->a->a->b = o->a->a->a;
  o->a->a->a->a->a->b = o->a->a->a->a;
  return count_memory_stats ((["block_pike_cycle_depth": 1]), o);
]], [["i:1,c:0,e:0,v:1,r:0,rnd:1"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {constant pike_cycle_depth = 4;};
  class Y (void|object a) {constant pike_cycle_depth = 0;};
  X o = X (X(), X());
  o->a->a = o->b;
  o->b->a = o->a;
  o->a->b = o->b->b = Y (Y());
  return count_memory_stats (0, o);
]], [["i:5,c:2,e:0,v:8,r:3,rnd:2"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {constant pike_cycle_depth = 4;};
  class Y (void|object a) {constant pike_cycle_depth = 0;};
  X o = X (X(), X());
  o->a->a = o->b;
  o->b->a = o->a;
  o->a->b = o->b->b = Y (Y());
  o->a->b->a->a = o->a->b;
  return count_memory_stats (0, o);
]], [["i:3,c:2,e:0,v:6,r:3,rnd:2"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {};
  X o = X (X (X()));
  o->a->a->a = o->a;
  object(X)|zero o2 = X();
  o->b = o2;
  o2->a = o->a->a;
  o2 = 0;
  return count_memory_stats (2, o);
]], [["i:4,c:2,e:0,v:7,r:3,rnd:2"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {};
  X o = X (X (X()));
  o->a->a->a = o->a;
  X o2 = X();
  o->b = o2;
  o2->a = o->a->a;
  return count_memory_stats (2, o);
]], [["i:1,c:0,e:3,v:9,r:5,rnd:1"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {};
  X o = X (X(), X());
  o->a->b = o->b;
  o->b->a = o->a;
  o->a->a = o->b->b = X();
  return count_memory_stats (2, o);
]], [["i:4,c:3,e:0,v:8,r:4,rnd:2"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {};
  X o = X (X(), X());
  o->a->b = o->b;
  o->b->a = o->a;
  object(X)|zero o2 = X (X(), X());
  o2->a->b = o2->b;
  o2->b->a = o2->a;
  o2->a->a = o2->b->b = X();
  o->a->a = o->b->b = o2;
  o2 = 0;
  return count_memory_stats (1, o);
]], [["i:7,c:6,e:0,v:15,r:8,rnd:2"]])
test_any([[
  /* don't save parent */
  class X (void|object a, void|object b) {};
  X o = X (X(), X());
  o->a->b = o->b;
  o->b->a = o->a;
  X o2 = X (X(), X());
  o2->a->b = o2->b;
  o2->b->a = o2->a;
  o2->a->a = o2->b->b = X();
  o->a->a = o->b->b = o2;
  o2 = o2->b;
  mapping m = (["lookahead": 1,
		"collect_stats": 1,
		"collect_direct_externals": 1]);
  Pike.count_memory (m, o);
  //werror ("%O\n", m);
  return m->internal == 4 && m->cyclic == 3 && m->external == 3 &&
	 equal (m->collect_direct_externals, ({o2}));
]], 1)
test_any([[
  mixed r = ([]), p = r;
  p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = 0;
  return count_memory_stats (1, r);
]], [["i:1,c:0,e:1,v:6,r:2,rnd:1"]])
test_any([[
  mixed r = ([]), p = r;
  p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = 0;
  return count_memory_stats (2, r);
]], [["i:6,c:5,e:0,v:38,r:26,rnd:2"]])
test_any([[
  mixed r = ([]), p = r;
  p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = p->next; p->next = ([]); p->next->prev = p;
  p = 0;
  return Pike.count_memory ((["lookahead": 2, "return_count": 1]), r);
]], 6)
test_any([[
  /* don't save parent */
  class X (void|array|object a, void|array|object b) {};
  array a = ({X (X())});
  object|zero o = a[0];
  o->a->a = o; o->b = ({X (X())}); o = o->b[0];
  o->a->a = o; o->b = ({X (X())}); o = o->b[0];
  o->a->a = o; o->b = ({X (X())}); o = o->b[0];
  o->a->a = o; o->b = ({X (X())}); o = o->b[0];
  o->a->a = o; o = 0;
  return count_memory_stats ((["lookahead": 2, "block_arrays": 1]), a);
]], [["i:15,c:10,e:0,v:35,r:20,rnd:6"]])
test_any([[
  /* don't save parent */
  class X (void|array|object a, void|array|object b) {};
  array a = ({X (X())});
  object|zero o = a[0];
  o->a->a = o; o->a->b = ({X (X())}); o = o->a->b[0];
  o->a->a = o; o->a->b = ({X (X())}); o = o->a->b[0];
  o->a->a = o; o->a->b = ({X (X())}); o = o->a->b[0];
  o->a->a = o; o->a->b = ({X (X())}); o = o->a->b[0];
  o->a->a = o; o = 0;
  return count_memory_stats ((["lookahead": 2, "block_arrays": 1]), a);
]], [["i:15,c:10,e:0,v:35,r:20,rnd:6"]])
test_true([[Pike.count_memory (Int.NATIVE_MAX, ({master()})) ==
	    Pike.count_memory (-1, ({0}))]])
test_any([[
  mapping m = (["lookahead": Int.NATIVE_MAX,
		"block_programs": 0,
		"collect_stats": 1]);
  Pike.count_memory (m, master());
  return m->rounds;
]], 1)
test_true([[Pike.count_memory (-1, Int.NATIVE_MAX + 1) >
	    Pike.count_memory (-1, 17)]])
test_true([[Pike.count_memory (-1, Int.NATIVE_MAX << 100) >
	    Pike.count_memory (-1, Int.NATIVE_MAX + 1)]])
test_do([[add_constant("count_memory_stats")]])

test_program([[
  function ff()
  {
    array x;
    array b() {return x;};
    x = ({b});
    return b;
  }

  int a()
  {
    function|zero f = ff();
    int s = Pike.count_memory (0, f());
    f = 0;
    gc();
    return s > 0;
  }
]])

// Pike.identify_cycle
test_any_equal([[
  class Foo { Foo next; int counter; };
  array(Foo) foos = allocate(10, Foo)();
  for (int i = 0; i < 10; i++) {
    foos[i]->next = foos[(i+1)%10];
    foos[i]->counter = i;
  }
  return Pike.identify_cycle(foos[0])->counter;
]], ({ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }))
test_any([[
  // PIKE-106: Mutex not unlocked properly on error in identify_cycle().
  class Foo {
    int cnt;
    protected int __hash() { return 0; }
    protected int `==(mixed x) { if (!cnt++) error("Comparison failure.\n"); }
  };
  catch {
    // This triggered an error.
    Pike.identify_cycle(allocate(2, Foo)());
  };
  catch {
    // This hanged due to the mc_mutex not having been released.
    Pike.identify_cycle(allocate(2, Foo)());
  };
]], 0)

// Numerical limits.
test_true([[Int.NATIVE_MIN <= -2147483648]])
test_true([[Int.NATIVE_MAX >= 2147483647]])
test_true([[Float.DIGITS_10 >= 6]])
test_true([[Float.MIN_10_EXP <= -37]])
test_true([[Float.MAX_10_EXP >= 37]])
test_true([[Float.MIN <= 1e-37]])
test_true([[Float.MAX >= 1e37]])
test_true([[Float.EPSILON <= 1e-5]])
test_true([[1 <= 1.0]])
test_true([[1 >= 1.0]])
test_true([[1.0 <= 1]])
test_true([[1.0 >= 1]])

// Test the lexer.
test_eq("2147483648", [[ (string)0x80000000 ]])
test_eq("2147483649", [[ (string)0x80000001 ]])
test_eq("-2147483648", [[ (string)-0x80000000 ]])
test_eq("-2147483649", [[ (string)-0x80000001 ]])
test_eq("2147483648", [[ (string)-(-0x80000000) ]])
test_eq("2147483649", [[ (string)-(-0x80000001) ]])
test_eq("9223372036854775808", [[ (string)0x8000000000000000 ]])
test_eq("9223372036854775809", [[ (string)0x8000000000000001 ]])
test_eq("-9223372036854775808", [[ (string)-0x8000000000000000 ]])
test_eq("-9223372036854775809", [[ (string)-0x8000000000000001 ]])
test_eq("9223372036854775808", [[ (string)-(-0x8000000000000000) ]])
test_eq("9223372036854775809", [[ (string)-(-0x8000000000000001) ]])
test_eq("123456789123456789", [[ (string)123456789123456789 ]])
test_eq("-123456789123456789", [[ (string)-123456789123456789 ]])
test_eq("335812727629498640265", [[ (string)0x123456789123456789 ]])
test_eq("-335812727629498640265", [[ (string)-0x123456789123456789 ]])
test_eq("718046312823", [[ (string)012345671234567 ]])
test_eq("-718046312823", [[ (string)-012345671234567 ]])
test_eq("1125899906842624", [[ (string)0b100000000000000000000000000000000000000000000000000 ]])
test_eq("-1125899906842624", [[ (string)-0b100000000000000000000000000000000000000000000000000 ]])
test_eq(500000000 * 10, 5000000000)
test_eq(5000000000000000000 * 10, 50000000000000000000)

// Numbers that shouldn't be native integers. Has to resort to
// strange methods to test this since bignums behave like native
// integers in almost every way.
test_do([[ Debug.next ((mixed) Int.NATIVE_MAX + 1) ]])
test_do([[ Debug.next ((mixed) Int.NATIVE_MIN - 1) ]])

// These numbers should be native integers.
test_eval_error([[ Debug.next ((mixed) -0x80000000) ]])
test_eval_error([[ Debug.next ((mixed) -0x7fffffff) ]])
test_eval_error([[ Debug.next ((mixed) 0x7fffffff) ]])
test_eval_error([[ Debug.next ((mixed) Int.NATIVE_MAX) ]])
test_eval_error([[ Debug.next ((mixed) Int.NATIVE_MIN) ]])

// Test incrementations (FIXME: More cases?).
test_eq("2147483648",
 [[ (string)(class { int f(int x) { x++; return x; } })()->f(0x7fffffff) ]])
test_eq("2147483648",
 [[ (string)(class { int f(int x) { ++x; return x; } })()->f(0x7fffffff) ]])
test_eq("2147483648",
 [[ (string)(class { int x=0x7fffffff;int f() { ++x;return x; } })()->f() ]])
test_eq("2147483648",
 [[ (string)(class { int x=0x7fffffff;int f() { x++;return x; } })()->f() ]])
test_eq("2147483648",
 [[ (string)(class { int f() { int x=0x7fffffff;++x;return x; } })()->f() ]])
test_eq("2147483648",
 [[ (string)(class { int f() { int x=0x7fffffff;x++;return x; } })()->f() ]])
test_eq("9223372036854775808",
 [[ (string)(class { int f(int x) { x++; return x; } })()->f(0x7fffffffffffffff) ]])
test_eq("9223372036854775808",
 [[ (string)(class { int f(int x) { ++x; return x; } })()->f(0x7fffffffffffffff) ]])
test_eq("9223372036854775808",
 [[ (string)(class { int x=0x7fffffffffffffff;int f() { ++x;return x; } })()->f() ]])
test_eq("9223372036854775808",
 [[ (string)(class { int x=0x7fffffffffffffff;int f() { x++;return x; } })()->f() ]])
test_eq("9223372036854775808",
 [[ (string)(class { int f() { int x=0x7fffffffffffffff;++x;return x; } })()->f() ]])
test_eq("9223372036854775808",
 [[ (string)(class { int f() { int x=0x7fffffffffffffff;x++;return x; } })()->f() ]])

// Test decrementations (FIXME: More cases?).
test_eq("-2147483649",
 [[ (string)(class { int f(int x) { x--; return x; } })()->f(-0x80000000) ]])
test_eq("-2147483649",
 [[ (string)(class { int f(int x) { --x; return x; } })()->f(-0x80000000) ]])
test_eq("-2147483649",
 [[ (string)(class { int x=-0x80000000;int f() { --x;return x; } })()->f()]])
test_eq("-2147483649",
 [[ (string)(class { int x=-0x80000000;int f() { x--;return x; } })()->f()]])
test_eq("-2147483649",
 [[ (string)(class { int f() { int x=-0x80000000;--x;return x; } })()->f()]])
test_eq("-2147483649",
 [[ (string)(class { int f() { int x=-0x80000000;x--;return x; } })()->f()]])
test_eq("-9223372036854775809",
 [[ (string)(class { int f(int x) { x--; return x; } })()->f(-0x8000000000000000) ]])
test_eq("-9223372036854775809",
 [[ (string)(class { int f(int x) { --x; return x; } })()->f(-0x8000000000000000) ]])
test_eq("-9223372036854775809",
 [[ (string)(class { int x=-0x8000000000000000;int f() { --x;return x; } })()->f()]])
test_eq("-9223372036854775809",
 [[ (string)(class { int x=-0x8000000000000000;int f() { x--;return x; } })()->f()]])
test_eq("-9223372036854775809",
 [[ (string)(class { int f() { int x=-0x8000000000000000;--x;return x; } })()->f()]])
test_eq("-9223372036854775809",
 [[ (string)(class { int f() { int x=-0x8000000000000000;x--;return x; } })()->f()]])

test_encode(1<<99);

// - Left shift.
test_eq("1073741824", [[ (string)(1<<30) ]])
test_eq("2147483648", [[ (string)(1<<31) ]])
test_eq("4294967296", [[ (string)(1<<32) ]])
test_eq("8589934592", [[ (string)(1<<33) ]])
test_eq("1267650600228229401496703205376", [[ (string)(1<<100) ]])

test_eval_error(return 1<<100000000000000000000)
test_eval_error(return (-1)<<100000000000000000000)
test_eq(0<<100000000000000000000, 0)
test_eval_error(return 100000000000000000000<<100000000000000000000)
test_eval_error(return (-100000000000000000000)<<100000000000000000000)

// - Right shift.
test_eq("53265209898187398182",
		[[ (string)((int)"54543574935743895738479">>10) ]])
test_false([[ objectp((int)"54543574935743895738479">>60) ]])
test_eq(0, [[ 25>>30 ]])
test_eq(0, [[ 25>>31 ]])
test_eq(0, [[ 25>>32 ]])
test_eq(0, [[ 25>>33 ]])

test_eq(1>>100000000000000000000, 0)
test_eq(-1>>100000000000000000000, -1)
test_eq(0>>100000000000000000000, 0)
test_eq(100000000000000000000>>100000000000000000000, 0)
test_eq((-100000000000000000000)>>100000000000000000000, -1)

// - abs.
test_eq("2147483648", [[ (string)abs(-0x80000000) ]])
test_eq("2147483648", [[ (string)abs(0x80000000) ]])
test_eq("2147483649", [[ (string)abs(0x80000001) ]])
test_eq("2147483649", [[ (string)abs(-0x80000001) ]])
test_eq("9223372036854775808", [[ (string)abs(-0x8000000000000000) ]])
test_eq("9223372036854775808", [[ (string)abs(0x8000000000000000) ]])
test_eq("9223372036854775809", [[ (string)abs(0x8000000000000001) ]])
test_eq("9223372036854775809", [[ (string)abs(-0x8000000000000001) ]])

// - Add.
test_eq("2147483648", [[ (string)(0x7fffffff + 1) ]])
test_eq("2147483649", [[ (string)(0x7fffffff + 2) ]])
test_eq("-2147483648", [[ (string)((-0x80000001) + 1) ]])
test_eq("9223372036854775808", [[ (string)(0x7fffffffffffffff + 1) ]])
test_eq("9223372036854775809", [[ (string)(0x7fffffffffffffff + 2) ]])
test_eq("-9223372036854775808", [[ (string)((-0x8000000000000001) + 1) ]])
test_eq("2684354560", [[ (string)(0x50000000 + 0x50000000) ]])
test_eq("-2684354560", [[ (string)((-0x50000000) + (-0x50000000)) ]])
test_false([[ objectp((-0x80000001) + 1) ]])

// - Add-eq.
test_eq([[lambda() { int a=0x100000000; int b = a; a += 1; return b+a; }()]],
	  [[0x200000001]])

// - Sub.
test_eq("-2147483648", [[ (string)(-0x7fffffff - 1) ]])
test_eq("-2147483649", [[ (string)(-0x80000000 - 1) ]])
test_eq("2147483647", [[ (string)(0x80000000 - 1) ]])
test_eq("-9223372036854775808", [[ (string)(-0x7fffffffffffffff - 1) ]])
test_eq("-9223372036854775809", [[ (string)(-0x8000000000000000 - 1) ]])
test_eq("9223372036854775807", [[ (string)(0x8000000000000000 - 1) ]])
test_false([[ objectp(0x80000000 - 1) ]])

// - Multiplication.
test_eq("6442450941", [[ (string)(0x7fffffff * 3) ]])
test_eq("-6442450941", [[ (string)(0x7fffffff * -3) ]])
test_eq(-2147483648*-1,2147483648)
test_eq(-9223372036854775808*-1,9223372036854775808)

// Division.
test_eq("1073741824", [[ (string)((int)"2147483648" / 2) ]])
test_false([[ objectp((int)"2147483648" / 2) ]])
test_eq("13934998268672547360069539025",
        [[ (string)(48324683476346278246238462784624627348 / 3467864333) ]])

// Power.
test_eq("262144", [[ (string)(4**3**2) ]])
test_eq("-9", [[ (string)(-3**2) ]])
test_eq("16", [[ (string)lambda(){int a=3; return ++a**2;}() ]])
test_eq("9", [[ (string)lambda(){int a=3; return a++**2;}() ]])
test_eq("625", [[ (string)lambda(){int a=3; return 5**++a;}() ]])
test_eq("125", [[ (string)lambda(){int a=3; return 5**a++;}() ]])

// - sscanf.
test_eq("12345678901234567890",
	   [[ (string)array_sscanf("12345678901234567890", "%d")[0] ]])
test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("123456789F01234567890", "%x")[0] ]])
test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0x123456789F01234567890", "%x")[0] ]])
test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0X123456789F01234567890", "%x")[0] ]])
test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0x123456789F01234567890", "%i")[0] ]])
test_eq("1375488932614371410344080",
	   [[ (string)array_sscanf("0X123456789F01234567890", "%i")[0] ]])
test_eq("45954944846776",
	   [[ (string)array_sscanf("1234567012345670", "%o")[0] ]])
test_eq("45954944846776",
	   [[ (string)array_sscanf("01234567012345670", "%i")[0] ]])
test_eq("11", [[ (string)array_sscanf("1011", "%b")[0] ]])
test_eq("1125968643114208", [[ (string)array_sscanf("100000000000001000000000001000000000100010011100000", "%b")[0] ]])
test_eq("11", [[ (string)array_sscanf("0b1011", "%i")[0] ]])
test_eq("1125968643114208", [[ (string)array_sscanf("0b100000000000001000000000001000000000100010011100000", "%i")[0] ]])

test_eq("-12345678901234567890",
	   [[ (string)array_sscanf("-12345678901234567890", "%d")[0] ]])
test_eq("-1375488932614371410344080",
	   [[ (string)8.0::array_sscanf("-123456789F01234567890", "%x")[0] ]])
test_eq(({}),
	   [[ array_sscanf("-123456789F01234567890", "%x") ]])
test_eq("-1375488932614371410344080",
	   [[ (string)array_sscanf("-0x123456789F01234567890","%i")[0] ]])
test_eq("-45954944846776",
	   [[ (string)8.0::array_sscanf("-1234567012345670", "%o")[0] ]])
test_eq(({}),
	   [[ array_sscanf("-1234567012345670", "%o") ]])
test_eq("-45954944846776",
	   [[ (string)array_sscanf("-01234567012345670", "%i")[0] ]])
test_eq("-11", [[ (string)8.0::array_sscanf("-1011", "%b")[0] ]])
test_eq(({}), [[ array_sscanf("-1011", "%b") ]])
test_eq("-1125968643114208",
	   [[ (string)8.0::array_sscanf("-100000000000001000000000001000000000100010011100000", "%b")[0] ]])
test_eq("-11", [[ (string)array_sscanf("-0b1011", "%i")[0] ]])
test_eq("-1125968643114208", [[ (string)array_sscanf("-0b100000000000001000000000001000000000100010011100000", "%i")[0] ]])

test_eq([[ sprintf("%x", @array_sscanf("\0\0\0\0\1\2\3\4", "%4c")) ]], "0")
test_eq([[ sprintf("%x", @array_sscanf("\0\0\0\0\1\2\3\4", "%8c")) ]], "1020304")
test_eq([[ sprintf("%08x", @array_sscanf("\0\0\0\0\1\2\3\4", "%8c")) ]], "01020304")
test_eq([[ sprintf("%08x", @array_sscanf("\0\0\0\5\1\2\3\4", "%8c")) ]], "501020304")
test_eq([[ sprintf("%08x", @array_sscanf("\0\0\6\5\1\2\3\4", "%8c")) ]], "60501020304")
test_eq([[ sprintf("%08x", @array_sscanf("\0\7\6\5\1\2\3\4", "%8c")) ]], "7060501020304")
test_eq([[ sprintf("%08x", @array_sscanf("8\7\6\5\1\2\3\4", "%8c")) ]], "3807060501020304")
test_eq([[ sprintf("%08x", @array_sscanf("\010\7\6\5\1\2\3\4", "%8c")) ]], "807060501020304")

test_equal([[ ({ 118 }) ]], [[ array_sscanf("0x76", "%x") ]])
test_equal([[ ({42 }) ]], [[ array_sscanf("101010", "%b") ]])
test_equal([[ ({42 }) ]], [[ array_sscanf("0b101010", "%b") ]])
test_equal([[ ({42 }) ]], [[ array_sscanf("0B101010", "%b") ]])
test_equal([[ ({ 557239244978618154304871 }) ]],
           [[ array_sscanf("0x76000000000001234567", "%x") ]])

test_equal([[array_sscanf("foo \12345 bar <fie>","%[^<]")]],
            [[ ({"foo \12345 bar " }) ]])

test_eval_error([[
 // Test that the runtime survives svalues of type T_VOID (16)
 // on the stack.
 object p = Parser.HTML();
 p->add_tag("x", lambda(object p, mapping m, string h)
   {
     sscanf(h, "%s.js", h);
   });
 p->finish("<x/>");
]])

test_equal(471100000000000000000000000000000000000000000000042,
           (int)(mixed)471100000000000000000000000000000000000000000000042)
test_eq(6745697846498645967,
        [[ (int)Gmp.mpz("6745697846498645967") ]])

test_eq(0x7fffffff, [[ decode_value(encode_value(0x7fffffff)) ]])
test_eq(0x7ffffffff, [[ decode_value(encode_value(0x7ffffffff)) ]])
test_eq(0x7fffffffff, [[ decode_value(encode_value(0x7fffffffff)) ]])
test_eq(0x7ffffffffff, [[ decode_value(encode_value(0x7ffffffffff)) ]])
test_eq(0x7fffffffffff, [[ decode_value(encode_value(0x7fffffffffff)) ]])
test_eq(0x7ffffffffffff, [[ decode_value(encode_value(0x7ffffffffffff)) ]])
test_eq(0x80000000, [[ decode_value(encode_value(0x80000000)) ]])
test_eq(0x800000000, [[ decode_value(encode_value(0x800000000)) ]])
test_eq(0x8000000000, [[ decode_value(encode_value(0x8000000000)) ]])
test_eq(0x80000000000, [[ decode_value(encode_value(0x80000000000)) ]])
test_eq(0x800000000000, [[ decode_value(encode_value(0x800000000000)) ]])
test_eq(0x8000000000000, [[ decode_value(encode_value(0x8000000000000)) ]])
test_eq(0x12345678, [[ decode_value(encode_value(0x12345678)) ]])
test_eq(0x123456780, [[ decode_value(encode_value(0x123456780)) ]])
test_eq(0x1234567801, [[ decode_value(encode_value(0x1234567801)) ]])
test_eq(0x12345678012, [[ decode_value(encode_value(0x12345678012)) ]])
test_eq(0x123456780123, [[ decode_value(encode_value(0x123456780123)) ]])
test_eq(0x1234567801234, [[ decode_value(encode_value(0x1234567801234)) ]])

test_eq(-0x7fffffff, [[ decode_value(encode_value(-0x7fffffff)) ]])
test_eq(-0x7ffffffff, [[ decode_value(encode_value(-0x7ffffffff)) ]])
test_eq(-0x7fffffffff, [[ decode_value(encode_value(-0x7fffffffff)) ]])
test_eq(-0x7ffffffffff, [[ decode_value(encode_value(-0x7ffffffffff)) ]])
test_eq(-0x7fffffffffff, [[ decode_value(encode_value(-0x7fffffffffff)) ]])
test_eq(-0x7ffffffffffff, [[ decode_value(encode_value(-0x7ffffffffffff))]])
test_eq(-0x80000000, [[ decode_value(encode_value(-0x80000000)) ]])
test_eq(-0x800000000, [[ decode_value(encode_value(-0x800000000)) ]])
test_eq(-0x8000000000, [[ decode_value(encode_value(-0x8000000000)) ]])
test_eq(-0x80000000000, [[ decode_value(encode_value(-0x80000000000)) ]])
test_eq(-0x800000000000, [[ decode_value(encode_value(-0x800000000000)) ]])
test_eq(-0x8000000000000, [[ decode_value(encode_value(-0x8000000000000))]])
test_eq(-0x12345678, [[ decode_value(encode_value(-0x12345678)) ]])
test_eq(-0x123456780, [[ decode_value(encode_value(-0x123456780)) ]])
test_eq(-0x1234567801, [[ decode_value(encode_value(-0x1234567801)) ]])
test_eq(-0x12345678012, [[ decode_value(encode_value(-0x12345678012)) ]])
test_eq(-0x123456780123, [[ decode_value(encode_value(-0x123456780123)) ]])
test_eq(-0x1234567801234, [[ decode_value(encode_value(-0x1234567801234))]])

test_eval_error([[ Debug.next ((mixed) decode_value (encode_value (Int.NATIVE_MAX))) ]])
test_eval_error([[ Debug.next ((mixed) decode_value (encode_value (Int.NATIVE_MIN))) ]])
test_do([[ Debug.next ((mixed) decode_value (encode_value (Int.NATIVE_MAX + 1))) ]])
test_do([[ Debug.next ((mixed) decode_value (encode_value (Int.NATIVE_MIN - 1))) ]])
test_eq(2147483648, -2147483648/-1)
test_eq(2147483648, -2147483648*-1)

test_true([[   sqrt(0x7fffffff)+1 ]])
test_true([[   sqrt(0x7ffffffff)+1 ]])

test_true([[ catch { destruct((mixed)0x4783647824687234628462); } ]])

test_any_equal([[
  array a = ({4711, 0x54325827a124*0x12348795482485425});
  set_weak_flag (a, 1);
  gc();
  return set_weak_flag(a, 0);
]], [[ ({4711, 0x54325827a124*0x12348795482485425}) ]])

test_any_equal([[
  mapping m = ([
    4711: 0x54325827a124*0x12348795482485425,
    0x54325827124*0x1234879548a2485425: 1174,
  ]);
  set_weak_flag (m, 1);
  gc();
  return set_weak_flag(m, 0);
]], [[ ([
  4711: 0x54325827a124*0x12348795482485425,
  0x54325827124*0x1234879548a2485425: 1174,
]) ]])

test_any([[int a=2147483648; a=a+17;  return a]], 2147483665)
test_any([[int a=2147483648; a=a-17;  return a]], 2147483631)
test_any([[int a=2147483648; a=a*17;  return a]], 36507222016)
test_any([[int a=2147483648; a=a/17;  return a]], 126322567)
test_any([[int a=2147483648; a=a%17;  return a]], 9)
test_any([[int a=2147483648; a=a^17;  return a]], 2147483665)
test_any([[int a=2147483648; a=a&17;  return a]], 0)
test_any([[int a=2147483648; a=a|17;  return a]], 2147483665)
test_any([[int a=2147483648; a=a<<17; return a]], 281474976710656)
test_any([[int a=2147483648; a=a>>17; return a]], 16384)

test_eq([[2147483648+17 ]], 2147483665)
test_eq([[2147483648-17 ]], 2147483631)
test_eq([[2147483648*17 ]], 36507222016)
test_eq([[2147483648/17 ]], 126322567)
test_eq([[2147483648%17 ]], 9)
test_eq([[2147483648^17 ]], 2147483665)
test_eq([[2147483648&17 ]], 0)
test_eq([[2147483648|17 ]], 2147483665)
test_eq([[2147483648<<17]], 281474976710656)
test_eq([[2147483648>>17]], 16384)

test_true([[ floatp((1<<99)/3.14) ]]);
test_true([[ floatp((1<<99)*3.14) ]]);
test_true([[ floatp((1<<99)-3.14) ]]);
test_true([[ floatp((1<<99)+3.14) ]]);

test_eq([[(12)+(3)]],0xf);
test_eq([[(12)+(3*(1<<32))]],0x30000000c);
test_eq([[(12)+(3*(1<<64))]],0x3000000000000000c);
test_eq([[(12)+(3*(1<<128))]],0x30000000000000000000000000000000c);
test_eq([[(12*(1<<32))+(3)]],0xc00000003);
test_eq([[(12*(1<<32))+(3*(1<<32))]],0xf00000000);
test_eq([[(12*(1<<32))+(3*(1<<64))]],0x30000000c00000000);
test_eq([[(12*(1<<32))+(3*(1<<128))]],0x300000000000000000000000c00000000);
test_eq([[(12*(1<<64))+(3)]],0xc0000000000000003);
test_eq([[(12*(1<<64))+(3*(1<<32))]],0xc0000000300000000);
test_eq([[(12*(1<<64))+(3*(1<<64))]],0xf0000000000000000);
test_eq([[(12*(1<<64))+(3*(1<<128))]],0x3000000000000000c0000000000000000);
test_eq([[(12*(1<<128))+(3)]],0xc00000000000000000000000000000003);
test_eq([[(12*(1<<128))+(3*(1<<32))]],0xc00000000000000000000000300000000);
test_eq([[(12*(1<<128))+(3*(1<<64))]],0xc00000000000000030000000000000000);
test_eq([[(12*(1<<128))+(3*(1<<128))]],0xf00000000000000000000000000000000);
test_eq([[(12)-(3)]],0x9);
test_eq([[(12)-(3*(1<<32))]],-0x2fffffff4);
test_eq([[(12)-(3*(1<<64))]],-0x2fffffffffffffff4);
test_eq([[(12)-(3*(1<<128))]],-0x2fffffffffffffffffffffffffffffff4);
test_eq([[(12*(1<<32))-(3)]],0xbfffffffd);
test_eq([[(12*(1<<32))-(3*(1<<32))]],0x900000000);
test_eq([[(12*(1<<32))-(3*(1<<64))]],-0x2fffffff400000000);
test_eq([[(12*(1<<32))-(3*(1<<128))]],-0x2fffffffffffffffffffffff400000000);
test_eq([[(12*(1<<64))-(3)]],0xbfffffffffffffffd);
test_eq([[(12*(1<<64))-(3*(1<<32))]],0xbfffffffd00000000);
test_eq([[(12*(1<<64))-(3*(1<<64))]],0x90000000000000000);
test_eq([[(12*(1<<64))-(3*(1<<128))]],-0x2fffffffffffffff40000000000000000);
test_eq([[(12*(1<<128))-(3)]],0xbfffffffffffffffffffffffffffffffd);
test_eq([[(12*(1<<128))-(3*(1<<32))]],0xbfffffffffffffffffffffffd00000000);
test_eq([[(12*(1<<128))-(3*(1<<64))]],0xbfffffffffffffffd0000000000000000);
test_eq([[(12*(1<<128))-(3*(1<<128))]],0x900000000000000000000000000000000);

test_eq([[(12)*(3)]],0x24);
test_eq([[(12)*(3*(1<<32))]],0x2400000000);
test_eq([[(12)*(3*(1<<64))]],0x240000000000000000);
test_eq([[(12)*(3*(1<<128))]],0x2400000000000000000000000000000000);
test_eq([[(12*(1<<32))*(3)]],0x2400000000);
test_eq([[(12*(1<<32))*(3*(1<<32))]],0x240000000000000000);
test_eq([[(12*(1<<32))*(3*(1<<64))]],0x24000000000000000000000000);
test_eq([[(12*(1<<32))*(3*(1<<128))]],0x240000000000000000000000000000000000000000);
test_eq([[(12*(1<<64))*(3)]],0x240000000000000000);
test_eq([[(12*(1<<64))*(3*(1<<32))]],0x24000000000000000000000000);
test_eq([[(12*(1<<64))*(3*(1<<64))]],0x2400000000000000000000000000000000);
test_eq([[(12*(1<<64))*(3*(1<<128))]],0x24000000000000000000000000000000000000000000000000);
test_eq([[(12*(1<<128))*(3)]],0x2400000000000000000000000000000000);
test_eq([[(12*(1<<128))*(3*(1<<32))]],0x240000000000000000000000000000000000000000);
test_eq([[(12*(1<<128))*(3*(1<<64))]],0x24000000000000000000000000000000000000000000000000);
test_eq([[(12*(1<<128))*(3*(1<<128))]],0x240000000000000000000000000000000000000000000000000000000000000000);
test_eq([[(12)/(3)]],0x4);
test_eq([[(12)/(3*(1<<32))]],0x0);
test_eq([[(12)/(3*(1<<64))]],0x0);
test_eq([[(12)/(3*(1<<128))]],0x0);
test_eq([[(12*(1<<32))/(3*(1<<32))]],0x4);
test_eq([[(12*(1<<32))/(3*(1<<64))]],0x0);
test_eq([[(12*(1<<32))/(3*(1<<128))]],0x0);
test_eq([[(12*(1<<64))/(3*(1<<64))]],0x4);
test_eq([[(12*(1<<64))/(3*(1<<128))]],0x0);
test_eq([[(12*(1<<128))/(3*(1<<128))]],0x4);
test_eq([[(17+12)%(3)]],0x2);
test_eq([[(17+12)%(3*(1<<32))]],0x1d);
test_eq([[(17+12)%(3*(1<<64))]],0x1d);
test_eq([[(17+12)%(3*(1<<128))]],0x1d);
test_eq([[(17+12*(1<<32))%(3*(1<<32))]],0x11);
test_eq([[(17+12*(1<<32))%(3*(1<<64))]],0xc00000011);
test_eq([[(17+12*(1<<32))%(3*(1<<128))]],0xc00000011);
test_eq([[(17+12*(1<<64))%(3*(1<<64))]],0x11);
test_eq([[(17+12*(1<<64))%(3*(1<<128))]],0xc0000000000000011);
test_eq([[(17+12*(1<<128))%(3*(1<<128))]],0x11);

test_eq([[Gmp.mpz(68719476736)/Gmp.mpz(12884901888)]],5);
test_eq([[Gmp.mpz(123456789012345678901234567890)/Gmp.mpz(12884901888)]],
	  Gmp.mpz(9581507883061474724));
test_eq([[Gmp.mpz(123456789012345678901234567890)/
	  Gmp.mpz(67890123456789012345)]],1818479371);
test_eq([[Gmp.mpz(123456789012345678901234567890)/
	  Gmp.mpz(67890123456789)]],Gmp.mpz(1818479371169857));

test_any([[int a=10->pow(30); int b=1000000000000000000000000000000;
          return ([a:1])[b]]],1);
test_any([[int a=10->pow(30); int b=1000000000000000000000000000000;
          return (<a>)[b]]],1);
test_any([[int a=10->pow(30); int b=1000000000000000000000000000000;
          return sizeof( ({a})-({b}) )]],0);
test_any([[int a=10->pow(30); int b=1000000000000000000000000000000;
          return sizeof( ({a})&({b}) )]],1);
test_any([[int k=10->pow(30);
	    array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
          return sort(a)[0]==k && sort(a)[-1]==k+17]],1)

test_any_deprecated([[ // FIXME: Uses deprecated function Process.system
   // This is a memleak test
   rm("testsuite_test.pike");
   Stdio.write_file("testsuite_test.pike",
	"constant Q=10000000000000000;\n"
	"int main() {}\n");
   Process.system(RUNPIKE +" testsuite_test.pike");
   rm("testsuite_test.pike");
   return 0;
]],0)

// test the corresponding integer operations first
test_any([[int k=100; int j=k+1;
	   array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	   array b=({j+16,j+15,j+12,j+13,j+11,j-1,j+8});
           return sizeof( a&b )]],7);
test_any([[int k=100; int j=k+1;
	   array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	   array b=({j+13,j+11,j-1,j+8,j+16,j+15,j+12});
           return sizeof( a-b )]],0);

// now the bignum ones
test_any([[int k=10->pow(30); int j=k+1;
	   array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	   array b=({j+16,j+15,j+12,j+13,j+11,j-1,j+8});
           return sizeof( a&b )]],7);
test_any([[int k=10->pow(30); int j=k+1;
	   array a=({k+17,k+16,k+13,k+14,k+12,k,k+9});
	   array b=({j+13,j+11,j-1,j+8,j+16,j+15,j+12});
           return sizeof( a-b )]],0);

ifefun(_verify_internals,
[[
  test_do(_verify_internals())
]])

test_eq("\377"[0],255)
test_do(add_constant("foo",class {int i;}()))
test_eq(foo->i,0)
test_do(foo->i=17)
test_eq(foo->i,17)
test_do(add_constant("foo"));
test_do(add_constant("foo",class {array(int) i=({0});}()))
test_eq(foo->i[0],0)
test_do(foo->i[0]=17)
test_eq(foo->i[0],17)
test_do(add_constant("foo"));

// signum, signame
test_true(intp(signum("SIGKILL")))

// kill, signal, getpid
test_true(intp(getpid()))
cond([[all_constants()->kill && (cpp("__NT__")/"\n")[-1]=="__NT__" ]],
[[
  test_do(signal(signum("SIGFPE"),lambda() { add_constant("AFJLLAF",17); }))
  test_do(kill(getpid(),signum("SIGFPE")))
  test_do(sleep(2))
  test_eq(AFJLLAF,17)
  test_do(add_constant("AFJLLAF"))
  test_do(signal(signum("SIGFPE"), 0))
  test_do(signal(signum("SIGFPE")))
]])

// typeof
test_eq(sprintf("%O", typeof(1)),"int(1)")
test_eq(sprintf("%O", typeof("")),"string(zero:)")
ignore_warning("Indexing the empty string.", [[
  test_aq([[ sprintf("%O", typeof(""[0])) ]], "zero")
]])
test_eq(sprintf("%O", typeof(0.0)),"float")
test_eq(sprintf("%O", typeof(all_constants()["all_constants"])),"mixed")
dnl The following does test not currently work as typeof("hej3") includes
dnl character values between '4' and 'd'. Test the parts instead.
dnl test_true(typeof("hej"+3) >= typeof("hej3"))
test_true(typeof("hej"+3) >= typeof("hej"))
test_true(typeof("hej"+3) >= typeof("3"))

// _typeof
test_eq(sprintf("%O", _typeof(1)),"int(1)")
test_eq(sprintf("%O", _typeof("")),"string(zero:)")
test_eq(sprintf("%O", _typeof("x"[0])),"int(120)")
test_eq(sprintf("%O", _typeof(0.0)),"float")
test_eq([[sscanf(sprintf("%Ox", _typeof(this_object))-" ",
		 "function(void|int(0..%*[0-9]):object)%*c")]], 2)


// class
test_true(programp(class {}))
test_true(functionp(class { int foo() { return 1; }}()->foo))
test_true(class { int foo() { return 1; }}()->foo())
test_true(class { int i=1; }()->i)
test_false(class { int foo() { return 1; }}()->bar)
test_eq(class { program foo = class { int i=20; }; }()->foo()->i,20)

// class()
test_true(programp(class (){}))
test_equal(indices(class (string a,protected int b){}("foo",0)), ({"a"}))
test_equal(values(class (string a,protected int b){}("foo",0)), ({"foo"}))
test_true(programp(class (string ... a){}))
test_equal(indices(class (string a,protected int ... b){}("foo",0)), ({"a"}))
test_equal(values(class (protected string a, int ... b){}("foo",0)), ({({0})}))

test_do([[
  class A (int i) {};
  class B (int i, int j) {inherit A;};
  class C {inherit B;};
  C (1,1);
]])

// type checks
test_compile_error([[} int foo() { return]]);
test_compile_error([[} void foo() { return 1]]);
test_compile([[mapping|zero a; int b; a = b = 0;]]);
test_compile_error([[mapping|zero a; int b; a = b = 1;]]);
test_compile_any([[void a(int q){} void b(function(int:void) f){} void c(){b(a);}]]);
test_compile_error_any([[void a(int i){} void b(function(:void) f){} void c(){b(a);}]]);
test_compile_any([[void a(int i){} function(int:void) b = a;]]);
test_compile_error_any([[void a(int i){} function(:void) b = a;]]);

// Duplicate local variable
test_compile_error([[void f() {int i; int i;}]]);
test_compile_error([[void f() {int i; mapping i;}]]);
test_compile_error([[void f() {int i; void i() {};}]]);
test_compile_error([[void f (int i) {string i;}]]);

// Not yet cataloged
test_any(int i=10; { int i=0; } return i, 10)
test_program(void foo(int a, int b){} function(int,int:void) a() { return foo; })
test_program(void foo(int a, int ... b){} function(int,int ...:void) a() { return foo; })
test_program(void foo(){} function(:void) a() { return foo; })
test_compile_error([[} void foo(){} function(:string) a() { return foo;]])

test_do(lambda(){return;}())
test_equal( ({ lambda() { return 3; } , lambda() { return 7; }, lambda() { return 9; } })(), ({ 3,7,9 }))
test_any(array(int) a=({10}); a[0]++; return a[0], 11)
test_any(mapping a=([10:11]); a[10]++; return a[10], 12)
test_equal(mkmapping( ({3,6,2}), ({"3","6","2"})), ([3:"3", 6:"6", 2:"2"]))
test_equal(`+(([3:"3", 6:"6", 2:"2"])), ([3:"3", 6:"6", 2:"2"]))
test_true(`+(([3:"3", 6:"6", 2:"2"])) != ([3:"3", 6:"6", 2:"2"]))

test_true(predef::stringp(""))
test_equal([["a,b,4,7,8s,asfd,a,d,f" / ","]],[["a,b,4,7,8s,asfd,a,d,f" / ","]])
test_any([[array(string) a="a,b"/","; a[0]="c"; return equal(a,({"c","b"}))]],1)
test_true(0||1)
test_true(1||0)
test_true(!0||!0)
test_true(!0&&!0)
test_any(mixed a=1; a+=1; return a,2)
test_any(mixed a=1; a-=1; return a,0)
test_equal("abcd"/"" - indices("abcd"),({"a","b","c","d"}))
test_equal("abcd"/"" & indices("abcd"),({}))
test_eq(sizeof("abcd"/"" & "de"/""),1)
test_equal( ({0,0,0,0,0}), ({0,0,0,0,0}))
test_equal( ({"object","object","object","object","object"}), allocate(5,"object"))
test_equal(mkmapping("abcd"/"","jklm"/"") | mkmapping("jclm"/"","alcd"/""),
	mkmapping("abcdjlm"/"","jklmacd"/""))
test_program(int foo() { return 17;} mixed a() { return foo() == 17; })
test_any([[mixed a; a=2; a=a*3; return a]],6)
test_any([[mixed a = ({1}); a=a+({2}); return equal(a,({1,2}))]],1)
test_define_program(test,[[int foo() { return 17; }]])
test_any(function bar=test()->foo; return bar(),17)
test_do(add_constant("test"))

// sscanf
test_any([[mixed a; return sscanf("11","%d",a)]],1)
test_any([[return sscanf("11","%*d")]],1)
test_any([[mixed a; return sscanf("11","_%d",a)]],0)
test_any([[mixed a,b,c; return sscanf("11","%1d%1d%1d",a,b,c)]],2)

test_any([[mixed a; sscanf("11","%b",a); return a]],0b11)
test_any([[mixed a; sscanf("11","%d",a); return a]],11)
test_any([[mixed a; sscanf("11","%o",a); return a]],011)
test_any([[mixed a; sscanf("11","%x",a); return a]],0x11)
test_any([[mixed a; sscanf("11","%D",a); return a]],11)

test_any([[mixed a; sscanf("11","%2b",a); return a]],0b11)
test_any([[mixed a; sscanf("11","%2d",a); return a]],11)
test_any([[mixed a; sscanf("11","%2o",a); return a]],011)
test_any([[mixed a; sscanf("11","%2x",a); return a]],0x11)
test_any([[mixed a; sscanf("11","%2D",a); return a]],11)

test_any([[mixed a; sscanf("11","%4711b",a); return a]],0b11)
test_any([[mixed a; sscanf("11","%4711d",a); return a]],11)
test_any([[mixed a; sscanf("11","%4711o",a); return a]],011)
test_any([[mixed a; sscanf("11","%4711x",a); return a]],0x11)
test_any([[mixed a; sscanf("11","%4711D",a); return a]],11)

test_any([[mixed a; sscanf("11","%1b",a); return a]],1)
test_any([[mixed a; sscanf("11","%1d",a); return a]],1)
test_any([[mixed a; sscanf("11","%1o",a); return a]],1)
test_any([[mixed a; sscanf("11","%1x",a); return a]],1)
test_any([[mixed a; sscanf("11","%1D",a); return a]],1)

test_any([[mixed a; sscanf("0x11","%D",a); return a]],0x11)
test_any([[mixed a; sscanf("011","%D",a); return a]],011)
test_any([[mixed a; return sscanf("11foo","%dfoo",a)]],1)
test_any([[mixed a; sscanf("11foo","%dfoo",a); return a]],11)
test_any([[mixed a,b; return sscanf("11foo","%d%s",a,b)]],2)
test_any([[mixed a,b; sscanf("11foo","%d%s",a,b); return b]],"foo")
test_any([[mixed a,b; return sscanf("foo","%c%s",b,a)]],2)
test_any([[mixed a,b; sscanf("foo","%c%s",b,a); return b]],'f')
test_any([[mixed a,b; sscanf("foo","%c%s",b,a); return a]],"oo")
test_any([[mixed a; return sscanf("1.0","%f",a),a]],1.0)
test_any([[mixed a; return sscanf("-1.0","%f",a),a]],-1.0)
test_any([[mixed a; return sscanf("1.25","%f",a),a]],1.25)
test_any([[mixed a; return sscanf("-1.25","%f",a),a]],-1.25)
test_any([[mixed a; return sscanf("1.25e3","%f",a),a]],1.25e3)
test_any([[mixed a; return sscanf("-1.25e3","%f",a),a]],-1.25e3)
test_any([[mixed a; return sscanf("1.25e-3","%f",a),a]],1.25e-3)
test_any([[mixed a; return sscanf("-1.25e-3","%f",a),a]],-1.25e-3)
test_any([[mixed a; sscanf("1.0","%f",a); return a]],1.0)
test_any([[mixed a,b; sscanf("-z ","%[-z]%s",a,b); return a]],"-z")
test_any([[mixed a,b; sscanf("-z ","%[z-]%s",a,b); return a]],"-z")
test_any([[mixed a,b; sscanf("abcdeFGji","%[a-z]%s",a,b); return a]],"abcde")
test_any([[mixed a,b; sscanf("abcdeFGji","%[a-z]%s",a,b); return b]],"FGji")

test_any([[mixed a,b; return sscanf("foo-%-bar","%s-%%-%s",a,b);]],2)
test_any([[mixed a,b; sscanf("foo-%-bar","%s-%%-%s",a,b); return a]],"foo")
test_any([[mixed a,b; sscanf("foo-%-bar","%s-%%-%s",a,b); return b]],"bar")
test_any([[mixed a; sscanf("ab","%2c",a); return a]],'a'*256+'b')
test_any([[mixed a; sscanf("abc","%3c",a); return a]],'a'*256*256+'b'*256+'c')
test_any([[mixed a; sscanf("abc","%2c",a); return a]],'a'*256+'b')
test_any([[mixed a; sscanf("ac","%3c",a); return a]],0)
test_any([[mixed a; sscanf("ab","%2s",a); return a]],"ab")
test_any([[mixed a; sscanf("abc","%3s",a); return a]],"abc")
test_any([[mixed a; sscanf("abc","%2s",a); return a]],"ab")
test_any([[mixed a; sscanf("ac","%3s",a); return a]],0)
test_any([[mixed a; sscanf("a3","%*s%d",a); return a]],3)
test_any([[mixed a; sscanf("a3","%s%*d",a); return a]],"a")
test_any([[mixed a; sscanf("a93","%s%*o",a); return a]],"a9")
test_any([[mixed a; sscanf("a93","%*s%o",a); return a]],3)
test_any([[mixed a; sscanf("a93","%s%*x",a); return a]],"")
test_any([[mixed a; sscanf("a93","%*s%x",a); return a]],0xa93)
test_any([[mixed a; sscanf("f","f%n",a); return a]],1)
test_any([[
    string y = "32";
    {
        string foo = "bar";
    }
    if (1 || sscanf(y, "%d", int x)) return !x;
]], 1)

define(test_sscanf, [[
    test_any([[$1 a = $3, b; string s = sprintf($2, a); sscanf(s, $2, b); return s == sprintf($2, b);]], 1)
]])
define(test_sscanf_F, [[
    test_sscanf(float, "%8F", $1)
    test_sscanf(float, "%-8F", $1)
    test_sscanf(float, "%4F", $1)
    test_sscanf(float, "%-4F", $1)
]])
test_sscanf_F(Math.e)
test_sscanf_F(Math.pi)
test_sscanf_F(Math.nan)
test_sscanf_F(Math.inf)

test_any([[mixed a; sscanf("\102\052\100\000","%F",a); return a]],42.5625)
test_any([[mixed a; sscanf("\102\052\100\000","%4F",a); return a]],42.5625)
test_any([[mixed a; sscanf("\100\105\110\000\0\0\0\0","%8F",a); return a]],42.5625)
test_any([[mixed a; sscanf("\275\007\053\002","%4F",a); return a]],-0.032999999821186065673828125)
test_any([[mixed a; sscanf("\277\240\345\140\100\0\0\0","%8F",a); return a]],-0.032999999821186065673828125)

// Inf
test_any([[mixed a; sscanf("\177\200\0\0","%4F",a); return a>0.0]],1)
test_any([[mixed a; sscanf("\177\200\0\0","%4F",a); return (a/2)==a]],1)
// -Inf
test_any([[mixed a; sscanf("\377\200\0\0","%4F",a); return a<0.0]],1)
test_any([[mixed a; sscanf("\377\200\0\0","%4F",a); return (a/2)==a]],1)
// NaN
test_any([[mixed a; sscanf("\177\300\0\0","%4F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\177\300\0\0","%4F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\177\300\0\0","%4F",a); return a==0.0]],0)
// -NaN
test_any([[mixed a; sscanf("\377\300\0\0","%4F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\377\300\0\0","%4F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\377\300\0\0","%4F",a); return a==0.0]],0)

// Inf
test_any([[mixed a; sscanf("\177\360\0\0\0\0\0\0","%8F",a); return a>0.0]],1)
test_any([[mixed a; sscanf("\177\360\0\0\0\0\0\0","%8F",a); return(a/2)==a]],1)
// -Inf
test_any([[mixed a; sscanf("\377\360\0\0\0\0\0\0","%8F",a); return a<0.0]],1)
test_any([[mixed a; sscanf("\377\360\0\0\0\0\0\0","%8F",a); return(a/2)==a]],1)
// NaN
test_any([[mixed a; sscanf("\177\370\0\0\0\0\0\0","%8F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\177\370\0\0\0\0\0\0","%8F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\177\370\0\0\0\0\0\0","%8F",a); return a==0.0]],0)
// -NaN
test_any([[mixed a; sscanf("\377\370\0\0\0\0\0\0","%8F",a); return a>0.0]],0)
test_any([[mixed a; sscanf("\377\370\0\0\0\0\0\0","%8F",a); return a<0.0]],0)
test_any([[mixed a; sscanf("\377\370\0\0\0\0\0\0","%8F",a); return a==0.0]],0)

test_equal([[array_sscanf("10 20 30","%d %d %d")]],[[({10,20,30})]])
test_equal([[array_sscanf("1 2 3 4 5 6 7 8 9","%d %d %d %d %d %d %d %d %s")]],[[({1,2,3,4,5,6,7,8,"9"})]])
test_equal([[array_sscanf("abc","%{%c%}")]],[[ ({ ({ ({'a'}), ({'b'}), ({'c'}) }) }) ]])

test_equal([[array_sscanf("\x7fffffab#", "%c%c")]], [[ ({ 0x7fffffab, '#' }) ]])
test_equal([[array_sscanf("\x7fffffab#", "%1c%1c")]], [[ ({  }) ]])

test_true([[array_sscanf("(02323) 23455 344","%{%*[^0-9]%[0-9]%}")]])

test_eq([[ array_sscanf(sprintf("%4c",16909060),"%4c")[0] ]],16909060)
test_eq([[ array_sscanf(sprintf("%-4c",16909060),"%-4c")[0] ]],16909060)
test_eq([[ array_sscanf(sprintf("%4c",16909060),"%+4c")[0] ]],16909060)
test_eq([[ array_sscanf(sprintf("%-4c",16909060),"%+-4c")[0] ]],16909060)
test_eq([[ array_sscanf(sprintf("%4c",-16909060),"%+4c")[0] ]],-16909060)
test_eq([[ array_sscanf(sprintf("%-4c",-16909060),"%+-4c")[0] ]],-16909060)

test_equal([[array_sscanf("\1000\1001\2000","%[\1000-\1111]%s")]],
	[[ ({ "\1000\1001", "\2000" }) ]])

test_equal([[array_sscanf("foo\1000\1001\1111\1110\2000","%s%[\1000-\1111]%s")]],
	[[ ({ "foo", "\1000\1001\1111\1110", "\2000" }) ]])

test_equal([[array_sscanf("\2000\1000\1111\1001\1110foo","%s%[\1000-\1111]%s")]],
	[[ ({  "\2000", "\1000\1111\1001\1110", "foo"}) ]])

test_equal([[ array_sscanf("02 00 DC 00 0B","%{%x%*[\0-/:-@]%}")[0] ]],
    [[ ({ ({2}), ({0}), ({220}),({0}), ({11}) }) ]])

test_equal([[ array_sscanf("\51726\30212\66610\30131", "%*[ \t]%s")[0] ]],
    [[ "\51726\30212\66610\30131" ]])

test_equal([[ array_sscanf("hej","%s") ]], [[ ({ "hej" }) ]])
test_equal([[ array_sscanf("hej","%s%n") ]], [[ ({ "hej", 3 }) ]])
test_equal([[ array_sscanf("hejhopp", "%*!3s%s%n") ]], [[ ({ "hopp", 4 }) ]])
test_eval_error([[ function f=array_sscanf; f("hej","%s% ") ]])

test_equal([[ array_sscanf("\x304b\x3066\x3044\x308a\x3087\x3046\x308a", "%[^\x3042\x3044\x3046\x3048\x304a]")[0] ]],
    [[ "\x304b\x3066" ]])

test_equal( array_sscanf("xfoox", "%sfoo%s"), ({ "x", "x" }) )
test_equal( array_sscanf("xfoox", "%sfo\400%s"), ({}) )
test_equal( array_sscanf("xfoox", "%sfo\200000%s"), ({}) )
test_equal( array_sscanf("xfo\400x", "%sfoo%s"), ({}) )
test_equal( array_sscanf("xfo\400x", "%sfo\400%s"), ({ "x", "x" }) )
test_equal( array_sscanf("xfo\400x", "%sfo\200000%s"), ({}) )
test_equal( array_sscanf("xfo\200000x", "%sfoo%s"), ({}) )
test_equal( array_sscanf("xfo\200000x", "%sfo\400%s"), ({}) )
test_equal( array_sscanf("xfo\200000x", "%sfo\200000%s"), ({ "x", "x" }) )

dnl sscanf("", ...) triggers this warning.
ignore_warning("Indexing the empty string.", [[
test_any([[mixed a; sscanf("","%H",a); return a]],0)
test_any([[mixed a; sscanf("\0","%H",a); return a]],"")
test_any([[mixed a; sscanf("\4","%H",a); return a]],0)
test_any([[mixed a; sscanf("\4hello","%H",a); return a]],"hell")
test_eval_error([[mixed a; sscanf("","%0H",a); return a]])
test_eval_error([[mixed a; sscanf("\0","%0H",a); return a]])
test_eval_error([[mixed a; sscanf("\4","%0H",a); return a]])
test_eval_error([[mixed a; sscanf("\4hello","%0H",a); return a]])
test_any([[mixed a; sscanf("","%1H",a); return a]],0)
test_any([[mixed a; sscanf("\0","%1H",a); return a]],"")
test_any([[mixed a; sscanf("\4","%1H",a); return a]],0)
test_any([[mixed a; sscanf("\4hello","%1H",a); return a]],"hell")
test_any([[mixed a; sscanf("","%-1H",a); return a]],0)
test_any([[mixed a; sscanf("\0","%-1H",a); return a]],"")
test_any([[mixed a; sscanf("\4","%-1H",a); return a]],0)
test_any([[mixed a; sscanf("\4hello","%-1H",a); return a]],"hell")
test_any([[mixed a; sscanf("","%2H",a); return a]],0)
test_any([[mixed a; sscanf("\0\0","%2H",a); return a]],"")
test_any([[mixed a; sscanf("\0","%2H",a); return a]],0)
test_any([[mixed a; sscanf("\0\4","%2H",a); return a]],0)
test_any([[mixed a; sscanf("\0\4hello","%2H",a); return a]],"hell")
test_any([[mixed a; sscanf("","%-2H",a); return a]],0)
test_any([[mixed a; sscanf("\0\0","%-2H",a); return a]],"")
test_any([[mixed a; sscanf("\4","%-2H",a); return a]],0)
test_any([[mixed a; sscanf("\4\0","%-2H",a); return a]],0)
test_any([[mixed a; sscanf("\4\0hello","%-2H",a); return a]],"hell")
]])

test_any([[
class Bar {
  string sum = "";
  void bar(string s) {
    sum += s;
  }
  string foo()
  {
    foreach(({ "foo ", "bar ", "baz " }), string s) {
      sscanf(s, "%*[\t ]%[^ \t]", s);
      switch(foo) {
      default:
        bar(s);
        break;
      }
    }
    return sum;
  }
};
  return Bar()->foo()
]], "foobarbaz")

test_equal( array_sscanf("^^;|", "%[^-|]%s"), ({ "^^", ";|" }) )
test_any([[mixed a; sscanf("^^;|","%[^-|]",a); return a]],"^^")

// sscanf %O -------------------------------------------------------------

define(test_percent_o_raw, [[
   test_equal(array_sscanf(]]$3[[,]]$1[[),[[$2]])
]])
define(test_percent_o_fmt, [[
   test_percent_o_raw(]]$1[[,]]$2[[,sprintf(]]$1[[,@]]$2[[))
]])
define(test_percent_o_char, [[
dnl patsubst doesn't exist on all m4's (it's a gnuism?)
ifdef(patsubst,[[
  test_percent_o_raw("%O",({']]$1[['}),"']]patsubst($1,\\,\\\\)[['"))
  test_percent_o_raw("%O%s",({']]$1[[',"abc"}),"']]patsubst($1,\\,\\\\)[['abc"))
]])]])
ifdef(patsubst,[[
define(test_percent_o_string, [[
  test_percent_o_raw("%O",({"]]$1[["}),"\"]]patsubst($1,\\,\\\\)[[\""))
  test_percent_o_raw("%O%s",({"]]$1[[","abc"}),"\"]]patsubst($1,\\,\\\\)[[\"abc"))
]])]])

test_percent_o_fmt("%O",({10}))
test_percent_o_fmt("%O%s",({10,"abc"}))

test_percent_o_char([[a]])
test_percent_o_char([[\a]])
test_percent_o_char([[\123]])
test_percent_o_char([[\x4711]])
test_percent_o_char([[\d4711]])

test_percent_o_string([[a]])
test_percent_o_string([[\a]])
test_percent_o_string([[\123]])
test_percent_o_string([[\x4711]])
test_percent_o_string([[\d4711]])

test_percent_o_fmt("%O %O %O",({10,20,30}))
test_percent_o_fmt("%O %O %s",({10,20,"30"}))

// -------------------------------------------------------------



// Basics
test_true(1)
test_true("")
test_true(!0)
test_true(!(!1))
test_true(this)
test_true(a) // a is the test function
test_true(0.0)
test_true(([]))
test_true(({}))
test_true((<>))
test_true(this_program)

// testing !
test_equal(!"",0)
test_equal(!this,0)

// testing ==
test_true(1==1)
test_true(!(1==2))
test_true(""=="")
test_true(!(""=="foo"))
test_true(this==this)
test_true(2.0==2.0)
test_true(({})==({}))

// testing !=
test_true(({1})!=({1}))
test_true(1!=2)
test_true(!(1==2))
test_true(!(""!=""))
test_true(""!="foo")

test_cmp3(1,2,3)
test_cmp3(1.0,2.0,3.0)
test_cmp3(1,2.0,3.6)
test_cmp3(1.0,2,4)
test_cmp3("a","b","c")
test_cmp3("","b","cc")
test_cmp3("\x0","\x100","\x10000")
test_cmp3("a\x10000","b\x100","c\x100")

// hex construction
test_eq(0,0x0)
test_eq(1,0x1)
test_eq(10,0xa)
test_eq(16,0x10)
test_eq(65535,0xffff)
test_eq(17*257*65537,0x11111111)

// octal construction
test_eq(0,00)
test_eq(1,01)
test_eq(8,010)
test_eq(64,0100)
test_eq(1073741824,010000000000)
test_eq((8+1)*(8*8+1)*(8*8*8*8+1),011111111)

// string construction tests
test_eq(16,"\20"[0])
test_eq(16,"\020"[0])
test_eq(255,"\377"[0])
test_eq(4,'\4')
test_eq('a',0x61)
test_eq('ab',0x6162)
test_eq('abc',0x616263)
test_eq('abcd',0x61626364)
test_true("\r"[-1]!='r')
test_eq("\r"[0],'\r')
test_eq("\n"[0],'\n')

// testing +
test_eq(1+1,2)
test_eq(1+(-2),-1)
test_eq((-2)+(-2),-4)
test_eq("hi"+"there","hithere")
test_eq("human"+"number"+666,"humannumber666")
test_eq("human"+("number"+666),"humannumber666")
test_eq(("human"+"number")+666,"humannumber666")
test_eq(("human"+"number")+666+111,"humannumber666111")
test_eq("humannumber"+(666+111),"humannumber777")
test_eq("a"+"b"+"c"+"d"+"e"+"f"+"g"+"h"+"i"+"j"+"k"+"l"+"m"+"n"+"o"+"p"+"q"+"r"+"s"+"t"+"u"+"v"+"x"+"y","abcdefghijklmnopqrstuvxy")
test_eq(1.0+1.0,2.0)
test_eq(1.0+(-1.0),0.0)
test_eq((-1.0)+(-1.0),-2.0)
test_eq(1.0+1,2.0)
test_eq(1+1.0,2.0)
test_eq(1+(-1.0),0.0)
test_eq(1.0+(-1),0.0)
test_eq((-1)+(-1.0),-2.0)
test_eq((-1.0)+(-1),-2.0)
test_equal(({1,2,3})+({4,5,6}),({1,2,3,4,5,6}))
test_equal((<1,2,3,4>)+(<4,5,6>),(<1,2,3,4,4,5,6>))
test_equal(([0:1,3:6])+([5:2,3:6]),([0:1,3:6,3:6,5:2]))
test_eval_error(return this + this)
test_any(return((1+2+3)-(1+2-3)), 6)

// testing F_APPEND_MAPPING
test_any([[
    // F_APPEND_MAPPING is not used when adding constant mappings
    string index = "foo";
    mapping m = ([ "foo" : 1 ]);
    m += ([ index : 2 ]);
    return m->foo;
]], 2)


// testing -
test_eq(10-3,7)
test_eq(3-10,-7)
test_eq(10.0-3.0,7.0)
test_eq(3.0-10.0,-7.0)
test_eq(10-3.0,7.0)
test_eq(3-10.0,-7.0)
test_eq(10.0-3,7.0)
test_eq(3.0-10,-7.0)
test_eq(034567 - 10000,4711)
test_eq("foobargazonk"-"o","fbargaznk")
test_equal(({"foo","bar","gazonk"})-({"foo","gazonk"}),({"bar"}))
test_equal(({"c","foo","bar","gazonk","a","b",})-({"foo","gazonk"}),({"c","bar","a","b"}))
test_equal((<"foo","bar","gazonk">)-(<"foo","gazonk">),(<"bar">))
test_equal((["foo":3,"bar":4,"gazonk":5])-(["foo":3,"gazonk":8]),(["bar":4]))

test_any([[string s="\57070 abcdefghijklmnopqrstuvwxyz012345678"; return strlen(s-s[1..35])]],37-35)

// testing ~
test_eq(-1-4,~4)
test_eq(-1-627893874,~627893874)
test_eq(~1.0,-2.0)
test_eq(~"\x55","\xaa")

// testing *
test_eq(3*4,12)
test_eq(4*3,12)
test_eq(2*2*2*2*2,32)
test_eq(3.0*4.0,12.0)
test_eq(4.0*3.0,12.0)
test_eq(2.0*2.0*2.0*2.0*2.0,32.0)
test_eq(3*4.0,12.0)
test_eq(4*3.0,12.0)
test_eq(2*2.0*2.0*2.0*2.0,32.0)
test_eq(3.0*4,12.0)
test_eq(4.0*3,12.0)
test_eq(2.0*2*2.0*2*2.0,32.0)

test_eq([[({})*""]],"")
test_eq([[({"foo",0,"bar"})*"-"]],"foo-bar")
test_eq([[({"f","o","o"})*""]],"foo")

test_eq(({"foo","bar","gazonk"})*"-","foo-bar-gazonk")
test_eq(({"f\777\777","bar","gaz\777nk"})*"-","f\777\777-bar-gaz\777nk")
test_eq(({"f\7777777\7777777","bar","gaz\7777777nk"})*"-","f\7777777\7777777-bar-gaz\7777777nk")

test_eq(({"foo","bar","gazonk"})*"\777","foo\777bar\777gazonk")
test_eq(({"f\777\777","bar","gaz\777nk"})*"\777","f\777\777\777bar\777gaz\777nk")
test_eq(({"f\7777777\7777777","bar","gaz\7777777nk"})*"\777","f\7777777\7777777\777bar\777gaz\7777777nk")

test_eq(({"foo","bar","gazonk"})*"\7777777","foo\7777777bar\7777777gazonk")
test_eq(({"f\777\777","bar","gaz\777nk"})*"\7777777","f\777\777\7777777bar\7777777gaz\777nk")
test_eq(({"f\7777777\7777777","bar","gaz\7777777nk"})*"\7777777","f\7777777\7777777\7777777bar\7777777gaz\7777777nk")


test_equal( ({ ({1}), ({2}), ({3}) })*({8}), ({1,8,2,8,3}))
test_equal( ({ 1 })*3, ({1,1,1}) )
test_equal( "foo"*3, "foofoofoo" )
test_equal( "foo"*2.5, "foofoofo" )
test_equal( "\1234oo"*2.5, "\1234oo\1234oo\1234o" )

test_equal( ({1,2,3})*1.5, ({1,2,3,1,2}))
test_equal( ({1,2,3})*1.4, ({1,2,3,1}))
test_equal( ({1,2,3})*0.0, ({}))
test_equal( ({})*3.0, ({}))



// testing /
test_eq(12/3,4)
test_eq(13/3,4)
test_eq(14/3,4)
test_eq(15/3,5)
test_eq(-2/4,-1)
test_eq(-12/3,-4)
test_eq(-13/3,-5)
test_eq(-14/3,-5)
test_eq(-15/3,-5)
test_eval_error(return 15/0)
test_eq(12.0/3.0,4.0)
test_eq(14.0/4.0,3.5)
test_eq(15.0/3.0,5.0)
test_eq(12/3.0,4.0)
test_eq(14/4.0,3.5)
test_eq(15/3.0,5.0)
test_eq(12.0/3,4.0)
test_eq(14.0/4,3.5)
test_eq(15.0/3,5.0)
test_eval_error(return 15.0/0.0)
test_equal("foo-bar-gazonk"/"-",({"foo","bar","gazonk"}))
test_equal("foobargazonk"/"",({"f","o","o","b","a","r","g","a","z","o","n","k"}))
test_equal(({1,0,1,2,1,2,2,2,1,1,1})/({2}),({ ({1,0,1}), ({1}), ({}), ({}), ({1,1,1}) }))
test_equal(({1,2,3,4})/({}),({ ({1}), ({2}), ({3}), ({4}) }))
test_eq(sizeof(allocate(119)/({})), 119)
test_eq(sizeof(allocate(120)/({})), 120)
test_eq(sizeof(allocate(121)/({})), 121)
test_eq(sizeof(allocate(122)/({})), 122)
test_equal(({1,0,1,2,1,2,2,2,1,1,1})/({2,1}),({ ({1,0,1}), ({2,2}), ({1,1}) }))
test_equal( ({1,2,3})/({2,3}), ({ ({1}), ({}) }) )
test_eq([[`/(20,2,2)]],5)
test_eq([[`/(13,2,3)]],2)
test_equal("foobargazonk"/1,"foobargazonk"/"")
test_equal("foobargazonk"/2,({"fo","ob","ar","ga","zo","nk"}))
test_equal("foobargazonk"/3,({"foo","bar","gaz","onk"}))
test_equal("foobargazonk"/4,({"foob","arga","zonk"}))
test_equal("foobargazonk"/5,({"fooba","rgazo"}))
test_equal("foobargazonk"/-6,({"foobar","gazonk"}))
test_equal("foobargazonk"/-7,({"rgazonk"}))
test_eq(({})/100.0, ({}));
test_eq(({})/100, ({}));

test_equal("foobargazonk"/5.0,({"fooba","rgazo","nk"}))
test_equal("foobargazonk"/-5.0,({"fo","obarg","azonk"}))
test_equal("foobargazonk"/2.5,({"foo","ba","rga","zo","nk"}))
test_equal("foo"/2.6,({"foo",""}))
test_equal("\1233oo"/2.6,({"\1233oo",""}))

test_equal("f\777\777bargaz\777nk"/1,"f\777\777bargaz\777nk"/"")
test_equal("f\777\777bargaz\777nk"/2,({"f\777","\777b","ar","ga","z\777","nk"}))
test_equal("f\777\777bargaz\777nk"/3,({"f\777\777","bar","gaz","\777nk"}))
test_equal("f\777\777bargaz\777nk"/4,({"f\777\777b","arga","z\777nk"}))
test_equal("f\777\777bargaz\777nk"/5,({"f\777\777ba","rgaz\777"}))
test_equal("f\777\777bargaz\777nk"/-6,({"f\777\777bar","gaz\777nk"}))
test_equal("f\777\777bargaz\777nk"/-7,({"rgaz\777nk"}))

test_equal("f\777\777bargaz\777nk"/5.0,({"f\777\777ba","rgaz\777","nk"}))
test_equal("f\777\777bargaz\777nk"/-5.0,({"f\777","\777barg","az\777nk"}))
test_equal("f\777\777bargaz\777nk"/2.5,({"f\777\777","ba","rga","z\777","nk"}))

test_equal(""/"hej", ({""}))
test_equal("hej"/"hej", ({"",""}))
test_equal("f\7777777\7777777bargaz\7777777nk"/1,"f\7777777\7777777bargaz\7777777nk"/"")
test_equal("f\7777777\7777777bargaz\7777777nk"/2,({"f\7777777","\7777777b","ar","ga","z\7777777","nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/3,({"f\7777777\7777777","bar","gaz","\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/4,({"f\7777777\7777777b","arga","z\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/5,({"f\7777777\7777777ba","rgaz\7777777"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/-6,({"f\7777777\7777777bar","gaz\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/-7,({"rgaz\7777777nk"}))

test_equal("f\7777777\7777777bargaz\7777777nk"/5.0,({"f\7777777\7777777ba","rgaz\7777777","nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/-5.0,({"f\7777777","\7777777barg","az\7777777nk"}))
test_equal("f\7777777\7777777bargaz\7777777nk"/2.5,({"f\7777777\7777777", "ba","rga","z\7777777","nk"}))

test_equal(({1,2,3})/1,({ ({1}), ({2}), ({3}) }))
test_equal(({1,2,3})/2,({ ({1,2}) }))
test_equal(({1,2,3})/-2,({ ({2,3}) }))

test_equal(({1,2,3})/2.0,({ ({1,2}), ({3}) }))
test_equal(({1,2,3})/-2.0,({ ({1}), ({2,3}) }))
test_equal(({1,2,3})/1.5,({ ({1, 2}), ({3}) }))

// testing %
test_eq(12%3,0)
test_eq(13%3,1)
test_eq(14%3,2)
test_eq(15%3,0)
test_eq(2%17,2)
test_eq(2%-17,-15)
test_eq(-2%17,15)
test_eq(-2%-17,-2)
test_eq(-10%10,0)
test_eq(10%-10,0)
test_eq(-10%-10,0)
test_eq(10%10,0)
test_eval_error(return 15 % 0)
test_eq(12.0 % 3.0,0.0)
test_eq(13.0 % 3.0,1.0)
test_eq(14.0 % 3.0,2.0)
test_eq(14.5 % 3.0,2.5)
test_eq(15.0 % 3.0,0.0)
test_eq(13 % 3.0,1.0)
test_eq(14 % 3.0,2.0)
test_eq(13.0 % 3,1.0)
test_eq(14.0 % 3,2.0)
test_eq(14.5 % 3,2.5)
test_eval_error(return 15.0 % 0.0)

test_eq("foobargazonk"%5,"nk")
test_eq("foobargazonk"%-5,"fo")
test_eq("f\777\777bargaz\777nk"%5,"nk")
test_eq("f\777\777bargaz\777nk"%-5,"f\777")
test_eq("f\7777777\7777777bargaz\7777777nk"%5,"nk")
test_eq("f\7777777\7777777bargaz\7777777nk"%-5,"f\7777777")
test_equal(({1,2,3})%2,({3}))
test_equal(({1,2,3})%-2,({1}))


// testing &&
test_eq(0 && 1,0)
test_eq(1 && 0,0)
test_eq(0 && 0,0)
test_eq(1 && 1,1)
test_eq(78 && 1,1)
test_eq(78 && 99,99)
test_eq(78 && 99,99)

// testing ||
test_eq(0 || 1,1)
test_eq(1 || 0,1)
test_eq(0 || 0,0)
test_eq(1 || 1,1)
test_eq(78 || 1,78)
test_eq(78 || 0,78)

// testing |
test_eq(0 | 0,0)
test_eq(1 | 1,1)
test_eq(4 | 1,5)
test_eq(1 | 9,9)
test_eq([[ "\007" | "\023"]],"\027")
test_eq([[ "\177777x" | "ab" ]], "\177777z")
test_equal( ({1,2,3,4,4}) | ({3,5,6}), ({1,2,3,4,4,5,6}))
test_equal( (<4,5,6>) | (<5,5,5>), (<4,5,5,5,6>) )
test_equal( ([-4:8,8:7]) | ([3:3,8:3]), ([-4:8,8:3,3:3]) )
test_any([[
  class Foo {protected int `< (object o) {return 0;}};
  return sizeof (({Foo()}) | ({Foo()}));
]], 2)

// testing &
test_eq(0 & 0,0)
test_eq(1 & 1,1)
test_eq(4 & 1,0)
test_eq(1 & 9,1)
test_eq([[ "\007" & "\023"]],"\003")
test_eq([[ "\177777x" & "ab" ]], "a`")
test_equal( ({1,2,3,4,4}) & ({3,5,6}), ({3}))
test_equal( (<4,5,6>) & (<5,5,5>), (<5>) )
test_equal( ([-4:8,8:7]) & ([3:3,8:3]), ([8:3]) )
test_equal(({1,2,1}) & ({1,2}), ({1,2}))
test_equal(({2,1,2}) & ({1,2}), ({2,1}))
test_equal(({1,2,1,2,2}) & ({1,2}), ({1,2}))
test_equal(({2,1,2,1,2}) & ({1,2}), ({2,1}))

// testing ^
test_eq(0 ^ 0,0)
test_eq(1 ^ 1,0)
test_eq(4 ^ 1,5)
test_eq(1 ^ 9,8)
test_eq([[ "\007" ^ "\023"]],"\024")
test_eq([[ "\177777x" ^ "ab" ]], "\177636\32")
test_equal( ({1,2,3,4,4}) ^ ({3,5,6}) , ({1,2,4,4,5,6}))
test_equal( (<4,5,6>) ^ (<5,5,5>), (<4,5,5,6>) )
test_equal( ([-4:8,8:7]) ^ ([3:3,8:3]), ([-4:8,3:3]) )
test_equal(({1,3,3,3,4}) ^ ({2,3,3,5}), ({1,3,4,2,5}))
test_equal(({1,3,3,4}) ^ ({2,3,3,3,5}), ({1,4,2,3,5}))
test_any([[
  string(7bit) cyrillic_to_7bit(string(0x401..0x45f) text) {
    return text ^ "\u0400"*sizeof(text);
  }
  return cyrillic_to_7bit("\u041d\u0435\u0442");
]], "\35""5B")

// testing <<
test_eq(1<<0,1)
test_eq(1<<1,2)
test_eq(1<<10,1024)
test_eq(5<<3,40)
test_eval_error(return 17<<-10)

// testing >>
test_eq(9>>2,2)
test_eq(1>>1,0)
test_eq(1024>>10,1)
test_eq(47>>3,5)
test_eq(-10>>10000,-1)
test_eval_error(return 17>>-10)

// testing ? :
test_true(0?0:1)
test_true(1?1:0)
test_true(""?1:0)
test_true(!0?1:0)
test_true(!(!1)?1:0)
test_true(this?1:0)
test_true(a?1:0) // a is the test function
test_true(0.0?1:0)
test_true(([])?1:0)
test_true(({})?1:0)
test_true((<>)?1:0)
test_true(this_program?1:0)
test_eq(1 ? "a" : 1 ? "b" : 1, "a")
test_eq(0 ? "a" : 1 ? "b" : 1 ? "c" : 1, "b")
test_eq(0 ? "a" : 0 ? "b" : 1 ? "c" : 1, "c")

// testing overflow checks
test_eq(-1 - 0x7fffffff, -0x80000000)
test_eq(Int.NATIVE_MIN % -1, 0)
test_eq(Int.NATIVE_MAX % Int.NATIVE_MIN, -1)

// testing indexing
test_eq("foo"[0],'f')
test_eq("foo"[1],'o')
test_eq("foo"[2],'o')
test_eq("foo"[-1],'o')
test_eq("foo"[-2],'o')
test_eq("foo"[-3],'f')

test_eq("f\777\777"[0],'f')
test_eq("f\777\777"[1],'\777')
test_eq("f\777\777"[2],'\777')
test_eq("f\777\777"[-1],'\777')
test_eq("f\777\777"[-2],'\777')
test_eq("f\777\777"[-3],'f')

test_eq("f\77777777\77777777"[0],'f')
test_eq("f\77777777\77777777"[1],'\77777777')
test_eq("f\77777777\77777777"[2],'\77777777')
test_eq("f\77777777\77777777"[-1],'\77777777')
test_eq("f\77777777\77777777"[-2],'\77777777')
test_eq("f\77777777\77777777"[-3],'f')

test_eq(({'f','o','o'})[0],'f')
test_eq(({'f','o','o'})[1],'o')
test_eq(({'f','o','o'})[2],'o')
test_eq(({'f','o','o'})[-1],'o')
test_eq(({'f','o','o'})[-2],'o')
test_eq(({'f','o','o'})[-3],'f')
test_eq(([0:'f',1:'o',2:'o'])[0],'f')
test_eq(([0:'f',1:'o',2:'o'])[1],'o')
test_eq(([0:'f',1:'o',2:'o'])[2],'o')
test_eq(([0:'f',1:'o',2:'o'])[random(0)+3],0)
test_eq(([0:'f',1:'o',2:'o'])[random(0)-1],0)
test_eq((<'f','o','o'>)['o'],1)
test_eq((<'f','o','o'>)['f'],1)
test_eq((<'f','o','o'>)[random(0)+'b'],0)
test_eq((<'f','o','o'>)[ [int](mixed)-1],0)

test_eq([[class { protected mixed `->(mixed x) { return this[x]; } int foo() { return 1; }}()->foo()]],1)

// Test some indexing opcodes.
test_eval_error([[return ({1})[1];]])
test_eval_error([[int i = 1; return ({1})[i];]])
test_eval_error([[array a = ({ 1 }); return a[1];]])
test_eval_error([[array a = ({ 1 }); int i = 1; return a[i];]])

// index assigning
test_any(mixed a=({1}); a[0]=2; return equal(a,({2})),1)
test_any(mixed a=(<1>); a[1]=2; return equal(a,(<1>)),1)
test_any(mixed a=(<1>); a[0]=2; return equal(a,(<1,0>)),1)
test_any(mixed a=(<1>); a[1]=0; return equal(a,(<>)),1)
test_any(mixed a=(<1>); a[0]=0; return equal(a,(<1>)),1)
test_any(mixed a=([1:1]); a[0]=0; return equal(a,([1:1,0:0])),1)
test_any(mixed a=([1:1]); a[1]=0; return equal(a,([1:0])),1)
test_any(mixed a="hej"; a[1]='o'; return a,"hoj")
test_do( string x=" "*73; x[64]=1; x[65]=1; )

test_define_program(test,[[public int q,w,e,r; mixed t; mixed getw() { return w; } void setw(int _) { w=_; }]])
test_eq(test()->q,0)
test_eq(test()->w,0)
test_eq(test()->e,0)
test_eq(test()->r,0)
test_eq(test()->getw(),0)
test_any(object o=test(); o->setw(17); return o->w,17)
test_any(object o=test(); o->w=17; return o->getw(),17)

test_eq(test()["q"],0)
test_eq(test()["w"],0)
test_eq(test()["e"],0)
test_eq(test()["r"],0)
test_eq(test()["getw"](),0)
test_any(object o=test(); o["setw"](17); return o["w"],17)
test_any(object o=test(); o["w"]=17; return o["getw"](),17)
test_do(add_constant("test");)

// testing range
test_eq("foObar"[0..0],"f")
test_eq("foobargazonk"[3..5],"bar")
test_eq("foo"[1..10],"oo")
test_eq("foo"[-100..0],"f")
test_eq("foo"[-100..100],"foo")
ignore_warning("Range is always empty.", [[
  test_any(return "foo"[1..0];,"")
]])
test_any(int u=-100; return "foo"[0..u];,"") dnl Use variable to avoid warning.
test_eq("foobargazonk"[0..],"foobargazonk")
test_eq("foobargazonk"[1..],"oobargazonk")
test_eq("foobargazonk"[5..],"rgazonk")
test_eq("foobargazonk"[..2],"foo")
test_eq("foobargazonk"[..5],"foobar")
test_eq("1234"[..Int.NATIVE_MAX], "1234")
test_eq("1234"[..Int.NATIVE_MAX - 1], "1234")
test_eq("1234"[Int.NATIVE_MIN..], "1234")
test_eq("1234"[Int.NATIVE_MIN + 1..], "1234")

test_eq("f\7777\7777bargaz\7777nk"[0..],"f\7777\7777bargaz\7777nk")
test_eq("f\7777\7777bargaz\7777nk"[1..],"\7777\7777bargaz\7777nk")
test_eq("f\7777\7777bargaz\7777nk"[5..],"rgaz\7777nk")
test_eq("f\7777\7777bargaz\7777nk"[..2],"f\7777\7777")
test_eq("f\7777\7777bargaz\7777nk"[..5],"f\7777\7777bar")

test_eq("f\77777777\77777777bargaz\77777777nk"[0..],"f\77777777\77777777bargaz\77777777nk")
test_eq("f\77777777\77777777bargaz\77777777nk"[1..],"\77777777\77777777bargaz\77777777nk")
test_eq("f\77777777\77777777bargaz\77777777nk"[5..],"rgaz\77777777nk")
test_eq("f\77777777\77777777bargaz\77777777nk"[..2],"f\77777777\77777777")
test_eq("f\77777777\77777777bargaz\77777777nk"[..5],"f\77777777\77777777bar")

test_eq("ABCD\u2019"[1..][1..], "ABCD\u2019"[2..])

test_any_equal([[
  // Bug 7780
  string s1 = "aaaaa";
  string s2 = "BBBBBBBB";
  s2 = (s2 + s1)[..sizeof(s1) - 1];
  return (array)s2;
]], ({ 66, 66, 66, 66, 66 }))

test_equal(({1,2,3})[0..0],({1}))
test_equal(({1,2,3})[1..2],({2,3}))
test_equal(({1,2,3})[2..10],({3}))
test_equal(({1,2,3})[-100..0],({1}))
test_equal(({1,2,3})[-100..100],({1,2,3}))
ignore_warning("Range is always empty.", [[
  test_any_equal(return ({1,2,3})[1..0];,({}))
]])
test_any_equal(int u=-100; return ({1,2,3})[0..u];,({})) dnl Use variable to avoid warning.

test_eq("abcdef"[1..3],   "bcd")
test_eq("abcdef"[1..<3],  "bc")
test_eq("abcdef"[1..],    "bcdef")
test_eq("abcdef"[<1..3],  "")
test_eq("abcdef"[<1..<3], "")
test_eq("abcdef"[<1..],   "ef")
test_eq("abcdef"[<3..3],  "cd")
test_eq("abcdef"[<3..<3], "c")
test_eq("abcdef"[<3..],   "cdef")
test_eq("abcdef"[..3],    "abcd")
test_eq("abcdef"[..<3],   "abc")
ignore_warning("Redundant range operator.", [[
  test_eq("abcdef"[..],     "abcdef")
]])

test_equal(`[..] ("abcdef"/"", 1, Pike.INDEX_FROM_BEG, 3, Pike.INDEX_FROM_BEG), "bcd"/"");
test_equal(`[..] ("abcdef"/"", 1, Pike.INDEX_FROM_BEG, 3, Pike.INDEX_FROM_END), "bc"/"");
test_equal(`[..] ("abcdef"/"", 1, Pike.INDEX_FROM_BEG, 3, Pike.OPEN_BOUND),     "bcdef"/"");
test_equal(`[..] ("abcdef"/"", 3, Pike.INDEX_FROM_END, 3, Pike.INDEX_FROM_BEG), "cd"/"");
test_equal(`[..] ("abcdef"/"", 3, Pike.INDEX_FROM_END, 3, Pike.INDEX_FROM_END), "c"/"");
test_equal(`[..] ("abcdef"/"", 3, Pike.INDEX_FROM_END, 3, Pike.OPEN_BOUND),     "cdef"/"");
test_equal(`[..] ("abcdef"/"", 1, Pike.OPEN_BOUND, 3, Pike.INDEX_FROM_BEG),     "abcd"/"");
test_equal(`[..] ("abcdef"/"", 1, Pike.OPEN_BOUND, 3, Pike.INDEX_FROM_END),     "abc"/"");
test_equal(`[..] ("abcdef"/"", 1, Pike.OPEN_BOUND, 3, Pike.OPEN_BOUND),         "abcdef"/"");

define(test_new_style, [[
  test_any_equal([[
    object new_style = class {
        protected array(int) `[..] (int... args) {return args;}
      }();
    return new_style $1;
  ]], $2)
]])
test_new_style([1..3],   ({1, Pike.INDEX_FROM_BEG, 3, Pike.INDEX_FROM_BEG}))
test_new_style([1..<3],  ({1, Pike.INDEX_FROM_BEG, 3, Pike.INDEX_FROM_END}))
test_new_style([1..],    ({1, Pike.INDEX_FROM_BEG, 0, Pike.OPEN_BOUND}))
test_new_style([<1..3],  ({1, Pike.INDEX_FROM_END, 3, Pike.INDEX_FROM_BEG}))
test_new_style([<1..<3], ({1, Pike.INDEX_FROM_END, 3, Pike.INDEX_FROM_END}))
test_new_style([<1..],   ({1, Pike.INDEX_FROM_END, 0, Pike.OPEN_BOUND}))
test_new_style([..3],    ({0, Pike.OPEN_BOUND, 3, Pike.INDEX_FROM_BEG}))
test_new_style([..<3],   ({0, Pike.OPEN_BOUND, 3, Pike.INDEX_FROM_END}))
test_new_style([..],     ({0, Pike.OPEN_BOUND, 0, Pike.OPEN_BOUND}))
undefine([[test_new_style]])

define(test_old_style, [[
  test_any_equal([[
    object old_style = class {
        protected int _sizeof() {return 6;}
        protected array(int) `[] (int... args) {return args;}
      }();
    return old_style $1;
  ]], $2)
]])
test_old_style([1..3],   ({1, 3}))
test_old_style([1..<3],  ({1, 2}))
test_old_style([1..],    ({1, Int.NATIVE_MAX})) dnl Upper bound might become larger.
test_old_style([<1..3],  ({4, 3}))
test_old_style([<1..<3], ({4, 2}))
test_old_style([<1..],   ({4, Int.NATIVE_MAX})) dnl Upper bound might become larger.
test_old_style([..3],    ({0, 3}))
test_old_style([..<3],   ({0, 2}))
test_old_style([..],     ({0, Int.NATIVE_MAX})) dnl Upper bound might become larger.
undefine([[test_old_style]])

// casting
test_eq([[(int)1]],[[1]])
test_eq([[(int)-1]],[[-1]])
test_eq([[(int)1.0]],[[1]])
test_eq([[(int)-1.0]],[[-1]])
test_eq([[(int)"1"]],[[1]])
test_eq([[(int)"-1"]],[[-1]])
test_eq([[(int)"0x1"]],[[0]])
test_eq([[(int)"010"]],[[10]])
test_eq((int)Gmp.mpz(5), 5)
test_eq((int)class { protected mixed cast(string x) { return x=="int" && 7; } }(), 7)
test_eval_error([[ return (int)class { protected mixed cast(string x) {
  return 1.0; } }(); ]]);
test_eval_error([[ return (int)class { protected mixed cast(string x) {
  return ADT.Heap(); } }(); ]]);
test_any([[ return (int)class { protected mixed cast(string x) {
  return Gmp.mpz(7); } }(); ]], Gmp.mpz(7));
test_eq([[(float)"1"]],[[1.0]])
test_eq([[(float)"-1"]],[[-1.0]])
test_eq([[(float)"1.0"]],[[1.0]])
test_eq([[(float)"-1.0"]],[[-1.0]])
test_eq([[(float)1.0]],[[1.0]])
test_eq([[(float)-1.0]],[[-1.0]])
test_eq([[(float)1]],[[1.0]])
test_eq([[(float)-1]],[[-1.0]])
test_eq([[(string)1]],[["1"]])
test_eq([[(string)-1]],[["-1"]])
test_eq([[(string)1.0]],[["1.0"]])
test_eq([[(string)-1.0]],[["-1.0"]])
test_eq((string)Gmp.mpz(5), "5")
test_eq((string)class { protected mixed cast(string x) {
  return x=="string" && "7"; } }(), "7")
test_eval_error((string)class { protected mixed cast(string x) { return 1.0; }}();)
test_eval_error((string)class { protected mixed cast(string x) {
  return ADT.Heap(); }}();)
test_any([[
  class A { int q=9; protected int _is_type(string x) { return x=="string"; } };
  mixed o = (string)class { protected mixed cast(string x) { return A(); } }();
  return o->q;]], 9)
// Note: 32-bit floats overflow at ~3.4e38.
test_true([[has_value ((string)1e38, ".") ||
	    has_value ((string)1e38, "e")]])
test_true([[has_value ((string)-1e38, ".") ||
	    has_value ((string)-1e38, "e")]])
test_true([[has_value ((string)1e-38, ".") ||
	    has_value ((string)1e-38, "e")]])
test_true([[has_value ((string)-1e-38, ".") ||
	    has_value ((string)-1e-38, "e")]])
cond([[Float.DIGITS_10 >= 15]], [[  // Usual size with 64 bit IEEE floats.
  // Note: 1e100 overflows to infinity with 32 bit floats.
  test_true([[has_value ((string)1e100, ".") ||
	      has_value ((string)1e100, "e")]])
  test_true([[has_value ((string)-1e100, ".") ||
	      has_value ((string)-1e100, "e")]])
]])
// Note: 1e-100 underflows to 0.0 with 32 bit IEEE floats, but that's ok.
test_true([[has_value ((string)1e-100, ".") ||
	    has_value ((string)1e-100, "e")]])
test_true([[has_value ((string)-1e-100, ".") ||
	    has_value ((string)-1e-100, "e")]])
test_true([[has_value ((string)124354236143512312334562453624.1, ".") ||
	    has_value ((string)124354236143512312334562453624.1, "e")]])
test_eq([[(string) 0.8]], [["0.8"]])
cond([[Float.DIGITS_10 >= 6]], [[  // Usual size with 32 bit IEEE floats.
  test_eq([[(string) 0.811113]], [["0.811113"]])
  test_eq([[(string) 0.811114]], [["0.811114"]])
  test_eq([[Regexp ("^8\\.11113e\\+0*34$")->match ((string) 0.811113e35) ||
            (string) 0.811113e35]], 1)
  test_eq([[Regexp ("^8\\.11114e\\+0*34$")->match ((string) 0.811114e35) ||
            (string) 0.811114e35]], 1)
]])
cond([[Float.DIGITS_10 >= 15]], [[  // Usual size with 64 bit IEEE floats.
  test_eq([[(string) 0.811111111111113]], [["0.811111111111113"]])
  test_eq([[(string) 0.811111111111114]], [["0.811111111111114"]])
  test_eq([[Regexp ("^8\\.11111111111113e\\+0*34$")->match ((string) 0.811111111111113e35) || (string) 0.811111111111113e35]], 1)
  test_eq([[Regexp ("^8\\.11111111111114e\\+0*34$")->match ((string) 0.811111111111114e35) || (string) 0.811111111111114e35]], 1)
]])
test_do(return (string)1e308)
test_do(return (string)1e200)
test_do(return (string)1e-200)
test_do(return (string)1e-307)
test_any([[
  array foo=({ 1 });
  return (string)sizeof(foo);
]], [["1"]])
test_any([[
  array foo=({ -1 });
  return (string)-sizeof(foo);
]], [["-1"]])
test_equal([[(array)(["1":1])]],[[ ({ ({"1", 1}) }) ]])
test_equal([[(array(int)) ({"1","4711",2.0,4})]],[[({1,4711,2,4})]])
test_equal([[(array(array))({({})})]],[[({({})})]])
test_equal([[ (array(array(int))) ({ ({"1","4711",2.0,4}) }) ]],[[ ({ ({1,4711,2,4}) }) ]])
test_equal([[ (array(array(array(int)))) ({ ({ ({"1","4711",2.0,4}) }) }) ]],[[ ({ ({ ({1,4711,2,4}) }) }) ]])
test_equal([[ (array(array(array(array(int))))) ({ ({ ({ ({"1","4711",2.0,4}) }) }) }) ]],[[ ({ ({ ({ ({1,4711,2,4}) }) }) }) ]])

test_equal([[(array)"foo"]],[[ values("foo") ]])
test_equal([[(array)(<1,2,3>)]],[[ indices( (<1,2,3>) )]])
test_equal([[sort(column((array)([1:2,3:4]),0))]],[[ sort(indices(([1:2,3:4])) )]])
test_equal([[sort(column((array)([1:2,3:4]),1))]],[[ sort(values(([1:2,3:4])))]])
test_true([[(array(array))([]) ]])
test_true([[(array(array))([1:2]) ]])
test_true([[(array(array))([1:2,3:4]) ]])
test_true([[(array(array))([1:2,3:4,5:6]) ]])
test_equal( [[ (multiset) ({1})]], [[ (< 1 >) ]] )
test_equal( [[ (multiset(string)) ({1})]], [[ (< "1" >) ]] )
test_eval_error([[return (mapping)""]])
test_equal([[ (mapping)({({1,2}),({3,4})})]], [[([1:2,3:4]) ]])
test_equal([[ ({({1,2})})]], [[(array)([1:2]) ]])
test_equal([[ (mapping)({})]], [[ ([]) ]])
test_equal([[ ({}) ]], [[ (array)([]) ]])
test_eval_error([[ mapping m=(mapping)({ ({1,2,3}), ({4,5,6}) }); ]])

test_equal([[ (mapping)class{int i=3;}() ]],[[ (["i":3]) ]])
test_equal([[ (mapping(string:string))class{int i=3;}() ]],[[ (["i":"3"]) ]])

test_any([[
  object x = class {
      protected mixed cast (string t) {return t == "string" && "foo";}
    }();
  destruct (x);
  return (string) x;
]], "0")

test_eq([[(string) ({0,1,2})]], "\0\1\2")
test_eq([[(string) ({'z', 0xff, '.'})]], "z\xff.")
test_eq([[(string) ({'z', 0x100, '.'})]], "z\x100.")
test_eq([[(string) ({'z', 0xffff, '.'})]], "z\xffff.")
test_eq([[(string) ({'z', 0x10000, '.'})]], "z\x10000.")
test_eq([[(string) ({'z', -1, '.'})]], "z\xffffffff.")
test_eq([[(string) ({'z', 0x7fffffff, '.'})]], "z\x7fffffff.")
test_eval_error([[(string) ({0x80000000})]])
test_eq([[(string) ({'z', -0x80000000, '.'})]], "z\x80000000.")
test_eval_error([[(string) ({-0x80000001})]])
test_eval_error([[(int)class { protected mixed cast() { return UNDEFINED; } }();]])
test_eval_error([[(string)class { protected mixed cast() { return UNDEFINED; } }();]])
dnl There is a default rule for casting objects to mapping.
test_equal([[(mapping)class { protected mixed cast() { return UNDEFINED; } }();]], ([]))
test_eval_error([[(mapping)class { protected mixed cast() { error("Cast\n"); } }();]])

test_any([[
  // Cast to subtyped object.
  class A(int val) {
    int next() { return ++val; }
  }
  return ((object(A))17)->next();
]], 18)

// testing @
test_equal(({1,2,3}),lambda(mixed ... x) { return x; }(@a()))
test_equal("foo"/"",lambda(mixed ... x) { return x; }(@a()))
test_any([[array a=({1,2,3}); return lambda(mixed ... x) { return x; }(@a) !=a]],1)
test_any([[array z=({lambda(mixed x){return x;},17});return `()(@z);]],17)

// testing ++
test_any([[ class A(void|int i){}; object a = A(); a->i++; return undefinedp(a->i); ]], 0)
test_any([[ class A(void|int i){}; object a = A(); ++a->i; return undefinedp(a->i); ]], 0)

// testing --
test_any([[ class A(void|int i){}; object a = A(); a->i--; return undefinedp(a->i); ]], 0)
test_any([[ class A(void|int i){}; object a = A(); --a->i; return undefinedp(a->i); ]], 0)

// testing +=
test_any(int a=1; a+=10; return a,11)
test_any_equal(mapping m=([]); m->x+=([]); return m->x, ([]))
test_any_equal(mapping m=([]); m->x+=(<>); return m->x, (<>))
test_any_equal(mapping m=([]); m->x+=({}); return m->x, ({}))
test_any_equal([[
  array a = ({});
  catch {
    a += Array.reduce(`+,({}));
  };
  return a;
]],({}))

// testing -=
test_any(int a=1; a-=10; return a,-9)
test_do([[ add_constant("FOO", class {
				 array(string) arr = ({ "a", "b", "c" });
			       }()); ]])
test_any_equal([[
  // LysLysKOM 20983743.
  compile_string("void x() {string z=\"a\"; FOO->arr-=({z});}")()->x();
  compile_string("void x() {string z=\"b\"; FOO->arr=FOO->arr-({z});}")()->x();
  compile_string("void x() {FOO->arr-=({\"c\"});}")()->x();
  return FOO->arr;
]], ({}))
test_do([[ add_constant("FOO"); ]])
// testing &=
test_any(int a=3; a&=10; return a,2)
// testing |=
test_any(int a=3; a|=10; return a,11)
test_any(int a = UNDEFINED; a|=1; return zero_type(a), 0)
test_any_equal(array a=({ "x" }); a|=({"x","y"}); return a, ({"x","y"}))
test_any_equal(array a=({ "x" }); a|=({"y"}); return a, ({"x","y"}))
test_any_equal(array a=({ "x" }); a|=({"x"}); return a, ({"x"}))
test_any_equal(array a=({ "x" }); a|=a; return a, ({"x"}))
test_any_equal(array a=({ "x" }); mapping m=(["a":a]); a|=({"x","y"}); return a, ({"x","y"}))
test_any_equal(array a=({ "x" }); mapping m=(["a":a]); a|=({"y"}); return a, ({"x","y"}))
test_any_equal(array a=({ "x" }); mapping m=(["a":a]); a|=({"x"}); return a, ({"x"}))
test_any_equal(array a=({ "x" }); mapping m=(["a":a]); a|=a; return a, ({"x"}))
// testing ^=
test_any(int a=3; a^=10; return a,9)
// testing <<=
test_any(int a=3; a<<=2; return a,12)
// testing <<=
test_any(int a=12; a>>=2; return a,3)
// testing *=
test_any(int a=12; a*=2; return a,24)
// testing /=
test_any(int a=12; a/=2; return a,6)
// testing %=
test_any(int a=12; a%=7; return a,5)

// testing control structs
test_any(return 1,1)
test_any(return lambda(){return 1;} (),1 )
test_any(if(0) return 0; else return 1,1)
test_any(if(0) return 0; return 1,1)
test_any(if(1) return 1; else return 0,1)
test_any(if("") return 1; else return 0,1)
test_any(if(!0) return 1; else return 0,1)
test_any(if(!(!1)) return 1; else return 0,1)
test_any(if(this) return 1; else return 0,1)
test_any(if(a) return 1; else return 0,1) dnl a is the test function
test_any(if(0.0) return 1; else return 0,1)
test_any(if(([])) return 1; else return 0,1)
test_any(if(({})) return 1; else return 0,1)
test_any(if((<>)) return 1; else return 0,1)
test_any(if(this_program) return 1; else return 0,1)

// break
test_any(while(1) break; return 1,1)
test_any(while(1) if(1) break; return 1,1)

// for
test_program(
array(int) ia=({1,2,3,4,5,6});

int a()
{
  int i;
  for (i=0; i<sizeof(ia); i++)
    {
      if (ia[i]==3)
	{
	  ia=ia[..i-1]+ia[i+1..];
	  --i;
	}
    }
  return 1;
}
)
test_any(int e; for(e=0;e<10;e++) break; return e,0)
test_any(int e; for(e=0;e<10;e++) continue; return e,10)
test_any(int e;string t=""; for(e=0;e<10;e++) t+=e; return t,"0123456789")
test_any(int e;string t=""; for(e=0;e<=10;e++) t+=e; return t,"012345678910")
test_any(int e;string t=""; for(e=9;e>0;e--) t+=e; return t,"987654321")
test_any(int e;string t=""; for(e=9;e>=0;e--) t+=e; return t,"9876543210")
test_any(int e;string t=""; for(e=9;e!=0;e--) t+=e;  return t,"987654321")
test_any(int e;string t=""; for(e=2;e!=10;e++) t+=e; return t,"23456789")
test_any(int e;string t=""; for(e=0;e>-10;e--) t+=e; return t,"0-1-2-3-4-5-6-7-8-9")

// foreach
test_any([[int e;string t=""; foreach(({7,6,3,8}),e) t+=e; return t]],"7638")
test_any([[
  /* FIXME: This test needs to be proofed against the optimizer. */
  string s;if(1) foreach(({}),s); else foreach(({}),s); return 1
]],1)

test_any([[
  // Bug 7426.
  array a = ({});
  foreach(a[1..], mixed e) return 0;
  return 1;
]], 1)

test_any([[
  int ret;
  foreach( ([1:2,3:5,7:11,13:17]) ; int a ; int b) ret+=a*b;
  return ret;
]],315)

test_any([[
  int ret;
  foreach( ([1:2,3:5,7:11,13:17]) ; ; int b) ret+=b;
  return ret;
]],35)

test_any([[
  int ret;
  foreach( ([1:2,3:5,7:11,13:17]) ; int a; ) ret+=a;
  return ret;
]],24)

test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; ; int b) ret+=b;
  return ret;
]],4)

test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; int a; ) ret+=a;
  return ret;
]],24)

test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; ; ) ret++;
  return ret;
]],4)


test_any([[
  int ret;
  foreach( (<1,3,7,13>) ; int a; int b) ret+=a+b;
  return ret;
]],24+4)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; int a; ) ret+=a;
  return ret;
]],6)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; ; int b) ret+=b;
  return ret;
]],35)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; int a; int b) ret+=a*b;
  return ret;
]],78)

test_any([[
  int ret;
  foreach( ({2,5,11,17}) ; ; ) ret++;
  return ret;
]],4)

test_any([[
  int ret;
  foreach( "foobar" ; int a; int b) ret+=a*b;
  return ret;
]],1585)

test_any([[
  int ret;
  foreach( "foobar" ; int a;) ret+=a;
  return ret;
]],15)

test_any([[
  int ret;
  foreach( "foobar" ; ; int b) ret+=b;
  return ret;
]],633)

test_any([[
  mapping m=([1:2,3:5,7:11,13:17]);
  foreach(m; int a; int b) if (m_delete(m,a) != b) return -1;
  return sizeof(m);
]],0)

test_any([[
  mapping m=([1:2,3:5,7:11,13:17]);
  int ret;
  foreach(m  ; int a ; int b) { m_delete(m,a); ret+=a*b; }
  return ret;
]],315)

test_eval_error([[
  int i;
  foreach (class{}(); mixed a; mixed b) i++;
  return i;
]])

test_any([[
  String.Iterator iter = String.Iterator ("foo");
  foreach (iter; int idx;)
    if (idx != iter->index()) return 1;
  return 0;
]], 0)

test_any([[
  mapping(object:int) x = ([]);
  object o = class {}();
  x[o] = 1;
  destruct (o);
  int i;
  foreach (x;;) i++;
  return i;
]], 0)

test_any([[
  multiset(object) x = (<>);
  object o = class {}();
  x[o] = 1;
  destruct (o);
  int i;
  foreach (x;;) i++;
  return i;
]], 0)

test_any([[
  // Check foreach with negative ranges [bug 7216]/[LysLysKOM 20892964].
  array a = ({ -2, -1, 0, 1, 2 });
  int total;
  foreach(a, int start) {
    foreach(a[start..], int val) {
      if (!intp(val)) error("Invalid svalue!\n");
      total += (val + 3)*(start + 3);
    }
  }
  return total;
]], 15 + 30 + 45 + 56 + 60)

// do-while
test_any(int e;string t=""; e=0; do{ t+=e; }while(++e<6); return t,"012345";)

// while
test_any(int e;string t=""; e=8; while(--e) t+=e; return t,"7654321";)
test_any(int e;string t=""; e=8; while(e--) t+=e; return t,"76543210";)
test_any(int e;string t=""; e=0; while(++e<6) t+=e; return t,"12345";)
test_any(int e=1;string t=""; while(e<20){t+=e;e*=2;} return t,"124816";)

// Switch
test_any(switch((mixed)"") { case -1: case "gazonk": return 0; } return 1,1)
test_any(switch((mixed)"") { case -2: case "gazonk": return 0; } return 1,1)
test_any(switch((mixed)"") { case 0: case "gazonk": return 0; } return 1,1)
test_any(switch((mixed)"") { case "gazonk": case 0: return 0; } return 1,1)
test_any(switch((mixed)0) { case 0: case "gazonk": return 0; } return 1,0)
test_any(switch((mixed)"gazonk") { case "gazonk": case 0: return 0; } return 1,0)
test_any(switch((mixed)0) { case "": } return 1,1)
test_any(switch((mixed)1) { case 1: return 1; default: } return 0,1)
test_any(switch((mixed)2) { case 1: return 0; default: return 1;} return 0,1)
test_any(switch((mixed)1) { default: return 0; case 1: return 1; } return 0,1)
test_any(switch((mixed)2) { default: return 1; case 1: return 0; } return 0,1)
test_any(switch((mixed)0) { case "apa": case 1.0: return 0; }  return 1,1)
test_any(switch((mixed)"apa") { case "apa": return 1; case 1.0: }  return 0,1)
test_any(switch((mixed)1.0) { case "apa": return 0; case 1.0: return 1; } return 0,1)
test_any(switch((mixed)"sune") { case "gunnel": return 0; case "gunnar": return 1; case "sune": case "gusten": return 0; } return 0,0)
test_any(switch((mixed)"a") { case "a": return 1; case "b": case "c": case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)"b") { case "a": return 0; case "b": return 1; case "c": case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)"c") { case "a": case "b": return 0; case "c": return 1; case "d": case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)"d") { case "a": case "b": case "c": return 0; case "d": return 1; case 'a': case '1': case '0': default: } return 0,1)
test_any(switch((mixed)'a') { case "a": case "b": case "c": case "d": return 0; case 'a': return 1; case '1': case '0': default: } return 0,1)
test_any(switch((mixed)'1') { case "a": case "b": case "c": case "d": case 'a': return 0; case '1': return 1; case '0': default: } return 0,1)
test_any(switch((mixed)'0') { case "a": case "b": case "c": case "d": case 'a': case '1': return 0; case '0': return 1; default: } return 0,1)
test_any(switch((mixed)"a") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,1)
test_any(switch((mixed)"b") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,2)
test_any(switch((mixed)"c") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,3)
test_any(switch((mixed)"d") { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,4)
test_any(switch((mixed)'a') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,5)
test_any(switch((mixed)'1') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,6)
test_any(switch((mixed)'0') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,7)
test_any(switch((mixed)'9') { case "a": return 1; case "b": return 2; case "c": return 3; case "d": return 4; case 'a': return 5; case '1': return 6; case '0': return 7; default: return 8; } return 9,8)

test_program([[
void bar() {}
int a()
{
  foreach( ({1}), int n)
  {
    switch(n)
    {
      default:
      bar();
      break;
    }
  }
  return 1;
}
]])


define(test_switch0,[[
test_any(switch((mixed)$1) { $2; $3; $4; $5; } return 0,$6)
test_any(switch((mixed)$1) { default: return 0; $2; $3; $4; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; default: return 0; $3; $4; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; $3; default: return 0; $4; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; $3; $4; default: return 0; $5; } return -1,$6)
test_any(switch((mixed)$1) { $2; $3; $4; $5; default: return 0; } return -1,$6)
]])

define(test_switch1,[[
test_switch0($1, $2,$3,$4,$5, $6)
test_switch0($1, $2,$3,$5,$4, $6)
]])

define(test_switch2,[[
test_switch1($1, $2,$3,$4,$5, $6)
test_switch1($1, $2,$4,$3,$5, $6)
test_switch1($1, $2,$5,$4,$3, $6)
]])

define(test_switch3,[[
test_switch2($1,case $2:return 2,case $3:return 3,case $4:return 4,case $5:return 5,$6)
test_switch2($1,case $3:return 3,case $2:return 2,case $4:return 4,case $5:return 5,$6)
test_switch2($1,case $4:return 4,case $3:return 3,case $2:return 2,case $5:return 5,$6)
test_switch2($1,case $5:return 5,case $3:return 3,case $4:return 4,case $2:return 2,$6)
]])

define(test_switch4,[[
test_switch3($1,$2,$3,$4,$5,0)
test_switch3($2,$2,$3,$4,$5,2)
test_switch3($3,$2,$3,$4,$5,3)
test_switch3($4,$2,$3,$4,$5,4)
test_switch3($5,$2,$3,$4,$5,5)
]])

test_switch4(17,18,19,20,21)
test_switch4("a","b","c","d","e")
test_switch4("a",0,"c","d","e")
test_switch4(1.0,2.0,3.0,4.0,5.0)
test_switch4(this,"",0,4.0,1)

test_any(int e;string t=""; for(e=0;e<10;e++) switch(e) { default: t+=e; case 4..8: } return t,"01239")

// use sprintf here; the sums aren't totally equal for doubles (error~=1e-16)
test_any([[float e,q; q=0.0; for(e=0.1;e<10.0;e+=1.0) switch(e) { default: q+=e; case 4.0..8.0: } return sprintf("%.6f",q)]],[[sprintf("%.6f",0.1+1.1+2.1+3.1+8.1+9.1)]])

test_compile_error([[switch (1) {case 1: break; case 1: break;}]])
test_compile_error([[switch (1) {case 1: break; case 0..2: break;}]])
test_compile_error([[switch (1) {case 1..2: break; case 0..3: break;}]])
test_compile_error([[switch (1) {case 1..3: break; case 0..2: break;}]])
test_compile_error([[switch (1) {case 1..2: break; case 0..: break;}]])
test_compile_error([[switch (1) {case 1..2: break; case ..3: break;}]])
test_compile_error([[switch (1) {case 1..: break; case ..3: break;}]])
test_compile_error([[switch (1) {case ..: break;}]])
test_compile_error([[switch (1) {case "x"..: break;}]])
test_compile_error([[switch (1) {case .."y": break;}]])
test_compile_error([[switch (1) {case "x".."y": break;}]])

define(test_switch_ranges,[[
  test_any_equal([[
    int f (int i) {{$1;} return 0;};
    array res = ({});
    for (int i = -3; i <= 3; i++) res += ({f (i)});
    return res;
  ]], $2)
]])

test_switch_ranges([[
  switch (i) {case 1..2: return 2; case -2..-1: return 1;}
]], ({0, 1, 1, 0, 2, 2, 0}))
test_switch_ranges([[
  switch (i) {case 1..2: return 2; case -2..0: return 1;}
]], ({0, 1, 1, 1, 2, 2, 0}))
test_switch_ranges([[
  switch (i) {case 1..2: return 2; case -2..-1: return 1; case 0: return 3;}
]], ({0, 1, 1, 3, 2, 2, 0}))
test_switch_ranges([[
  switch (i) {case 1..2: return 2; case ..-1: return 1; case 0: return 3;}
]], ({1, 1, 1, 3, 2, 2, 0}))
test_switch_ranges([[
  switch (i) {case 1..: return 2; case -2..-1: return 1; case 0: return 3;}
]], ({0, 1, 1, 3, 2, 2, 2}))
test_switch_ranges([[
  switch (i) {case 1..: return 2; case ..-1: return 1; case 0: return 3;}
]], ({1, 1, 1, 3, 2, 2, 2}))

test_any([[
#pragma strict_types
  int(-1..1) i = [int(0..1)]random(1);
  switch(i)
  {
  case 0: return 3;
  case 1: return 3;
  case -1: return 3;
  }
  return 0;
]], 3)


// Breaks and continues with labels
test_compile_error([[break;]])
test_compile_error([[continue;]])
test_compile_error([[foo: break;]])
test_compile_error([[foo: continue;]])
test_compile_error([[break foo;]])
test_compile_error([[continue foo;]])
test_any([[foo: break foo; return 1;]], 1)
test_compile_error([[foo: continue foo;]])
test_compile_error([[int a; foo: if (a++) a++; else foo: a++;]])
test_compile_error([[int a; foo: foo: if (a++) a++; else a++;]])
ignore_warning("Label foo not used.", [[
  test_compile([[int a; foo: if (a++) a++; foo: a++;]])
]])
test_compile_error([[int a; do if (a++) break foo; while (0);]])
test_compile([[int a; do foo: if (a++) break foo; while (0);]])
test_compile([[int a; foo: do if (a++) break foo; while (0);]])
test_compile_error([[int a; do foo: if (a++) continue foo; while (0);]])
test_compile([[int a; foo: do if (a++) continue foo; while (0);]])
ignore_warning("Label foo not used.", [[
  test_any([[
    int i;
    for (i = 1; i <= 4; i++)
      foo: break;
    return i;
  ]], 1)
  test_any([[
    int i;
    for (int j = 1; j <= 4; j++) {
      foo: continue;
      i = j;
    }
    return i;
  ]], 0)
]])
test_any([[
  int i;
  for (i = 1; i <= 4; i++)
    foo: {
      if (i > 5) break foo;
      break;
    }
  return i;
]], 1)
test_any_equal([[
  int a, b;
foo:
  for (int i = 1; i <= 4; i++) {
    a = i;
    switch (1) {
      case 1:
	if (i >= 3) break foo;
	if (i >= 2) continue foo;
    }
    b = i;
  }
  return ({a, b});
]], ({3, 1}))
test_any_equal([[
  int a, b;
foo: {
    for (int i = 1; i <= 4; i++) {
      a = i;
      switch (1) {
	case 1:
	  if (i >= 3) break foo;
      }
      b = i;
    }
  }
  return ({a, b});
]], ({3, 2}))
test_any_equal([[
  array res = ({});
  foreach (({1, 2, 3}), int x) {
    res += ({-x});
  foo:
    foreach (({1, 2, 3, 4}), int i) {
      res += ({i});
      foreach (({1, 2}), int y) {
	if (i >= 3) break foo;
	if (i >= 2) continue foo;
	y;
      }
      res += ({i});
    }
  }
  return res;
]], ({-1, 1, 1, 2, 3, -2, 1, 1, 2, 3, -3, 1, 1, 2, 3}))
test_any_equal([[
  int a, b;
foo:
  for (int i = 1; i <= 4; i++) {
    a = i;
    catch {
      catch {
	if (i >= 3) break foo;
	if (i >= 2) continue foo;
      };
    };
    b = i;
  }
  return ({a, b});
]], ({3, 1}))
ignore_warning("Label foo not used.", [[
  test_any_equal([[
    int a, b;
  foo:
    for (int i = 1; i <= 4; i++) {
      a = i;
      catch {
        catch {
  	if (i >= 3) break;
  	if (i >= 2) continue;
        };
      };
      b += i;
    }
    return ({a, b})
  ]], ({4, 8}));
]])
test_any([[
foo:
  if (stringp (catch {int q=1; break foo;}) + 1) return 1;
  else return 2;
  return 3;
]], 3)
test_any([[
foo:
  do {
    if ((3*time() + 5) + stringp (catch {int q=1; break foo;})) return 1;
    else return 2;
  } while (0);
  return 3;
]], 3)
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (1,2,3, gauge {break foo;},4,5);
]])
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@indices (all_constants()), gauge {break foo;});
]])
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (1,2,3, catch {int q=1; break foo;},4,5);
]])
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@indices (all_constants()), catch {int q=1; break foo;});
]])
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@({1,2,3,4,5}), catch {int q=1; break foo;});
]])
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@indices (all_constants()), @allocate (511, 1), catch {int q=1; break foo;});
]])
test_do([[
  void gnu (mixed... args) {};
foo:
  gnu (@allocate (511, 1), @indices (all_constants()), catch {int q=1; break foo;});
]])
test_compile_error([[
foo: {
    @indices (all_constants());
    break foo;
  }
]])
test_do([[
  // Note: This is valid <= 7.0 code.
  foreach (({1,2,3}), int j)
    do
      if (17 + j + gauge {break;}) return 0;
    while (0);
]])
test_do([[
  // Note: This is valid <= 7.0 code.
  foreach (({1,2,3}), int j)
    do
      if (17 - j - gauge {break;}) return 0;
    while (0);
]])
test_do([[
  int gnu (mixed... args) {};
  gnu(@indices (all_constants()), gauge {
    foreach (({1,2,3}), int j)
      do
        if (j && gnu(@indices (all_constants()),
		17 + gauge {break;}))
	  return 0;
      while (0);
  });
]])
test_do([[
  int gnu (mixed... args) {};
foo:
  gnu(@indices (all_constants()), gauge {
    foreach (({1,2,3}), int j)
      do
        if (j && gnu(@indices (all_constants()),
		17 + gauge {break foo;}))
	  return 0;
      while (0);
  });
]])

ifefun(_verify_internals,
[[
  test_do(_verify_internals())
]])

test_compile_any([[import Stdio.Readline; mapping x=([]);]])

// testing preprocessor
test_eq([[cpp("#define FOO(X,Y) (X) (Y)\nFOO( (A),(B) )")]],"\n( (A) ) ( (B) )")
test_eq([[cpp("#define FOO(X)\nFOO BAR")]],"\nFOO BAR")
test_eq([[cpp("#define F 'F'\nF")]],"\n'F'")
test_eq([[cpp("#define MAX(X,Y) ((X)>(Y)?(X):(Y))\n#define MAX3(X,Y,Z) MAX(MAX(X,Y),Z)\nMAX3(1,2,3)")]],"\n\n(( (( 1 )>( 2 )?( 1 ):( 2 )) )>( 3 )?( (( 1 )>( 2 )?( 1 ):( 2 )) ):( 3 ))")
test_eq([[cpp("\t  foo\xfeff""bar \xfeff gazonk")]],
        [[cpp("\t  foobar  gazonk")]])
test_eq([[cpp("\t  foobar  gazonk\n")]], "\t  foobar  gazonk\n")
test_eq([[cpp("#define A(X) #X\n#define B(Y) A(Y)\nB(foo)")]],
	"\n\n \"foo\" ")
test_eq([[cpp("#define FOO(X) X\nFOO(\"\\\n\")\n")]], "\n\n \"\" \n");
test_eq([[cpp("#define FOO(X) X\r\nFOO(\"\\\r\n\")\r\n")]], "\n\n \"\" \n");
test_equal([[compile_string("#define FOO(X) X\nstring s=FOO(\"\\\n\\\n\");\nmixed f() {return ({__LINE__, backtrace()[-1][1]});}\n")()->f()]], ({5, 5}));
test_equal([[compile_string("#define FOO(X) X\nstring s=FOO(#\"\n\n\");\nmixed f() {return ({__LINE__, backtrace()[-1][1]});}\n")()->f()]], ({5, 5}));
test_equal([[
  compile_string("#define FOO BAR\n"
		 "#define TOSTR(X) #X\n"
		 "#define TOSTR2(X) TOSTR(X)\n"
		 "constant val = TOSTR2(FOO);\n")()->val;
]], "BAR")
test_equal([[
  compile_string("#define FOO\n"
		 "#define TOSTR(X) #X\n"
		 "#define TOSTR2(X) TOSTR(X)\n"
		 "constant val = TOSTR2(FOO);\n")()->val;
]], "")
test_eq([[cpp("foo _Pragma(\"strict_types \\\\back \\\"str\\\"\") bar")]],
  "foo \n#pragma strict_types \\back \"str\"\n#line 1 \"-\"\n bar")
test_equal([[
  compile_string(Charset.encoder("ebcdic-us")->
    feed("#charset ebcdic-us\n"
	 "constant val = \"abc\";\n")->drain())()->val;
]], "abc")
test_eq([[cpp("\\\n")]], "\n")
test_eq([[cpp("#if 1\\\n-1\nfoo\n#endif\n")]], "\n\n\n\n")
test_any([[
  #define TOSTR(X)	#X
  return TOSTR(FOO  "String with \\ and \" and  space"  BAR);
]], "FOO \"String with \\\\ and \\\" and  space\" BAR")
test_any([[
  Stdio.write_file("testsuite_test.h", "");
  return compile_string(#"
      #include \"\\
testsuite_test.h\"
      int line = __LINE__;
    ")()->line;
]], 4)
test_do([[cpp(#"
#define FOO(X) X
FOO(// Pike 7.6 and earlier don't seem to like single
    /* quotes (') in comments in macro arguments. */
arg)")]])
test_equal([[cpp(#"
FOO(foo)", ([
  "predefines": ([
    "FOO(X)":"X Y X",
  ]),
]))]], "\n foo  Y  foo ")
test_any_equal([[
  // Bug #10135
#define ENTRY(A, B, C, ARGS ...) ({ ({ C, ARGS }), ({ A, B }) })
  return ({ ENTRY(1, 1, "%s", "one"),
            ENTRY(1, 1, "%s %s", "one", "two"),
            ENTRY(1, 1, "%s %s %s", "one", "two", "three"),
            ENTRY(1, 1, "%s %d", "one", 2),
            ENTRY(1, 1, "%s %d %d", "one", 2, 3),
            ENTRY(1, 1, "%s %d %s", "one", 2, "three"),
  });
]],[[ ({
    ({ ({ "%s", "one" }), ({ 1, 1 }) }),
    ({ ({ "%s %s", "one", "two" }), ({ 1, 1 }) }),
    ({ ({ "%s %s %s", "one", "two", "three" }), ({ 1, 1 }) }),
    ({ ({ "%s %d", "one", 2 }), ({ 1, 1 }) }),
    ({ ({ "%s %d %d", "one", 2, 3 }), ({ 1, 1 }) }),
    ({ ({ "%s %d %s", "one", 2, "three" }), ({ 1, 1 }) }),
  }) ]])

// The following three tests are in triplicate to force testing in all shifts.
test_do([[
#define FOO(X) X
string s = FOO (#"a
b
c");
]]);
test_do([[
#define FOO(X) X
string s = FOO (#"a
b
c");
]]);
test_do([[
#define FOO(X) X
string s = FOO (#"a
b
c");
]]);
test_do([[
#define FOO(X) X
string s = FOO (#"

");
]]);
test_do([[
#define FOO(X) X
string s = FOO (#"

");
]]);
test_do([[
#define FOO(X) X
string s = FOO (#"

");
]]);
test_any([[
#define FOO(X) X
FOO ("\
\
");
return __LINE__;
]], 6);
test_any([[
#define FOO(X) X
FOO ("\
\
");
return __LINE__;
]], 6);
test_any([[
#define FOO(X) X
FOO ("\
\
");
return __LINE__;
]], 6);

test_any([[
#define ab\u0063
#ifdef \u0061\
bc
return 1;
#else
return 0;
#endif
]], 1)

test_any([[
#define \U00010330(\U00010331) #\U00010331
#define \U00010332(\U00010333) \U00010330 (\U00010333)
#define \U00010334 qth
return \U00010332 (\U00010334)
]], "qth")
test_any([[
#define \U00010330(\U00010331) #\U00010331
#define \U00010332(\U00010333) \U00010330 (\U00010333)
#define \U00010334 \u0220qt\u0222h
return \U00010332 (\U00010334)
]], "\x220qt\x222h")
test_any([[
#define \U00010330(\U00010331) #\U00010331
#define \U00010332(\U00010333) \U00010330 (\U00010333)
#define \U00010334 \U00010330qt\u0222h
return \U00010332 (\U00010334)
]], "\x10330qt\x222h")
test_program([[
  typedef \u0069n\u0074 \u02222;
  \u0222\u0032 my_\u0223 (\u02222 \u0220) {re\u0074urn \u0220+1\u0031;}
  int a() {return m\u0079_\u0223 (17) == 28;}
]])

test_eq([[compile_string(#"
#define Y(y) #y
#define X(x) x(z)
string a() {return X(Y);}
")()->a()]], "z")
test_eq([[compile_string(#"
#define Y() \"z\"
#define X(x) x()
string a() {return X(Y);}
")()->a()]], "z")
test_compile([[
#define Y(y) y
#define X(x) x()
X(Y)
]])
test_compile_error([[
#define Y(y,z) y
#define X(x) x()
X(Y)
]])
test_compile_error([[
#define Y() y
#define X(x) x(z)
X(Y)
]])
test_true([[compile_string(#"
#define Y() z
#define X(x) x()
int z() {return 0;}
mixed a() {return functionp(X(Y));}
")()->a()]])
test_false([[compile_string(#"
#define Y z
#define X(x) x()
int z() {return 0;}
mixed a() {return functionp(X(Y));}
")()->a()]])

test_do([[
  Stdio.write_file("testsuite_test.pmod", "syntax error");
  object orig_master = master();
  replace_master(object_program(orig_master)());
  mixed err = catch {
    compile_string(#"
#ifdef NONEXISTING_DEFINE
#error Not expected
#if constant (.testsuite_test)
#error Not expected either
#endif
#endif", "testsuite_test");
  };
  replace_master(orig_master);
  if (err) throw (err);
]]);

test_do([[
  Stdio.write_file("testsuite_test.pmod", "syntax error");
  object orig_master = master();
  replace_master(object_program(orig_master)());
  mixed err = catch {
    compile_string(#"
#if defined (NONEXISTING_DEFINE) && constant (.testsuite_test)
#error Not expected
#endif", "testsuite_test");
  };
  replace_master(orig_master);
  if (err) throw (err);
]]);

test_any([[
  class handler {mapping get_predefines() {return (["x": "1", "y": "", "z": 0]);}};
  return cpp ("x y z p", "-", 0, handler());
]], "1   p");
test_eval_error([[
  class handler {mixed get_predefines() {return (<"x">);}};
  cpp ("x y z", "-", 0, handler());
]]);
test_eval_error([[
  class handler {mapping get_predefines() {return ([0: 0]);}};
  cpp ("x y z", "-", 0, handler());
]]);
test_eval_error([[
  class handler {mapping get_predefines() {return (["": 1]);}};
  cpp ("x y z", "-", 0, handler());
]]);
test_eval_error([[
  class handler {mapping get_predefines() {return (["x": 1]);}};
  cpp ("x y z", "-", 0, handler());
]]);

test_true( Stdio.write_file("conftest.h", "return 17;\n") )

test_any([[
#include "conftest.h"
]],17)
dnltest_any([[
dnl#include <conftest.h>
dnl]],17)

test_any([[
// bug 2440 (a)
#define FILENAME "conftest.h"
return #string FILENAME;
]], "return 17;\n")

test_any([[
// bug 2440 (b)
#define FILENAME "conftest.h"
#include FILENAME
]], 17)

test_any([[
// Double expansion
string FILENAME = "";
#define FILENAME "conftest.h"	 + FILENAME
return #string FILENAME;
]], "return 17;\n")

test_true( rm("conftest.h") )

test_true(intp(__LINE__))
test_true(stringp(__FILE__))
test_eq(sizeof(dirname(__FILE__))?dirname(__FILE__):".",__DIR__)
test_true(stringp(__DATE__))
test_true([[ sscanf(__DATE__, "%3s %d %d", string m, int d, int y) == 3 &&
	     search(({"Jan", "Feb", "Mar", "Apr", "May", "Jun",
		      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}), m) != -1 &&
	     intp(d) && d>0 && d<32 && intp(y) ]])
test_true(stringp(__TIME__))
test_true([[ sscanf(__TIME__, "%d:%d:%d", int h, int m, int s) == 3 &&
	     intp(h) && intp(m) && intp(s) &&
	     h>=0 && m>=0 && s>=0 &&
	     h<24 && m<60 && s<61 ]])
test_true(floatp(__VERSION__))
test_true(floatp(__REAL_VERSION__))
test_true(intp(__MAJOR__))
test_true(intp(__REAL_MAJOR__))
test_true(intp(__MINOR__))
test_true(intp(__REAL_MINOR__))
test_true(intp(__BUILD__))
test_true(intp(__REAL_BUILD__))
test_eq(__PIKE__,1)

test_any_equal([[
  int base = __COUNTER__;
#define X __COUNTER__
  return map( ({ __COUNTER__, X, __COUNTER__ }), `-, base);
]], [[ ({ 1,2,3 }) ]])
test_any_equal([[
  int base = __COUNTER__;
#define X __COUNTER__
  return map( ({ __COUNTER__, X, __COUNTER__ }), `-, base);
]], [[ ({ 1,2,3 }) ]])
test_do(add_constant("COUNTER",__COUNTER__))
test_eq(__COUNTER__-1,COUNTER)
test_do(add_constant("COUNTER"))

test_eq( compile_string("string a=#\"a\nb\";")()->a, "a\nb" )
test_eq( compile_string("string a=#\"a\r\nb\";")()->a, "a\nb" )
test_eq( compile_string("string a=#\"a\n\rb\";")()->a, "a\nb" )

// #define
test_any([[
#define FOOa 1
return FOOa;
]],1)

test_any([[
#define FOOa array
FOOa(int) b = ({0});
return sizeof(b);
]],1)

test_any([[
#define FOOb 17
#undef FOOb
#define FOOb 1
return FOOb;
]],1)

test_compile_error([[
#define FOOc FOOc FOO
FOO
]])

test_any([[
#define FOOa(X) (X)
return FOOa(2);
]],2)

test_any([[
#define FOOa(X) \
(X)
return FOOa(2);
]],2)

test_any([[
#define FOOa(X) \
(X)
return FOOa(3);
]],3)

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3);
]],({3}))

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3,4);
]],({3,4}))

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3,4,5);
]],({3,4,5}))

test_any_equal([[
#define FOOa(X,Y...) ({X,Y})
return FOOa(3,4,5,6);
]],({3,4,5,6}))

test_any([[
#define FOOa(X) "bar\
gazonk"
return FOOa(3);
]],"bargazonk")

test_any([[
#define FOOa(X) "bar\
gazonk"
return FOOa(3);
]],"bargazonk")


// /* */
test_any([[
/* return 99; * /  /* */
return 1;
]],1)

test_any([[
/* return 99; // */
return 1;
]],1)

// //
test_any([[
// return 99;
return 1; // return 47;
]],1)

// #!
test_any([[
#! int i=4;
int i=3;
#! i=5;
return i;
]],3)

// #if
define(test_if_true,[[test_any([[
#if $1
return 1;
#else
return 0;
#endif
]],1)]])
define(test_if_false,[[test_any([[
#if $1
return 1;
#else
return 0;
#endif
]],0)]])

test_if_true(1)
test_if_false(0)

test_if_true('n' == 110)

// #if ==
test_if_true(1==1)
test_if_false(1==2)

// #if !=
test_if_true(1!=2)
test_if_false(1!=1)

// #if ( )
test_if_true( (((1))==1) )
test_if_false( ((1)==(2)) )

// #if -1
test_if_true( -1 )
test_if_true( (-1) )
test_if_true( (-1==0-1) )

// #if ~
test_if_true( (-1-1==~1) )

// #if ?:
test_if_true( 17 == ( 1 ? 17 : 18 ) )
test_if_true( 18 == ( 0 ? 17 : 18 ) )

// #if ||
test_if_true( 10 == ( 10 || 20 ) )
test_if_true( 20 == ( 0 || 20 ) )

// #if &&
test_if_true( 0 == ( 0 && 20 ) )
test_if_true( 20 == ( 10 && 20 ) )

// #if |
test_if_true( 3 == ( 1 | 2 ) )
test_if_true( 2 == ( 2 | 2 ) )

// #if ^
test_if_true( 0 == ( 2 ^ 2 ) )
test_if_true( 3 == ( 1 ^ 2 ) )

// #if &
test_if_true( 0 == ( 1 & 2 ) )
test_if_true( 2 == ( 2 & 7 ) )

// #if <= >= < > ! strings, floats

define(test_if_cmp,[[
test_if_true($1<$2)
test_if_true(!($1>$2))
test_if_true($2>$1)
test_if_true(!($2<$1))
test_if_true($1<=$2)
test_if_true(!($1>=$2))
test_if_true($2>=$1)
test_if_true(!($2<=$1))
test_if_true($2<=$2)
test_if_true($1>=$1) ]])

test_if_cmp(1,2)
test_if_cmp(1.0,2.0)
test_if_cmp("a","b")

// #if <<
test_if_true(1<<10==1024)
test_if_true(5<<3==40)

// #if >>
test_if_true(1024>>10==1)
test_if_true(47>>3==5)

// #if +
test_if_true(1024+10==1034)
test_if_true(47+3==50)

// #if -
test_if_true(1024-10==1014)
test_if_true(47-3==44)

// #if *
test_if_true(1024*10==10240)

// #if /
test_if_true(47/3==15)

test_compile_error([[
#if 1/0
return 1;
#else
return 0;
#endif
]])

// #if %
test_if_true(47%3==2)
test_compile_error([[
#if 1%0
return 1;
#else
return 0;
#endif
]])

// #if [ ]
test_if_true("foo"[0]=='f')

// #if defined
test_any([[
#define FOOe 0
#if defined(FOOe)
return 1;
#else
return 0;
#endif
]],1)

// #if define < x
test_any([[
#define FOOf 1
#if FOOf < 2
return 1;
#else
return 0;
#endif
]],1)

// #if define < x
test_any([[
#define FOOg 1
#if FOOg < 0
return 0;
#else
return 1;
#endif
]],1)

// #if x < define
test_any([[
#define FOOh 1
#if 0 < FOOh
return 1;
#else
return 0;
#endif
]],1)

// #if x < define
test_any([[
#define FOOi 1
#if 2 < FOOi
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if 0
#blahong
#endif
return 1;
]],1)

// #if efun
// see test for add_constant()

// #if /* */
test_any([[
#if 1 /* trying to be mean //  * / */ /* /* */
return 1;  /* */
#define foo
# 1 "---"
#undef foo
#else /* trying to be mean //  * / */ /* /* */
return 0;  //
#endif /* trying to be mean //  * / */ /* /* */
]],1)

test_any([[
#if 0 /* trying to be mean //  * / */ /* /* */
return 0; /* */
#define foo
# 1 "---"
#undef foo
#else /* trying to be mean //  * / */ /* /* */
return 1; //
#endif /* trying to be mean //  * / */ /* /* */
]],1)

// #if //
test_any([[
#if 1 //* trying to be mean //  */ */
return 1;
#else //* trying to be mean //  */ */
return 0;
#endif //* trying to be mean //  */ */
]],1)

test_any([[
#if 0 //* trying to be mean //  */ */
return 0;
#else //* trying to be mean //  */ */
return 1;
#endif //* trying to be mean // */ */
]],1)

test_any([[
#define FOOj
#if defined(FOOj)
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if defined(FOOk)
return 0;
#else
return 1;
#endif
]],1)

// #if constant
test_any([[
#if constant(Foo.Bar)
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if constant(Foo) && constant(Bar)
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if constant(String.Buffer)
return 1;
#else
return 0;
#endif
]],1)

test_any([[
#if constant(String.Bar)
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if constant(String) && constant(String.Bar)
return 0;
#else
return 1;
#endif
]],1)

test_compile_error([[
#if constant()
constant foo=1;
#endif
]])

// #ifdef
test_any([[
#ifdef FOOl
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#define FOOm
#ifdef FOOm
return 1;
#else
return 0;
#endif
]],1)

// #ifndef
test_any([[
#define FOOo
#ifndef FOOo
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#ifndef FOOp
return 1;
#else
return 0;
#endif
]],1)

// #else
test_any([[
#if 1
return 1;
#else
FEL
#if 0
FEL
#else
FEL
#endif
return 0;
#endif
]],1)

test_any([[
#if 0
FEL
#if 0
FEL
#else
FEL
#if 1
FEL
#else
FEL
#endif
#endif
return 0;
#else
return 1;
#endif
]],1)

// #elif
test_any([[
#if 0
return 0;
#elif 0
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if 0
return 0;
#elif 1
return 1;
#else
FEL
return 0;
#endif
]],1)

test_any([[
#if 1
return 1;
#elif 1
FEL
return 0;
#else
FEL
return 0;
#endif
]],1)

// #elseif
test_any([[
#if 0
return 0;
#elseif 0
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if 0
return 0;
#elseif 0
return 0;
#elseif 1
return 1;
#elseif 0
FEL
return 0;
#elseif 0
FEL
return 0;
#else
FEL
#endif
]],1)

test_any([[
#if 0
return 0;
#elseif 1
return 1;
#else
FEL
return 0;
#endif
]],1)

test_any([[
#if 1
return 1;
#elseif 1
FEL
return 0;
#else
FEL
return 0;
#endif
]],1)

// #elifdef
test_any([[
#if 0
return 0;
#elifdef FOOl
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#define FOOm
#if 0
return 0;
#elifdef FOOm
return 1;
#else
FEL
return 0;
#endif
]],1)

test_any([[
#define FOOm
#if 1
return 1;
#elifdef FOOm
FEL
return 0;
#else
FEL
return 0;
#endif
]],1)

// #elifndef
test_any([[
#define FOOo
#if 0
return 0;
#elifndef FOOo
return 0;
#else
return 1;
#endif
]],1)

test_any([[
#if 0
return 0;
#elifndef FOOp
return 1;
#else
FEL
return 0;
#endif
]],1)

test_any([[
#if 1
return 1;
#elifndef FOOp
FEL
return 0;
#else
FEL
return 0;
#endif
]],1)


// #pragma
// FIXME: add tests for real pragmas
test_compile_warning([[
#pragma whatever
return 1;
]])
test_any([[
#if 0
#pragma whatever
#endif
return 1;
]], 1)
test_compile_warning([[
#if 1
#pragma whatever
#endif
return 1;
]])

// #error
test_compile_error([[
#error Gurgel
]])

// #warning
test_compile_warning([[
#warning Gurgel
]])

// <<<<<<<
test_any([[
  master()->set_inhibit_compile_errors(1);
  int x = !!catch(cpp("<<<<<<<"));
  master()->set_inhibit_compile_errors(0);
  return x;
]], 1)
test_compile_error([[
#if 0
<<<<<<<
#endif
]])



define(do_test_cpp_string,[[
test_eq([[ (({""}) + (string)indices("."*256)/"" + ({""})) * $1]],
	[[ Stdio.write_file("testsuite.tmp",a()),compile_string("string s=#string \"testsuite.tmp\";")()->s ]])
]])

do_test_cpp_string([["0"]])
do_test_cpp_string([["1"]])
do_test_cpp_string([["2"]])
do_test_cpp_string([["3"]])
do_test_cpp_string([["4"]])
do_test_cpp_string([["5"]])
do_test_cpp_string([["6"]])
do_test_cpp_string([["7"]])
do_test_cpp_string([["8"]])
do_test_cpp_string([["9"]])
do_test_cpp_string([["a"]])
do_test_cpp_string([["A"]])
do_test_cpp_string([["\\"]])
do_test_cpp_string([["\\\\"]])
do_test_cpp_string([["\\\\\\"]])
do_test_cpp_string([["\""]])

// #undef inside an evaluation of the macro.
test_compile_error([[
#define LOCALE(X,Y) (Y)
#define DEFVAR(X, Y) ret[(X)]=my_defvar((X),(Y),vars)

  DEFVAR("cm_wa",
         Sitebuilder.SBConnect()->
         ChooseWorkareaVariable(LOCALE(0, "Work area") + LOCALE(0, "Work area"),
                                LOCALE(0, "the"));

  DEFVAR("cr_startpage",
         Variable.URLList(LOCALE(0, "Crawling behaviour") + LOCALE(0, "Start pages"), ""));

#undef DEFVAR

constant cif_defines = #"
   <input align='&_.img-align;' type='image' name='&_.name;' value='&_.contents;' src='&var.url;' border='0' />
</define>";
]])

// ####  Test annotations.

test_compile_any([[
  @constant;
]])
test_compile_any([[
  @Pike.Annotations.Implements(Builtin.null);
]])
test_compile_any([[
  import Pike.Annotations;
  @Implements(Builtin.null);
]])
test_compile_any([[
  import Pike.Annotations;
  class A {
    @Implements(A);
    int foo() {}
  }
]])
dnl test_compile_warning([[
dnl   import Pike.Annotations;
dnl   class A {
dnl     @Implements(A);
dnl     int foo();	// Just a prototype.
dnl   }
dnl ]])
test_compile_warning([[
  import Pike.Annotations;
  class A {
    int foo() {}
  }
  class B {
    @Implements(A);
  }
]])
dnl test_compile_warning([[
dnl   import Pike.Annotations;
dnl   class A {
dnl     int foo() {}
dnl   }
dnl   class B {
dnl     @Implements(A);
dnl     int foo();	// Just a prototype.
dnl   }
dnl ]])
test_compile_any([[
  import Pike.Annotations;
  class A {
    @Implements(A);
    int foo() {}
  }
  class B {
    // NB: The @Implements(A) annotation is NOT inherited from A.
    inherit A;
    float foo() { return 1.0; }
  }
]])
test_compile_any([[
  local class InheritedImplements {
    inherit Pike.Annotations.Implements;
    @constant;
    @Pike.Annotations.Inherited;
  }
  class A {
    // Everything that inherits A must implement A.
    @InheritedImplements(A);
    int foo() {}
  }
  class B {
    inherit A;
    int foo() { return 1; }
  }
]])
test_compile_error([[
  local class InheritedImplements {
    inherit Pike.Annotations.Implements;
    @constant;
    @Pike.Annotations.Inherited;
  }
  class A {
    // Everything that inherits A must implement A.
    @InheritedImplements(A);
    int foo() {}
  }
  class B {
    inherit A;
    // This fails due to bad return type compared with A::foo().
    float foo() { return 1.0; }
  }
]])

test_compile_any([[
  class A {
    int a;
  }
  class B {
    inherit A;
    @Pike.Annotations.Override: int a;
  }
]])
test_compile_error([[
  class A {
    int a;
  }
  class B {
    inherit A;

    // This fails due to b not being present in A.
    @Pike.Annotations.Override: int b;
  }
]])
test_compile_any([[
  class A {
    int a;
  }
  class B {
    private inherit A;

    @Pike.Annotations.Override: int a;
  }
]])
test_compile_any([[
  class A {
    int a;
  }
  class B {
    int b;
  }
  class C {
    inherit A;
    inherit B;

    @Pike.Annotations.Override: int a;
    @Pike.Annotations.Override: int b;
  }
]])
test_compile_error([[
  class A {
    int a;
  }
  class B {
    private inherit A;
  }
  class C {
    inherit B;

    // This fails due to a being hidden by B.
    @Pike.Annotations.Override: int a;
  }
]])

test_any_equal([[
  class A {
    @"class_A";
    @"constant_foo":constant foo = 0;
    @"function_bar":void bar() {}
    @"variable_baz":mixed baz;
    mixed a_none;
    @"variable_b_none":mixed b_none;
  }
  class B {
    @"class_B";
    @"inherit_A":inherit A;
    @"variable_buz":mixed buz;
    @"variable_a_none":mixed a_none;
    mixed b_none;
  }
  A a = A();
  B b = B();
  return ({
    mkmapping(indices(A), annotations(A)),
    mkmapping(indices(A), annotations(A, 1)),
    mkmapping(indices(a), annotations(a)),
    mkmapping(indices(a), annotations(a, 1)),
    mkmapping(indices(B), annotations(B)),
    mkmapping(indices(B), annotations(B, 1)),
    mkmapping(indices(b), annotations(b)),
    mkmapping(indices(b), annotations(b, 1)),
  });
]], [[
  ({
    ([ "foo": (< "constant_foo" >), ]),
    ([ "foo": (< "class_A", "constant_foo" >), ]),
    ([ "foo": (< "constant_foo" >),
       "bar": (< "function_bar" >),
       "baz": (< "variable_baz" >),
       "a_none": 0,
       "b_none": (< "variable_b_none" >),
    ]),
    ([ "foo": (< "class_A", "constant_foo" >),
       "bar": (< "class_A", "function_bar" >),
       "baz": (< "class_A", "variable_baz" >),
       "a_none": (< "class_A" >),
       "b_none": (< "class_A", "variable_b_none" >),
    ]),
    ([ "foo": (< "constant_foo" >), ]),
    ([ "foo": (< "class_B", "class_A", "inherit_A", "constant_foo" >), ]),
    ([ "foo": (< "constant_foo" >),
       "bar": (< "function_bar" >),
       "baz": (< "variable_baz" >),
       "buz": (< "variable_buz" >),
       "a_none": (< "variable_a_none" >),
       "b_none": 0,
    ]),
    ([ "foo": (< "class_B", "class_A", "inherit_A", "constant_foo" >),
       "bar": (< "class_B", "class_A", "inherit_A", "function_bar" >),
       "baz": (< "class_B", "class_A", "inherit_A", "variable_baz" >),
       "buz": (< "class_B", "variable_buz" >),
       "a_none": (< "class_B", "variable_a_none" >),
       "b_none": (< "class_B" >),
    ]),
  })
]])
test_any_equal([[
  // Issue #10147
  class A {
    @"sync": void syncfunc() { }
    @"async": __async__ void asyncfunc() { }
    @"gen": __generator__ void genfunc() { }
    @"asyncgen": __async__ __generator__ void asyncgenfunc() { }
  }
  A a = A();
  return mkmapping(indices(a), annotations(a));
]], [[
  ([ "syncfunc":(< "sync" >), "asyncfunc": (< "async" >),
     "genfunc":(< "gen" >), "asyncgenfunc": (< "asyncgen" >) ])
]])

// foop
define(do_test_foop,[[
test_eq($1 (17), !($2))
test_eq($1 (1.7), !($2-1))
test_eq($1 ("17"), !($2-2))
test_eq($1 (this), !($2-3))
test_eq($1 (a), !($2-4)) // a is the test function
test_eq($1 (({})), !($2-5))
test_eq($1 (([])), !($2-6))
test_eq($1 ((<>)), !($2-7))
test_eq($1 (this_program), !($2-8))
test_eq($1 (typeof(1)), 0)
]])

do_test_foop(intp,0)
do_test_foop(floatp,1)
do_test_foop(stringp,2)
do_test_foop(objectp,3)
do_test_foop(functionp,4)
do_test_foop(arrayp,5)
do_test_foop(mappingp,6)
do_test_foop(multisetp,7)
do_test_foop(programp,8)

// add_constant
test_do(add_constant("foobar",lambda() { return 1; }))
test_any([[
#if constant(foobar)
return 1;
#else
return 0;
#endif
]],1)
test_eq(foobar(),1)
test_do(add_constant("foobar"))
test_any([[
#if constant(foobar)
return 1;
#else
return 0;
#endif
]],0)


// ####  Test everything in all_constants.

// - __automap__
// - __empty_program
// - __null_program
// - __parse_pike_type
// - __placeholder_object
// - _describe_program
// - _disable_threads
// - _do_call_outs
// - _exit
// - _memory_usage
// - _static_modules
// - _typeof

// - _verify_internals
ifefun(_verify_internals,
[[
  test_do(_verify_internals())
]])

// - `!
// - `!=
// - `%

test_do([[
   class A (int x) { protected mixed `%(mixed y) { return this_program(x % (objectp(y)?y->x:y)); } };
   add_constant("A",A);
]])
test_eq(`%(A(13),A(5))->x, 3)
test_eval_error([[
   class B {}
   `%(B(),A(5));
]])
test_do(add_constant("A"));

test_do([[
   class A (int x) { protected mixed ``%(mixed y) { return this_program((objectp(y)?y->x:y) % x); } };
   add_constant("A",A);
]])
test_eq(`%(A(13),A(5))->x, 3)
test_eq(`%(13,A(5))->x, 3)
test_do(add_constant("A"));

test_eq(`%(Gmp.mpz(4), 1.5), Gmp.mpz(0))
test_eq(`%(4.5, Gmp.mpz(2)), Gmp.mpz(0))


// - `&

test_do([[
   class A (int x) { protected mixed `&(mixed y) { return this_program(x & (objectp(y)?y->x:y)); } };
   add_constant("A",A);
]])
test_eq(`&(A(7),A(5))->x, 5)
test_eq(`&(A(7),5)->x, 5)
test_eq(`&(A(7),A(5),A(4))->x, 4)
test_eq(`&(A(7),A(5),4)->x, 4)
test_eval_error([[
   class B {}
   `&(B(),A(5));
]])
test_do(add_constant("A"));

test_do([[
   class A (int x) { protected mixed ``&(mixed y) { return this_program(x & (objectp(y)?y->x:y)); } };
   add_constant("A",A);
]])
test_eq(`&(A(7),A(5))->x, 5)
test_eq(`&(7,A(5))->x, 5)
test_eq(`&(A(7),A(5),A(4))->x, 4)
test_eq(`&(7,A(5),A(4))->x, 4)
test_do(add_constant("A"));


// - `()
test_eq(1,`()(a))
test_eq(1,`()(lambda(int a){ return a; },1))
test_eq(1,`()(intp,1))

// - `*

test_do([[
   class A (int x) { protected mixed `*(mixed y) { return this_program(x * (objectp(y)?y->x:y)); } };
   add_constant("A",A);
]])
test_eq(`*(A(3),A(2))->x, 6)
test_eq(`*(A(3),2)->x, 6)
test_eq(`*(A(3),A(2),A(5))->x, 30)
test_eq(`*(A(3),A(2),5)->x, 30)
test_eval_error([[
   class B {}
   `*(B(),A(5));
]])
test_do(add_constant("A"));

test_do([[
   class A (int x) { protected mixed ``*(mixed y) { return this_program(x * (objectp(y)?y->x:y)); } };
   add_constant("A",A);
]])
test_eq(`*(A(3),A(2))->x, 6)
test_eq(`*(3,A(2))->x, 6)
test_eq(`*(A(3),A(2),A(5))->x, 30)
test_eq(`*(3,A(2),A(5))->x, 30)
test_do(add_constant("A"));

// - `+
test_eq(`+(1,1),2)
test_eq(`+(1,-2),-1)
test_eq(`+(-2,-2),-4)
test_eq(`+("hi","there"),"hithere")

test_eq(`+("hi\777","there"),"hi\777there")
test_eq(`+("hi","there\777"),"hithere\777")

test_eq(`+("hi\7777777","there"),"hi\7777777there")
test_eq(`+("hi","there\7777777"),"hithere\7777777")

test_eq(`+(5,6,"q"), "11q")
test_eq(`+(5,"q",6), "5q6")
test_eq(`+("",""), "")
test_eq(`+("","","a",""), "a")
test_eq(`+("a",UNDEFINED), "a0")
test_eq(`+("human","number",666),"humannumber666")
test_eq(`+("human","number",666),"humannumber666")
test_eq(`+("human","number",666),"humannumber666")
test_eq(`+("human","number",666,111),"humannumber666111")
test_eq(`+("humannumber",`+(666+111)),"humannumber777")
test_eq(`+("a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","x","y"),"abcdefghijklmnopqrstuvxy")
test_eq(`+(1.0,1.0),2.0)
test_eq(`+(1.0,-1.0),0.0)
test_eq(`+(-1.0,-1.0),-2.0)
test_equal(`+(({1,2,3}),({4,5,6})),({1,2,3,4,5,6}))
test_equal(`+(UNDEFINED,({1}),({2})), ({1,2}))
test_equal(`+(({1}),UNDEFINED,({2})), ({1,2}))
test_equal(`+((<1,2,3,4>),(<4,5,6>)),(<1,2,3,4,4,5,6>))
test_equal(`+(UNDEFINED,(<1>),(<2>)), (<1,2>))
test_equal(`+((<1>),UNDEFINED,(<2>)), (<1,2>))
test_equal(`+(([0:1,3:6]),([5:2,3:6])),([0:1,3:6,3:6,5:2]))
test_equal(`+(UNDEFINED,([1:2]),([3:4])), ([1:2,3:4]))
test_equal(`+(([1:2]),UNDEFINED,([3:4])), ([1:2,3:4]))

test_equal(17+class{protected mixed ``+(mixed n){return (<n>);}}(),(<17>))
test_equal(1700000000000000000000+class{protected mixed ``+(mixed n){return (<n>);}}(),(<1700000000000000000000>))

test_eval_error(Gmp.mpz(1700000000000000000000)+class{protected mixed ``+(mixed n){return (<n>);}}())

test_do([[
  class A (int x) {
    protected this_program `+(mixed y) {
      return this_program(x + (objectp(y)?y->x:y));
    }
  };
  add_constant("A",A);
]])
test_eq(`+(A(3),A(2))->x, 5)
test_eq(`+(A(3),2)->x, 5)
test_eq(`+(A(3),A(2),A(5))->x, 10)
test_eval_error([[
   class B {}
   `+(B(),A(5));
]])
test_do(add_constant("A"));

test_do([[
  class A (int x) {
    protected this_program ``+(mixed y) {
      return this_program(x + (objectp(y)?y->x:y));
    }
  };
  add_constant("A",A);
]])
test_eq(`+(A(3),A(2))->x, 5)
test_eq(`+(3,A(2))->x, 5)
test_eq(`+(A(3),A(2),A(5))->x, 10)
test_eq(`+(3,A(2),A(5))->x, 10)
test_do(add_constant("A"));

test_eq(`+(1.0,2,3.0), 6.0)
test_eq(`+(1,2.0,3), 6.0)

test_do([[
  class A {
    protected string `+(mixed s) { return "`+"+s; }
    protected string ``+(mixed s) { return s+"``+"; }
    protected string `+=(mixed s) { return "`+="+s; }
  };
  add_constant("A",A);
]])
test_eq(`+(A(),"e"), "`+=e")
test_any([[
  array a=({ A() });
  return `+(a[0],"e");
]], "`+e")
test_eq(`+("e",A()), "e``+")
dnl test_eq(`+(UNDEFINED,"x"), "x")
test_eq(`+(UNDEFINED,"x",A()), "x``+")
dnl test_eq(`+("x",UNDEFINED), "x")
test_eq(`+("x",UNDEFINED,A()), "x``+")
test_eq(`+(0,"x"), "0x")
test_eq(`+(0,"x",A()), "0x``+")
test_eq(`+("x",0), "x0")
test_eq(`+("x",0,A()), "x0``+")
test_eq(`+(1,2.0,A()), "3.0``+")
test_eq(`+(1.0,2,A()), "3.0``+")
test_eq(`+(1,2,A()), "3``+")
test_eq(`+(1.0,2.0,A()), "3.0``+")
test_eq(`+("a","b",A()), "ab``+")
test_do(add_constant("A"))

test_do([[
  class A { protected mixed ``+(mixed x) { return sprintf("%O",x)-" "-"\n"; } };
  add_constant("A",A);
]])
test_eq(`+(({1}),({2}),A()), "({/*2elements*/1,2})")
test_eq(`+((<1>),(<2>),A()), "(</*2elements*/1,2>)")
test_eq(`+(([1:2]),([3:4]),A()), "([/*2elements*/1:2,3:4])")
test_do(add_constant("A"))

test_do([[
  class A {
    protected mixed `+(mixed x) { return UNDEFINED; }
    protected mixed ``+(mixed x) { return UNDEFINED; }
  };
  add_constant("A",A);
]])
test_eval_error(`+(A(), ({1}), ({2})), ({1,2}))
test_eval_error(`+(({1}), A(), ({2})), ({1,2}))
test_do(add_constant("A"))

// - `-

test_do([[
   class A (int x) {
     protected mixed `-(mixed y) { return this_program(x - (objectp(y)?y->x:y)); }
     // Optimizer will modify the code which requires `+.
     protected mixed `+(int y) { return this_program(x+y); }
   };
   add_constant("A",A);
]])
test_eq(`-(A(5),A(2))->x, 3)
test_eq(`-(A(5),2)->x, 3)
test_eq(`-(A(5),A(2),A(1))->x, 2)
test_eq(`-(A(5),A(2),1)->x, 2)
test_eval_error([[
   class B {}
   `-(B(),A(5));
]])
test_do(add_constant("A"));

test_do([[
   class A (int x) {
     protected mixed ``-(mixed y) { return this_program((objectp(y)?y->x:y) - x); }
     // Optimizer will modify the code which requires `+.
     //mixed `+(int y) { return this_program(x+y); }
   };
   add_constant("A",A);
]])
test_eq(`-(A(5),A(2))->x, 3)
test_eq(`-(5,A(2))->x, 3)
test_eq(`-(A(5),A(2),A(1))->x, 2)
test_eq(`-(5,A(2),A(1))->x, 2)
test_do(add_constant("A"));

test_do([[
  class A (int x) {
    protected this_program `-(mixed|void y) {
      return this_program(-x);
    }
  };
  add_constant("A",A);
]])
test_eq(`-(A(5))->x, -5)
test_eval_error([[
   class B {};
   return `-(B());
]])
test_do(add_constant("A"));

test_eq(`-(4.5, Gmp.mpz(1)), Gmp.mpz(3))
test_eq(`-(Gmp.mpz(1), 4.5), Gmp.mpz(-3))

// - `->
// - `->=
// - `/

test_do([[
  class A (int x) {
    protected this_program `/(mixed y) {
      return this_program(x / (objectp(y)?y->x:y));
    }
  };
  add_constant("A",A);
]])
test_eq(`/(A(8),A(2))->x, 4)
test_eq(`/(A(8),2)->x, 4)
test_eq(`/(A(8),A(2),A(2))->x, 2)
test_eq(`/(A(8),A(2),2)->x, 2)
test_eval_error([[
   class B {}
   `/(B(),A(5));
]])
test_do(add_constant("A"));

test_do([[
  class A (int x) {
    protected this_program ``/(mixed y) {
      return this_program((objectp(y)?y->x:y) / x);
    }
  };
  add_constant("A",A);
]])
test_eq(`/(A(8),A(2))->x, 4)
test_eq(`/(8,A(2))->x, 4)
test_eq(`/(A(8),A(2),A(2))->x, 2)
test_eq(`/(8,A(2),A(2))->x, 2)
test_do(add_constant("A"));

test_eq(`/(4.5, Gmp.mpz(2)), 2.25)
test_eq(`/(Gmp.mpz(2), 4.0), 0.5))

// - `<
// - `<<
// - `<=
// - `==
// - `>
// - `>=
// - `>>
// - `[]
// - `[]=
// - `^

test_do([[
   class A (int x) { protected mixed `^(mixed y) { return this_program(x ^ (objectp(y)?y->x:y)); } };
   add_constant("A",A);
]])
test_eq(`^(A(7),A(1))->x, 6)
test_eq(`^(A(7),1)->x, 6)
test_eq(`^(A(7),A(1),A(7))->x, 1)
test_eq(`^(A(7),A(1),7)->x, 1)
test_eval_error([[
   class B {}
   `^(B(),A(5));
]])
test_do(add_constant("A"));

test_do([[
   class A (int x) { protected mixed ``^(mixed y) { return this_program(x ^ (objectp(y)?y->x:y)); } };
   add_constant("A",A);
]])
test_eq(`^(A(7),A(1))->x, 6)
test_eq(`^(7,A(1))->x, 6)
test_eq(`^(A(7),A(1),A(7))->x, 1)
test_eq(`^(7,A(1),A(7))->x, 1)
test_do(add_constant("A"));

// - `|

test_do([[
   class A (int x) { protected mixed `|(mixed y) { return this_program(x | (objectp(y)?y->x:y)); } };
   add_constant("A",A);
]])
test_eq(`|(A(3),A(6))->x, 7)
test_eq(`|(A(3),6)->x, 7)
test_eq(`|(A(3),A(6),A(9))->x, 15)
test_eq(`|(A(3),A(6),9)->x, 15)
test_eval_error([[
   class B {}
   `|(B(),A(5));
]])
test_do(add_constant("A"));

test_do([[
   class A (int x) { protected mixed ``|(mixed y) { return this_program(x | (objectp(y)?y->x:y)); } };
   add_constant("A",A);
]])
test_eq(`|(A(3),A(6))->x, 7)
test_eq(`|(3,A(6))->x, 7)
test_eq(`|(A(3),A(6),A(9))->x, 15)
test_eq(`|(3,A(6),A(9))->x, 15)
test_do(add_constant("A"));

// - `~

test_do([[
   class A (int x) { protected mixed `~() { return this_program(~x); } };
   add_constant("A",A);
]])
test_eq(`~(A(5))->x, -6)
test_eval_error([[
   class B {};
   return `-(B());
]])
test_do(add_constant("A"));

// - abs
// - acos
// Tested in _math

// - add_constant
test_compile_error(int a=grunk(5);)
test_do(add_constant("grunk",abs))
test_do(int a=grunk(5);)
test_do(add_constant("grunk"))
test_compile_error(int a=grunk(5);)

// - add_include_path
// - add_module_path
// - add_program_path
// Tested in lib

// - aggregate
test_equal(aggregate(),({}))
test_equal(aggregate(1,2,3,4),({1,2,3,4}))
test_equal(aggregate(1,2)+aggregate(3,4),({1,2,3,4}))
test_equal(aggregate(@({1,2,3,4})),({1,2,3,4}))
test_equal(aggregate(@({7})*50),({7})*50)

// - aggregate_multiset
test_equal(aggregate_multiset(), (<>))
test_equal(aggregate_multiset(1,1), (<1,1>))
test_equal(aggregate_multiset(1,2,"3"), (<1,2,"3">))

// - aggregate_mapping
test_equal(aggregate_mapping(), ([]))
test_equal(aggregate_mapping(1,2,3,4), ([1:2,3:4]))
test_eval_error(aggregate_mapping(1,2,3))

// - alarm

// - all_constants
test_true(mappingp(all_constants()))
test_eq(all_constants()["all_constants"],all_constants)

// - all_threads
ifefun(thread_create,
[[
  test_true(arrayp(all_threads()))
  test_true(sizeof(all_threads()))
  test_true(objectp(all_threads()[0]))
]])

// - allocate
test_equal(allocate(0),({}))
test_equal(allocate(2),({0,0}))
test_false(allocate(2)==({0,0}))
test_equal(allocate(2,2),({2,2}))
test_true(allocate(65536,random))

// - array_sscanf

// - arrayp
// Tested in foop

// - asin
// - atan
// - atan2
// Tested in _math

// - atexit

// - backtrace
test_true(arrayp(backtrace()))
test_eq(backtrace()[-1][2],a)

// - basename
// Tested in lib

// - basetype
test_eq(basetype(0),"int")
test_eq(basetype(0.0),"float")
test_eq(basetype(""),"string")
test_eq(basetype(({})),"array")
test_eq(basetype(({1})),"array")
test_eq(basetype((<>)),"multiset")
test_eq(basetype(([])),"mapping")
test_eq(basetype(class {}),"program")
test_eq(basetype(class {}()),"object")
test_eq(basetype(abs),"function")
test_eq(basetype(lambda(){}),"function")
test_eq(basetype(typeof(0)),"type")

// - call_function
test_eq(1,#pragma no_deprecation_warnings
call_function(a))
test_eq(1,#pragma no_deprecation_warnings
call_function(lambda(int a){ return a; },1))
test_eq(1,#pragma no_deprecation_warnings
call_function(intp,1))

// - call_out
// - call_out_info

// - callablep
define(test_callablep,[[
  test_eq( callablep($1), $2)
  test_any([[
    mixed x  = $1;
    mixed e = catch { x(); };
    return $2 ^ !!e;
  ]], 1)
]])

test_callablep(time, 1)
test_callablep(String.Buffer, 1)
test_callablep( class { protected void `()() { } }(), 1)
test_callablep(String.Buffer(), 0)
test_callablep( ({}), 1 )
test_callablep( ({ 0,0 }), 0 )
test_callablep( ({ 0,1 }), 0 )
test_callablep( ({ UNDEFINED, UNDEFINED }), 1 )
test_callablep( ({ UNDEFINED,1 }), 0 )
test_callablep( ({ time }), 1 )
test_callablep( ({ time, UNDEFINED }), 1 )
test_callablep( ({ "a", time }), 0 )
test_callablep( ({ "" }), 0 )
test_callablep( "", 0 )
test_callablep( 3.14, 0 )
test_callablep( (< time >), 0 )
test_callablep( 0, 0 )
test_callablep( UNDEFINED, 0 )
test_callablep( 7, 0 )
test_callablep( ({ ({ 0, 1, time }) }), 0 )
test_callablep( ({ ({ UNDEFINED, time }) }), 1 )
test_callablep( ({ ({ 0, "" }) }), 0 )
test_any([[
  array a = ({ UNDEFINED, UNDEFINED });
  a[1] = a;
  return callablep(a);
]], 1)
test_any([[
  array a = ({ UNDEFINED, UNDEFINED });
  a[1] = a;
  return equal(a(), a);
]], 1)

// - cd

// - ceil
// Tested in _math

// - chmod
// - chown
// - chroot
// - cleargroups
// - closelog

// - column
test_equal([[column(({({1,2,3}),({5,6,7}),({8,9,0})}),0)]],[[({1,5,8})]])
test_equal([[column(({({1,2,3}),({5,6,7}),({8,9,0})}),1)]],[[({2,6,9})]])
test_equal([[column(({({1,2,3}),({5,6,7}),({8,9,0})}),2)]],[[({3,7,0})]])
test_any_equal([[
  array a = ({({(["foo": 17])})});
  mixed res = column (a, "foo"); // Avoid constant optimization.
  return res && a[0][0];
]], (["foo": 17]))

// - combine_path
test_eq([[combine_path("/foo/bar/gazonk/","..")]],"/foo/bar")
test_eq([[combine_path("/foo/bar/gazonk","..")]],"/foo/bar")
test_eq([[combine_path("/foo/bar/", "gazonk")]],"/foo/bar/gazonk")
test_eq([[combine_path("/foo/bar", "gazonk")]],"/foo/bar/gazonk")
test_eq([[combine_path("/.../","sune")]],"/.../sune")
test_eq([[combine_path("/",".")]],"/")
test_eq([[combine_path("/","foo/.../sune")]],"/foo/.../sune")
test_eq([[combine_path("/./foo/bar//gazonk/","../")]],"/foo/bar/")
test_eq([[combine_path("/","/foo/./bar/gazonk/..")]],"/foo/bar")
test_eq([[combine_path("/","/foo/bar/gazonk/../../")]],"/foo/")
test_eq([[combine_path("/","/foo//bar/gazonk/../..")]],"/foo")
test_eq([[combine_path("/","/foo/bar/./gazonk/../../..")]],"/")
test_eq([[combine_path("/","/foo/../bar//./gazonk/../..")]],"/")
test_eq([[combine_path("/","/foo/././/bar/gazonk/../../../..")]],"/")
test_eq([[combine_path("/","..")]],"/")
test_eq([[combine_path("./","..")]],"..")
test_eq([[combine_path("./.","..")]],"..")
test_eq([[combine_path("/","../../foo")]],"/foo")
test_eq([[combine_path("./foobar/.","..")]],".")
test_eq([[combine_path("/","foo","bar","gazonk")]],"/foo/bar/gazonk")
test_eq([[combine_path("/", "foo", "")]], "/foo/")

test_eq([[combine_path("/","/foo/bar/ga\11111zonk/../../")]],"/foo/")
test_eq([[combine_path("/","/fo\1111/bar/ga\11111zonk/../../")]],"/fo\1111/")
test_eq([[combine_path("/","/fo\1111/bar/gazonk/../../")]],"/fo\1111/")

test_eq([[combine_path("foo", "../bar")]],"bar")
test_eq([[combine_path("foo/", "../bar")]],"bar")
test_eq([[combine_path("foo/", "../bar/")]],"bar/")
test_eq([[combine_path("foo/.", "../bar")]],"bar")
test_eq([[combine_path("foo", "..")]],".")
test_eq([[combine_path("foo/", "..")]],".")
test_eq([[combine_path("foo/.", "..")]],".")
test_eq([[combine_path(".", "bar")]],"bar")
test_eq([[combine_path("./", "bar")]],"bar")
test_eq([[combine_path(".", "../bar")]],"../bar")
test_eq([[combine_path("./", "../bar")]],"../bar")
test_eq([[combine_path("./bar")]],"bar")
test_eq([[combine_path("./bar")]],"bar")
test_eq([[combine_path("./../bar")]],"../bar")

// - combine_path_nt
test_eq([[combine_path_nt("/","/fo\1111/bar/gazonk/../../")]],"/fo\1111/")
test_eq([[combine_path_nt("a:/","/fo\1111/bar/gazonk/../../")]],"a:/fo\1111/")
test_eq([[combine_path_nt("a:/", "/foo","bar")+combine_path_nt("/foo","bar")]],
	  "a:/foo/bar/foo/bar")

// - combine_path_unix
test_eq([[combine_path_unix("/","/fo\1111/bar/gazonk/../../")]],"/fo\1111/")

// - append_path_nt
test_any([[
  // Bug 7723.
  int i;
  for (i = 0; i < 1000; i++) {
    array(string) a = (array(string))(({""}) + allocate(5, random)(10000));
    string ret = Stdio.append_path_nt("/", a*"/");
    if (ret != (a*"/")) {
      return sprintf("%d: %O != %O\n", i, ret, a*"/");
    }
  }
  return "";
]], "")

// - compile
// - compile_file

// - compile_string
// see test for clone()

cond_begin([[all_constants()->thread_create]])

  test_any([[
    string file = #"
/*
 * Attempt to trig the lex.current_file == NULL bug.
 *
 * Henrik Grubbström 1999-07-01
 */

string file = Stdio.File(__FILE__, \"r\")->read();

void thread_func()
{
  int i;

  for (i=0; i < 1000; i++) {
    compile_string(file);
  }
}

int main(int argc, array(string) argv)
{
  array(object) a = allocate(10, thread_create)(thread_func);

  a->wait();

  return 0;
}

";
  allocate(10, thread_create)(lambda() {
    int i;
    for(i = 0; i < 1000; i++) {
      compile_string(file);
      // These watchdog calls shouldn't be necessary - the timeframe
      // is at least 20 minutes between two calls, so doing these can
      // extend the test time to up to 20000 minutes before the
      // watchdog kicks in.. /mast
      //if (!(i%10))
      //  __signal_watchdog();
      if (!(i % 100))
	log_status ("%s: %O at %d", ctime (time())[..<1], this_thread(), i);
    }
  } )->wait();

  return 0;
  ]], 0)

cond_end // thread_create

// - copy_value
test_eq(copy_value(1),1)
test_eq(copy_value(""),"")
test_eq(copy_value(1.0),1.0)
test_eq(copy_value(this),this)
test_eq(copy_value(a),a)
test_eq(copy_value(typeof(true)),typeof(true))
define(do_test_copy_value,[[
test_any([[mixed x=$1; return x==x]],1)
test_any([[mixed x=$1; return copy_value(x)!=x]],1)
test_any([[mixed x=$1; return equal(copy_value(x),x)]],1)]])
do_test_copy_value( ({1}) )
do_test_copy_value( ([]) )
do_test_copy_value( (<>) )
do_test_copy_value( (< ([]), ({1}) ,"" , 1.0 >) )
test_true(get_weak_flag(copy_value(set_weak_flag(({17}), 1))))
test_true(get_weak_flag(copy_value(set_weak_flag((<17>), 1))))
test_true(get_weak_flag(copy_value(set_weak_flag(([17:17]), 1))))
test_true(get_weak_flag(copy_value(set_weak_flag(([17:({17})]), 1))))
test_any([[
  array x = ({0});
  x[0] = x;
  return equal (copy_value (x), x);
]], 1)
test_any([[
  mapping x = ([]);
  x[x] = x;
  return equal (copy_value (x), x);
]], 1)
test_any([[
  multiset x = (<>);
  x[x] = 1;
  return equal (copy_value (x), x);
]], 1)
test_any([[
   array a=({0,0,0});
   array b=copy_value(a); b[0]=17; b[1]=42; b[2]=128;
   return equal( ({0,0,0}), a) && equal( ({17,42,128}), b);
]], 1)
test_any([[
  // Bug 3693
  array(mapping) a = ({([])})*2;
  return a[0] == a[1];
]], 1)
test_any([[
  mapping m = ([]);
  multiset l = (<>);
  m->foo = ({l});
  m->bar = ({l});
  mapping copy = copy_value (m);
  return copy->foo != copy->bar && copy->foo[0] == copy->bar[0];
]], 1)

test_any([[
  class X {protected int __hash() {return 17;}};
  mixed c = copy_value (X());
  return objectp (c) && object_program (c) == X;
]], 1)

// - cos
// Tested in _math

// - cpp

// - crypt
test_do(add_constant("random",Random.Deterministic(17)->random))
test_eq(crypt("hello"),"yWUNYFIhtQEg6")
test_eq(crypt("hello"),"tB0k4A51tkBFI")
test_eq(crypt("hello"),"qLKH6pE54iDM.")
test_do(add_constant("random_string",Random.Deterministic(17)->random_string))
test_eq(crypt(), "SQn8XrmeKKetI");
test_eq(crypt(), "WkF1H7X4pX7YA");
test_do(add_constant("random",Random.System()->random))
test_do(add_constant("random_string",Random.System()->random_string))
test_true(crypt("hej",crypt("hej")))
test_true(crypt("hej","Oz5i0K.16qkgA"))
test_true(crypt("hej","buf8/Z7taE6qs"))
test_true(crypt("123456789", crypt("123456780")))
test_false(crypt("hej","hej"))
test_false(crypt("h","hej"))
test_false(crypt("hej","buf8/Z7taE6qst"))
test_false(crypt("hej","buf8/Z7taE6q"))

// - ctime
test_eq(ctime(0)[-1],'\n')
test_do([[int t = -1; catch(ctime(t));]])

// - decode_value
// - delay
// - describe_backtrace
// - describe_error

// - destruct
test_do(add_constant("PROG",compile_string("int foo() { return 1; }")));
test_any([[object o=PROG(); destruct(o); return o]],0);
test_any([[object o=PROG(); destruct(o); return objectp(o)]],0);
test_any([[array(object) o=({PROG()}); destruct(o[0]); return o-({0}) ]],({}));
test_any([[mapping o=(["foo":PROG()]); destruct(o["foo"]); return o["foo"]; ]],0);
dnl test_any([[object t; mapping o=([t=PROG():"foo"]); destruct(t); return sizeof(o)]],0);
test_do([[object t; array(object) o=({}); o+=({t=PROG()}); destruct(t); o=({});]]);
test_do(add_constant("PROG"))

// - dirname
// Tested in lib

// - encode_value
// - encode_value_canonic
// - endgrent
// - endpwent

// - enumerate
// Tested in lib

// - equal
// equal is already tested a lot in this script

test_any([[
  class X (string|zero s) {};
  return equal (({X ("foo")}), ({X (0)}));
]], 0)
test_any([[
  class X (string|zero s) {};
  return equal (({X (0)}), ({X ("foo")}));
]], 0)
test_any([[
  class X (string s) {};
  return equal (({X ("foo")}), ({X ("foo")}));
]], 1)

// - errno

// - error
// Tested in lib

// - exece
// - exit

// - exp
// Tested in _math

// - explode_path
// - file_stat
// - file_truncate
// - filesystem_stat

// - filter
// Tested in lib/modules

// - find_call_out

// - floatp
// Tested in foop

// - floor
// Tested in _math

// - fork

// - function_name
test_eq(function_name(a),"a")
test_eq(function_name(function_name),0)

// - function_object
test_eq(function_object(a),this)
test_eq(function_name(function_object),0)

// - function_program

// - functionp
// Tested in foop

// - gc
// gc is already tested above

// - get_all_groups
ifefun(get_all_groups,[[
  test_true(arrayp(get_all_groups()))
  test_any([[
    foreach(get_all_groups(), array group)
      foreach(group; int pos; array(string)|int|string value)
        switch(pos) {
          case 0: case 1:
            if(!stringp(value)) return 0;
            break;
          case 2:
            if(!intp(value)) return 0;
            break;
          case 3:
            if(!arrayp(value)) return 0;
            foreach(value, string user)
              if(!stringp(user)) return 0;
            break;
        }
    return 1;
  ]], 1)
]])

// - get_all_users
ifefun(get_all_users,[[
  test_true(arrayp(get_all_users()))
  test_any([[
    foreach(get_all_users(), array user)
      foreach(user; int pos; int|string value)
        switch(pos) {
          case 0: case 1: case 4: case 5: case 6:
            if(!stringp(value)) return 0;
            break;
          case 2: case 3:
            if(!intp(value)) return 0;
            break;
        }
    return 1;
  ]], 1)
]])

// - get_dir
test_do(Stdio.recursive_rm("get_dir_test"))
test_do(mkdir("get_dir_test"))
test_equal(get_dir("get_dir_test"),({}))
test_do(Stdio.write_file("get_dir_test/x", "x"));
test_equal(get_dir("get_dir_test"),({"x"}))
test_do(Stdio.recursive_rm("get_dir_test"))
test_true(arrayp(get_dir()))

// - get_groups_for_user
// - get_weak_flag

// - getcwd
test_true(stringp(getcwd()))
test_true(sizeof(getcwd()))
test_do(Stdio.recursive_rm("getcwd_test"))
test_do(mkdir("getcwd_test"))
test_any([[
  // NB: getcwd() may return $PWD if it matches the current directory.
  //     We do not want this as it may differ from the canonic path
  //     due to symlinks, etc in the path in $PWD, so invalidate $PWD.
  putenv("PWD");
  cd(".");	// Flush the cached value (if any).
  string a = getcwd();
  cd("getcwd_test");
  string b = getcwd();
  cd("..");
#ifdef __NT__
  return (a==getcwd() && b==a+"\\getcwd_test") || \
    ({ a, b, getcwd() });
#else
  return (a==getcwd() && b==a+"/getcwd_test") || \
    ({ a, b, getcwd() });
#endif
]], 1)
cond(Stdio.stdout["cd"], [[
  test_any([[
    string a = getcwd();
    Stdio.File f = Stdio.File(".", "r");
    f->cd("getcwd_test");
    string b = getcwd();
    cd("..");
  #ifdef __NT__
    return (a==getcwd() && b==a+"\\getcwd_test") || \
      ({ a, b, getcwd() });
  #else
    return (a==getcwd() && b==a+"/getcwd_test") || \
      ({ a, b, getcwd() });
  #endif
  ]], 1)
  test_any([[
    string a = getcwd();
    Stdio.File f = Stdio.File("getcwd_test", "r");
    f->cd();
    string b = getcwd();
    cd("..");
  #ifdef __NT__
    return (a==getcwd() && b==a+"\\getcwd_test") || \
      ({ a, b, getcwd() });
  #else
    return (a==getcwd() && b==a+"/getcwd_test") || \
      ({ a, b, getcwd() });
  #endif
  ]], 1)
  test_any([[
    string a = getcwd();
    Stdio.File f = Stdio.File("getcwd_test", "r");
    f->cd(".");
    string b = getcwd();
    cd("..");
  #ifdef __NT__
    return (a==getcwd() && b==a+"\\getcwd_test") || \
      ({ a, b, getcwd() });
  #else
    return (a==getcwd() && b==a+"/getcwd_test") || \
      ({ a, b, getcwd() });
  #endif
  ]], 1)
]])
test_do(Stdio.recursive_rm("getcwd_test"))

// - getegid
ifefun(getegid,[[
  test_true(intp(getegid()))
  test_true(getegid()==getegid())
]])

// - getenv

// - geteuid
ifefun(geteuid,[[
  test_true(intp(geteuid()))
  test_true(geteuid()==geteuid())
]])

// - getgid
ifefun(getgid,[[
  test_true(intp(getgid()))
  test_true(getgid()==getgid())
]])

// - getgrent
// - getgrgid
// - getgrnam
// - getgroups
// - gethostbyaddr
// - gethostbyname

// - gethostname
test_true(stringp(gethostname()))
test_true(sizeof(gethostname()))

// - gethrtime
// See time

// - gethrvtime

// - getpgrp
ifefun(getpgrp,[[
  test_true(intp(getpgrp()))
  test_true(getpgrp()==getpgrp())
]])

// - getpid
ifefun(getpid,[[
  test_true(intp(getpid()))
  test_true(getpid()==getpid())
]])

// - getppid
ifefun(getppid,[[
  test_true(intp(getppid()))
  test_true(getppid()==getppid())
]])

// - getpwent
// - getpwnam
// - getpwuid

// - getsid
ifefun(getsid,[[
  test_true(intp(getsid()))
  test_true(getsid()==getsid())
]])

// - getuid
ifefun(getuid,[[
  test_true(intp(getuid()))
  test_true(getuid()==getuid())
]])

// - glob
test_false(glob("","a"))
test_false(glob("a",""))
test_false(glob("?",""))
test_true(glob("*",""))
test_false(glob("foo","bar"))
test_true(glob("foo","foo"))
test_true(glob("f?o","foo"))
test_true(glob("f??","foo"))
test_true(glob("?o?","foo"))
test_true(glob("f*","foo"))
test_true(glob("*o","foo"))
test_true(glob("*<<<*","<<<"))
test_true(glob("*<<<*","<<<foo"))
test_false(glob("*f","foo"))
test_false(glob("o*","foo"))
test_false(glob("?f?","foo"))
test_equal([[glob("?f?",({"ff","ffff","off","fff",""}))]],[[({"off","fff"})]])
test_equal([[glob("foo*bar",({"foobar","foobargazonk","","foofoobar","fobar","fooar"}))]],[[({"foobar","foofoobar"})]])
test_eval_error([[
  array a=({"a","b",3});
  return glob("*", a);
]])
test_equal([[glob("foo", ({}))]], ({}))
test_false( glob( ({ "a*", "b*" }), "foo" ) )
test_eq( glob( ({ "a*", "b*" }), "bar" ), "b*" )
test_false( glob( "\\**", "a*") )
test_true( glob( "\\**", "*a") )
test_false( glob( "[abc]*", "[abc]d") )
test_true( glob( "\\[abc\\]*", "[abc]d") )
test_true( glob( "[abc]*", "ad") )

// - gmtime
cond([[all_constants()->localtime && all_constants()->mktime]],[[
  test_do([[int t = -1; catch(gmtime(t));]])
]])

// - hardlink

// - has_index
define(test_has_index,[[test_any([[mixed foo=$1; return has_index(foo,$2)==$3;]], 1)]])
test_has_index([[ ({}) ]],0,0)
test_has_index([[ ({}) ]],"foo",0)
test_has_index([[ ({ "a" }) ]],-1,0)
test_has_index([[ ({ "a" }) ]],"a",0)
test_has_index([[ ({ "a" }) ]],0,1)
test_has_index([[ ({ "a" }) ]],1,0)
test_has_index([[ ({ "a", "b" }) ]],1,1)
test_has_index([[ ([ "a":"A" ]) ]],4711,0)
test_has_index([[ ([ "a":"A" ]) ]],"a",1)
test_has_index([[ ([ "a":"A" ]) ]],"A",0)
test_has_index([[ ([ "a":"A", "b":"B", "c":"C" ]) ]],"b",1)
test_has_index([[ ([ "a":"A", "b":"B", "c":"C" ]) ]],"B",0)
test_has_index([[ (< "a" >) ]],4711,0)
test_has_index([[ (< "a" >) ]],"a",1)
test_has_index([[ (< "a" >) ]],"A",0)
test_has_index([[ (< "a", "b", "c" >) ]],"b",1)
test_has_index([[ (< "a", "b", "c" >) ]],"B",0)
test_has_index([[ class {}() ]],"foo",0)
test_has_index([[ (class{protected array _indices(){return({"a","b"});}})() ]],"b",1)

// - has_prefix
test_true(has_prefix("abc","a"))
test_false(has_prefix("abc","b"))
test_true(has_prefix("abc",""))
test_true(has_prefix("",""))
test_false(has_prefix("","abc"))
test_true(has_prefix("\666abc","\666a"))

// - has_suffix
test_true(has_suffix("cba","a"))
test_false(has_suffix("cba","b"))
test_true(has_suffix("abc",""))
test_true(has_suffix("",""))
test_false(has_suffix("","abc"))
test_true(has_suffix("cba\666","a\666"))

// - has_value
define(test_has_value,[[test_true([[mixed foo=$1; return has_value(foo,$2)==$3;]])]])
test_has_value([[ ({}) ]],0,0)
test_has_value([[ ({}) ]],"foo",0)
test_has_value([[ ({ "a" }) ]],-1,0)
test_has_value([[ ({ "a" }) ]],"a",1)
test_has_value([[ ({ "a" }) ]],0,0)
test_has_value([[ ({ "a", "b" }) ]],"b",1)
test_has_value([[ ([ "a":"A" ]) ]],4711,0)
test_has_value([[ ([ "a":"A" ]) ]],"a",0)
test_has_value([[ ([ "a":"A" ]) ]],"A",1)
test_has_value([[ ([ "a":"A", "b":"B", "c":"C" ]) ]],"B",1)
test_has_value([[ ([ "a":"A", "b":"B", "c":"C" ]) ]],"b",0)
test_has_value([[ class {}() ]],"foo",0)
test_has_value([[ (class{protected array _values(){return({"a","b"});}})() ]],"b",1)

// - hash
test_eq(hash("foo"),246314004)
test_eq(hash("foo",10),4)
test_eq(hash("bar"),134531432)
test_eq(hash("bar",10),2)
test_eq(hash("b\666arqwerty1234"),312063732)
test_eq(hash(""),1937178839)
test_eq(hash("\12345678"*10), 1294053961);
test_eq(hash("\12345"*10), 2138088857);
test_eval_error( return hash("foo",0) )
test_eval_error( return hash("foo",-1) )

// - hash_8_0
ignore_warning("Calling a deprecated value.", [[
test_eq(hash_8_0("foo"),2091538203)
test_eq(hash_8_0("foo",10),3)
test_eq(hash_8_0("bar"),2091518428)
test_eq(hash_8_0("bar",10),8)
test_eq(hash_8_0("b\666arqwerty1234"),1829582221)
test_eq(hash_8_0(""),0)
test_eval_error( return hash_8_0("foo",0) )
test_eval_error( return hash_8_0("foo",-1) )
]])

// - hash_7_4
define(test_hash_7_4, [[
  test_any([[
    int i = hash_7_4($1);
    return ]]dnl
ifelse([[$3]],,, [[((i==$2)||(i==$3))?$2:]])dnl
[[i;
  ]], $2)
]])
ignore_warning("Calling a deprecated value.", [[
test_hash_7_4("foo",2091538203)
test_hash_7_4([["foo",10]],3)
test_hash_7_4("bar",2091518428)
test_hash_7_4([["bar",10]],8)
test_hash_7_4("b\666arqwerty1234", 2142487018, 1858424874)
test_hash_7_4("",0)
test_eval_error( return 7.4::hash("foo",0) )
]])

// - hash_7_0
ignore_warning("Calling a deprecated value.", [[
test_eq([[ hash_7_0("foo") ]],27734)
test_eq([[ hash_7_0("foo",10) ]],4)
test_eq([[ hash_7_0("bar") ]],26689)
test_eq([[ hash_7_0("bar",10) ]],9)
test_eq([[ hash_7_0("b\666arqwerty1234") ]], [[(Pike.get_runtime_info().native_byteorder == 4321? 2142487018 : 1858424874)]])
test_eq([[ hash_7_0("") ]],0)
test_eval_error( return hash_7_0("foo",0) )
]])

// - hash_value
define(test_hash_value, [[
  test_true(intp(hash_value($1)))
  dnl Make sure the value to hash has a chance at surviving the optimizer...
  test_do(add_constant("test_value", $1))
  test_eq(hash_value($1),hash_value($1))
  test_do(add_constant("test_value"))
]])
test_hash_value(77)
test_hash_value(5.0)
test_hash_value("hello")
test_hash_value(({}))
dnl (<>) is mutable.
test_true(intp(hash_value((<>))))
dnl ([]) is mutable.
test_true(intp(hash_value(([]))))
test_hash_value(time)
test_hash_value(ADT.Stack)
dnl test_hash_value(String)
test_hash_value(typeof(true))
test_any([[
    int v = 0;

    void trampoline() {
        v = 1;
    };

    int(0..1) check_hash()
    {
        function f1 = trampoline;
        function f2 = trampoline;
        return hash_value(f1) == hash_value(f2);
    };

    return check_hash();
]], 1)


// - indices
test_equal(indices("foo"),({0,1,2}))
test_equal(indices(({'f','o','o'})),({0,1,2}))
test_equal(Array.sort_array(indices(([7:3,8:9,99:12]))),({7,8,99}))
test_equal(Array.sort_array(indices((<7,8,99>))),({7,8,99}))
test_equal(mkmultiset(indices(class{constant a="a"; constant b="b";}())),
	   (<"a","b">))

// - initgroups
// - innetgrp

// - int2char
// - int2hex
// Tested in String

// - intp
// Tested in foop

// - is_absolute_path
// Tested in lib

// - kill
// - load_module

// - localtime
cond([[all_constants()->localtime && (Pike.get_runtime_info()->time_size > 32)]],
[[
  test_true(mappingp(localtime(0)))
  test_eq(localtime(1<<31)->year, 138)
  test_eq(localtime(1<<32)->year, 206)
  test_eq(localtime(1<<33)->year, 342)
  test_equal(sort(indices(localtime(0))),({
     "hour",
     "isdst",
     "mday",
     "min",
     "mon",
     "sec",
     "timezone",
     "wday",
     "yday",
     "year"
  }))
  test_do([[int t = -1; catch(localtime(t));]])
]])
cond([[all_constants()->localtime && (Pike.get_runtime_info()->time_size == 32)]],
[[
  test_true(mappingp(localtime(0)))
  test_eval_error([[return localtime(1<<31)->year]])
  test_eq(localtime((1<<31)-1)->year, 138)
  test_equal(sort(indices(localtime(0))),({
     "hour",
     "isdst",
     "mday",
     "min",
     "mon",
     "sec",
     "timezone",
     "wday",
     "yday",
     "year"
  }))
  test_do([[int t = -1; catch(localtime(t));]])
]])
cond([[all_constants()->localtime && all_constants()->mktime]],
[[
  test_any([[int x=time(); return mktime(localtime(x)) == x;]], 1)
  test_any([[int x=time(); for(int y=0;y<100;y++) if(mktime(localtime(x+y)) != x+y) return x+y; return 0;]], 0)
]])


// - log
// Tested in _math

// - lower_case
test_equal(lower_case("foo"),"foo")
test_equal(lower_case("Foo"),"foo")
test_equal(lower_case("Foo1234-*~\n"),"foo1234-*~\n")
test_equal(lower_case("foo\x3000"),"foo\x3000")
test_equal(lower_case("Foo\x3000"),"foo\x3000")
test_equal(lower_case("Foo1234-*~\n\x3000"),"foo1234-*~\n\x3000")
test_equal(lower_case("foo\x13000"),"foo\x13000")
test_equal(lower_case("Foo\x13000"),"foo\x13000")
test_equal(lower_case("Foo1234-*~\n\x13000"),"foo1234-*~\n\x13000")
test_equal(lower_case("Foo\x178"),"foo\xff")
test_equal(lower_case("Foo\x39c"),"foo\x3bc")
test_equal(lower_case((string) ({
// These characters correspond to the cases in case_info.h
// Please update this and the corresponding upper_case table
// when UnicodeData.txt is changed.
// Part 1: 0x0000 - 0x0FFF
0x0000, 0x0041, 0x005b, 0x0061, 0x007b, 0x00b5, 0x00b6, 0x00c0,
0x00d7, 0x00d8, 0x00df, 0x00e0, 0x00f7, 0x00f8, 0x00ff, 0x0100,
0x0130, 0x0131, 0x0132, 0x0138, 0x0139, 0x0149, 0x014a, 0x0178,
0x0179, 0x017f, 0x0180, 0x0181, 0x0182, 0x0186, 0x0187, 0x0189,
0x018b, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0193, 0x0194,
0x0195, 0x0196, 0x0197, 0x0198, 0x019a, 0x019b, 0x019c, 0x019d,
0x019e, 0x019f, 0x01a0, 0x01a6, 0x01a7, 0x01a9, 0x01aa, 0x01ac,
0x01ae, 0x01af, 0x01b1, 0x01b3, 0x01b7, 0x01b8, 0x01ba, 0x01bc,
0x01be, 0x01bf, 0x01c0, 0x01c4, 0x01c5, 0x01c7, 0x01c8, 0x01ca,
0x01cb, 0x01dd, 0x01de, 0x01f0, 0x01f1, 0x01f2, 0x01f6, 0x01f7,
0x01f8, 0x0220, 0x0221, 0x0222, 0x0234, 0x023a, 0x023b, 0x023d,
0x023e, 0x023f, 0x0241, 0x0243, 0x0244, 0x0245, 0x0246, 0x0250,
0x0251, 0x0252, 0x0253, 0x0254, 0x0255, 0x0256, 0x0258, 0x0259,
0x025a, 0x025b, 0x025c, 0x025d, 0x0260, 0x0261, 0x0262, 0x0263,
0x0264, 0x0265, 0x0266, 0x0267, 0x0268, 0x0269, 0x026a, 0x026b,
0x026c, 0x026d, 0x026f, 0x0270, 0x0271, 0x0272, 0x0273, 0x0275,
0x0276, 0x027d, 0x027e, 0x0280, 0x0281, 0x0282, 0x0283, 0x0284, 0x0287,
0x0288, 0x0289, 0x028a, 0x028c, 0x028d, 0x0292, 0x0293, 0x029d,
0x029e, 0x029f, 0x0345, 0x0346, 0x0370, 0x0374, 0x0376, 0x0378,
0x037b, 0x037e, 0x037f, 0x0380, 0x0386, 0x0387, 0x0388, 0x038b,
0x038c, 0x038d, 0x038e, 0x0390, 0x0391, 0x03a0, 0x03a2, 0x03a3,
0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03c0, 0x03c2, 0x03c3, 0x03cc,
0x03cd, 0x03cf, 0x03d0, 0x03d1, 0x03d2, 0x03d5, 0x03d6, 0x03d7,
0x03d8, 0x03f0, 0x03f1, 0x03f2, 0x03f3, 0x03f4, 0x03f5, 0x03f6,
0x03f7, 0x03f9, 0x03fa, 0x03fc, 0x03fd, 0x0400, 0x0410, 0x0420,
0x0430, 0x0440, 0x0450, 0x0460, 0x0482, 0x048a, 0x04c0, 0x04c1,
0x04cf, 0x04d0, 0x0530, 0x0531, 0x0557, 0x0561, 0x0587, })), (string) ({
0x0000, 0x0061, 0x005b, 0x0061, 0x007b, 0x00b5, 0x00b6, 0x00e0,
0x00d7, 0x00f8, 0x00df, 0x00e0, 0x00f7, 0x00f8, 0x00ff, 0x0101,
0x0069, 0x0131, 0x0133, 0x0138, 0x013a, 0x0149, 0x014b, 0x00ff,
0x017a, 0x017f, 0x0180, 0x0253, 0x0183, 0x0254, 0x0188, 0x0256,
0x018c, 0x018d, 0x01dd, 0x0259, 0x025b, 0x0192, 0x0260, 0x0263,
0x0195, 0x0269, 0x0268, 0x0199, 0x019a, 0x019b, 0x026f, 0x0272,
0x019e, 0x0275, 0x01a1, 0x0280, 0x01a8, 0x0283, 0x01aa, 0x01ad,
0x0288, 0x01b0, 0x028a, 0x01b4, 0x0292, 0x01b9, 0x01ba, 0x01bd,
0x01be, 0x01bf, 0x01c0, 0x01c6, 0x01c6, 0x01c9, 0x01c9, 0x01cc,
0x01cc, 0x01dd, 0x01df, 0x01f0, 0x01f3, 0x01f3, 0x0195, 0x01bf,
0x01f9, 0x019e, 0x0221, 0x0223, 0x0234, 0x2c65, 0x023c, 0x019a,
0x2c66, 0x023f, 0x0242, 0x0180, 0x0289, 0x028c, 0x0247, 0x0250,
0x0251, 0x0252, 0x0253, 0x0254, 0x0255, 0x0256, 0x0258, 0x0259,
0x025a, 0x025b, 0x025c, 0x025d, 0x0260, 0x0261, 0x0262, 0x0263,
0x0264, 0x0265, 0x0266, 0x0267, 0x0268, 0x0269, 0x026a, 0x026b,
0x026c, 0x026d, 0x026f, 0x0270, 0x0271, 0x0272, 0x0273, 0x0275,
0x0276, 0x027d, 0x027e, 0x0280, 0x0281, 0x0282, 0x0283, 0x0284, 0x0287,
0x0288, 0x0289, 0x028a, 0x028c, 0x028d, 0x0292, 0x0293, 0x029d,
0x029e, 0x029f, 0x0345, 0x0346, 0x0371, 0x0374, 0x0377, 0x0378,
0x037b, 0x037e, 0x03f3, 0x0380, 0x03ac, 0x0387, 0x03ad, 0x038b,
0x03cc, 0x038d, 0x03cd, 0x0390, 0x03b1, 0x03c0, 0x03a2, 0x03c3,
0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03c0, 0x03c2, 0x03c3, 0x03cc,
0x03cd, 0x03d7, 0x03d0, 0x03d1, 0x03d2, 0x03d5, 0x03d6, 0x03d7,
0x03d9, 0x03f0, 0x03f1, 0x03f2, 0x03f3, 0x03b8, 0x03f5, 0x03f6,
0x03f8, 0x03f2, 0x03fb, 0x03fc, 0x037b, 0x0450, 0x0430, 0x0440,
0x0430, 0x0440, 0x0450, 0x0461, 0x0482, 0x048b, 0x04cf, 0x04c2,
0x04cf, 0x04d1, 0x0530, 0x0561, 0x0557, 0x0561, 0x0587, }))
test_equal(lower_case((string) ({
// These characters correspond to the cases in case_info.h
// Please update this and the corresponding upper_case table
// when UnicodeData.txt is changed.
// Part 2: 0x1000 -
0x10a0, 0x10c6, 0x10c7, 0x10c8, 0x10cd, 0x13a0, 0x13f0, 0x13f6,
0x13f8, 0x13fe, 0x1c80, 0x1c81, 0x1c82, 0x1c83, 0x1c85, 0x1c86,
0x1c87, 0x1c88, 0x1c89, 0x1d79, 0x1d7a, 0x1d7d, 0x1d7e, 0x1d8e,
0x1e00, 0x1e96, 0x1e9b, 0x1e9c, 0x1e9e, 0x1e9f, 0x1ea0, 0x1f00,
0x1f08, 0x1f10, 0x1f16, 0x1f18, 0x1f1e, 0x1f20, 0x1f28, 0x1f30,
0x1f38, 0x1f40, 0x1f46, 0x1f48, 0x1f4e, 0x1f51, 0x1f52, 0x1f53,
0x1f54, 0x1f55, 0x1f56, 0x1f57, 0x1f58, 0x1f59, 0x1f5a, 0x1f5b,
0x1f5c, 0x1f5d, 0x1f5e, 0x1f5f, 0x1f60, 0x1f68, 0x1f70, 0x1f72,
0x1f76, 0x1f78, 0x1f7a, 0x1f7c, 0x1f7e, 0x1f80, 0x1f88, 0x1f90,
0x1f98, 0x1fa0, 0x1fa8, 0x1fb0, 0x1fb2, 0x1fb3, 0x1fb4, 0x1fb8,
0x1fba, 0x1fbc, 0x1fbd, 0x1fbe, 0x1fbf, 0x1fc3, 0x1fc4, 0x1fc8,
0x1fcc, 0x1fcd, 0x1fd0, 0x1fd2, 0x1fd8, 0x1fda, 0x1fdc, 0x1fe0,
0x1fe2, 0x1fe5, 0x1fe6, 0x1fe8, 0x1fea, 0x1fec, 0x1fed, 0x1ff3,
0x1ff4, 0x1ff8, 0x1ffa, 0x1ffc, 0x1ffd, 0x2126, 0x2127, 0x212a,
0x212b, 0x212c, 0x2132, 0x2133, 0x214e, 0x214f, 0x2160, 0x2180,
0x2183, 0x2185, 0x24b6, 0x24d0, 0x24ea, 0x2c00, 0x2c2f, 0x2c30,
0x2c5f, 0x2c60, 0x2c62, 0x2c63, 0x2c64, 0x2c65, 0x2c66, 0x2c67,
0x2c6d, 0x2c6e, 0x2c6f, 0x2c70, 0x2c71, 0x2c72, 0x2c74, 0x2c75,
0x2c77, 0x2c7e, 0x2c80, 0x2ce4, 0x2ceb, 0x2cef, 0x2cf2, 0x2cf4,
0x2d00, 0x2d26, 0x2d27, 0x2d28, 0x2d2d, 0x2d2e, 0xa640, 0xa66e,
0xa680, 0xa69c, 0xa722, 0xa730, 0xa732, 0xa770, 0xa779, 0xa77d,
0xa77e, 0xa788, 0xa78b, 0xa78d, 0xa78e, 0xa790, 0xa794, 0xa796,
0xa7aa, 0xa7ab, 0xa7ac, 0xa7ad, 0xa7ae, 0xa7af, 0xa7b0, 0xa7b1,
0xa7b2, 0xa7b3, 0xa7b4, 0xa7b8, 0xa7b9, 0xa7c3, 0xa7c4, 0xa7c5,
0xa7c6, 0xa7c7, 0xa7c8, 0xa7c9, 0xa7ca, 0xa7d0, 0xa7d1, 0xa7d5,
0xa7d6, 0xa7d7, 0xa7f5, 0xa7f6, 0xab53, 0xab54, 0xab70, 0xabc0,
0xff21, 0xff3b, 0xff41, 0xff5b, 0x10400, 0x10428, 0x10450, 0x104b0,
0x104d4, 0x104d8, 0x104fc, 0x10c80, 0x10cb3, 0x10cc0, 0x10cf3, 0x118a0,
0x118e0, 0x1e900, 0x1e922, 0x1e944, })), (string) ({
0x2d00, 0x10c6, 0x2d27, 0x10c8, 0x2d2d, 0xab70, 0x13f8, 0x13f6,
0x13f8, 0x13fe, 0x1c80, 0x1c81, 0x1c82, 0x1c83, 0x1c85, 0x1c86,
0x1c87, 0x1c88, 0x1c89, 0x1d79, 0x1d7a, 0x1d7d, 0x1d7e, 0x1d8e,
0x1e01, 0x1e96, 0x1e9b, 0x1e9c, 0x00df, 0x1e9f, 0x1ea1, 0x1f00,
0x1f00, 0x1f10, 0x1f16, 0x1f10, 0x1f1e, 0x1f20, 0x1f20, 0x1f30,
0x1f30, 0x1f40, 0x1f46, 0x1f40, 0x1f4e, 0x1f51, 0x1f52, 0x1f53,
0x1f54, 0x1f55, 0x1f56, 0x1f57, 0x1f58, 0x1f51, 0x1f5a, 0x1f53,
0x1f5c, 0x1f55, 0x1f5e, 0x1f57, 0x1f60, 0x1f60, 0x1f70, 0x1f72,
0x1f76, 0x1f78, 0x1f7a, 0x1f7c, 0x1f7e, 0x1f80, 0x1f80, 0x1f90,
0x1f90, 0x1fa0, 0x1fa0, 0x1fb0, 0x1fb2, 0x1fb3, 0x1fb4, 0x1fb0,
0x1f70, 0x1fb3, 0x1fbd, 0x1fbe, 0x1fbf, 0x1fc3, 0x1fc4, 0x1f72,
0x1fc3, 0x1fcd, 0x1fd0, 0x1fd2, 0x1fd0, 0x1f76, 0x1fdc, 0x1fe0,
0x1fe2, 0x1fe5, 0x1fe6, 0x1fe0, 0x1f7a, 0x1fe5, 0x1fed, 0x1ff3,
0x1ff4, 0x1f78, 0x1f7c, 0x1ff3, 0x1ffd, 0x03c9, 0x2127, 0x006b,
0x00e5, 0x212c, 0x214e, 0x2133, 0x214e, 0x214f, 0x2170, 0x2180,
0x2184, 0x2185, 0x24d0, 0x24d0, 0x24ea, 0x2c30, 0x2c5f, 0x2c30,
0x2c5f, 0x2c61, 0x026b, 0x1d7d, 0x027d, 0x2c65, 0x2c66, 0x2c68,
0x0251, 0x0271, 0x0250, 0x0252, 0x2c71, 0x2c73, 0x2c74, 0x2c76,
0x2c77, 0x023f, 0x2c81, 0x2ce4, 0x2cec, 0x2cef, 0x2cf3, 0x2cf4,
0x2d00, 0x2d26, 0x2d27, 0x2d28, 0x2d2d, 0x2d2e, 0xa641, 0xa66e,
0xa681, 0xa69c, 0xa723, 0xa730, 0xa733, 0xa770, 0xa77a, 0x1d79,
0xa77f, 0xa788, 0xa78c, 0x0265, 0xa78e, 0xa791, 0xa794, 0xa797,
0x0266, 0x025c, 0x0261, 0x026c, 0x026a, 0xa7af, 0x029e, 0x0287,
0x029d, 0xab53, 0xa7b5, 0xa7b9, 0xa7b9, 0xa7c3, 0xa794, 0x0282,
0x1d8e, 0xa7c8, 0xa7c8, 0xa7ca, 0xa7ca, 0xa7d1, 0xa7d1, 0xa7d5,
0xa7d7, 0xa7d7, 0xa7f6, 0xa7f6, 0xab53, 0xab54, 0xab70, 0xabc0,
0xff41, 0xff3b, 0xff41, 0xff5b, 0x10428, 0x10428, 0x10450, 0x104d8,
0x104d4, 0x104d8, 0x104fc, 0x10cc0, 0x10cb3, 0x10cc0, 0x10cf3, 0x118c0,
0x118e0, 0x1e922, 0x1e922, 0x1e944, }))

// - m_delete
// - map

// - mappingp
// Tested in foop

// - master

// - max
// - min
// Tested in _math

// - mkdir

// - mkmapping
test_equal(mkmapping(({}),({})), ([]))
test_equal(mkmapping(({0}),({0})), ([0:0]))
test_any_equal([[
  array a=({"a"});
  return mkmapping(a,a);
]], (["a":"a"]))
test_equal(mkmapping( ({({})}),({({})}) )[ ({}) ], ({}))

// - mkmultiset
test_equal(mkmultiset(({})), (<>))
test_equal(mkmultiset(({0})), (<0>))
test_equal(mkmultiset(({(<>)})), (<(<>)>))

// - mktime
ifefun(mktime,
[[
  test_true([[mktime( ([
  "sec":58,
  "year":98,
  "mon":3,
  "mday":26,
  "hour":1,
  "min":51
]))]])

  test_eq([[mktime(58,51,1,26,3,98,0,0)]],[[mktime( ([
  "sec":58,
  "isdst":0,
  "year":98,
  "mon":3,
  "mday":26,
  "hour":1,
  "min":51,
  "timezone":0,
]) ) ]])

  // Check for mktime() in default timezone having a second count
  // that is off (observed on Haiku).
  test_eq([[localtime(mktime(0,0,0,1,0,70))->sec]], 0)
  test_eq([[localtime(mktime(59,59,23,31,11,69))->sec]], 59)

  test_any([[foreach(({1075550400,94691300,220921700,347152100,473382500,
		       599612900,725843300,852073700,978304100,1104534500,
		       1230764900,1356995300,1483225700,1609456100,1735686500,
                       1861916900,1988147300,2114377700,1500033813,
                       0,1,2,(1<<31)-1,
                       -0x67748580, -0x67748581,
                       -1<<31,(-1<<31)+1,-2,-1,
		      }),int t) {
	       if (mixed err = catch {
	           int res = mktime (gmtime (t));
	           if(res!=t) return ({t, res});
	         }) {
	         log_msg("Failure for %d (0x%08x).\n", t, t & 0xffffffff);
	         throw(err);
	       }
	     }
	     return 0;]], 0)
]])

cond([[all_constants()->mktime && (Pike.get_runtime_info()->time_size > 32)]],
[[
  test_any([[foreach(({-1<<33,-1<<32,
                       1<<31,(1<<31)+1,1<<32,1<<33,(-1<<31)-1,
		      }),int t) {
	       if (mixed err = catch {
		   int res = mktime (gmtime (t));
		   if(res!=t) return ({t, res});
		 }) {
		 log_msg("Failure for %d (0x%016x).\n",
			 t, t & 0xffffffffffffffff);
		 throw(err);
	       }
	     }
	     return 0;]], 0)
]])

ifefun(mktime,
[[
  test_eq(mktime (0, 0, 0, -200, -6, 101, 0, 0), 945043200);
  test_eq(mktime (0, 0, 0, -1, 2, 107, 0, 0), 1172534400);
  test_eq(mktime (0, 0, 0, 200, 1, 107, 0, 0), 1187481600);
  test_eq(mktime (200, 200, 200, 200, 1, 107, 0, 0), 1188213800);
  test_eq(mktime (-200, -200, -200, 200, 1, 107, 0, 0), 1186749400);
  test_eq(mktime (33, 3, 12, 14, 6, 117, 0, 0), 1500033813);
  test_eq(mktime ((["sec":33, "min":3, "hour":12,
   "mday":14, "mon":6, "year":117, "isdst":0, "timezone":0])), 1500033813);

  test_eq(strftime("%Y/%m/%d %H:%M:%S", gmtime(0)), "1970/01/01 00:00:00");
  test_eq(strftime("%Y/%m/%d %H:%M:%S", gmtime(1234567890)), "2009/02/13 23:31:30");
  test_eq(mktime(strptime(strftime("%Y/%m/%d %H:%M:%S", gmtime(1234567890)), "%Y/%m/%d %H:%M:%S") + (["timezone": 0])), 1234567890);

  test_any( [[
  // bug [2861] ------------------------------------------------------------
  // http://community/crunch/show_bug.cgi?id=2861
  return mktime(0,0,0,1,0,70,0,0);
  ]], 0)

  test_any( [[
  // bug [3270] ------------------------------------------------------------
  // http://community/crunch/show_bug.cgi?id=3270
  // Tue, 15 Oct 2002 09:38:32 GMT
  return mktime(32, 38, 9, 15, 9, 102, 0, 0);
  ]], 1034674712)
]])
cond([[all_constants()->mktime && (Pike.get_runtime_info()->time_size > 32)]],
[[
  test_any( [[
  // Mon, 26 Dec 1791, Charles Babbage's birthday
  return mktime((["year":-109,"mon":11,"mday":26,"timezone":0]));
  ]], -5617641600)
]])

// - multisetp
// Tested in foop

// - mv

// - normalize_path
// Tested in lib

// - object_program
test_true(programp(object_program(this_object())))
test_true(object_program(this)==this_program)

// - object_variablep
// - openlog

// - pow
// Tested in _math

// - programp
// Tested in foop

// - putenv
// Tested in lib

// - query_num_arg
test_eq(lambda(int ... q) { return query_num_arg(); }(),0)
test_eq(lambda(int ... q) { return query_num_arg(); }(1),1)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1),2)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1,1),3)
test_eq(lambda(int ... q) { return query_num_arg(); }(1,1,1,1),4)

// - random
// Tested in Random

// - random_string
// Tested in Random

// - readlink
// - remove_call_out

// - remove_include_path
// - remove_module_path
// - remove_program_path
// Tested in lib

// - replace
test_eq(replace("foo","f","\x9999"),"\x9999oo")
test_eq(replace("foo",({"f"}),({"\x9999"})),"\x9999oo")
test_eq([[replace("11013",({"1","100","108","13","1069","1067","106","10"}),
	({"A","B","C","D","E","F","G","H"}))]],"AHD")
test_eq([[replace("1264412124",({"126","124","12","122","1260"}),
         ({"13333","13335","883","13329","226709"}))]],"133334488313335")
test_eq(replace("foobargazonk","o","-"),"f--bargaz-nk")
test_eq(replace("foobargazonk",({"o","a"}),({"()","<>"})),"f()()b<>rg<>z()nk")
test_eq(replace("f--barf--",({"f--","f--bar"}),({"f--bar","f--"})),"f--f--bar")
test_eq(replace("f--barf--",({"f--bar","f--"}),({"f--","f--bar"})),"f--f--bar")
test_eq(replace("test\ntest\n\ntest\ntest",({"\n","\n\n"}),({" ","<p>"})),"test test<p>test test")
test_eq(replace("test\ntest\n\ntest\ntest",({"\n\n","\n"}),({"<p>"," "})),"test test<p>test test")
test_eq(replace("\xfffffff0", ({ "\xfffffff0" }), ({ "" })), "")
test_eq([[ replace("abcdefg", ([ "a":"x", "d":"y", "h":"z" ])) ]], "xbcyefg")

test_eq("123\000456""890"-"\0", "123\456""890")
test_eq("123\456000""890"-"\0", "123\456000""890")

test_any([[
  array a=({ 1 });
  replace(a,1,2);
  return a[0];
]], 2)

test_any([[
  mapping a=([ 1:1 ]);
  replace(a,1,2);
  return a[1];
]], 2)

test_any([[
function reference=lambda(string x, array(string) a, array(string) b)
{
  string ret="";
  for(int pos=0;pos<strlen(x);)
  {
    int best=-1;
    int bestlen=-1;
    for(int e=0;e<sizeof(a);e++)
    {
      if(strlen(a[e])>bestlen)
      {
	if(x[pos..pos+strlen(a[e])-1] == a[e])
	{
	  best=e;
	  bestlen=strlen(a[e]);
	}
      }
    }

    if(best==-1)
    {
      ret+=x[pos..pos];
      pos++;
    }else{
      ret+=b[best];
      pos+=bestlen;
    }
  }
  return ret;
};

  for(int e=0;e<10000;e++)
  {
    array(string) base=(array(string)) ( (({random})*(1+random(10)))(20) );

    for(int d=0;d<random(random(40));d++)
      base+=({ base[ random(sizeof(base))] + random(10) });

    base=Array.uniq(base);
    array(string) to=(array(string))Array.map(base,hash);

    string text="";
    for(int d=0;d<1+random(random(50));d++)
    {
      if(random(2))
	text+=base[ random(sizeof(base))];
      else
	text+=sprintf("%2d",random(100));
    }

    string r1=replace(text,base,to);
    string r2=reference(text,base,to);

    if(r1 != r2)
    {
      werror("\nFailure:\n");
      werror("Text: %O\n",text);
      werror("From: %O\n",base);
      werror("To  : %O\n",to);
      werror("Builtin: %O\n",r1);
      werror("Ref    : %O\n",r2);
      return -1;
    }
  }
  return 1;
]],1)

test_eq(replace("f\777\777bargaz\777nk","\777","-"),"f--bargaz-nk")
test_eq(replace("f\777\777bargaz\777nk",({"\777","a"}),({"()","<>"})),"f()()b<>rg<>z()nk")
test_eq(replace("f\777\777barf\777\777",({"f\777\777","f\777\777bar"}),({"f\777\777bar","f\777\777"})),"f\777\777f\777\777bar")
test_eq(replace("f\777\777barf\777\777",({"f\777\777bar","f\777\777"}),({"f\777\777","f\777\777bar"})),"f\777\777f\777\777bar")

test_eq(replace("f\7777777\7777777bargaz\7777777nk","\7777777","-"),"f--bargaz-nk")
test_eq(replace("f\7777777\7777777bargaz\7777777nk",({"\7777777","a"}),({"()","<>"})),"f()()b<>rg<>z()nk")
test_eq(replace("f\7777777\7777777barf\7777777\7777777",({"f\7777777\7777777","f\7777777\7777777bar"}),({"f\7777777\7777777bar","f\7777777\7777777"})),"f\7777777\7777777f\7777777\7777777bar")
test_eq(replace("f\7777777\7777777barf\7777777\7777777",({"f\7777777\7777777bar","f\7777777\7777777"}),({"f\7777777\7777777","f\7777777\7777777bar"})),"f\7777777\7777777f\7777777\7777777bar")

test_equal(replace(({1,2,3,4,5,1,2,3,4}),3,-1),({1,2,-1,4,5,1,2,-1,4}))
test_equal(replace(([1:2,3:4,5:1,2:3]),3,-1),([1:2,3:4,5:1,2:-1]))

test_eval_error([[
  mapping a = ([ "a":"b", 3:"c" ]);
  return replace("bar", a);
]])
test_eval_error([[
  mapping a = ([ "a":"b", "c":3 ]);
  return replace("bar", a);
]])
test_eval_error([[
  return replace("bar", ({"a"}), ({"b","c"}));
]])

// - replace_master

// - reverse
test_eq(reverse("reverse"),"esrever")
test_eq(reverse("foobar", 2, 4), "foabor")
test_eq(reverse("r\777v\777rs\777"),"\777sr\777v\777r")
test_eq(reverse("r\7777777v\7777777rs\7777777"),"\7777777sr\7777777v\7777777r")
test_eq(reverse(""),"")
test_eq(reverse("a"),"a")
test_equal(reverse(({1,5,9})),({9,5,1}))
test_equal(reverse(({})),({}))
test_equal(reverse(({42})),({42}))
test_equal(reverse(({42,4711})),({4711,42}))
test_equal(reverse(0x12345678),0x1e6a2c48)

// - rm

// - round
// Tested in _math

// - rows
test_equal([[rows(({1,2,3,4,5,6,7,8,9}),({6,7,2}))]],[[({7,8,3})]])
test_equal([[rows(({1,2,3,4,5,6,7,8,9}),({0,4,1}))]],[[({1,5,2})]])
test_equal([[rows(({1,2,3,4,5,6,7,8,9}),({8,3,5}))]],[[({9,4,6})]])

// - search
test_eval_error(return search("foolbar","o",-10))
test_eval_error(return search("foolbar","o",2983742))
test_eq(search("foolbar","gazonk"),-1)
test_eq(search("qowiueproqiuweproiwqueoplkjljlklksjjriwueproiuwerowieu","lkjljlklksjj"),24)
test_eq(search("lkjljlklksjjriwueproiuwerlskjdvlaskjfowieu","lkjljlklksjj"),0)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj","lkjljlklksjj"),24)

// Search cache is initialized with 10 slots.
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj1","lkjljlklksjj1"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj2","lkjljlklksjj2"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj3","lkjljlklksjj3"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj4","lkjljlklksjj4"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj5","lkjljlklksjj5"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj6","lkjljlklksjj6"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj7","lkjljlklksjj7"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj8","lkjljlklksjj8"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj9","lkjljlklksjj9"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj0","lkjljlklksjj0"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjjx","lkjljlklksjjx"),24)
test_eq(search("aaaaaaaaaaaaaaaaaaaaaaaalkjljlklksjj","lkjljlklksjj"),24)

test_eq(search("foobargazonk","oo"),1)
test_eq(search("foobargazonk","o",3),9)
test_eq(search("foobargazonk","o",9),9)
test_eq(search("foobargazonk","o",10),-1)
test_eq(search("foobargazonk","x",9),-1)
test_eq(search("foobargazonk",'o',3),9)
test_eq(search("foobargazonk",'o',9),9)
test_eq(search("foobargazonk",'o',10),-1)
test_eq(search("foobargazonk",'x',9),-1)
test_eq(search(({56,8,2,6,2,7,3,56,7}),8),1)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,0),0)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,1),7)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,7),7)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56,8),-1)
test_eq(search("foobargazonk","oo", 0, 2),-1)
test_eq(search("foobargazonk","o", 3, 9),-1)
test_eq(search("foobargazonk","o", 3, 10), 9)
test_eq(search("foobargazonk",'o', 3, 9),-1)
test_eq(search("foobargazonk",'o', 3, 10), 9)
test_eq(search(({56,8,2,6,2,7,3,56,7}), 8, 0, 1),-1)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56, 0, 1),0)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56, 1, 7),-1)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56, 7, 8),7)
test_eq(search(({56,8,2,6,2,7,3,56,7}),56, 7, 7),-1)
test_eq(search(({"foo"}),"foo"),0)
test_eq(search("fo-obar|gazonk"/"|","fo-obar"),0)
test_eq(search("fo-obar|gazonk"/"|","gazonk"),1)
test_eq(search(([1:2,3:4,5:6,7:8]),4),3)
test_true(zero_type(search(([1:2,3:4,5:6,7:8]),(int)3)))
test_eq(search(([1:2,3:4,5:6,7:8]),8),7)
test_eq(search("foo",""),0)
test_any([[
  mapping m=([]);
  m+=(["x":([])]);
  m->x->y++;
  m=([]);
  m+=(["x":([])]);
  return m->x->y;
]], 0)

test_do([[
  class C
  {
    mapping m;

    protected int `==()
    {
      foreach(indices(m), mixed x)
  	m_delete(m, x);
      return 0;
    }

    protected void create(mapping _m)
    {
      m = _m;
    }
  };

  mapping m = ([ ]);
  C o = C(m);

  for(int i = 0; i < 100; i++)
    m[i] = o;

  return search(m, 4711);
]])

test_any_equal([[
  mapping m = (["foo": "bar", "bar": "gnu", "gnu": "bar"]);
  array a = ({});
  a += ({search (m, "bar")});
  a += ({search (m, "bar", a[-1])});
  a += ({search (m, "bar", a[-1])});
  return sort (a);
]], sort(({0, "foo", "gnu"})))

test_equal([[
  sort(({"\Uffffffff","\0", "", "\177", "\377", "\U7fffffff"}));
]], ({ "", "\Uffffffff", "\0", "\177", "\377", "\U7fffffff" }))

// test large searches (find string, size, pattern)
define(test_search,[[
test_eq(sprintf($1+"%'"+$3+"'*n",$2)[..strlen($1)-1],$1)
test_eq(search(sprintf($1+"%'"+$3+"'*n",$2),$1),0)
test_eq(search(sprintf("%'"+$3+"'*n" ,$2),$1),-1)
test_eq(search(sprintf("%'"+$3+"'*n"+$1,$2),$1),$2)
test_eq(search(sprintf("%'"+$3+"'*n"+$1+"%'"+$3+"'*n",$2,$2),$1),$2)
]])

define(test_search2,[[dnl
test_search($1,$2,$3)
test_search($1,$2+1,$3)
test_search($1,$2+2,$3)
test_search($1,$2+3,$3)
test_search($1,$2+4,$3)
test_search($1,$2+5,$3)
]])

define(test_search3,[[dnl
test_search2($1,10,$2)
test_search2($1,1000,$2)
test_search2($1,100000,$2)
]])

define(test_search4,[[dnl
test_search3($1,"+-*")
test_search3($1,($1[..strlen($1)-2]))
test_search3($1,($1[..strlen($1)-3]))
test_search3($1,($1[1..]))
]])

dnl some m4's don't handle 8 bit characters...
test_search4("SUNE")
test_search4("kapit\344l>")
test_search4("-------------------+")
test_search4("\345-------------------")
test_search4(sprintf("%'argel-bargel glop-glyf?'2000n"))
test_search4("\34567-------------------")
test_search4("\345677777-------------------")
test_search4("kapit\3333l>")
test_search4("kapit\3333333l>")

test_eq(search((string)({123456})*390, " "*199), -1);

// - set_priority
// - set_weak_flag
// - setegid
// - seteuid
// - setgid
// - setgrent
// - setgroups
// - setpgrp
// - setpwent
// - setresgid
// - setresuid
// - setsid
// - setuid

// - sgn
// Tested in _math

// - signal
// - signame
// - signum

// - sin
// Tested in _math

// - sizeof
test_eq(sizeof("felbar"),6)
test_eq(sizeof(({"fulbar","gazonk",7})),3)
test_eq(sizeof(([8:3,6:6,7:0])),3)
test_eq(sizeof((<8,7,6,5,4,7>)),6)
test_eq([[ sizeof( class { protected int _sizeof() { return 17; } }() ) ]], 17)

// - sleep
test_do(sleep(1))
test_do(sleep(0.5))
test_any([[int x=time(); sleep(2); return x!=time()]],1)
test_any([[int x=time(); sleep(2); return x!=time()]],1)

// - sort
test_equal(sort(({1,3,2,4})),({1,2,3,4}))
test_equal(sort(({4,3,2,1})),({1,2,3,4}))
test_equal(sort(({({1, 4}), ({3, 2}), ({2, 3}), ({4, 1})})),
		({({1, 4}), ({2, 3}), ({3, 2}), ({4, 1})}))
test_equal(sort(({({4, 1}), ({2, 3}), ({3, 2}), ({1, 4})})),
		({({1, 4}), ({2, 3}), ({3, 2}), ({4, 1})}))
test_equal([[lambda() {array(int) a=({1,2,3,4}); sort(({4,3,2,1}),a); return a; }()]],[[({4,3,2,1})]] )
test_equal([[lambda() {array(int) a=({1,2,3,4}), b=a+({}); sort(({4,3,2,1}),a,b); return b; }()]],[[({4,3,2,1})]] )
test_equal([[sort("a,A,å,Å,ä,*A,[A"/",")]],[["*A,A,[A,a,Å,ä,å"/","]])
test_equal([[sort(sprintf("%c",enumerate(256)[*]))]],
  [[sprintf("%c",enumerate(256)[*])]])
test_equal([[sort(sprintf("%c",enumerate(1024)[*]))]],
  [[sprintf("%c",enumerate(1024)[*])]])
test_equal(sort(({})),({}))
test_equal(sort(({1.0,2.0,4.0,3.0})),({1.0,2.0,3.0,4.0}))
test_any_equal([[
  // sort() on one arg should be stable.
  class C (int id) {protected int `< (mixed x) {return 0;}};
  return sort (({C(2), C(6), C(1), C(4), C(3), C(5)}))->id;
]], ({2, 6, 1, 4, 3, 5}))
test_any_equal([[
  // sort() on several args should be stable.
  array a = ({2, 6, 1, 4, 3, 5});
  sort (({1, 1, 1, 1, 1, 1}), a);
  return a;
]], ({2, 6, 1, 4, 3, 5}))
test_any_equal([[
  // sort() on several args should be stable.
  array a = ({2, 6, 1, 4, 3, 5});
  sort (({1, 2, 1, 2, 1, 2}), a);
  return a;
]], ({2, 1, 3, 6, 4, 5}))
test_any([[
  class foo {
    int x=random(100);
    protected int `<(object o) {return x < o->x;}
  };
  array(object) o=allocate(100,foo)();
  sort(o);
  for(int e=1;e<100;e++)
    if(o[e-1]->x > o[e]->x)
      return e;
  return -1;
]],-1)
test_equal(sort (({(<2>), (<1>)})), ({(<1>), (<2>)}))
test_any_equal([[
  function pike_fun = lambda() {};
  function c_fun = sleep;
  return ({equal (sort (({pike_fun, pike_fun})), ({pike_fun, pike_fun})),
	   equal (sort (({c_fun, c_fun})), ({c_fun, c_fun})),
	   equal (sort (({pike_fun, c_fun})), ({pike_fun, c_fun})),
	   equal (sort (({c_fun, pike_fun})), ({pike_fun, c_fun}))});
]], [[({1, 1, 1, 1})]])

dnl missing tests for objects, arrays, multisets and mappings

// - sprintf
// Tested in sprintf

// - sqrt
// Tested in _math

// - strerror
test_true(stringp(strerror(0)))
test_true(stringp(strerror(1)))
test_true(stringp(strerror(-1)))

// - string_to_unicode, unicode_to_string
dnl string, utf16, utf16le
define(test_unicode, [[
  test_eq(string_to_unicode($1), $2)
  test_eq(string_to_unicode($1, 0), $2)
  test_eq(string_to_unicode($1, 1), $3)
  test_eq(string_to_unicode($1, 2),
	  ((Pike.get_runtime_info()->native_byteorder == 1234)?$3:$2))
  test_eq(unicode_to_string($2), $1)
  test_eq(unicode_to_string($2, 0), $1)
  test_eq(unicode_to_string($3, 1), $1)
  test_eq(unicode_to_string(((Pike.get_runtime_info()->native_byteorder == 1234)?$3:$2), 2), $1)
  test_eq(unicode_to_string("\xfe\xff" $2), $1)
  test_eq(unicode_to_string("\xfe\xff" $2, 0), $1)
  test_eq(unicode_to_string("\xfe\xff" $2, 1), $1)
  test_eq(unicode_to_string("\xfe\xff" $2, 2), $1)
  test_eq(unicode_to_string("\xff\xfe" $3), $1)
  test_eq(unicode_to_string("\xff\xfe" $3, 0), $1)
  test_eq(unicode_to_string("\xff\xfe" $3, 1), $1)
  test_eq(unicode_to_string("\xff\xfe" $3, 2), $1)
]])
test_unicode("", "", "")
test_unicode("foo", "\0f\0o\0o", "f\0o\0o\0")
test_unicode("blä", "\0b\0l\0ä", "b\0l\0ä\0")
test_unicode("\77077", "\176\77", "\77\176")
test_unicode("\777077", "\330\277\336\77",  "\277\330\77\336")
test_unicode("\777077foo\77077\777077blä\777077",
	     "\330\277\336\77\0f\0o\0o\176\77\330\277\336\77\0b\0l\0ä\330\277\336\77",
	     "\277\330\77\336f\0o\0o\0\77\176\277\330\77\336b\0l\0ä\0\277\330\77\336")

test_eval_error(return string_to_unicode("\7077077"))
test_eval_error(return string_to_unicode("\xffff\x10000"))
test_eval_error(return unicode_to_string(" "))

// - string_to_utf8, utf8_to_string
test_eq(string_to_utf8("foo"), "foo")
test_eq(string_to_utf8("blä"), "bl\303\244")
test_eq(string_to_utf8("\77077"), "\347\270\277")
test_eq(string_to_utf8("\U0010ffff\U00100000\U00010000"), "\364\217\277\277\364\200\200\200\360\220\200\200")
test_eq(string_to_utf8("\U0010ffff\U00100000\U00010000", 2), "\355\257\277\355\277\277\355\257\200\355\260\200\355\240\200\355\260\200")
test_eq(string_to_utf8("\7077077", 1), "\367\207\270\277")
test_eq(string_to_utf8("\77077077", 1), "\370\277\207\270\277")
test_eq(string_to_utf8("\7077077077", 1), "\374\270\277\207\270\277")

// 077077077077 has 33 bits unsigned. The escape sequence parser used
// to silently truncate too long char values, but not anymore.
dnl test_eq(string_to_utf8("\77077077077", 1), "\376\203\270\277\207\270\277")
dnl test_eq(utf8_to_string("\376\203\270\277\207\270\277", 1), "\77077077077")
// The following uses the char that actually got tested.
test_eq(string_to_utf8("\37077077077", 1), "\376\203\270\277\207\270\277")
test_eq(utf8_to_string("\376\203\270\277\207\270\277", 1), "\37077077077")

test_eq(utf8_to_string("\374\270\277\207\270\277", 1), "\7077077077")
test_eq(utf8_to_string("\370\277\207\270\277", 1), "\77077077")
test_eq(utf8_to_string("\367\207\270\277", 1), "\7077077")
test_eval_error(return utf8_to_string("\355\257\277\355\277\277\355\257\200\355\260\200\355\240\200\355\260\200"))
test_eq(utf8_to_string("\355\257\277\355\277\277\355\257\200\355\260\200\355\240\200\355\260\200", 2), "\U0010ffff\U00100000\U00010000")
test_eq(utf8_to_string("\364\217\277\277\364\200\200\200\360\220\200\200"), "\U0010ffff\U00100000\U00010000")
test_eq(utf8_to_string("\347\270\277"), "\77077")
test_eq(utf8_to_string("bl\303\244"), "blä")
test_eq(utf8_to_string("foo"), "foo")

test_eval_error(return string_to_utf8("\77077077077"))
test_eval_error(return utf8_to_string("\376\203\270\277\207\270\277"))
test_eval_error(return utf8_to_string("\277"));
test_eval_error(return utf8_to_string("\377"));
test_eval_error(return utf8_to_string("\376\203\270\277\207\270", 1));
test_eval_error(return utf8_to_string("\374\270\277\207\270"));
test_eval_error(return utf8_to_string("\370\277\207\270"));
test_eval_error(return utf8_to_string("\367\207\270"));
test_eval_error(return utf8_to_string("\347\270"));
test_eval_error(return utf8_to_string("\303"));
test_eval_error(return utf8_to_string("\376\203\270\277\207\270a"));
test_eval_error(return utf8_to_string("\374\270\277\207\270a"));
test_eval_error(return utf8_to_string("\370\277\207\270a"));
test_eval_error(return utf8_to_string("\367\207\270a"));
test_eval_error(return utf8_to_string("\347\270a"));
test_eval_error(return utf8_to_string("\303a"));

// Invalid ranges
test_eq(string_to_utf8 ("\ud7ff"), "\u00ed\u009f\u00bf")
test_eval_error(return string_to_utf8 ("\ud800"))
test_eq(string_to_utf8 ("\ud800", 1), "\u00ed\u00a0\u0080")
test_eq(string_to_utf8 ("\udfff", 1), "\u00ed\u00bf\u00bf")
test_eval_error(return string_to_utf8 ("\udfff"))
test_eq(string_to_utf8 ("\ue000"), "\u00ee\u0080\u0080")
test_eq(string_to_utf8 ("\U0010ffff"), "\u00f4\u008f\u00bf\u00bf")
test_eval_error(return string_to_utf8 ("\U00110000"))
test_eq(string_to_utf8 ("\U00110000", 1), "\u00f4\u0090\u0080\u0080")

test_eq(utf8_to_string ("\u00ed\u009f\u00bf"), "\ud7ff")
test_eval_error(return utf8_to_string ("\u00ed\u00a0\u0080"))
test_eq(utf8_to_string ("\u00ed\u00a0\u0080", 1), "\ud800")
test_eq(utf8_to_string ("\u00ed\u00bf\u00bf", 1), "\udfff")
test_eval_error(return utf8_to_string ("\u00ed\u00bf\u00bf"))
test_eq(utf8_to_string ("\u00ee\u0080\u0080"), "\ue000")
test_eq(utf8_to_string ("\u00f4\u008f\u00bf\u00bf"), "\U0010ffff")
test_eval_error(return utf8_to_string ("\u00f4\u0090\u0080\u0080"))
test_eq(utf8_to_string ("\u00f4\u0090\u0080\u0080", 1), "\U00110000")
test_eval_error(return utf8_to_string ("\u00f8\u0088\u0080\u0080\u0080"))
test_eval_error(return utf8_to_string ("\u00fc\u0084\u0080\u0080\u0080\u0080"))
test_eval_error(return utf8_to_string ("\u00fe\u0082\u0080\u0080\u0080\u0080\u0080"))
test_eq(utf8_to_string ("\u00fe\u0083\u00bf\u00bf\u00bf\u00bf\u00bf", 1), "\Uffffffff")
test_eval_error(return utf8_to_string ("\u00fe\u0084\u0080\u0080\u0080\u0080\u0080", 1))
test_eval_error(return utf8_to_string ("\u00ff"))
test_eval_error(return utf8_to_string ("\u00ff", 1))

// Non-shortest forms
test_eval_error(return utf8_to_string ("\u00c0\u0080"))
test_eval_error(return utf8_to_string ("\u00c1\u00bf"))
test_eq(utf8_to_string ("\u00c2\u0080"), "\u0080")
test_eval_error(return utf8_to_string ("\u00e0\u0080\u0080"))
test_eval_error(return utf8_to_string ("\u00e0\u009f\u00bf"))
test_eq(utf8_to_string ("\u00e0\u00a0\u0080"), "\u0800"))
test_eval_error(return utf8_to_string ("\u00f0\u0080\u0080\u0080"))
test_eval_error(return utf8_to_string ("\u00f0\u008f\u00bf\u00bf"))
test_eq(utf8_to_string ("\u00f0\u0090\u0080\u0080"), "\U00010000")
test_eval_error(return utf8_to_string ("\u00f8\u0080\u0080\u0080\u0080", 1))
test_eval_error(return utf8_to_string ("\u00f8\u0087\u00bf\u00bf\u00bf", 1))
test_eq(utf8_to_string ("\u00f8\u0088\u0080\u0080\u0080", 1), "\U00200000")
test_eval_error(return utf8_to_string ("\u00fc\u0080\u0080\u0080\u0080\u0080", 1))
test_eval_error(return utf8_to_string ("\u00fc\u0083\u00bf\u00bf\u00bf\u00bf", 1))
test_eq(utf8_to_string ("\u00fc\u0084\u0080\u0080\u0080\u0080", 1), "\U04000000")
test_eval_error(return utf8_to_string ("\u00fe\u0080\u0080\u0080\u0080\u0080\u0080", 1))
test_eval_error(return utf8_to_string ("\u00fe\u0081\u00bf\u00bf\u00bf\u00bf\u00bf", 1))
test_eq(utf8_to_string ("\u00fe\u0082\u0080\u0080\u0080\u0080\u0080", 1), "\U80000000")

// validate_utf8
test_true(validate_utf8("foo"))
test_false(validate_utf8("blä"))
test_true(validate_utf8("bl\303\244"))
test_false(validate_utf8([string(8bit)](mixed)"\77077"))
test_true(validate_utf8("\347\270\277"))
test_false(validate_utf8([string(8bit)](mixed)"\7077077"))
test_false(validate_utf8("\367\207\270\277"))
test_true(validate_utf8("\367\207\270\277", 1))
test_false(validate_utf8("\370\277\207\270\277"))
test_true(validate_utf8("\370\277\207\270\277", 1))
test_false(validate_utf8([string(8bit)](mixed)"\7077077077"))
test_false(validate_utf8("\374\270\277\207\270\277"))
test_true(validate_utf8("\374\270\277\207\270\277", 1))

test_false(validate_utf8("\376\203\270\277\207\270\277"))
test_true(validate_utf8("\376\203\270\277\207\270\277", 1))

test_false(validate_utf8("\277"));
test_false(validate_utf8("\377"));
test_false(validate_utf8("\376\203\270\277\207\270", 1));
test_false(validate_utf8("\374\270\277\207\270"));
test_false(validate_utf8("\370\277\207\270"));
test_false(validate_utf8("\367\207\270"));
test_false(validate_utf8("\347\270"));
test_false(validate_utf8("\303"));
test_false(validate_utf8("\376\203\270\277\207\270a"));
test_false(validate_utf8("\374\270\277\207\270a"));
test_false(validate_utf8("\370\277\207\270a"));
test_false(validate_utf8("\367\207\270a"));
test_false(validate_utf8("\347\270a"));
test_false(validate_utf8("\303a"));

// Invalid ranges
test_true(validate_utf8("\u00ed\u009f\u00bf"))
test_false(validate_utf8("\u00ed\u00a0\u0080"))
test_true(validate_utf8("\u00ed\u00a0\u0080", 1))
test_false(validate_utf8("\u00ed\u00a0\u0080", 2))
test_false(validate_utf8("\u00ed\u00bf\u00bf"))
test_true(validate_utf8("\u00ed\u00bf\u00bf", 1))
test_false(validate_utf8("\u00ed\u00bf\u00bf", 2))
test_true(validate_utf8("\u00ed\u00a0\u0080\u00ed\u00bf\u00bf", 2))

test_true(validate_utf8("\u00ee\u0080\u0080"))
test_true(validate_utf8("\u00f4\u008f\u00bf\u00bf"))
test_false(validate_utf8("\u00f4\u0090\u0080\u0080"))
test_true(validate_utf8("\u00f4\u0090\u0080\u0080", 1))
test_false(validate_utf8("\u00f4\u0090\u0080\u0080", 2))

test_false(validate_utf8("\u00f8\u0088\u0080\u0080\u0080"))
test_false(validate_utf8("\u00fc\u0084\u0080\u0080\u0080\u0080"))
test_false(validate_utf8("\u00fe\u0082\u0080\u0080\u0080\u0080\u0080"))
test_true(validate_utf8("\u00fe\u0083\u00bf\u00bf\u00bf\u00bf\u00bf", 1))
test_false(validate_utf8("\u00fe\u0084\u0080\u0080\u0080\u0080\u0080", 1))
test_false(validate_utf8("\u00ff"))
test_false(validate_utf8("\u00ff", 1))

// Non-shortest forms
test_false(validate_utf8("\u00c0\u0080"))
test_false(validate_utf8("\u00c1\u00bf"))
test_true(validate_utf8("\u00c2\u0080"))
test_false(validate_utf8("\u00e0\u0080\u0080"))
test_false(validate_utf8("\u00e0\u009f\u00bf"))
test_true(validate_utf8("\u00e0\u00a0\u0080"))
test_false(validate_utf8("\u00f0\u0080\u0080\u0080"))
test_false(validate_utf8("\u00f0\u008f\u00bf\u00bf"))
test_true(validate_utf8("\u00f0\u0090\u0080\u0080"))
test_false(validate_utf8("\u00f8\u0080\u0080\u0080\u0080", 1))
test_false(validate_utf8("\u00f8\u0087\u00bf\u00bf\u00bf", 1))
test_true(validate_utf8("\u00f8\u0088\u0080\u0080\u0080", 1))
test_false(validate_utf8("\u00fc\u0080\u0080\u0080\u0080\u0080", 1))
test_false(validate_utf8("\u00fc\u0083\u00bf\u00bf\u00bf\u00bf", 1))
test_true(validate_utf8("\u00fc\u0084\u0080\u0080\u0080\u0080", 1))
test_false(validate_utf8("\u00fe\u0080\u0080\u0080\u0080\u0080\u0080", 1))
test_false(validate_utf8("\u00fe\u0081\u00bf\u00bf\u00bf\u00bf\u00bf", 1))
test_true(validate_utf8("\u00fe\u0082\u0080\u0080\u0080\u0080\u0080", 1))

// - stringp
// Tested in foop

// - strlen
test_compile_error(strlen( ({}) ))

// - symlink
// - syslog

// - tan
// Tested in _math

// - this_object and this
test_true(objectp(this_object()))
test_true(objectp(this))
test_true(objectp(global::this))
test_true(this_object() == this)
test_true([[typeof(this) == typeof(this_object())]])
test_true([[typeof(this) == typeof(global::this)]])
test_true([[typeof(this_program) == typeof(object_program(this_object()))]])
test_true([[typeof(this_program) == typeof(object_program(global::this))]])

test_program_eq([[
  protected string _sprintf() {return "g";}
  class A {
    protected string _sprintf() {return "A";}
    class B {
      protected string _sprintf() {return "B";}
      mixed f() {
	return sprintf ("%O%O%O%O%O%O",
			global::this, A::this, B::this, this_program::this, this::this, this);
      }
    }
  }
  string a() {return A()->B()->f();}
]], "gABBBB")

test_program_eq([[
  protected string _sprintf() {return "g";}
  class A {
    protected string _sprintf() {return "A";}
    class B {
      protected string _sprintf() {return "B";}
      mixed f() {
	return sprintf ("%O%O%O%O%O",
			this_object (2), this_object (1), this_object (0), this_object(), this);
      }
    }
  }
  string a() {return A()->B()->f();}
]], "gABBB")

test_program_eq([[
  protected string _sprintf() {return "g";}
  class A {
    protected string _sprintf() {return "A";}
    class B {
      protected string _sprintf() {return "B";}
      mixed f() {
	return map (({2, 1, 0}), lambda (int l) {
				   return sprintf ("%O", this_object (l));
				 }) * "";
      }
    }
  }
  string a() {return A()->B()->f();}
]], "gAB")

test_program_eq([[
  protected string _sprintf() {return "g";}
  class A {
    protected string _sprintf() {return "A";}
    class B {
      protected string _sprintf() {return "B";}
      mixed f() {
	return sprintf ("%O%O%O%O%O%O",
			global::this, A::this, B::this, this_program::this, this::this, this);
      }
    }
    constant this = 7;
  }
  string a() {return A()->B()->f();}
]], "g7BBB7")

test_compile_error([[
  this = 17;
]])

test_compile_error([[
  class A {
    class B {
      void f() {A::this = 17;}
    }
  };
]])

test_any([[
  class A {
    class B {
      A parent() {return A::this;}
    }
  };
  A a = A();
  A.B b = a->B();
  destruct (a);
  return zero_type (b->parent());
]], 2)

test_eval_error([[
  class A {
    class B {
      class C {
	A grandparent() {return A::this;}
      }
    }
  };
  A.B b = A()->B();
  A.B.C c = b->C();
  destruct (b);
  b->grandparent();
]], 2)

test_program_eq([[
  protected string _sprintf() {return "g";}
  class A {
    protected string _sprintf() {return "A";}
    mixed f() {
      return sprintf ("%O%O", global::this, A::this);
    }
  }
  class B {
    protected string _sprintf() {return "B";}
    class C {
      inherit A;
      protected string _sprintf() {return "C";}
      mixed f() {
	return A::f() + sprintf ("%O%O%O%O",
				 global::this, B::this, this_program::this, this);
      }
    }
  }
  string a() {return B()->C()->f();}
]], "gCgBCC")

test_program_eq([[
  protected string _sprintf() {return "g";}
  class A {
    protected string _sprintf() {return "A";}
    mixed f() {
      return sprintf ("%O%O%O%O",
		      global::this, A::this, this_program::this, this);
    }
  }
  class B {
    protected string _sprintf() {return "B";}
    class C {
      inherit A;
      protected string _sprintf() {return "C";}
      mixed f() {
	return A::f() + "|" +
	  sprintf ("%O%O%O%O%O",
		   global::this, B::this, C::this, this_program::this, this);
      }
    }
  }
  string a() {return B()->C()->f();}
]], "gCCC|gBCCC")

test_program([[
  class A {
    class B {
      mixed f() {
	return typeof (A::this) != typeof (B::this);
      }
    }
  }
  int a() {return A()->B()->f();}
]])

test_program([[
  class A {
    class B {
      mixed f() {
	return typeof (this_object (1)) != typeof (this_object (0));
      }
    }
  }
  int a() {return A()->B()->f();}
]])

test_program([[
  class A {
    class B {
      mixed f() {
	return typeof (A::this_program) != typeof (B::this_program);
      }
    }
  }
  int a() {return A()->B()->f();}
]])

test_any([[
  // Test disambiguation order with multiple inherit and ::this_program.
  class A {
    class Foo {
      string foo() { return "A"; }
    }
  };
  class B {
    class Foo {
      string foo() { return "B"; }
    }
  };
  class C {
    inherit A;
    inherit B;
    class Foo {
      // We expect this to inherit B::Foo and not A::Foo.
      inherit ::this_program;
    }
  };
  return C()->Foo()->foo();
]], "B")

// Names of inherits
test_program_eq([[
  // 1: Direct inherit in the current class.
  class A { local constant foo = 1; };
  inherit A;
  class B { inherit A; local constant foo = 2; };
  class C { inherit B:A; local constant foo = 4;
    int get_foo() {
      return A::foo;
    }
  };
  int a() { return C()->get_foo(); }
]],[[2]])
test_program_eq([[
  // 2: The name of the current class.
  class A { local constant foo = 1; };
  inherit A:C;
  class B { inherit A:C; local constant foo = 2; };
  class C { inherit B; local constant foo = 4;
    int get_foo() {
      return C::foo;
    }
  };
  int a() { return C()->get_foo(); }
]],[[4]])
test_program_eq([[
  // 3.1: Direct inherit in a surrounding parent class.
  class A { local constant foo = 1; };
  class B { inherit A; local constant foo = 2; };
  inherit B:A;
  class C { inherit B; local constant foo = 4;
    int get_foo() {
      return A::foo;
    }
  };
  int a() { return C()->get_foo(); }
]],[[2]])
test_program_eq([[
  // 3.2: The name of a surrounding parent class.
  class D {
    class A { local constant foo = 1; };
    inherit A;
    class B { inherit A; local constant foo = 2; };
    class C { inherit B; local constant foo = 4;
      int get_foo() {
        return D::foo;
      }
    };
    int get_foo() {
      return C()->get_foo();
    }
  };
  int a() { return D()->get_foo(); }
]],[[1]])
test_program_eq([[
  // 4: Indirect inherit in the current class.
  class A { local constant foo = 1; };
  class B { inherit A; local constant foo = 2; };
  class C { inherit B; local constant foo = 4;
    int get_foo() {
      return A::foo;
    }
  };
  int a() { return C()->get_foo(); }
]],[[1]])
test_program_eq([[
  // 5: Indirect inherit in a surrounding parent class.
  class A { local constant foo = 1; };
  class B { inherit A; local constant foo = 2; };
  class C { inherit B; local constant foo = 4;
    class D {
      local constant foo = 8;
      int get_foo() {
        return A::foo;
      }
    }
    int get_foo() { return D()->get_foo(); }
  };
  int a() { return C()->get_foo(); }
]],[[1]])

test_program_eq([[
  object ao = compile_string(#"
    string id() {return \"A\";}
    class B {
      string id() {return \"B\";}
      string foo()
      {
	return this->id() + id() + local::id() + global::this->id() + global::id();
      }
    }")();

  class Handler
  {
    mixed resolv (string id, void|string file, void|object handler)
    {
      if (id == "B") return ao->B;
      return master()->resolv (id, file, handler);
    }
  }

  string a()
  {
    object c = compile_string(#"
      string id() {return \"C\";}
      class D {
	inherit B;
	string id() {return \"D\";}
	string foo()
	{
	  return ::foo() + \"|\" +
	    this->id() + id() + B::id() + global::this->id() + global::id();
	}
      }", UNDEFINED, Handler())();

    return c->D()->foo();
  }
]], "DDBAA|DDBCC")

test_program_eq([[
  class X
  {
    object parent() {return global::this;}
  }

  class Handler
  {
    mixed resolv (string id, void|string file, void|object handler)
    {
      if (id == "X") return X;
      return master()->resolv (id, file, handler);
    }
  }

  object a()
  {
    object o = compile_string ("inherit X;", UNDEFINED, Handler())();
    return o->parent();
  }
]], this)


// - this_thread
// - thread_create
// - thread_local

// - throw
test_eq(20,catch(throw(a())))

// - time
test_true(time())
test_true(time(1))
test_true(intp(time()))
test_true(intp(time(1)))
test_true(floatp(time(2)))

// gethrtime() may gethrtime(), RDTSC or gettimeofday
// sleep uses a combination of select/poll and the above
// time() uses gettimeofday
test_any([[
   float tts=2.0;

   int t0=time();
   float t1=time(t0);
   int hrt1=gethrtime();
   sleep(tts);
   int hrt2=gethrtime();
   float t2=time(t0);

   float e=(hrt2-hrt1)*1e-6;
   float f=t2-t1;

   array r=({});
   if (e<tts-0.1 || e>tts+0.2)
      r+=({sprintf("hrtime %.6f, %+.6f",e,e-tts)});

   if (f<tts-0.1 || f>tts+0.2)
      r+=({sprintf("timeofday %.6f, %+.6f",f,f-tts)});

   if (sizeof(r)) return r*" / ";
   return "no error";
]],"no error")

// - trace
test_do(trace(0))
test_eq(trace(0),0)

// - ualarm

// - umask
test_true(intp(System.umask()))
test_eq(System.umask(System.umask()),System.umask())

// - uname
test_true(mappingp(uname()))

// - unicode_to_string
// See string_to_unicode

// - upper_case
test_equal(upper_case("fooq"),"FOOQ")
test_equal(upper_case("FooR"),"FOOR")
test_equal(upper_case("Foo1234-*~\n"),"FOO1234-*~\n")
test_equal(upper_case("fooq\x3000"),"FOOQ\x3000")
test_equal(upper_case("FooR\x3000"),"FOOR\x3000")
test_equal(upper_case("Foo1234-*~\n\x3000"),"FOO1234-*~\n\x3000")
test_equal(upper_case("fooq\x13000"),"FOOQ\x13000")
test_equal(upper_case("FooR\x13000"),"FOOR\x13000")
test_equal(upper_case("Foo1234-*~\n\x13000"),"FOO1234-*~\n\x13000")
test_equal(upper_case("Foo\xff"),"FOO\x178")
test_equal(upper_case("Foo\xb5"),"FOO\x39c")
test_equal(upper_case((string) ({
// These characters correspond to the cases in case_info.h
// Please update this and the corresponding lower_case table
// when UnicodeData.txt is changed.
// Part 1: 0x0000 - 0x0FFF
0x0000, 0x0041, 0x005b, 0x0061, 0x007b, 0x00b5, 0x00b6, 0x00c0,
0x00d7, 0x00d8, 0x00df, 0x00e0, 0x00f7, 0x00f8, 0x00ff, 0x0100,
0x0130, 0x0131, 0x0132, 0x0138, 0x0139, 0x0149, 0x014a, 0x0178,
0x0179, 0x017f, 0x0180, 0x0181, 0x0182, 0x0186, 0x0187, 0x0189,
0x018b, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0193, 0x0194,
0x0195, 0x0196, 0x0197, 0x0198, 0x019a, 0x019b, 0x019c, 0x019d,
0x019e, 0x019f, 0x01a0, 0x01a6, 0x01a7, 0x01a9, 0x01aa, 0x01ac,
0x01ae, 0x01af, 0x01b1, 0x01b3, 0x01b7, 0x01b8, 0x01ba, 0x01bc,
0x01be, 0x01bf, 0x01c0, 0x01c4, 0x01c5, 0x01c7, 0x01c8, 0x01ca,
0x01cb, 0x01dd, 0x01de, 0x01f0, 0x01f1, 0x01f2, 0x01f6, 0x01f7,
0x01f8, 0x0220, 0x0221, 0x0222, 0x0234, 0x023a, 0x023b, 0x023d,
0x023e, 0x023f, 0x0241, 0x0243, 0x0244, 0x0245, 0x0246, 0x0250,
0x0251, 0x0252, 0x0253, 0x0254, 0x0255, 0x0256, 0x0258, 0x0259,
0x025a, 0x025b, 0x025c, 0x025d, 0x0260, 0x0261, 0x0262, 0x0263,
0x0264, 0x0265, 0x0266, 0x0267, 0x0268, 0x0269, 0xa7ae, 0x026b,
0x026c, 0x026d, 0x026f, 0x0270, 0x0271, 0x0272, 0x0273, 0x0275,
0x0276, 0x027d, 0x027e, 0x0280, 0x0281, 0x0282, 0x0283, 0x0284, 0x0287,
0x0288, 0x0289, 0x028a, 0x028c, 0x028d, 0x0292, 0x0293, 0x029d,
0x029e, 0x029f, 0x0345, 0x0346, 0x0370, 0x0374, 0x0376, 0x0378,
0x037b, 0x037e, 0x037f, 0x0380, 0x0386, 0x0387, 0x0388, 0x038b,
0x038c, 0x038d, 0x038e, 0x0390, 0x0391, 0x03a0, 0x03a2, 0x03a3,
0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03c0, 0x03c2, 0x03c3, 0x03cc,
0x03cd, 0x03cf, 0x03d0, 0x03d1, 0x03d2, 0x03d5, 0x03d6, 0x03d7,
0x03d8, 0x03f0, 0x03f1, 0x03f2, 0x03f3, 0x03f4, 0x03f5, 0x03f6,
0x03f7, 0x03f9, 0x03fa, 0x03fc, 0x03fd, 0x0400, 0x0410, 0x0420,
0x0430, 0x0440, 0x0450, 0x0460, 0x0482, 0x048a, 0x04c0, 0x04c1,
0x04cf, 0x04d0, 0x0530, 0x0531, 0x0557, 0x0561, 0x0587, })), (string) ({
0x0000, 0x0041, 0x005b, 0x0041, 0x007b, 0x039c, 0x00b6, 0x00c0,
0x00d7, 0x00d8, 0x00df, 0x00c0, 0x00f7, 0x00d8, 0x0178, 0x0100,
0x0130, 0x0049, 0x0132, 0x0138, 0x0139, 0x0149, 0x014a, 0x0178,
0x0179, 0x0053, 0x0243, 0x0181, 0x0182, 0x0186, 0x0187, 0x0189,
0x018b, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0193, 0x0194,
0x01f6, 0x0196, 0x0197, 0x0198, 0x023d, 0x019b, 0x019c, 0x019d,
0x0220, 0x019f, 0x01a0, 0x01a6, 0x01a7, 0x01a9, 0x01aa, 0x01ac,
0x01ae, 0x01af, 0x01b1, 0x01b3, 0x01b7, 0x01b8, 0x01ba, 0x01bc,
0x01be, 0x01f7, 0x01c0, 0x01c4, 0x01c5, 0x01c7, 0x01c8, 0x01ca,
0x01cb, 0x018e, 0x01de, 0x01f0, 0x01f1, 0x01f2, 0x01f6, 0x01f7,
0x01f8, 0x0220, 0x0221, 0x0222, 0x0234, 0x023a, 0x023b, 0x023d,
0x023e, 0x2c7e, 0x0241, 0x0243, 0x0244, 0x0245, 0x0246, 0x2c6f,
0x2c6d, 0x2c70, 0x0181, 0x0186, 0x0255, 0x0189, 0x0258, 0x018f,
0x025a, 0x0190, 0xa7ab, 0x025d, 0x0193, 0xa7ac, 0x0262, 0x0194,
0x0264, 0xa78d, 0xa7aa, 0x0267, 0x0197, 0x0196, 0xa7ae, 0x2c62,
0xa7ad, 0x026d, 0x019c, 0x0270, 0x2c6e, 0x019d, 0x0273, 0x019f,
0x0276, 0x2c64, 0x027e, 0x01a6, 0x0281, 0xa7c5, 0x01a9, 0x0284, 0xa7b1,
0x01ae, 0x0244, 0x01b1, 0x0245, 0x028d, 0x01b7, 0x0293, 0xa7b2,
0xa7b0, 0x029f, 0x0399, 0x0346, 0x0370, 0x0374, 0x0376, 0x0378,
0x03fd, 0x037e, 0x037f, 0x0380, 0x0386, 0x0387, 0x0388, 0x038b,
0x038c, 0x038d, 0x038e, 0x0390, 0x0391, 0x03a0, 0x03a2, 0x03a3,
0x0386, 0x0388, 0x03b0, 0x0391, 0x03a0, 0x03a3, 0x03a3, 0x038c,
0x038e, 0x03cf, 0x0392, 0x0398, 0x03d2, 0x03a6, 0x03a0, 0x03cf,
0x03d8, 0x039a, 0x03a1, 0x03f9, 0x037f, 0x03f4, 0x0395, 0x03f6,
0x03f7, 0x03f9, 0x03fa, 0x03fc, 0x03fd, 0x0400, 0x0410, 0x0420,
0x0410, 0x0420, 0x0400, 0x0460, 0x0482, 0x048a, 0x04c0, 0x04c1,
0x04c0, 0x04d0, 0x0530, 0x0531, 0x0557, 0x0531, 0x0587, }))
test_equal(upper_case((string) ({
// These characters correspond to the cases in case_info.h
// Please update this and the corresponding lower_case table
// when UnicodeData.txt is changed.
// Part 2: 0x1000 -
0x10a0, 0x10c6, 0x10c7, 0x10c8, 0x10cd, 0x13a0, 0x13f0, 0x13f6,
0x13f8, 0x13fe, 0x1c80, 0x1c81, 0x1c82, 0x1c83, 0x1c85, 0x1c86,
0x1c87, 0x1c88, 0x1c89, 0x1d79, 0x1d7a, 0x1d7d, 0x1d7e, 0x1d8e,
0x1e00, 0x1e96, 0x1e9b, 0x1e9c, 0x1e9e, 0x1e9f, 0x1ea0, 0x1f00,
0x1f08, 0x1f10, 0x1f16, 0x1f18, 0x1f1e, 0x1f20, 0x1f28, 0x1f30,
0x1f38, 0x1f40, 0x1f46, 0x1f48, 0x1f4e, 0x1f51, 0x1f52, 0x1f53,
0x1f54, 0x1f55, 0x1f56, 0x1f57, 0x1f58, 0x1f59, 0x1f5a, 0x1f5b,
0x1f5c, 0x1f5d, 0x1f5e, 0x1f5f, 0x1f60, 0x1f68, 0x1f70, 0x1f72,
0x1f76, 0x1f78, 0x1f7a, 0x1f7c, 0x1f7e, 0x1f80, 0x1f88, 0x1f90,
0x1f98, 0x1fa0, 0x1fa8, 0x1fb0, 0x1fb2, 0x1fb3, 0x1fb4, 0x1fb8,
0x1fba, 0x1fbc, 0x1fbd, 0x1fbe, 0x1fbf, 0x1fc3, 0x1fc4, 0x1fc8,
0x1fcc, 0x1fcd, 0x1fd0, 0x1fd2, 0x1fd8, 0x1fda, 0x1fdc, 0x1fe0,
0x1fe2, 0x1fe5, 0x1fe6, 0x1fe8, 0x1fea, 0x1fec, 0x1fed, 0x1ff3,
0x1ff4, 0x1ff8, 0x1ffa, 0x1ffc, 0x1ffd, 0x2126, 0x2127, 0x212a,
0x212b, 0x212c, 0x2132, 0x2133, 0x214e, 0x214f, 0x2160, 0x2180,
0x2183, 0x2185, 0x24b6, 0x24d0, 0x24ea, 0x2c00, 0x2c2f, 0x2c30,
0x2c5f, 0x2c60, 0x2c62, 0x2c63, 0x2c64, 0x2c65, 0x2c66, 0x2c67,
0x2c6d, 0x2c6e, 0x2c6f, 0x2c70, 0x2c71, 0x2c72, 0x2c74, 0x2c75,
0x2c77, 0x2c7e, 0x2c80, 0x2ce4, 0x2ceb, 0x2cef, 0x2cf2, 0x2cf4,
0x2d00, 0x2d26, 0x2d27, 0x2d28, 0x2d2d, 0x2d2e, 0xa640, 0xa66e,
0xa680, 0xa69c, 0xa722, 0xa730, 0xa732, 0xa770, 0xa779, 0xa77d,
0xa77e, 0xa788, 0xa78b, 0xa78d, 0xa78e, 0xa790, 0xa794, 0xa796,
0xa7aa, 0xa7ab, 0xa7ac, 0xa7ad, 0xa7ae, 0xa7af, 0xa7b0, 0xa7b1,
0xa7b2, 0xa7b3, 0xa7b4, 0xa7b8, 0xa7b9, 0xa7c3, 0xa7c4, 0xa7c5,
0xa7c6, 0xa7c7, 0xa7c8, 0xa7c9, 0xa7ca, 0xa7d0, 0xa7d1, 0xa7d5,
0xa7d6, 0xa7d7, 0xa7f5, 0xa7f6, 0xab53, 0xab54, 0xab70, 0xabc0,
0xff21, 0xff3b, 0xff41, 0xff5b, 0x10400, 0x10428, 0x10450, 0x104b0,
0x104d4, 0x104d8, 0x104fc, 0x10c80, 0x10cb3, 0x10cc0, 0x10cf3, 0x118a0,
0x118e0, 0x1e900, 0x1e922, 0x1e944, })), (string) ({
0x10a0, 0x10c6, 0x10c7, 0x10c8, 0x10cd, 0x13a0, 0x13f0, 0x13f6,
0x13f0, 0x13fe, 0x0412, 0x0414, 0x041e, 0x0421, 0x0422, 0x042a,
0x0462, 0xa64a, 0x1c89, 0xa77d, 0x1d7a, 0x2c63, 0x1d7e, 0xa7c6,
0x1e00, 0x1e96, 0x1e60, 0x1e9c, 0x1e9e, 0x1e9f, 0x1ea0, 0x1f08,
0x1f08, 0x1f18, 0x1f16, 0x1f18, 0x1f1e, 0x1f28, 0x1f28, 0x1f38,
0x1f38, 0x1f48, 0x1f46, 0x1f48, 0x1f4e, 0x1f59, 0x1f52, 0x1f5b,
0x1f54, 0x1f5d, 0x1f56, 0x1f5f, 0x1f58, 0x1f59, 0x1f5a, 0x1f5b,
0x1f5c, 0x1f5d, 0x1f5e, 0x1f5f, 0x1f68, 0x1f68, 0x1fba, 0x1fc8,
0x1fda, 0x1ff8, 0x1fea, 0x1ffa, 0x1f7e, 0x1f88, 0x1f88, 0x1f98,
0x1f98, 0x1fa8, 0x1fa8, 0x1fb8, 0x1fb2, 0x1fbc, 0x1fb4, 0x1fb8,
0x1fba, 0x1fbc, 0x1fbd, 0x0399, 0x1fbf, 0x1fcc, 0x1fc4, 0x1fc8,
0x1fcc, 0x1fcd, 0x1fd8, 0x1fd2, 0x1fd8, 0x1fda, 0x1fdc, 0x1fe8,
0x1fe2, 0x1fec, 0x1fe6, 0x1fe8, 0x1fea, 0x1fec, 0x1fed, 0x1ffc,
0x1ff4, 0x1ff8, 0x1ffa, 0x1ffc, 0x1ffd, 0x2126, 0x2127, 0x212a,
0x212b, 0x212c, 0x2132, 0x2133, 0x2132, 0x214f, 0x2160, 0x2180,
0x2183, 0x2185, 0x24b6, 0x24b6, 0x24ea, 0x2c00, 0x2c2f, 0x2c00,
0x2c2f, 0x2c60, 0x2c62, 0x2c63, 0x2c64, 0x023a, 0x023e, 0x2c67,
0x2c6d, 0x2c6e, 0x2c6f, 0x2c70, 0x2c71, 0x2c72, 0x2c74, 0x2c75,
0x2c77, 0x2c7e, 0x2c80, 0x2ce4, 0x2ceb, 0x2cef, 0x2cf2, 0x2cf4,
0x10a0, 0x2d26, 0x10c7, 0x2d28, 0x10cd, 0x2d2e, 0xa640, 0xa66e,
0xa680, 0xa69c, 0xa722, 0xa730, 0xa732, 0xa770, 0xa779, 0xa77d,
0xa77e, 0xa788, 0xa78b, 0xa78d, 0xa78e, 0xa790, 0xa7c4, 0xa796,
0xa7aa, 0xa7ab, 0xa7ac, 0xa7ad, 0xa7ae, 0xa7af, 0xa7b0, 0xa7b1,
0xa7b2, 0xa7b3, 0xa7b4, 0xa7b8, 0xa7b8, 0xa7c2, 0xa7c4, 0xa7c5,
0xa7c6, 0xa7c7, 0xa7c7, 0xa7c9, 0xa7c9, 0xa7d0, 0xa7d0, 0xa7d5,
0xa7d6, 0xa7d6, 0xa7f5, 0xa7f5, 0xa7b3, 0xab54, 0x13a0, 0xabc0,
0xff21, 0xff3b, 0xff21, 0xff5b, 0x10400, 0x10400, 0x10450, 0x104b0,
0x104d4, 0x104b0, 0x104fc, 0x10c80, 0x10cb3, 0x10c80, 0x10cf3, 0x118a0,
0x118e0, 0x1e900, 0x1e900, 0x1e944, }))

// - utf8_to_string
// See string_to_utf8

// - utime

// - values
test_equal(values("foo"),({'f','o','o'}))
test_equal(values(({'f','o','o'})),({'f','o','o'}))
test_equal(Array.sort_array(values(([7:3,8:9,99:12]))),({3,9,12}))
test_equal(values((<7,8,99>)),({1,1,1}))
test_equal(mkmultiset(values(class{ constant a="a"; constant b="b";}())),
           (<"a","b">))

// - version
test_equal(version(), "Pike v"+__REAL_MAJOR__+"."+__REAL_MINOR__+" release "+__REAL_BUILD__)

// - werror
// - write

// - zero_type
test_eq(zero_type(0),0)
test_eq(lambda(mapping (int:mixed) m) {return zero_type(m[7]);} (([])),1)
test_eq(zero_type(([7: 0])[7]),0)
test_eq(zero_type(([7: UNDEFINED])[7]),0)
test_eq(zero_type(UNDEFINED), 1)
test_eq(zero_type (m_delete (([]), 1)), 1)

test_eq(zero_type (allocate (5, UNDEFINED)[2]), 1);
test_eq(zero_type (allocate (5, 0)[2]), 0);
test_eq(zero_type (allocate (5)[2]), 0);

test_true([[lambda (int|void a) { return zero_type(a); }()]])
test_true([[lambda () {mixed a; return zero_type(a = UNDEFINED);}()]])
test_true([[lambda () {mapping a=([]); return zero_type(a[0] = UNDEFINED);}()]])
test_true([[zero_type (lambda () {return UNDEFINED;}())]])

test_any([[
  class A {
    int j = 0;
    int k = UNDEFINED;
    int l;
  };
  A a = A();
  return "" + zero_type(a->j) + zero_type(a->k) + zero_type(a->l) + zero_type(a->m) + " " + has_index(a, "j") + has_index(a, "k") + has_index(a, "l") + has_index(a, "m");
]], "0101 1110")
test_any([[
  mapping m = ([
    "x" : 0,
    "y" : UNDEFINED,
  ]);
  return "" + zero_type(m->x) + zero_type(m->y) + zero_type(m->z) + " " + has_index(m, "x") + has_index(m, "y") + has_index(m, "z");
]], "001 110")

test_any([[
  int i = lambda() {return UNDEFINED;}();
  lambda (int x) {} (i += 17);
  return zero_type (i);
]], 0)
test_any([[
  int i = lambda() {return UNDEFINED;}();
  lambda (int x) {} (i -= 17);
  return zero_type (i);
]], 0)
test_any([[
  int i = lambda() {return UNDEFINED;}();
  lambda (int x) {} (i++);
  i++;
  return zero_type (i);
]], 0)
test_any([[
  int i = lambda() {return UNDEFINED;}();
  lambda (int x) {} (i--);
  return zero_type (i);
]], 0)
test_any([[
  int i = lambda() {return UNDEFINED;}();
  return zero_type (-i);
]], 0)

test_any([[
  // Preserve zero_type in call.
  return lambda (mixed a) {return zero_type (a);} (UNDEFINED);
]], 1);
test_true([[zero_type (({UNDEFINED})[0])]], 1); // Preserve zero_type in array.
test_true([[zero_type (map (({1}), ([]))[0])]], 1); // Produce zero_type in map().
test_any([[
  // Preserve zero_type in foreach.
  foreach (({UNDEFINED}), mixed e)
    if (zero_type (e)) return 1;
  return 0;
]], 1);

test_program(int b=10; mixed a() { return 1; })
test_program(mixed b=10; mixed a() { return 1;})
test_define_program(test,[[int q,w,e,r,t; mixed foo() { return 10; }]])

test_program(inherit test; mixed a() { return foo()==10; })
test_program(inherit test; mixed a() { return test::foo()==10; })
test_program(inherit test : bar; mixed a() { return bar::foo()==10; })

test_define_program(test2,[[int z,x,c,v,b; mixed bar() { return 11; }]])
test_program(inherit test; inherit test2; mixed a() { return foo()==10 && bar()==11; })
test_program(inherit test2; inherit test; mixed a() { return foo()==10 && bar()==11; })

test_define_program(test,[[int q,w,e,r; mixed t; mixed getw() { return w; } void setw(int _) { w=_; }]])
test_define_program(test2,[[int z,x,c,v,b; mixed getb() { return b; } void setb(int _) { b=_; }]])

test_program(inherit test; inherit test2; mixed a() { w=20; b=22; return getw()==20 && getb()==22; })
test_program(inherit test; inherit test2; mixed a() { setw(20); setb(22); return w==20 && b==22; })
test_program(inherit test2; inherit test; mixed a() { w=20; b=22; return getw()==20 && getb()==22; })
test_program(inherit test2; inherit test; mixed a() { setw(20); setb(22); return w==20 && b==22; })

test_do(add_constant("test"))
test_do(add_constant("test2"))

test_eval_error(return class {int i;void foo(){ destruct(this_object());i=0;return i;}}()->foo())
test_compile_error(return class c{int i;void foo(){ destruct(this_object());i=0;return i;}}()->foo())
test_eq(a,this_object()->a)

// - catch
test_false([[class { string test(string|zero foo) { catch { return lower_case(foo); }; return foo; }}()->test(0); ]])
test_true([[catch (1.0 / 0.0)]])
test_true([[catch {float f = 1.0 / 0.0;}]])


// Pike modules

// - this failed in Calendar.Timezone

test_compile(
[[
   array tz_ux(int ux)
   {
      if (ux<-0x80000000 || ux>0x7fffffff)
	 error("bah\n");
      return ({});
   };
   tz_ux(0);
]]);

// string[]=
test_any([[string s="foo"; s[2]='t'; s[0]--; return s;]],"eot")
test_any([[string s="foo"; s[2]=0777; s[1]--; return s;]],"fn\777")
test_any([[string s="foo"; s[2]=07777777; s[1]--; return s;]],"fn\7777777")
test_any([[string s="foo"; s[2]='t'; catch (s[10]='x'); return s;]], "fot")

ifefun(_verify_internals,
[[
  test_do(_verify_internals())
]])

test_tests([[
array a()
{
  return Tools.Testsuite.run_script ("]]SRCDIR[[/test_resolve.pike");
}
]])

// enum and typedef

test_compile_error_any([[enum X {A, B}; enum(X) x;]])
test_compile_error_any([[enum {intern : extern};]])

test_compile_any([[
  // GitHub pikelang/Pike #25.
  typedef typeof(Val.true)|typeof(Val.false) bool;

  int main (int argc, array(string) argv) {
    bool a = Val.true;
    return 0;
  }
]])

// - modifiers, compile time type checks

test_compile_any(class A {int v;} class B {inherit A; int v;})
test_compile_error_any(class A {int v;} class B {inherit A; float v;})
dnl test_compile_error_any(class A {int v;} class B {inherit A; mixed v;})
dnl test_compile_error_any(class A {mixed v;} class B {inherit A; int v;})
dnl test_compile_error_any(class A {public int v;} class B {inherit A; mixed v;})
dnl test_compile_error_any(class A { public { int v; } } class B {inherit A; mixed v;})
dnl test_compile_error_any(class A {public mixed v;} class B {inherit A; int v;})
test_compile_error_any(class A {protected int v;} class B {inherit A; float v;})
dnl test_compile_error_any(class A {protected int v;} class B {inherit A; mixed v;})
dnl test_compile_error_any(class A {protected mixed v;} class B {inherit A; int v;})
test_compile_any(class A {private int v; int q=v;} class B {inherit A; float v;})
dnl test_compile_any(class A {private int v; int q=v;} class B {inherit A; mixed v;})
dnl test_compile_any(class A {private mixed v; mixed q=v;} class B {inherit A; int v;})
test_compile_error_any(class A {final int v;} class B {inherit A; int v;})
test_compile_error_any(class A {final int v;} class B {inherit A; final int v;})
test_compile_any(class A {local int v;} class B {inherit A; float v;})
test_compile_any(class A {local int v;} class B {inherit A; mixed v;})
test_compile_any(class A {local mixed v;} class B {inherit A; int v;})
test_compile_any(class A {inline int v;} class B {inherit A; float v;})
test_compile_any(class A {inline int v;} class B {inherit A; mixed v;})
test_compile_any(class A {inline mixed v;} class B {inherit A; int v;})

test_compile_any(class A {int f(){}} class B {inherit A; int f(){}})
test_compile_any(class A {int f(){}} class B {inherit A; float f(){}})
test_compile_any(class A {int f(){}} class B {inherit A; mixed f(){}})
test_compile_any(class A {mixed f(){}} class B {inherit A; int f(){}})
test_compile_any(class A {void f(){}} class B {inherit A; void f(int a){}})
test_compile_any(class A {void f(int a){}} class B {inherit A; void f(float a){}})
test_compile_any(class A {void f(int a){}} class B {inherit A; void f(mixed a){}})
test_compile_any(class A {void f(mixed a){}} class B {inherit A; void f(int a){}})
test_compile_error_any(class A {final int f(){}} class B {inherit A; int f(){}})
test_compile_error_any(class A {final int f(){}} class B {inherit A; final int f(){}})

test_compile_warning(class A {int v;}; class B {inherit A; int v(){}})
test_compile_warning(class A {public int v;}; class B {inherit A; int v(){}})
test_compile_warning(class A {protected int v;}; class B {inherit A; int v(){}})
test_compile_any(class A {private int v; int q=v;} class B {inherit A; int v(){}})
test_compile_error_any(class A {final int v;} class B {inherit A; int v(){}})
test_compile_any(class A {local int v;} class B {inherit A; int v(){}})
test_compile_any(class A {inline int v;} class B {inherit A; int v(){}})

test_compile_error_any(class A {int f(){}} class B {inherit A; int f;})
test_compile_error_any(class A {public int f(){}} class B {inherit A; int f;})
test_compile_error_any(class A {protected int f(){}} class B {inherit A; int f;})
test_compile_any(class A {private int f(){} int q=f();} class B {inherit A; int f;})
test_compile_error_any(class A {final int f(){}} class B {inherit A; int f;})
test_compile_any(class A {local int f(){}} class B {inherit A; int f;})
test_compile_any(class A {inline int f(){}} class B {inherit A; int f;})

test_any([[
  // Test code generation for local (aka inline) constants.
  class Foo {
    constant A = "c";
    local constant B = "d";
    class Bar {
      local constant C = "e";

      string bar()
      {
        return A + B + C + B + A;
      }
    }
  };

  class Test {
    inherit Foo;
    constant B = "a";

    class Bar {
      inherit Foo::Bar;

      local constant C = "b";

      string bar()
      {
        return C + ::bar() + C;
      }
    }

    string test()
    {
      return B + Bar()->bar() + B;
    }
  };

  return Test()->test();
]], "abcdedcba")

test_any_equal([[
  // Test code generation for private global variables.
  // Derived from [LysLysKOM 20929878].
  class Test {
    private multiset ds = (< >);
    private mapping dcv = ([ ]);

    private void foo(string what)
    {
      what-="\r";
      foreach(replace(what, "\\\n", " ")/"\n"-({""}), string line)
      {
        array(string) sups =
          replace(line, ({"\t",","}), ({" "," "}))/" " -({ "" });

	if(line[0] != '#') {
	  if(sups[0] == "d") {
	    array(multiset|mapping) tmp = ({(<>), (<>), ([])});
	    ds = tmp[0] - tmp[1];
	    dcv = tmp[2];
	  }
	}
      }
    }

    public array(multiset|string) test()
    {
      foo("\nd\t\tu, t, c, b\n");

      return ({ ds, dcv });
    }
  };

  return Test()->test();
]], ({ (<>), ([]) }))

// - attributes
test_compile_any(
  class A { __deprecated__ int foo(int x) { return x; } };
)
test_compile_warning(
  class A { __deprecated__ int foo(int x) { return x; } };
  A()->foo(0);
)
test_compile_warning(
  class A { __deprecated__ int foo(int x) { return x; } };
  function bar = A()->foo;
)
test_compile_warning(
  class A { __deprecated__(int) foo(int x) { return x; } };
)
test_compile_any(
  class A { __deprecated__(int) foo(int x) { return (__deprecated__(int))x; } };
)
test_compile_warning(
  class A { int foo(__deprecated__(int)|void x) { return x; } };
)
test_compile_any(
  class A { int foo(__deprecated__(int)|void x) { return (int)x; } };
)
test_compile_warning(
  class A { int foo(__deprecated__(int)|void x) { return (int)x; } };
  A()->foo(1);
)
test_compile_any(
  class A { int foo(__deprecated__(int)|void x) { return (int)x; } };
  mixed bar = A()->foo();
)
test_compile_any([[
  class A {
    inherit Stdio.File;

    // NB: Stdio.File()->seek() has a deprecated variant, which this
    //     should NOT match.
    int seek(int pos) {}

    int close()
    {
      // In the broken case this complains:
      //   Warning: Using deprecated function(int, int, void | int : int) value.
      object(this_program) f = Stdio.File();
    }
  };
]])
test_compile_warning(
  class A {
    __deprecated__ mapping m;
    void foo() {
      m["foo"] = "bar";
    }
  };
)

// - modifiers, compile time access properties

test_compile_error_any(class A {} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {public int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {protected int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_error_any(class A {private int v; int q=v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {final int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {local int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {inline int v;} class B {inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {public int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {protected int f(){}} class B {inherit A; void g(){f();}})
test_compile_error_any(class A {private int f(){} int q=f();} class B {inherit A; void g(){f();}})
test_compile_any(class A {final int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {local int f(){}} class B {inherit A; void g(){f();}})
test_compile_any(class A {inline int f(){}} class B {inherit A; void g(){f();}})

test_compile_any(class A {int v;} class B {public inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {protected inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {private inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {final inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {local inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int v;} class B {inline inherit A; int q; void g(){q=v;}})
test_compile_any(class A {int f(){}} class B {public inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {protected inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {private inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {final inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {local inherit A; void g(){f();}})
test_compile_any(class A {int f(){}} class B {inline inherit A; void g(){f();}})

test_compile_error_any(class A {} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {public int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {protected int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_error_any(class A {private int v; int q=v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {final int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {local int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {inline int v;} class B {inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {public int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {protected int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_error_any(class A {private int f(){} int q=f();} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {final int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {local int f(){}} class B {inherit A; void g(){A::f();}})
test_compile_any(class A {inline int f(){}} class B {inherit A; void g(){A::f();}})

test_compile_any(class A {int v;} class B {public inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {protected inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {private inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {final inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {local inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int v;} class B {inline inherit A; int q; void g(){q=A::v;}})
test_compile_any(class A {int f(){}} class B {public inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {protected inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {private inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {final inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {local inherit A; void g(){A::f();}})
test_compile_any(class A {int f(){}} class B {inline inherit A; void g(){A::f();}})

test_compile_error_any(class A {} class B {inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {public inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {protected inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_error_any(class A {int v;} class B {private inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {final inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {local inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int v;} class B {inline inherit A;} class C {inherit B; int q; void g(){q=B::v;}})
test_compile_any(class A {int f(){}} class B {inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {public inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {protected inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_error_any(class A {int f(){}} class B {private inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {final inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {local inherit A;} class C {inherit B; void g(){B::f();}})
test_compile_any(class A {int f(){}} class B {inline inherit A;} class C {inherit B; void g(){B::f();}})

// - modifiers, run time access properties

test_eval_error(return class {}()->f())
test_do(class {int f(){}}()->f())
test_do(class {public int f(){}}()->f())
test_eval_error(return class {protected int f(){}}()->f())
test_eval_error(return class {private int f(){} int q=f();}()->f())
test_do(class {final int f(){}}()->f())
test_do(class {local int f(){}}()->f())
test_do(class {inline int f(){}}()->f())
test_do(class {class A {}}()->A())
test_do(class {public class A {}}()->A())
test_eval_error(return class {protected class A {}}()->A())
test_eval_error(return class {private class A {} object q=A();}()->A())
test_do(class {final class A {}}()->A())
test_do(class {local class A {}}()->A())
test_do(class {inline class A {}}()->A())

test_equal(indices(class {}()), ({}))
test_equal(indices(class {int v;}()), ({"v"}))
test_equal(indices(class {public int v;}()), ({"v"}))
test_equal(indices(class {protected int v;}()), ({}))
test_equal(indices(class {private int v; protected int q=v;}()), ({}))
test_equal(indices(class {final int v;}()), ({"v"}))
test_equal(indices(class {local int v;}()), ({"v"}))
test_equal(indices(class {inline int v;}()), ({"v"}))
test_equal(indices(class {int f(){}}()), ({"f"}))
test_equal(indices(class {public int f(){}}()), ({"f"}))
test_equal(indices(class {protected int f(){}}()), ({}))
test_equal(indices(class {private int f(){} protected int q=f();}()), ({}))
test_equal(indices(class {final int f(){}}()), ({"f"}))
test_equal(indices(class {local int f(){}}()), ({"f"}))
test_equal(indices(class {inline int f(){}}()), ({"f"}))

test_equal(indices(class {class A {} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {public int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {protected int v;} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {private int v; protected int q=v;} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {final int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {local int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {inline int v;} class B {inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {public int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {protected int f(){}} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {private int f(){} protected int q=f();} class B {inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {final int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {local int f(){}} class B {inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {inline int f(){}} class B {inherit A;}}()->B()), ({"f"}))

test_equal(indices(class {class A {int v;} class B {public inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {protected inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int v;} class B {private inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int v;} class B {final inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {local inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {inline inherit A;}}()->B()), ({"v"}))
test_equal(indices(class {class A {int f(){}} class B {public inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {protected inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int f(){}} class B {private inherit A;}}()->B()), ({}))
test_equal(indices(class {class A {int f(){}} class B {final inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {local inherit A;}}()->B()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {inline inherit A;}}()->B()), ({"f"}))

test_equal(indices(class {class A {} class B {inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int v;} class B {inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {public inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {protected inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int v;} class B {private inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int v;} class B {final inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {local inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int v;} class B {inline inherit A;} class C {inherit B;}}()->C()), ({"v"}))
test_equal(indices(class {class A {int f(){}} class B {inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {public inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {protected inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int f(){}} class B {private inherit A;} class C {inherit B;}}()->C()), ({}))
test_equal(indices(class {class A {int f(){}} class B {final inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {local inherit A;} class C {inherit B;}}()->C()), ({"f"}))
test_equal(indices(class {class A {int f(){}} class B {inline inherit A;} class C {inherit B;}}()->C()), ({"f"}))

// - modifiers, binding and redefinition properties with compile time access

test_any(class A {int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {public int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {protected int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {private int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_compile_error_any(class A {final int v=1;}; class B {inherit A; int v=2;};)
test_any(class A {local int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {inline int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {public int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {protected int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {private int f(){return 1;} int q=f();}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_compile_error_any(class A {final int f(){return 1;}}; class B {inherit A; int f(){return 2;}};)
test_any(class A {local int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {inline int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)

test_any(class A {int v=1;}; class B {public inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {protected inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {private inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_compile_error_any(class A {int v=1;}; class B {final inherit A; int v=2;};)
test_any(class A {int v=1;}; class B {local inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inline inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {public inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {protected inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {private inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_compile_error_any(class A {int f(){return 1;}}; class B {final inherit A; int f(){return 2;}};)
test_any(class A {int f(){return 1;}}; class B {local inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inline inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)

test_any(class A {int v=1;}; class B {inherit A; int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; public int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; protected int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; private int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; final int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; local int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int v=1;}; class B {inherit A; inline int v=2; int t(){return v;}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; public int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; protected int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; private int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; final int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; local int f(){return 2;} int t(){return f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;} int t(){return local::f();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; inline int f(){return 2;} int t(){return f();}}; return B()->t(), 2)

test_any(class A {int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 2)
test_any(class A {public int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 2)
test_any(class A {protected int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 2)
test_any(class A {private int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 1)
test_any(class A {local int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 1)
test_any(class A {inline int v=1; int t(){return v;}}; class B {inherit A; int v=2;}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 2)
test_any(class A {public int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 2)
test_any(class A {protected int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 2)
test_any(class A {private int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)
test_any(class A {local int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return local::f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)
test_any(class A {inline int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;}}; return B()->t(), 1)

test_any(class A {int v=1; int t(){return v;}}; class B {inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {public inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {protected inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int v=1; int t(){return v;}}; class B {private inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int v=1; int t(){return v;}}; class B {local inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int v=1; int t(){return v;}}; class B {inline inherit A; int v=2; int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {public inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {protected inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 2)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {private inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {local inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 1)
test_any(class A {int f(){return 1;} int t(){return f();}}; class B {inline inherit A; int f(){return 2;} int t(){return A::t();}}; return B()->t(), 1)

test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x003)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; public int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x003)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; private int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x021)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; protected int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x003)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; local int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x021)
test_any([[
  class A {int v=0x100; int a(){return v;}}; class B {inherit A; inline int v=0x010; int b(){return v;}}; class C {inherit B; int v=0x001; int c(){return v;}};
  object c=C(); return c->a()+c->b()+c->c();
]], 0x021)

// - modifiers, binding and redefinition properties with run time access

test_any(class A {int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {public int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {protected int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {private int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {local int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {inline int v=1;}; class B {inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {public int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {protected int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {private int f(){return 1;} int q=f();}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {local int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {inline int f(){return 1;}}; class B {inherit A; int f(){return 2;}}; return B()->f(), 2)

test_any(class A {int v=1;}; class B {public inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {protected inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {private inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {local inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inline inherit A; int v=2;}; return B()->v, 2)
test_any(class A {int f(){return 1;}}; class B {public inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {protected inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {private inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {local inherit A; int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inline inherit A; int f(){return 2;}}; return B()->f(), 2)

test_any(class A {int v=1;}; class B {inherit A; public int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; protected int v=2;}; return B()->v, 0)
test_any(class A {int v=1;}; class B {inherit A; private int v=2;}; return B()->v, 0)
test_any(class A {int v=1;}; class B {inherit A; final int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; local int v=2;}; return B()->v, 2)
test_any(class A {int v=1;}; class B {inherit A; inline int v=2;}; return B()->v, 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; public int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; protected int f(){return 2;}}; return B()->f, 0)
test_any(class A {int f(){return 1;}}; class B {inherit A; private int f(){return 2;} int q=f();}; return B()->f, 0)
test_any(class A {int f(){return 1;}}; class B {inherit A; final int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; local int f(){return 2;}}; return B()->f(), 2)
test_any(class A {int f(){return 1;}}; class B {inherit A; inline int f(){return 2;}}; return B()->f(), 2)

// test masking of lfuns using an empty declaration

test_any([[
    // F_LFUN vs F_GLOBAL
    class A {
        void a() {}
        int(0..1) b() {
            return this->a == a;
        }
    };
    class B {
        inherit A;

        void a();
    };
    return B()->b();
]], 1)

test_any([[
    class A {
        void a();
        int(0..1) b() {
            return this->a == a;
        }
    };
    class B {
        inherit A;

        void a() {}
    };
    class C {
        inherit B;
        void a();
    };
    return B()->b();
]], 1)

// - modifiers, misc checks

test_program([[
  class A {int i = 17;}
  class B {
    private inherit A;
    class C {
      int f() {return i;}
    }
  }
  int a() {return B()->C()->f() == 17;}
]])

test_any([[
class Fnord
{
  array gnzpp() { }
  constant fNord = 4711;

  class Bzonk
  {
    int xxxxx=17;
    int yyyyy=17;
    int zzzzz=17;

  }

  class Zboink
  {
    int pphfiztzz=1;
    inherit Bzonk;
    constant floingngg=fNord;
    array Zpfoooinginoooo() {}

    int t()
      {
	return fNord + fNord;
      }
    int z()
      {
	return floingngg + floingngg;
      }
  }
};
return Fnord()->Zboink()->t() + Fnord()->Zboink()->z();
]],4711 * 4)

test_any([[
  class Foo
  {
    string s = "a";

    int|string foo()
    {
      int i;
      for (; i < strlen(s); i++) {
        if (!strlen(s) && i) {
          return "Optimizer error!";
        }
        s = "";
        i = 0;
      }
      return 0;
    }
  };
  return Foo()->foo();
]], 0)

// - call_out, call_out_info, remove_call_out, find_call_out
test_do(add_constant("call_out_cb", a))
test_do(call_out(call_out_cb,100000))
test_true(call_out(lambda() {},1000.0))
test_true(remove_call_out(call_out(lambda() {},1000.0)) != -1)
test_true(find_call_out(call_out(lambda() {},1000.0)) != -1)
test_true(find_call_out(call_out(lambda() {},1000.0)) > 990)
test_false(zero_type(remove_call_out(call_out(lambda() {},1000.0))))
test_true(arrayp(call_out_info()))
test_true(sizeof(call_out_info()) > 0)
test_true(call_out_info()[-1][0] > 1)
test_eq(find_call_out(call_out_info()[-1][2]), call_out_info()[-1][0])
test_eq(find_call_out(a),-1)
test_eq(zero_type(find_call_out(a)),1)
test_true(zero_type(find_call_out(a)))
test_true(!sizeof(call_out_info()) || function_name(call_out_info()[-1][2])!="call_out_cb")
test_do(remove_call_out(call_out_info()[-1][2]))
test_do(add_constant("call_out_cb"))
test_do(_do_call_outs())
test_any([[
  object pid = Process.create_process(RUNPIKE_ARRAY +
				      ({ "]]SRCDIR[[/test_co.pike" }));
  int i;
  for (i=0; i < 120; i++) {
    if (pid->status()>0) break;
    __signal_watchdog();
    sleep(1);
  }
  if (pid->status() <= 0) {
    pid->kill(9);
    return "Killed";
  }
  return pid->wait();
]], 0)
test_do_([[ catch { _do_call_outs(); }]])

// - varargs
test_any_equal([[
  mixed test(int a, mixed ... b) {
    return b;
  };
  return test(1);
]],[[ ({}) ]])
test_any_equal([[
  mixed test(int a, mixed ... b) {
    return b;
  };
  return test(1,2);
]],[[ ({2}) ]])
test_any_equal([[
  mixed test(int a, mixed ... b) {
    return b;
  };
  return test(1,2,3);
]],[[ ({2,3}) ]])
test_any_equal([[
  mixed test(int a, mixed ... b) {
    return b;
  };
  return test(1,2,3);
]],[[ ({2,3}) ]])
test_compile_error([[
  mixed test(int a, mixed ... b) {
    return b;
  };
  return test();
]])
test_any_equal([[
  mixed test(void|int a, mixed ... b) {
    return b;
  };
  return test();
]],[[ ({}) ]])
test_any_equal([[
  mixed test(int a, mixed ... b) {
    if(a) return test(0);
    return b;
  };
  return test(1,2);
]],[[ ({}) ]])
test_any_equal([[
  class X {
    mixed test(int a, mixed ... b) {
      if(a) return test(0);
      return b;
    }
  };
  return X()->test(1,2);
]],[[ ({}) ]])


// sprintf

dnl This really belongs to sscanf, but...
test_eq([[ array_sscanf(sprintf("%1c", -1), "%1c")[0] ]], 255)
test_eq([[ array_sscanf(sprintf("%2c", -1), "%2c")[0] ]], 65535)
test_eq([[ array_sscanf(sprintf("%3c", -1), "%3c")[0] ]], 16777215)

test_eq([[ sprintf("%4c",16909060) ]],"\1\2\3\4")
test_eq([[ sprintf("%-4c",16909060) ]],"\4\3\2\1")
test_eq([[ sprintf("%2c",16909060) ]],"\3\4")
test_eq([[ sprintf("%-2c",16909060) ]],"\4\3")
test_eq([[ sprintf("%4c",2147483648) ]],"\200\0\0\0")
test_eq([[ sprintf("%-4c",2147483648) ]],"\0\0\0\200")
test_eq([[ sprintf("%2c",2147483648) ]],"\0\0")
test_eq([[ sprintf("%-2c",2147483648) ]],"\0\0")

test_eq([[ sprintf("%1c", 0x1abcd7893) ]], "\223")
test_eq([[ sprintf("%2c", 0x1abcd7893) ]], "x\223")
test_eq([[ sprintf("%3c", 0x1abcd7893) ]], "\315x\223")
test_eq([[ sprintf("%4c", 0x1abcd7893) ]], "\253\315x\223")
test_eq([[ sprintf("%5c", 0x1abcd7893) ]], "\1\253\315x\223")
test_eq([[ sprintf("%6c", 0x1abcd7893) ]], "\0\1\253\315x\223")
test_eq([[ sprintf("%7c", 0x1abcd7893) ]], "\0\0\1\253\315x\223")

test_eq([[ sprintf("%1c", -0x1abcd7893) ]], "m")
test_eq([[ sprintf("%2c", -0x1abcd7893) ]], "\207m")
test_eq([[ sprintf("%3c", -0x1abcd7893) ]], "2\207m")
test_eq([[ sprintf("%4c", -0x1abcd7893) ]], "T2\207m")
test_eq([[ sprintf("%5c", -0x1abcd7893) ]], "\376T2\207m")
test_eq([[ sprintf("%6c", -0x1abcd7893) ]], "\377\376T2\207m")
test_eq([[ sprintf("%7c", -0x1abcd7893) ]], "\377\377\376T2\207m")

test_eq([[ array_sscanf(sprintf("%4c", -1), "%4c")[0] ]], 4294967295)
test_eq([[ array_sscanf(sprintf("%5c", -1), "%5c")[0] ]], 1099511627775)
test_eq([[ array_sscanf(sprintf("%6c", -1), "%6c")[0] ]], 281474976710655)
test_eq([[ array_sscanf(sprintf("%7c", -1), "%7c")[0] ]], 72057594037927935)
test_eq([[ array_sscanf(sprintf("%8c", -1), "%8c")[0] ]], 18446744073709551615)
test_eq([[ array_sscanf(sprintf("%9c", -1), "%9c")[0] ]], 4722366482869645213695)
test_eq([[ array_sscanf(sprintf("%10c", -1), "%10c")[0] ]], 1208925819614629174706175)
test_eq([[ array_sscanf(sprintf("%11c", -1), "%11c")[0] ]], 309485009821345068724781055)

test_eq("\25363274223", [[ sprintf("%c", 0x1abcd7893) ]])
test_eq("\12414503555", [[ sprintf("%c", -0x1abcd7893) ]])

test_eq([[ sprintf("%x", -1) ]], "-1")
test_eq([[ sprintf("%4x", -1) ]], "  -1")
test_eq([[ sprintf("%10x", -1) ]], "        -1")
test_eq([[ sprintf("%10x", -15) ]], "        -f")
test_eq([[ sprintf("%010x", -15) ]], "-00000000f")
test_eq( sprintf("%x", "\0hej\xff"), "0068656aff" )
test_eq( sprintf("%d %x %d", 1,"\0hej\xff",2), "1 0068656aff 2" )
test_eq( sprintf("%X", "\0hej\xff"), "0068656AFF" )

test_eq([[ sprintf("%08x", -1) ]], "-0000001")
test_eq([[ sprintf("%016x", -15) ]], "-00000000000000f")
test_eq([[ sprintf("%x", 65535) ]], "ffff")
test_eq([[ sprintf("%x", -0x80000000) ]], "-80000000")

test_eq("f", [[ sprintf("%.1x", -1) ]])
test_eq("ff", [[ sprintf("%.2x", -1) ]])
test_eq("fff", [[ sprintf("%.3x", -1) ]])
test_eq("ffffffffffffffffffff", [[ sprintf("%.20x", -1) ]])
test_eq("1", [[ sprintf("%.3x", 1) ]])
test_eq("1", [[ sprintf("%0.3x", 1) ]])
test_eq("fff", [[ sprintf("%0.3x", -1) ]])
test_eq("1", [[ sprintf("%0.16x", 1) ]])
test_eq("ffffffffffffffff", [[ sprintf("%0.16x", -1) ]])
test_eq("  ff", [[ sprintf("%4.2x", -1) ]])
test_eq("00ff", [[ sprintf("%04.2x", -1) ]])
test_eq("0001", [[ sprintf("%04.2x", 1) ]])
test_eq("00cc", [[ sprintf("%04.2x", -0x1234) ]])

test_eq("-123456789123456789", [[ sprintf("%x", -0x123456789123456789) ]])
test_eq("ba9877", [[ sprintf("%.6x", -0x123456789123456789) ]])
test_eq("876edcba9877", [[ sprintf("%.12x", -0x123456789123456789) ]])
test_eq("        876edcba9877", [[ sprintf("%20.12x",-0x123456789123456789)]])

test_eq("77777777760000000000", [[ sprintf("%.20o", -0x80000000) ]])

test_true(stringp(sprintf("")))
test_true(sprintf("--real %1.20f --imaginary %1.20f --scale %1.20f\n",-0.9,-0.9,-0.9))
test_eq(sprintf("%%"),"%")
test_eq(sprintf("%d",1),"1")
test_eq(sprintf("%d",-1),"-1")
test_eq(sprintf("%o",1),"1")
test_eq(sprintf("%u",1<<31),"2147483648")
test_false(sprintf("%u",-1)=="-1")
test_eq(sprintf("%o",255),"377")
test_eq(sprintf("%o",-9),"-11")
test_eq(sprintf("%o",012345670),"12345670")
test_eq(sprintf("%x",255),"ff")
test_eq(sprintf("%x",-27),"-1b")
test_eq(sprintf("%X",255),"FF")
test_eq(sprintf("%X",-27),"-1B")
test_eq(sprintf("%c",255),"\377")
test_eq(sprintf("%2c",65535),"\377\377")
test_eq(sprintf("%3c",0xffffff),"\377\377\377")
test_true(stringp(sprintf("%f",255.0)))
test_true(stringp(sprintf("%g",255.0)))
test_true(stringp(sprintf("%G",255.0)))
test_true(stringp(sprintf("%e",255.0)))
test_true(stringp(sprintf("%E",255.0)))

test_eq(sprintf("%.1f",31415.9267),"31415.9")
test_eq(sprintf("%.0f",31415.9267),"31416")
test_eq(sprintf("%.-1f",31415.9267),"31420")
test_eq(sprintf("%.-2f",31415.9267),"31400")
test_eq(sprintf("%.-2f",-31415.9267),"-31400")
test_eq(sprintf("%.-10f",31415.9267),"0")
test_eq(sprintf("%20.-3f", 31415.92670),"               31000")


dnl test for high exponent problems
dnl (this might only effect --with-double-precision et al)
test_true(stringp(sprintf("%f",exp(700))))
test_true(stringp(sprintf("%g",exp(700))))
test_true(stringp(sprintf("%G",exp(700))))
test_true(stringp(sprintf("%e",exp(700))))
test_true(stringp(sprintf("%E",exp(700))))

dnl test for "inf" problems
test_eq(lower_case(sprintf("%f",Math.inf)),"inf")
test_eq(lower_case(sprintf("%g",Math.inf)),"inf")
test_eq(lower_case(sprintf("%G",Math.inf)),"inf")
test_eq(lower_case(sprintf("%e",Math.inf)),"inf")
test_eq(lower_case(sprintf("%E",Math.inf)),"inf")
test_eq(lower_case(sprintf("%f",-Math.inf)),"-inf")
test_eq(lower_case(sprintf("%g",-Math.inf)),"-inf")
test_eq(lower_case(sprintf("%G",-Math.inf)),"-inf")
test_eq(lower_case(sprintf("%e",-Math.inf)),"-inf")
test_eq(lower_case(sprintf("%E",-Math.inf)),"-inf")

dnl test for "nan" problems
dnl At least the following variants exist: "nan", "Nan", "NaN", "NaNQ".
test_eq(lower_case(sprintf("%f",Math.nan)[..2]),"nan")
test_eq(lower_case(sprintf("%g",Math.nan)[..2]),"nan")
test_eq(lower_case(sprintf("%G",Math.nan)[..2]),"nan")
test_eq(lower_case(sprintf("%e",Math.nan)[..2]),"nan")
test_eq(lower_case(sprintf("%E",Math.nan)[..2]),"nan")

test_eq(sprintf("%s","foobaR"),"foobaR")
test_eq(sprintf("%s","foo\nbar"),"foo\nbar")
test_eq(sprintf("%8.3s","foobar"),"     foo")
test_true(stringp(sprintf("%O",this_object())))
test_true(stringp(sprintf("%O",({}))))
test_eq(sprintf("%n"),"")
test_eq(sprintf("%t",1),"int")
test_eq(sprintf("%t",1.0),"float")
test_eq(sprintf("%t",""),"string")
test_eq(sprintf("%t",this_object()),"object")
test_eq(sprintf("%t", ({"a"})), "array")
test_any([[array(string) a = ({"a"}); return sprintf("%t", a);]], "array")
test_eq(sprintf("%t", 0), "int")
test_any([[array(string)|zero a = 0; return sprintf("%t", a);]], "int")
test_eq(sprintf("%t", (<>)), "multiset")
test_eq(sprintf("%t", ([])), "mapping")
test_eq(sprintf("%t", sin), "function")
test_eq(sprintf("%t", class {}), "program")
test_eq(sprintf("%t", typeof(3)), "type")

test_eq(strlen(sprintf("%1000s","")),1000)
test_eq(sprintf("%2d",1)," 1")
test_eq(sprintf("%2d",1)," 1")
test_eq(sprintf("foo_%3d",1),"foo_  1")
test_eq(sprintf("%2d",2222),"2222")
test_eq(sprintf("%!2d",2222),"22")
test_eq(sprintf("%!!2d",2222),"2222")
test_eq(sprintf("% d",2)," 2")
test_eq(sprintf("% d",-2),"-2")
test_eq(sprintf("%+d",2),"+2")
test_eq(sprintf("%+d",-2),"-2")
test_eq(sprintf("%-2d",2),"2 ")
test_eq(sprintf("%|3d",2)," 2 ")
test_eq(sprintf("%-=3s","f o bar gaz"),"f o\nbar\ngaz")
dnl test_eq(sprintf("%/3s","f o bargaz"),"f o\nbar\ngaz")
test_true(stringp(sprintf("%3#s","f\no\nbargaz\nonk")))
test_true(stringp(sprintf("%3$s","f\no\nbargaz\nonk")))
test_eq(sprintf("%-$79s","foo\nbar\ngazonk"),"foo    bar    gazonk ")
test_eq(sprintf("%-$20s","foo\nbar\ngazonk"),"foo    bar    \ngazonk ")
test_eq(sprintf("%-#79s","foo\nbar\ngazonk"),"foo    bar    gazonk ")
test_eq(sprintf("%-#20s","foo\nbar\ngazonk"),"foo    gazonk \nbar    ")

test_eq(sprintf("%.0f",17.23456),"17")

test_eq(sprintf("%*d",3,3),"  3")
test_eq(sprintf("%'FOO'10s","BAR"),"FOOFOOFBAR")
test_eq(sprintf("%d %<d %<d",2),"2 2 2")
test_true(stringp(sprintf("%O",({1,2,"foo"}))))
test_true(stringp(sprintf("%O",([1:2,"foo":"bar"]))))
test_eq(sprintf("%@4d", (array)"hi!")," 104 105  33")
test_eq(strlen(sprintf("%@c",allocate(1000))),1000)

test_eq(sprintf("test \0 \n"),"test \0 \n")
test_eq(sprintf("test \0"),"test \0")
test_eq(sprintf("%~*n","f",5),"fffff")
test_eq(sprintf("%'\000'*n",5),"\000\000\000\000\000")

test_eq(sprintf("%{%d\n%}",({1,2,3,4})),"1\n2\n3\n4\n")

test_true([[sprintf("%{%{%s%}\n%}",({({({"hej"})}),({({"hop"})})}))]])
test_true([[sprintf("%{%{%s%}\n%}",({({({"hej"})}),({({"hop"})})}))]])
test_true([[sprintf("%{%{%s%}\n%}",({({({"hej"})}),({({"hop"})})}))]])
test_true([[sprintf("%{%{%s%}\n%}",({({({"hej"})}),({({"hop"})})}))]])

test_eq([[sprintf("%{%d %d %d\n%}",({ ({1,2,3}), ({4,5,6}) }) )]],"1 2 3\n4 5 6\n")

test_eq([[sprintf("%4F", 0.0)]], "\000\000\000\000")
test_eq([[sprintf("%4F", 1.0)]], "\077\200\000\000")
test_eq([[sprintf("%4F", 0.5)]], "\077\000\000\000")
test_eq([[sprintf("%4F", 2.0)]], "\100\000\000\000")
test_eq([[sprintf("%4F", 1.5)]], "\077\300\000\000")
test_eq([[sprintf("%4F", 1048576.125)]], "\111\200\000\001")
test_eq([[sprintf("%4F", -17.5)]], "\301\214\000\000")
cond([[pow(2.0,-128.0)!=0.0]],
[[
  test_eq([[sprintf("%4F", pow(2.0,-128.0))]], "\000\040\000\000")
]])
test_eq([[sprintf("%4F", 0.033)]], "\075\007\053\002")
test_eq([[sprintf("%4F", pow(2.0,128.0))]], "\177\200\000\000")
test_eq([[sprintf("%8F", 0.0)]], "\000\000\000\000\000\000\000\000")
test_eq([[sprintf("%8F", 1.0)]], "\077\360\000\000\000\000\000\000")
test_eq([[sprintf("%8F", 0.5)]], "\077\340\000\000\000\000\000\000")
test_eq([[sprintf("%8F", 2.0)]], "\100\000\000\000\000\000\000\000")
test_eq([[sprintf("%8F", 1.5)]], "\077\370\000\000\000\000\000\000")
test_eq([[sprintf("%8F", 1048576.125)]], "\101\060\000\000\040\000\000\000")
test_eq([[sprintf("%8F", -17.5)]], "\300\061\200\000\000\000\000\000")
cond([[pow(2.0,-128.0)!=0.0]],
[[
  test_eq([[sprintf("%8F", pow(2.0,-128.0))]], "\067\360\000\000\000\000\000\000")
]])
test_eq([[sprintf("%8F", 0.032999999821186065673828125)]], "\077\240\345\140\100\000\000\000")

cond([[pow(2.0,1024.0)!=0.0]],
[[
  test_eq([[sprintf("%8F", pow(2.0,1024.0))]], "\177\360\000\000\000\000\000\000")
]])

dnl Make sure that _sprintf is called and that the argument list isn't screwed.
test_eq(sprintf("%d%c%s%t%o%d%u%x%X%e%f%g%E%G%O%d", 4711,
        @allocate(14, (class { protected string _sprintf(int t)
                                { mixed x = "not a number";
                                  string s;
                                  catch {
                                    s = sprintf("%d%d%d%d", 1, 2, x, 3);
                                  };
                                  return sprintf("[%c%c%c]", 'a', t, 'b'); }
                             })()), 42),
        "4711[acb][asb][atb][aob][adb][aub][axb][aXb]"
        "[aeb][afb][agb][aEb][aGb][aOb]42")

test_eq(sprintf("%[*]s %s",2,"a","b"),"b a")
test_eq(sprintf("%[1]s %s %[2]s %s","b","a","r"),"a b r a")

test_do(catch(sprintf("%d-" *101, @allocate(101))))

test_eq(sprintf("%O", "a\nb"),"\"a\\n\"\n\"b\"")
test_eq(sprintf("%O", "a\0b"),"\"a\\0b\"")
test_eq(sprintf("%O", "a\0""0"),"\"a\\0\"\"0\"")

test_eq(sprintf("%q", "a\nb"),"\"a\\nb\"")
test_eq(sprintf("%q", "a\0b"),"\"a\\0b\"")
test_eq(sprintf("%q", "a\0""0"),"\"a\\u00000\"")
test_eq(sprintf("%q", "\177\177""0"),"\"\\177\\u007f0\"")

test_eq(sprintf("%H", ""),"\0")
test_eq(sprintf("%H", "hello"),"\5hello")

test_eval_error(return sprintf("%0H", ""))
test_eval_error(return sprintf("%0H", "hello"))

test_eq(sprintf("%1H", ""),"\0")
test_eq(sprintf("%1H", "hello"),"\5hello")
test_eq(sprintf("%-1H", ""),"\0")
test_eq(sprintf("%-1H", "hello"),"\5hello")
test_eq(sprintf("%2H", ""),"\0\0")
test_eq(sprintf("%2H", "hello"),"\0\5hello")
test_eq(sprintf("%-2H", ""),"\0\0")
test_eq(sprintf("%-2H", "hello"),"\5\0hello")
test_eq(sprintf("%4H", ""),"\0\0\0\0")
test_eq(sprintf("%4H", "hello"),"\0\0\0\5hello")
test_eq(sprintf("%-4H", ""),"\0\0\0\0")
test_eq(sprintf("%-4H", "hello"),"\5\0\0\0hello")
test_do(sprintf("%9H", "x"*300););

test_eval_error(return sprintf("%H", "\x100");)
test_do(return sprintf("%1H", "x"*255);)
test_eval_error(return sprintf("%1H", "x"*256);)

define(test_object_sprintf, [[
       test_eq(sprintf("%"+$1, OBJ), $1);
       test_eq(sprintf("%"+$1+"%<"+$1, OBJ), $1 + $1);
       test_eq(sprintf("%[1]"+$1+"%[0]"+$1, OBJ, OBJ), $1 + $1);
   ]]);
test_do(add_constant("OBJ",class { protected string _sprintf(int t) { return sprintf("%c",t); } }() ))
test_object_sprintf("t")
test_object_sprintf("c")
test_object_sprintf("H")
test_object_sprintf("b")
test_object_sprintf("o")
test_object_sprintf("d")
test_object_sprintf("u")
test_object_sprintf("x")
test_object_sprintf("X")
test_object_sprintf("e")
test_object_sprintf("f")
test_object_sprintf("g")
test_object_sprintf("E")
test_object_sprintf("G")
test_object_sprintf("F")
test_object_sprintf("O")
test_object_sprintf("s")
test_object_sprintf("q")
test_do(add_constant("OBJ"))

test_any_equal([[
  class A {
    mapping m;
    protected string _sprintf(int t, mapping args)
    {
      m = args;
      return "";
    }
  };
  A a = A();
  string s = sprintf("%-2.3O", a);
  return a->m || s;
]], ([ "flag_left":1, "width":2, "precision":3 ]))
test_eq( sprintf("%*f",([ "precision":2, "width":5, "flag_left":1 ]),Math.pi),
  "3.14 " )

dnl / : ; ^ _ > hasn't been tested
test_eval_error(return sprintf("%d");)

test_any_equal([[
    class A {
        object true = Val.true;
        object false = Val.false;
        object null = Val.null;
    };
    object a = A();
    return map(values(a), objectp);
]], ({ 1, 1, 1 }))

dnl This syntax error generates a Fatal with PIKE_DEBUG
test_compile_error(object(foo bar) o;)

test_do([[
    class A(object|zero ctx) {
        this_program get(void|int level) {
            this_program ret = this;

            for (int i = 0; i < level; i++) ret = (ret && ret->ctx);

            return ret || this;
        }
    };

    return A(0)->get(UNDEFINED);
]])


dnl Verify some coding practices.
test_tests([[
  constant srcdir="]]SRCDIR[[";

  void report_test(array res, int failed, string fail_msg, mixed ... extra)
  {
    if (!failed) {
      res[0]++;
      return;
    }
    res[1]++;
    log_msg(fail_msg, @extra);
  }

  array(int) test_dir(string dir)
  {
    log_status("Testing directory %s/.\n", dir);

    string configure_script =
      Stdio.read_bytes(combine_path(srcdir, dir, "configure.in"));
    array(int) res = ({ 0, 0 });

    if (!configure_script) return res;

    // Makefile.in should exist.
    string makefile_in =
      Stdio.read_bytes(combine_path(srcdir, dir, "Makefile.in"));
    report_test(res, !makefile_in,
		"Makefile.in missing in directory %O.\n", dir);

    foreach(get_dir(combine_path(srcdir, dir)), string f) {
      if (has_prefix(f, ".#")) continue;	// Auto-save file.
      if (has_suffix(f, ".cmod")) {
	// Ensure that there's an explicit rule to precompile the file.
	string fbase = f[..<sizeof(".cmod")];
	int found;
	foreach(replace(makefile_in, "\\\n", " ")/"\n", string line) {
	  sscanf(line, "%s#%*s", line);
	  if (!has_value(line, ":")) continue;
	  if (!has_prefix(line, fbase + ".o")) continue;
	  if (has_value((line/":")[1..]*":", "$(SRCDIR)/" + fbase + ".c")) {
	    found = 1;
	    break;
	  }
	}
	report_test(res, !found,
		    "No explicit makefile rule to generate %s.c from %s in %s/.\n",
		    fbase, f, dir);
      }
    }
    return res;
  }

  array(int) recur_test_dir(string dir)
  {
    array(int) res = test_dir(dir);

    foreach(get_dir(combine_path(srcdir, dir)), string f) {
      string path = combine_path(dir, f);
      if (Stdio.is_dir(combine_path(srcdir, path))) {
	array(int) delta = recur_test_dir(path);
	res[0] += delta[0];
	res[1] += delta[1];
      }
    }
    return res;
  }

  array(int) a()
  {
    return recur_test_dir(".");
  }
]])


dnl Dumping test

test_do(Stdio.recursive_rm("recursive_module_dump_test"))
test_do(mkdir("recursive_module_dump_test"))
test_do(mkdir("recursive_module_dump_test/TestModule.pmod"))
test_do([[Stdio.write_file("recursive_module_dump_test/TestModule.pmod/module.pmod", #"
class B
{
  void foo()
  {
    .A.bar(C());
  }
}

class C
{
}
")]])
test_do([[Stdio.write_file("recursive_module_dump_test/TestModule.pmod/A.pmod", #"
import \".\";

void bar(C c)
{
}
")]])
test_do([[Stdio.write_file("recursive_module_dump_test/Xyzzy.pike", #"
void foo()
{
}
")]])
test_do([[Stdio.write_file("recursive_module_dump_test/Quux.pmod", #"
inherit Xyzzy;

void bar()
{
  Quux.foo();
}
")]])
define(dump_test_module, [[test_tests([[ array a() {
  Tools.Testsuite.log_status("Dumping ]]$1[[, case=$2");
  return Tools.Testsuite.run_script(({"-M", "recursive_module_dump_test", "-x", "dump", "recursive_module_dump_test/]]$1[["}));
}]])]])
define(try_load_test_module, [[test_tests([[ array a() {
  Tools.Testsuite.log_status("Instantiating TestModule.A, case=$1");
  return Tools.Testsuite.run_script(({"-M", "recursive_module_dump_test", "-e", "TestModule.A"}));
}]])
test_tests([[ array a() {
  Tools.Testsuite.log_status("Calling Quux.bar(), case=$1");
  return Tools.Testsuite.run_script(({"-M", "recursive_module_dump_test", "-e", "Quux.bar()"}));
}]])]])

dnl - First, try without dumping
try_load_test_module(1)

dnl - Next, dump only A.pmod / Xyzzy.pike
dump_test_module(TestModule.pmod/A.pmod, 2)
dump_test_module(Xyzzy.pike, 2)
try_load_test_module(2)

dnl - Now, only module.pmod / Quux.pmod
test_do(rm("recursive_module_dump_test/TestModule.pmod/A.pmod.o"))
test_do(rm("recursive_module_dump_test/Xyzzy.pike.o"))
dump_test_module(TestModule.pmod/module.pmod, 3)
dump_test_module(Quux.pmod, 3)
try_load_test_module(3)

dnl - A.pmod before module.pmod, Xyzzy before Quux
test_do(rm("recursive_module_dump_test/TestModule.pmod/module.pmod.o"))
test_do(rm("recursive_module_dump_test/Quux.pmod.o"))
dump_test_module(TestModule.pmod/A.pmod, 4)
dump_test_module(TestModule.pmod/module.pmod, 4)
dump_test_module(Xyzzy.pike, 4)
dump_test_module(Quux.pmod, 4)
try_load_test_module(4)

dnl - module.pmod before A.pmod, Quux before Xyzzy
test_do(rm("recursive_module_dump_test/TestModule.pmod/A.pmod.o"))
test_do(rm("recursive_module_dump_test/TestModule.pmod/module.pmod.o"))
test_do(rm("recursive_module_dump_test/Xyzzy.pike.o"))
test_do(rm("recursive_module_dump_test/Quux.pmod.o"))
dump_test_module(TestModule.pmod/module.pmod, 5)
dump_test_module(TestModule.pmod/A.pmod, 5)
dump_test_module(Quux.pmod, 5)
dump_test_module(Xyzzy.pike, 5)
try_load_test_module(5)

test_do(Stdio.recursive_rm("recursive_module_dump_test"))


dnl Another dumping test
test_do(Stdio.recursive_rm("cmod_dependency_dump_test"))
test_do(mkdir("cmod_dependency_dump_test"))
test_do(mkdir("cmod_dependency_dump_test/TestModule.pmod"))
test_do([[Stdio.write_file("cmod_dependency_dump_test/TestModule.pmod/module.pmod", #"
inherit Parser._parser.XML;
.Foo.Bar x;
")]])
test_do([[Stdio.write_file("cmod_dependency_dump_test/TestModule.pmod/Foo.pmod", #"
class Bar { inherit .Simple; }
")]])

test_tests([[ array a() {
  Tools.Testsuite.log_status("Accessing TestModule.Foo before dump");
  return Tools.Testsuite.run_script(({"-M", "cmod_dependency_dump_test", "-e", "TestModule.Foo"}));
}]])
test_tests([[ array a() {
  Tools.Testsuite.log_status("Dumping module.pmod");
  return Tools.Testsuite.run_script(({"-M", "cmod_dependency_dump_test", "-x", "dump", "cmod_dependency_dump_test/TestModule.pmod/module.pmod"}));
}]])
test_tests([[ array a() {
  Tools.Testsuite.log_status("Accessing TestModule.Foo after dump");
  return Tools.Testsuite.run_script(({"-M", "cmod_dependency_dump_test", "-e", "TestModule.Foo"}));
}]])

test_do(Stdio.recursive_rm("cmod_dependency_dump_test"))


dnl - Deprecated safe indexing
test_compile_warning( mapping foo; foo?->bar; )


END_MARKER

/* -*- mode: c; encoding: utf-8; -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/

#include "global.h"
#include "stralloc.h"
#include "string_builder.h"
#include "pike_macros.h"
#include "buffer.h"
#include "pike_memory.h"
#include "pike_error.h"
#include "gc.h"
#include "bignum.h"
#include "interpret.h"
#include "operators.h"
#include "pike_float.h"
#include "pike_types.h"
#include "block_allocator.h"
#include "whitespace.h"
#include "sprintf.h"
#include "pike_search.h"
#include "fdlib.h"
#include "builtin_functions.h"

#include <errno.h>

#define DEFAULT_CMOD_STORAGE

DECLARATIONS

PMOD_EXPORT void init_string_builder_alloc(struct string_builder *s, ptrdiff_t length, int mag)
{
  s->s=begin_wide_shared_string(length,mag);
  s->malloced=length;
  s->known_shift=0;
  s->s->len=0;
  low_set_index (s->s, 0, 0);
}

PMOD_EXPORT void init_string_builder(struct string_builder *s, int mag)
{
  init_string_builder_alloc(s, 256, mag);
}

PMOD_EXPORT void init_string_builder_copy(struct string_builder *to,
					  const struct string_builder *from)
{
  to->malloced = from->malloced;
  to->s = begin_wide_shared_string (from->malloced, from->s->size_shift);
  to->s->len = from->s->len;
  memcpy (to->s->str, from->s->str, (from->s->len + 1) << from->s->size_shift);
  to->known_shift = from->known_shift;
}

/* str becomes invalid if successful (i.e. nonzero returned),
 * otherwise nothing happens. */
PMOD_EXPORT int init_string_builder_with_string (struct string_builder *s,
						 struct pike_string *str)
{
  if (string_may_modify(str)) {
    /* Unlink the string and use it as buffer directly. */
    unlink_pike_string (str);
    str->flags = STRING_NOT_SHARED;
    s->s = str;
    s->malloced = str->len;
    s->known_shift = str->size_shift;
    return 1;
  }
  return 0;
}

PMOD_EXPORT void string_build_mkspace(struct string_builder *s,
				      ptrdiff_t chars, int mag)
/* Doesn't touch or sanity check s->known_shift. */
{
  if (!s->s) {
    init_string_builder_alloc(s, chars, mag);
    return;
  }
  if(mag > s->s->size_shift)
  {
    struct pike_string *n;
    ptrdiff_t l = s->s->len + chars;
    if (l < s->malloced)
      l = s->malloced;
    n=begin_wide_shared_string(l,mag);
    pike_string_cpy(MKPCHARP_STR(n),s->s);
    n->len=s->s->len;
    s->s->len = s->malloced;	/* Restore the real length */
    s->malloced=l;
    free_string(s->s);
    s->s=n;
  }
  else if(s->s->len+chars > s->malloced)
  {
    ptrdiff_t newlen = MAXIMUM(s->malloced*2,
			       s->s->len + chars);
    ptrdiff_t oldlen = s->s->len;

    s->s->len = s->malloced;	/* Restore the real length */
    s->s = realloc_unlinked_string(s->s, newlen);
    s->s->len = oldlen;
    s->malloced = newlen;
  }
}

PMOD_EXPORT void *string_builder_allocate(struct string_builder *s, ptrdiff_t chars, int mag)
{
  void *ret;
  string_build_mkspace(s, chars, mag);
  if(chars<0) s->known_shift=0;
  ret = s->s->str + (s->s->len<<s->s->size_shift);
  s->s->len += chars;
  return ret;
}

PMOD_EXPORT void string_builder_putchar(struct string_builder *s, int ch)
{
  ptrdiff_t i;
  enum size_shift mag = min_magnitude(ch);

  string_build_mkspace(s, 1, mag);
  if (mag > s->known_shift) {
    s->known_shift = mag;
  }
  i = s->s->len++;
  low_set_index(s->s,i,ch);
}

PMOD_EXPORT void string_builder_putchars(struct string_builder *s, int ch,
					 ptrdiff_t count)
{
  ptrdiff_t len = s->s?s->s->len:0;
  enum size_shift mag = min_magnitude(ch);

  /* This is not really expected to happen. But since we are doing
   * memset here, a negative argument should be avoided. */
  if (count < 0)
    Pike_fatal("Non-positive count in call to string_builder_putchars().\n");
  if (!count) return;

  string_build_mkspace(s, count, mag);
  if (mag > s->known_shift) {
    s->known_shift = mag;
  }

  switch (s->s->size_shift) {
    case 0:
      memset (STR0 (s->s) + s->s->len, ch, count);
      break;
    case 1: {
      int i;
      for (i = 0; i < count; i++)
	(STR1 (s->s) + s->s->len)[i] = ch;
      break;
    }
    case 2: {
      int i;
      for (i = 0; i < count; i++)
	(STR2 (s->s) + s->s->len)[i] = ch;
      break;
    }
  }

  s->s->len += count;
}


PMOD_EXPORT void string_builder_binary_strcat0(struct string_builder *s,
					       const p_wchar0 *str, ptrdiff_t len)
{
  string_build_mkspace(s,len,0);
  switch(s->s->size_shift)
  {
    case 0: convert_0_to_0(STR0(s->s)+s->s->len,str,len); break;
    case 1: convert_0_to_1(STR1(s->s)+s->s->len,str,len); break;
    case 2: convert_0_to_2(STR2(s->s)+s->s->len,str,len); break;
  }
  s->s->len+=len;
}

PMOD_EXPORT void string_builder_binary_strcat1(struct string_builder *s,
					       const p_wchar1 *str, ptrdiff_t len)
{
  if (!s->s || !s->s->size_shift) {
    if (find_magnitude1 (str, len) == 0) {
      string_build_mkspace (s, len, 0);
      convert_1_to_0 (STR0(s->s) + s->s->len, str, len);
      s->s->len += len;
      return;
    }
    s->known_shift = 1;
  }

  string_build_mkspace (s, len, 1);
  if (s->s->size_shift == 1)
    convert_1_to_1 (STR1(s->s)+s->s->len, str, len);
  else {
#ifdef PIKE_DEBUG
    if (s->s->size_shift != 2)
      Pike_fatal ("I aint got no clue 'bout nothing, dude. (%d)\n",
		  s->s->size_shift);
#endif
    convert_1_to_2 (STR2(s->s)+s->s->len, str, len);
  }
  s->s->len += len;
}

PMOD_EXPORT void string_builder_binary_strcat2(struct string_builder *s,
					       const p_wchar2 *str, ptrdiff_t len)
{
  if (s->s && (s->s->size_shift < 2)) {
    enum size_shift shift = find_magnitude2 (str, len);

    if (shift > s->s->size_shift) {
      string_build_mkspace (s, len, shift);
      if (shift == 1)
	convert_2_to_1 (STR1(s->s) + s->s->len, str, len);
      else {
#ifdef PIKE_DEBUG
	if (shift != 2) Pike_fatal ("Uhh.. Like, what? (%d)\n", shift);
#endif
	convert_2_to_2 (STR2(s->s) + s->s->len, str, len);
      }
      s->known_shift = shift;
    }

    else {
      string_build_mkspace (s, len, 0);
      if (s->s->size_shift == 0)
	convert_2_to_0 (STR0(s->s) + s->s->len, str, len);
      else {
#ifdef PIKE_DEBUG
	if (s->s->size_shift != 1)
	  Pike_fatal ("This is soo way bogus, man. (%d)\n", s->s->size_shift);
#endif
	convert_2_to_1 (STR1(s->s) + s->s->len, str, len);
      }
    }
  }

  else {
    string_build_mkspace (s, len, 2);
    convert_2_to_2 (STR2(s->s) + s->s->len, str, len);
  }

  s->s->len += len;
}

PMOD_EXPORT void string_builder_append(struct string_builder *s,
				       const PCHARP from,
				       ptrdiff_t len)
{
  enum size_shift shift = from.shift;
  if (s->s && (shift > s->s->size_shift)) {
    if (shift == 1) {
      shift = find_magnitude1((p_wchar1 *)from.ptr, len);
    } else {
      shift = find_magnitude2((p_wchar2 *)from.ptr, len);
    }
    if (shift > s->known_shift)
      s->known_shift = shift;
  }
  string_build_mkspace(s, len, shift);
  generic_memcpy(MKPCHARP_STR_OFF(s->s,s->s->len), from, len);
  s->s->len+=len;
}

PMOD_EXPORT void string_builder_fill(struct string_builder *s,
				     ptrdiff_t howmany,
				     const PCHARP from,
				     ptrdiff_t len,
				     ptrdiff_t offset)
{
  ptrdiff_t tmp;
  enum size_shift shift;

#ifdef PIKE_DEBUG
  if(len<=0)
    Pike_fatal("Cannot fill with zero length strings!\n");
#endif
  if(howmany<=0) return;

  if((!s->s || !s->s->size_shift) &&
     len == 1 &&
     (!from.shift || !min_magnitude(EXTRACT_PCHARP(from))))
  {
    memset(string_builder_allocate(s,howmany,0),
	   EXTRACT_PCHARP(from),
	   howmany);
    return;
  }

  shift = from.shift;
  if (shift > (s->s ? (enum size_shift)s->s->size_shift : eightbit)) {
    /* Check if we really need the extra magnitude. */
    /* FIXME: What about offset? */
    if (shift == 1) {
      shift = find_magnitude1((p_wchar1 *)from.ptr, len);
    } else {
      shift = find_magnitude2((p_wchar2 *)from.ptr, len);
    }
  }

  string_build_mkspace(s, howmany, shift);
  tmp = MINIMUM(howmany, len - offset);

  generic_memcpy(MKPCHARP_STR_OFF(s->s,s->s->len),
		 ADD_PCHARP(from,offset),
		 tmp);
  s->s->len+=tmp;
  howmany-=tmp;
  if(howmany > 0)
  {
    PCHARP to;
    tmp=MINIMUM(howmany, len);
    to=MKPCHARP_STR_OFF(s->s,s->s->len);
    generic_memcpy(to,from, tmp);
    s->s->len+=tmp;
    howmany-=tmp;

    while(howmany > 0)
    {
      tmp = MINIMUM(len, howmany);
      memcpy(s->s->str + (s->s->len << s->s->size_shift),
	     to.ptr,
	     tmp << s->s->size_shift);
      len+=tmp;
      howmany-=tmp;
      s->s->len+=tmp;
    }
  }
}

/* Append a NUL-terminated UTF16 string possibly containing surrogates. */
PMOD_EXPORT void string_builder_utf16_strcat(struct string_builder *s,
					     const p_wchar1 *utf16str)
{
  p_wchar1 uc;
  while ((uc = *(utf16str++))) {
    if ((uc & 0xf800) == 0xd800) {
      /* Surrogate. */
      p_wchar2 wchar = uc & 0x03ff;
      if (!(uc & 0x0400)) {
	/* High order 10 bits. */
	wchar <<= 10;
      }
      uc = *(utf16str++);
      if (uc & 0x0400) {
	/* Low order 10 bits. */
	wchar |= (uc & 0x3ff);
      } else {
	/* High order 10 bits. */
	wchar |= (uc & 0x3ff) << 10;
      }
      string_builder_putchar(s, wchar + 0x00010000);
    } else {
      string_builder_putchar(s, uc);
    }
  }
}

PMOD_EXPORT void string_builder_strcat(struct string_builder *s, const char *str)
{
  string_builder_binary_strcat(s,str,strlen(str));
}

PMOD_EXPORT void string_builder_shared_strcat(struct string_builder *s,
                                              const struct pike_string *str)
{
  string_build_mkspace(s,str->len,str->size_shift);

  pike_string_cpy(MKPCHARP_STR_OFF(s->s,s->s->len), str);
  s->known_shift=MAXIMUM(s->known_shift,str->size_shift);
  s->s->len+=str->len;
}

/**
 * Append a string quoted to Latin-1 (ISO8859-1).
 *
 * @param buf
 *   Buffer to append to.
 *
 * @param str
 *   String to quote.
 *
 * @param i
 *   Starting position of the string.
 *
 * @param max_len
 *   Maximum length of the string. This can be used together with i
 *   to just output a sub-range of the string.
 *
 * @param flags
 *   Set of option flags:
 *
 *   QUOTE_BREAK_AT_DQOUTE
 *     Terminate after the next unescaped double quote ('\"') character.
 *   QUOTE_BREAK_AT_SQUOTE
 *     Terminate after the next unescaped single quote ('\'') character.
 *   QUOTE_BREAK_AT_LF
 *     Terminate after the next unescaped line feed ('\n') character.
 *   QUOTE_NORMALIZE_WS
 *     Combine unescaped sequences of white space characters into
 *     a single space (' ') character.
 *   QUOTE_TOKENIZE
 *     Parse embedded strings.
 *   QUOTE_NO_STRING_CONCAT
 *     Do not insert sequences of two double quotes, and expect them
 *     to be a no-op.
 *
 * CAVEAT EMPTOR:
 *   In old implementations of this function, max_len was the
 *   maximum size of the resulting buffer (including any initial
 *   content).
 */
PMOD_EXPORT ptrdiff_t string_builder_quote_string(struct string_builder *buf,
						  const struct pike_string *str,
						  ptrdiff_t i,
						  ptrdiff_t max_len,
						  int flags)
{
  // NB: Requires QUOTE_NORMALIZE_WS to be != 1.
  int inhibit_whitespace = (flags & QUOTE_NORMALIZE_WS);
  int escaped = 0;

  if (str->len < max_len) {
    max_len = str->len;
  }

  for (; i < max_len; i++) {
    p_wchar2 ch = index_shared_string(str, i);
    if (ch < 0 || ch > 0xffff) {
      /* Huge character. */
      string_builder_binary_strcat(buf, "\\U", 2);
      string_builder_append_integer(buf, (unsigned INT32)ch, 16, APPEND_ZERO_PAD, 8, 8);
    } else if (ch > 0xff) {
      /* Unicode character. */
      string_builder_binary_strcat(buf, "\\u", 2);
      string_builder_append_integer(buf, ch, 16, APPEND_ZERO_PAD, 4, 4);
    } else if (ch & 0x60) {
      /* Printable character or DEL. */
      if (ch == '\177' || ch == ' ') {
	/* DEL or SP */
	goto ctrl_char;
      }

      if (ch == '"') {
	string_builder_putchar(buf, '\\');
	string_builder_putchar(buf, '"');
	if (!escaped) {
	  if (flags & QUOTE_BREAK_AT_DQUOTE) {
	    i++;
	    break;
	  }
	  if (flags & QUOTE_TOKENIZE) {
	    i = string_builder_quote_string(buf, str, i+1, max_len,
					    (flags & ~QUOTE_NORMALIZE_WS) |
					    QUOTE_BREAK_AT_DQUOTE);
	  }
	}
	goto next;
      } else if (ch == '\'') {
	string_builder_putchar(buf, '\\');
	string_builder_putchar(buf, '\'');
	if (!escaped) {
	  if (flags & QUOTE_BREAK_AT_SQUOTE) {
	    i++;
	    break;
	  }
	  if (flags & QUOTE_TOKENIZE) {
	    i = string_builder_quote_string(buf, str, i+1, max_len,
					    (flags & ~QUOTE_NORMALIZE_WS) |
					    QUOTE_BREAK_AT_SQUOTE);
	  }
	}
	goto next;
      } else if (ch == '\\') {
	string_builder_putchar(buf, '\\');
	string_builder_putchar(buf, '\\');
	escaped = !escaped;
	inhibit_whitespace = 0;
	goto next_ws;
      }
      string_builder_putchar(buf, ch);
    } else {
      p_wchar2 next_ch;
    ctrl_char:
      /* Control character or whitespace. */
      if (flags & QUOTE_NORMALIZE_WS) {
	/* Normalize all sequences of whitespace to a single SP. */
	if (!inhibit_whitespace) {
	  string_builder_putchar(buf, ' ');
	  inhibit_whitespace = 1;
	}
	goto next_ws;
      }
      if (ch == ' ') {
	string_builder_putchar(buf, ' ');
	goto next;
      }
      string_builder_putchar(buf, '\\');
      if ((ch > 6) && (ch < 14)) {
	string_builder_putchar(buf, "0123456abtnvfr"[ch]);
	if ((ch == 10) && (flags & QUOTE_BREAK_AT_LF)) {
	  return i+1;
	}
	goto next;
      }
      if (ch == 27) {
	string_builder_putchar(buf, 'e');
	goto next;
      }
      /* Check if we can use an octal escape. */
      if ((i+1 < str->len) &&
	  ((next_ch = index_shared_string(str, i+1)) >= '0') &&
	  (next_ch <= '7')) {
	/* No. */
	if (flags & QUOTE_NO_STRING_CONCAT) {
	  string_builder_putchar(buf, 'u');
	  string_builder_append_integer(buf, ch, 16, APPEND_ZERO_PAD, 4, 4);
	} else {
	  string_builder_append_integer(buf, ch, 8, 0, 1, 1);
	  string_builder_binary_strcat(buf, "\"\"", 2);
	}
	goto next;
      }
      string_builder_append_integer(buf, ch, 8, 0, 1, 1);
    }
  next:
    inhibit_whitespace = 0;
    escaped = 0;

  next_ws:
    /* A statement is required after a label... */
    ;
  }
  if (inhibit_whitespace && (inhibit_whitespace != QUOTE_NORMALIZE_WS)) {
    /* Get rid of the SP at the end of the buffer. */
    buf->s->len--;
  }
  return i;
}

PMOD_EXPORT void string_builder_append_integer(struct string_builder *s,
                                               INT64 val,
					       unsigned int base,
					       int flags,
					       size_t min_width,
					       size_t precision)
{
  UINT64 tmp;
  size_t len = 1;
  const char *numbers = "0123456789abcdef";
  if ((base < 2) || (base > 16)) {
    Pike_fatal("string_builder_append_int(): Unsupported base %u.\n", base);
  }
  if (flags & APPEND_UPPER_CASE) {
    numbers = "0123456789ABCDEF";
  }
  if ((flags & APPEND_SIGNED) && (val < 0)) {
    string_builder_putchar(s, '-');
    val = -val;
  } else if (flags & APPEND_POSITIVE) {
    string_builder_putchar(s, '+');
  }
  if ((flags & APPEND_ZERO_PAD) && (precision < min_width)) {
    precision = min_width;
  }

  tmp = val;
  if (base & (base - 1)) {
    size_t cnt;
    /* Calculate the output length.
     * Use do-while to ensure that zero isn't output as an empty string.
     */
    len = 0;
    do {
      len++;
      tmp /= base;
    } while (tmp);

    /* Precision is minimum number of digits. */
    if (len < precision) len = precision;

    /* Perform padding. */
    if (!(flags & APPEND_LEFT)) {
      if (len < min_width) {
	string_builder_fill(s, min_width - len, MKPCHARP("    ", 0),
			    4, 0);
      }
      min_width = 0;
    }

    cnt = len;

    tmp = val;
    switch(s->s->size_shift) {
    case 0:
      {
	p_wchar0 *p = string_builder_allocate(s, len, 0);
	do {
	  p[--cnt] = numbers[tmp%base];
	  tmp /= base;
	} while (cnt);
      }
      break;
    case 1:
      {
	p_wchar1 *p = string_builder_allocate(s, len, 0);
	do {
	  p[--cnt] = numbers[tmp%base];
	  tmp /= base;
	} while (cnt);
      }
      break;
    case 2:
      {
	p_wchar2 *p = string_builder_allocate(s, len, 0);
	do {
	  p[--cnt] = numbers[tmp%base];
	  tmp /= base;
	} while (cnt);
      }
      break;
    }
  } else {
    /* base is a power of two, so we can do without
     * the division and modulo operations.
     */
    int delta;
    size_t shift;
    unsigned int mask;

    for(delta = 1; (base>>delta) > 1; delta++)
      ;

    mask = (1<<delta)-1;	/* Usually base-1. */

    /* Precision is minimum number of digits. */
    if (precision) shift = (len = precision) * delta;
    else shift = delta;

    /* Calculate actual number of digits and initial shift. */
    for (; shift < SIZEOF_INT64 * 8 && tmp >> shift; shift += delta, len++)
      ;

    if ((len < min_width) && !(flags & APPEND_LEFT)) {
      /* Perform padding.
       * Note that APPEND_ZERO_PAD can not be active here, since
       * len is at least min_width in that case.
       */
      string_builder_fill(s, min_width - len, MKPCHARP("    ", 0),
			  4, 0);
      min_width = 0;
    }

    while(shift) {
      shift -= delta;
      string_builder_putchar(s, numbers[(tmp>>shift) & mask]);
    }
  }
  if (len < min_width) {
    /* Perform padding.
     * Note that APPEND_ZERO_PAD can not be active here, since
     * len is at least min_width in that case.
     * Note that APPEND_LEFT is always active here, since
     * min_width isn't zero.
     */
    string_builder_fill(s, min_width - len, MKPCHARP("    ", 0),
			4, 0);
  }
}

/* Kludge around brokeness of gcc/x86_64 */
#ifdef VA_LIST_IS_STATE_PTR
#define VA_LIST_PTR		va_list
#define VA_LIST_ADDR(X)		(X)
#define VA_LIST_DEREF(X)	(X)
#else
#define VA_LIST_PTR		va_list *
#define VA_LIST_ADDR(X)		(&(X))
#define VA_LIST_DEREF(X)	(*(X))
#endif

static INT64 pike_va_int(VA_LIST_PTR args, int flags)
{
  switch (flags & (APPEND_WIDTH_MASK|APPEND_SIGNED)) {
  case APPEND_WIDTH_HALF:
    return va_arg(VA_LIST_DEREF(args), unsigned int) & 0xffff;
  case APPEND_WIDTH_HALF|APPEND_SIGNED:
    return (short)va_arg(VA_LIST_DEREF(args), int);
  case 0:
    return va_arg(VA_LIST_DEREF(args), unsigned int);
  case APPEND_SIGNED:
    return va_arg(VA_LIST_DEREF(args), int);
  case APPEND_WIDTH_LONG:
    return va_arg(VA_LIST_DEREF(args), unsigned long);
  case APPEND_WIDTH_LONG|APPEND_SIGNED:
    return va_arg(VA_LIST_DEREF(args), long);
  case APPEND_WIDTH_LONG_LONG:
    return va_arg(VA_LIST_DEREF(args), UINT64);
  case APPEND_WIDTH_LONG_LONG|APPEND_SIGNED:
    return va_arg(VA_LIST_DEREF(args), INT64);
  }
  Pike_fatal("string_builder_append_integerv(): Unsupported flags: 0x%04x\n",
	     flags);
  UNREACHABLE(return 0);
}

/* Standard formats supported by string_builder_{v,}sprintf():
 *
 *   '%'	Insert %.
 *   'a'	Insert double.
 *   'b'	Insert binary integer (C23-draft).
 *   'c'	Insert character.
 *   'd'	Insert decimal integer.
 *   'e'	Insert double.
 *   'f'	Insert double.
 *   'g'	Insert double.
 *   'o'	Insert octal integer.
 *   'p'	Insert pointer / Pike extension-prefix.
 *   's'	Insert string.
 *   'u'	Insert unsigned decimal integer.
 *   'x'	Insert lower-case hexadecimal integer.
 *   'E'	Insert double.
 *   'G'	Insert double.
 *   'X'	Insert upper-case hexadecimal integer.
 *
 * Format modifiers supported by string_builder_{v,}sprintf():
 *
 *   '+'	Explicit sign for non-negative numeric values.
 *   '-'	Align left.
 *   '0'	Zero pad.
 *   '0'..'9'	Field width.
 *   '*'	Field width parameter taken from argument (int).
 *   '.'	Precision field width follows.
 *   'h'	Half-width input.
 *   'l'	Long(-er) input.
 *   't'	Pointer-width input (ptrdiff_t).
 *   'w'	Wide input (same as 'l', but only for strings).
 *   'z'	Pointer-width input (size_t).
 *
 * Extended formats supported by string_builder_{v,}sprintf()
 * these accept 'p' as a immediate prefix in order to keep gcc happy:
 *
 *   'O'	Insert description of svalue.
 *   'q'	Insert quoted pike_string.
 *   'S'	Insert pike_string.
 *   'T'	Insert pike_type.
 *
 * In addition, the sequence 'px' can be used to insert a pointer
 * in the same way as 'p'.  This can be used as an escape when printing
 * a raw pointer immediately followed by a literal O/q/S/T/x.
 * i.e. '%pxO' prints a raw pointer followed by the letter 'O',
 * '%pxx' prints a raw pointer followed by the letter 'x'.
 */

/* Values used internally in string_builder_vsprintf() */
#define STATE_MIN_WIDTH	1
#define STATE_PRECISION 2

PMOD_EXPORT void string_builder_vsprintf(struct string_builder *s,
					 const char *fmt,
					 va_list args)
{
  STACK_LEVEL_START(0);
  while (*fmt) {
    if (*fmt == '%') {
      int flags = 0;
      size_t min_width = 0;
      size_t precision = 0;
      int state = 0;

      fmt++;
      while (1) {
	switch (*(fmt++)) {
	case '%':
	  string_builder_putchar(s, '%');
	  break;

	case '+':
	  flags |= APPEND_POSITIVE;
	  continue;
	case '-':
	  flags |= APPEND_LEFT;
	  continue;

	case '0':
	  if (!state) {
	    flags |= APPEND_ZERO_PAD;
	  }
	  /* FALLTHRU */
	case '1': case '2': case '3':
	case '4': case '5': case '6':
	case '7': case '8': case '9':
	  if (state == STATE_PRECISION) {
	    precision = precision * 10 + fmt[-1] - '0';
	  } else {
	    state = STATE_MIN_WIDTH;
	    min_width = min_width * 10 + fmt[-1] - '0';
	  }
	  continue;

	case '*':
	  if (state == STATE_PRECISION) {
	    precision = va_arg(args, int);
	  } else {
	    state = STATE_MIN_WIDTH;
	    min_width = va_arg(args, int);
	  }
	  continue;

	case '.':
	  state = STATE_PRECISION;
	  continue;

	case 'h':
	  flags |= APPEND_WIDTH_HALF;
	  continue;

	case 'w':	/* Same as l, but old-style, and only for %s. */
	case 'l':
	  if (flags & APPEND_WIDTH_LONG) {
	    flags |= APPEND_WIDTH_LONG_LONG;
	  } else {
	    flags |= APPEND_WIDTH_LONG;
	  }
	  continue;

	case 't':	/* ptrdiff_t */
	case 'z':	/* size_t */
	  flags = (flags & ~APPEND_WIDTH_MASK) | APPEND_WIDTH_PTR;
	  continue;

	case 'T':	/* struct pike_type */
	  /* FIXME: Doesn't care about field or integer widths yet. */
	  low_describe_type(s, va_arg(args, struct pike_type *));
	  break;

	case 'O':
	  {
	    /* FIXME: Doesn't care about field or integer widths yet. */
            struct byte_buffer buf = BUFFER_INIT();
	    describe_svalue(&buf, va_arg(args, struct svalue *), 0, NULL);
	    string_builder_binary_strcat(s, buffer_ptr(&buf), buffer_content_length(&buf));
	    buffer_free(&buf);
	  }
	  break;
	case 'q':
	  {
	    struct pike_string *str = va_arg(args, struct pike_string *);
            size_t len = str?str->len:0;
	    size_t buf_len = s->s->len;

	    if (precision && (precision < len)) len = precision;
            if (str) {
              string_builder_putchar(s, '"');
              string_builder_quote_string(s, str, 0, len,
                                          QUOTE_NO_STRING_CONCAT);
              string_builder_putchar(s, '"');
            } else {
              string_builder_strcat(s, "(NULL)");
            }

	    len = s->s->len - buf_len;
	    if (min_width > len) {
	      if (!(flags & APPEND_LEFT)) {
		/* Rewind the buffer so that we can prepend the padding.
		 *
		 * NB: We assume that the quoted string will be
		 *     the same langth the second time too.
		 */
		s->s->len = buf_len;
	      }
	      string_builder_fill(s, min_width - len, MKPCHARP("    ", 0),
				  4, 0);
	      if (!(flags & APPEND_LEFT)) {
                if (str) {
                  string_builder_putchar(s, '"');
                  string_builder_quote_string(s, str, 0, len,
                                              QUOTE_NO_STRING_CONCAT);
                  string_builder_putchar(s, '"');
                } else {
                  string_builder_strcat(s, "(NULL)");
                }
	      }
	    }
	  }
	  break;
	case 'S':
	  /* Note: On some platforms this is an alias for %ls, so if you
	   *       want to output wchar_t strings, use %ls instead!
	   */
	  {
	    struct pike_string *str = va_arg(args, struct pike_string *);
	    size_t len = str->len;
	    if (precision && (precision < len)) len = precision;
	    if (min_width > len) {
	      if (flags & APPEND_LEFT) {
		string_builder_append(s, MKPCHARP_STR(str), len);
		string_builder_fill(s, min_width - len, MKPCHARP("    ", 0),
				    4, 0);
	      } else {
		string_builder_fill(s, min_width - len, MKPCHARP("    ", 0),
				    4, 0);
		string_builder_append(s, MKPCHARP_STR(str), len);
	      }
	    } else {
	      string_builder_append(s, MKPCHARP_STR(str), len);
	    }
	  }
	  break;
	case 's':
          if (flags & APPEND_WIDTH_MASK) {
	    /* Wide string: %ws, %ls or %lls
             * NB: Some platforms use %hs for UTF-16 strings.
	     */
	    PCHARP str;
	    size_t len;
            if ((flags & APPEND_WIDTH_MASK) != APPEND_WIDTH_LONG_LONG) {
	      str = MKPCHARP(va_arg(args, p_wchar1 *), 1);
	    } else {
	      str = MKPCHARP(va_arg(args, p_wchar2 *), 2);
	    }
	    len = pcharp_strlen(str);
	    if (precision && precision < len) len = precision;
	    if (min_width > len) {
	      if (flags & APPEND_LEFT) {
		string_builder_append(s, str, len);
		string_builder_fill(s, min_width - len, MKPCHARP("    ", 0),
				    4, 0);
	      } else {
		string_builder_fill(s, min_width - len, MKPCHARP("    ", 0),
				    4, 0);
		string_builder_append(s, str, len);
	      }
	    } else {
	      string_builder_append(s, str, len);
	    }
	  } else {
	    const char *str = va_arg(args, char *);
	    size_t len = strlen(str);
	    if (precision && precision < len) len = precision;
	    if (min_width > len) {
	      if (flags & APPEND_LEFT) {
		string_builder_binary_strcat(s, str, len);
		string_builder_fill(s, min_width - len, MKPCHARP("    ", 0),
				    4, 0);
	      } else {
		string_builder_fill(s, min_width - len, MKPCHARP("    ", 0),
				    4, 0);
		string_builder_binary_strcat(s, str, len);
	      }
	    } else {
	      string_builder_binary_strcat(s, str, len);
	    }
	  }
	  break;
	case 'c':
	  /* FIXME: Doesn't care about field or integer widths yet. */
	  string_builder_putchar(s, va_arg(args, int));
	  break;
	case 'b':
	  string_builder_append_integer(s, pike_va_int(VA_LIST_ADDR(args), flags), 2,
					flags, min_width, precision);
	  break;
	case 'o':
	  string_builder_append_integer(s, pike_va_int(VA_LIST_ADDR(args), flags), 8,
					flags, min_width, precision);
	  break;
	case 'p':
          if ((*fmt == 'O') || (*fmt == 'q') ||
              (*fmt == 'S') || (*fmt == 'T')) {
            /* Pike sprintf formatting extension. */
            continue;
          }
          if (*fmt == 'x')
            /* Escape to prevent the following character from being
               interpreted as an extension */
            fmt ++;
	  string_builder_append_integer(s, pike_va_int(VA_LIST_ADDR(args),
#if SIZEOF_CHAR_P == SIZEOF_LONG
						       APPEND_WIDTH_LONG
#elif SIZEOF_CHAR_P == 64
						       APPEND_WIDTH_LONG_LONG
#else /* SIZEOF_CHAR_P == 32 */
						       0
#endif
						       ), 16,
					flags, min_width, precision);
	  break;
	case 'x':
	  string_builder_append_integer(s, pike_va_int(VA_LIST_ADDR(args), flags), 16,
					flags, min_width, precision);
	  break;
	case 'X':
	  string_builder_append_integer(s, pike_va_int(VA_LIST_ADDR(args), flags), 16,
					flags | APPEND_UPPER_CASE,
					min_width, precision);
	  break;
	case 'u':
	  string_builder_append_integer(s, pike_va_int(VA_LIST_ADDR(args), flags), 10,
					flags, min_width, precision);
	  break;
	case 'd':
	  flags |= APPEND_SIGNED;
	  string_builder_append_integer(s, pike_va_int(VA_LIST_ADDR(args), flags), 10,
					flags, min_width, precision);
	  break;

	  /* %f used in modules/Image/colors.c. */
	case 'a':
	case 'e':
	case 'E':
	case 'f':
	case 'g':
	case 'G':
	  {
	    double val = va_arg(args, double);
	    size_t bytes;
	    char nfmt[] = { '%', fmt[-1], 0 };

	    if (PIKE_ISNAN(val)) {
	      /* NaN */
	      string_builder_strcat(s, "nan");
	      break;
	    }
	    if (val < 0.0) {
	      string_builder_putchar(s, '-');
	      val = -val;
	    } else if (flags & APPEND_POSITIVE) {
	      string_builder_putchar(s, '+');
	    }
            if (PIKE_ISINF(val)) {
	      /* Infinity */
	      string_builder_strcat(s, "inf");
	      break;
	    }
	    /* FIXME: Field lengths and precision. */
	    if ((bytes = snprintf(NULL, 0, nfmt, val))) {
	      p_wchar0 *p = string_builder_allocate(s, bytes, 0);
	      size_t check = snprintf((char*)p, bytes+1, nfmt, val);
	      if (check != bytes) {
		Pike_fatal("string_builder_vsprintf(): snprintf(\"%s\", %f) "
			   "is not trustworthy: "
			   "%"PRINTSIZET"u != %"PRINTSIZET"u\n",
			   nfmt, val, bytes, check);
	      }
	      if (s->s->size_shift) {
		/* We need to widen the string we just wrote. */
		if (s->s->size_shift == 1) {
		  p_wchar1 *p1 = (p_wchar1 *)p;
		  while (bytes--) {
		    p1[bytes] = p[bytes];
		  }
		} else {
		  p_wchar2 *p2 = (p_wchar2 *)p;
		  while (bytes--) {
		    p2[bytes] = p[bytes];
		  }
		}
	      }
	    }
	  }
	  break;

	default:
	  Pike_fatal("string_builder_vsprintf(): Invalid formatting method: "
		     "\"%%%c\" 0x%x.\n", (fmt[-1] & 0xff), fmt[-1]);
	}
	break;
      }
    } else {
      const char *start = fmt;
      while (*fmt && (*fmt != '%'))
	fmt++;
      string_builder_binary_strcat(s, start, fmt-start);
    }
  }
  STACK_LEVEL_DONE(0);
}


PMOD_EXPORT void string_builder_sprintf(struct string_builder *s,
					const char *fmt, ...)
{
  va_list args;
  va_start(args, fmt);
  string_builder_vsprintf(s, fmt, args);
  va_end(args);
}


/* Standard formats supported by string_builder_strftime():
 *
 * Escaped characters:
 *   '%'	Insert %.
 *   'n'	Insert newline.
 *   't'	Insert tab.
 *
 * Flags (NB: None of these actually do anything yet):
 *   '!'	Inhibit numerical padding (Roxen-style).
 *   '-'	Inhibit numerical padding (glibc-style).
 *   '#'	Inhibit numerical padding (MSVC-style).
 *   '^'	Upper-case (glibc-style).
 *   '~'	Capitalize (Roxen-style).
 *   'E'	Locale dependent alternative form (glibc-style).
 *   'O'	Use alternative numeric symbols.
 *
 * Formats:
 *   'a'	Abbreviated weekday name.
 *   'A'	Weekday name.
 *   'b'	Abbreviated month name.
 *   'B'	Month name.
 *   'c'	Date and time.
 *   'C'	Century number; 0-prefix.
 *   'd'	Day of month [1,31]; 0-prefix.
 *   'D'	Date.
 *   'e'	Day of month [1,31], space-prefix.
 *   'F'	ISO 8601 date (C99).
 *   'g'	Short year for the ISO 8601 week containing the day.
 *   'G'	Year for the ISO 8601 week containing the day.
 *   'h'	Abbreviated month name (Single Unix Specification).
 *   'H'	Hour (24-hour clock) [0,23]; 0-prefix.
 *   'I'	Hour (12-hour clock) [1,12]; 0-prefix.
 *   'j'	Day number of year [1,366]; 0-prefix.
 *   'k'	Hour (24-hour clock); space-prefix.
 *   'l'	Hour (12-hour clock) [1,12]; space-prefix.
 *   'm'	Month number [1,12]; 0-prefix.
 *   'M'	Minute [0,59]; 0-prefix.
 *   'p'	AM or PM.
 *   'P'	am or pm
 *   'q'	Quarter number (Roxen-style).
 *   'r'	Time in 12-hour clock format with %p.
 *   'R'	24-hour clock time no seconds.
 *   's'	Seconds since epoch.
 *   'S'	Seconds [0,60]; 0-prefix.
 *   'T'	24-hour clock time including seconds.
 *   'u'	Weekday as a decimal number [1,7], Monday == 1.
 *   'U'	Week number of current year [0,53]; 0-prefix,
 *		Sunday is first day of week.
 *   'V'	ISO week number of the year as a decimal number [01,53];
 *		0-prefix.
 *   'w'	Weekday as a decimal number [0,6], Suday == 0.
 *   'W'	Week number of year as a decimal number [00,53],
 *		with Monday as the first day of week 1; 0-prefix.
 *   'x'	Date in locale preferred format.
 *   'X'	Time in locale preferred format.
 *   'y'	Year [00,99]; 0-prefix.
 *   'Y'	Year [0000,9999]; 0-prefix.
 *   'z'	Time zone as hour offset from UTC.
 *   'Z'	Timezone name of abbreviation, or no bytes if
 *		no timezone information exists.
 */

/* Compat notes:
 *
 * The MSVC implementation of strftime() only supports
 *
 *   %a, %A, %b, %B, %c, %d, %H, %I,
 *   %j, %m, %M, %p, %S, %U, %w, %W,
 *   %x, %X, %y, %Y, %z, %Z and %%,
 *
 * and in debug mode it aborts on any others.
 */

static const char *internal_strftime_weekdays[7 + 1] =
  { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", NULL };

static const char *internal_strftime_long_weekdays[7 + 1] =
  { "Sunday", "Monday", "Tuesday", "Wednesday",
    "Thursday", "Friday", "Saturday", NULL };

static const char *internal_strftime_months[12 + 1] =
  { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", NULL };

static const char *internal_strftime_long_months[12 + 1] =
  { "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December", NULL };

static const char *internal_strftime_ampm[2 + 1] =
  { "AM", "PM", NULL };

PMOD_EXPORT void string_builder_strftime(struct string_builder *s,
                                         const char *fmt,
                                         struct tm *tm)
{
  char buffer[1024];	/* Used when calling strftime(3C). */

  STACK_LEVEL_START(0);
  while (*fmt) {
    if (*fmt == '%') {
      int prefix = 1;
      int alt_num = 0;
      int alt_form = 0;
      int upper_case = 0;

      fmt++;
      while (1) {
        switch (*(fmt++)) {
          /*
           * Escaped characters.
           */

        case '%':
          string_builder_putchar(s, '%');
          break;

        case 'n': /* Newline. */
          string_builder_putchar(s, '\n');
          break;

        case 't': /* Tab. */
          string_builder_putchar(s, '\t');
          break;

          /*
           * Flags
           */
        case '!': /* Inhibit numerical padding (Roxen-style). */
        case '-': /* Inhibit numerical padding (glibc-style). */
        case '#': /* Inhibit numerical padding (MSVC-style). */
          prefix = 0;
          continue;

        case '^': /* Upper-case (glibc-style). */
          upper_case = 3;
          continue;

        case '~': /* Capitalize (Roxen-style). */
          upper_case = 1;
          continue;

        case 'E': /* Locale dependent alternative form (glibc-style). */
          alt_form = 1;
          continue;

        case 'O': /* Use alternative numeric symbols. */
          alt_num = 1;
          continue;

          /*
           * Formats
           */

        case 'a': /* Abbreviated weekday name. */
          string_builder_strcat(s, internal_strftime_weekdays[tm->tm_wday]);
          break;

        case 'A': /* Weekday name. */
          string_builder_strcat(s, internal_strftime_long_weekdays[tm->tm_wday]);
          break;

        case 'b': /* Abbreviated month name. */
        case 'h': /* Abbreviated month name (Single Unix Specification). */
          string_builder_strcat(s, internal_strftime_months[tm->tm_mon]);
          break;

        case 'B': /* Month name. */
          string_builder_strcat(s, internal_strftime_long_months[tm->tm_mon]);
          break;

        case 'c': /* Date and time. */
          string_builder_strftime(s, "%a %b %e %H:%M:%S %Y", tm);
          break;

        case 'C': /* Century number; 0-prefix. */
          string_builder_sprintf(s, "%02d", 19 + tm->tm_year/100);
          break;

        case 'd': /* Day of month [1,31]; 0-prefix. */
          string_builder_sprintf(s, "%02d", tm->tm_mday);
          break;

        case 'D': /* Date. */
          string_builder_strftime(s, "%m/%d/%y", tm);
          break;

        case 'e': /* Day of month [1,31], space-prefix. */
          string_builder_sprintf(s, "%2d", tm->tm_mday);
          break;

        case 'F': /* ISO 8601 date. */
          string_builder_strftime(s, "%Y-%m-%d", tm);
          break;

        case 'g': /* Short year for the ISO 8601 week containing the day. */
          {
            int wday = (tm->tm_wday + 1) % 7;	/* ISO 8601 weekday number. */
            if ((wday - tm->tm_yday) >= 4) {
              /* The day belongs to the last week of the previous year. */
              string_builder_sprintf(s, "%02d", (99 + tm->tm_year) % 100);
            } else if ((tm->tm_mon == 11) && ((tm->tm_mday - wday) >= 29)) {
              /* The day belongs to the first week of the next year. */
              string_builder_sprintf(s, "%02d", (1 + tm->tm_year) % 100);
            } else {
              string_builder_sprintf(s, "%02d", tm->tm_year % 100);
            }
          }
          break;

        case 'G': /* Year for the ISO 8601 week containing the day. */
          {
            int wday = (tm->tm_wday + 1) % 7;	/* ISO 8601 weekday number. */
            if ((wday - tm->tm_yday) >= 4) {
              /* The day belongs to the last week of the previous year. */
              string_builder_sprintf(s, "%04d", 1899 + tm->tm_year);
            } else if ((tm->tm_mon == 11) && ((tm->tm_mday - wday) >= 29)) {
              /* The day belongs to the first week of the next year. */
              string_builder_sprintf(s, "%04d", 1901 + tm->tm_year);
            } else {
              string_builder_sprintf(s, "%04d", 1900 + tm->tm_year);
            }
          }
          break;

        case 'H': /* Hour (24-hour clock) [0,23]; 0-prefix. */
          string_builder_sprintf(s, "%02d", tm->tm_hour);
          break;

        case 'I': /* Hour (12-hour clock) [1,12]; 0-prefix. */
          string_builder_sprintf(s, "%02d", 1 + (tm->tm_hour + 11) % 12);
          break;

        case 'j': /* Day number of year [1,366]; 0-prefix. */
          string_builder_sprintf(s, "%03d", tm->tm_yday + 1);
          break;

        case 'k': /* Hour (24-hour clock); space-prefix. */
          string_builder_sprintf(s, "%2d", tm->tm_hour);
          break;

        case 'l': /* Hour (12-hour clock) [1,12]; space-prefix. */
          string_builder_sprintf(s, "%2d", 1 + (tm->tm_hour + 11) % 12);
          break;

        case 'm': /* Month number [1,12]; 0-prefix. */
          string_builder_sprintf(s, "%02d", tm->tm_mon + 1);
          break;

        case 'M': /* Minute [0,59]; 0-prefix. */
          string_builder_sprintf(s, "%02d", tm->tm_min);
          break;

        case 'p': /* AM or PM. */
          string_builder_strcat(s, tm->tm_hour < 12 ? "AM" : "PM");
          break;

        case 'P': /* am or pm */
          string_builder_strcat(s, tm->tm_hour < 12 ? "am" : "pm");
          break;

        case 'q': /* Quarter number (Roxen-style). */
          string_builder_sprintf(s, "%d", tm->tm_mon/3 + 1);
          break;

        case 'r': /* Time in 12-hour clock format with %p. */
          string_builder_strftime(s, "%I:%M:%S %p", tm);
          break;

        case 'R': /* 24-hour clock time no seconds. */
          string_builder_strftime(s, "%H:%M", tm);
          break;

        case 's': /* Seconds since epoch. */
          {
            time_t t = mktime_zone(tm, 0, 0);
            string_builder_sprintf(s, "%ld", (long)t);
          }
          break;

        case 'S': /* Seconds [0,60]; 0-prefix. */
          string_builder_sprintf(s, "%02d", tm->tm_sec);
          break;

        case 'T': /* 24-hour clock time including seconds. */
          string_builder_strftime(s, "%H:%M:%S", tm);
          break;

        case 'u': /* Weekday as a decimal number [1,7], Monday == 1. */
          string_builder_sprintf(s, "%d", 1 + ((tm->tm_wday + 6) % 7));
          break;

        case 'U': /* Week number of current year [0,53]; 0-prefix,
                   * Sunday is first day of week. */
          string_builder_sprintf(s, "%02d",
                                 1 + (tm->tm_yday - tm->tm_wday) / 7);
          break;

        case 'V': /* ISO week number of the year as a decimal number [01,53];
                   * 0-prefix. */
          {
            int wday = 1 + (tm->tm_wday + 6) % 7;	/* ISO wday. */
            int weekno = (10 + tm->tm_yday - tm->tm_wday) / 7;
            if (!weekno || (weekno == 53)) {
              int y = tm->tm_year + 1900;
              int p;

              if (!weekno) {
                /* Last week of previous year. */
                y--;
              }

              p = (y + y/4 - y/100 + y/400) % 7;
              if (p == 4) {
                weekno = 53;
              } else {
                y--;
                p = (y + y/4 - y/100 + y/400) % 7;
                if (p == 3) {
                  weekno = 53;
                } else if (weekno) {
                  /* First week of next year. */
                  weekno = 1;
                } else {
                  weekno = 52;
                }
              }
            }
            string_builder_sprintf(s, "%02d", weekno);
          }
          break;

        case 'w': /* Weekday as a decimal number [0,6], Suday == 0. */
          string_builder_sprintf(s, "%d", tm->tm_wday);
          break;

        case 'W': /* Week number of year as a decimal number [00,53],
                   * with Monday as the first day of week 1; 0-prefix. */
          string_builder_sprintf(s, "%02d",
                                 ((tm->tm_yday + (5 + tm->tm_wday) % 7) / 7));
          break;

        case 'x': /* Date in locale preferred format. */
          buffer[0] = 0;
          strftime(buffer, sizeof(buffer), "%x", tm);
          string_builder_strcat(s, buffer);
          break;

        case 'X': /* Time in locale preferred format. */
          buffer[0] = 0;
          strftime(buffer, sizeof(buffer), "%X", tm);
          string_builder_strcat(s, buffer);
          break;

        case 'y': /* Year [00,99]; 0-prefix. */
          string_builder_sprintf(s, "%02d", tm->tm_year % 100);
          break;

        case 'Y': /* Year [0000,9999]; 0-prefix. */
          string_builder_sprintf(s, "%04d", 1900 + tm->tm_year);
          break;

        case 'z': /* Time zone as hour offset from UTC. */
          {
            int minutes = (
#ifdef STRUCT_TM_HAS_GMTOFF
                           -tm->tm_gmtoff
#elif defined(STRUCT_TM_HAS___TM_GMTOFF)
                           -tm->__tm_gmtoff
#elif defined(HAVE_EXTERNAL_TIMEZONE)
                           /* Assume dst is one hour. */
                           timezone - 3600*tm->tm_isdst
#else
                           /* Assume dst is one hour. */
                           -3600*tm->tm_isdst
#endif
                           ) / 60;
            minutes += (minutes/60) * 40;
            string_builder_sprintf(s, "%+05d", minutes);
          }
          break;

        case 'Z': /* Timezone name of abbreviation, or no bytes if
                   * no timezone information exists. */
          break;

        default:
#if 0
          Pike_fatal("string_builder_vsprintf(): Invalid formatting method: "
                     "\"%%%c\" 0x%x.\n", (fmt[-1] & 0xff), fmt[-1]);
#endif
          string_builder_putchar(s, fmt[-1]);
          break;
        }
        break;
      }
    } else {
      const char *start = fmt;
      while (*fmt && (*fmt != '%'))
        fmt++;
      string_builder_binary_strcat(s, start, fmt-start);
    }
  }
  STACK_LEVEL_DONE(0);
}

static const char *pike_strptime_read_int(const char *s, int *dest, int digits)
{
  int res = 0;
  int c;
  int n;

  for (n = 0; (n < digits) && (c = *s); s++, n++) {
    if (c == ' ') continue;
    if ((c < '0') || (c > '9')) break;
    res = res * 10 + c - '0';
  }

  if (!n) return NULL;

  *dest = res;

  return s;
}

static const char *pike_strptime_read_str(const char *s,
                                          int *dest,
                                          const char **alts)
{
  int n;
  const char *t;

  for (n = 0; (t = alts[n]); n++) {
    int i;
    for(i = 0; t[i]; i++) {
      /* NB: We know that the strings only contain [A-Z][a-z]. */
      if (!s[i]) break;
      if ((t[i]|0x20) != (s[i]|0x20)) {
        break;
      }
    }
    if (!t[i]) {
      *dest = n;
      return s;
    }
  }
  return NULL;
}

const char *low_pike_strptime(const char *s,
                              const char *fmt,
                              struct tm *tm,
                              int *century,
                              int *ampm)
{
  if (!fmt || !tm) return NULL;

  while (*fmt) {

    if (!s) return NULL;

#define STRPTIME_EXPECT(C) do {                 \
      if (*(s++) != (C)) {                      \
        return NULL;                            \
      }                                         \
    } while(0)

    if (*fmt == '%') {
      int prefix = 1;
      int alt_num = 0;
      int alt_form = 0;
      int upper_case = 0;
      int tmp = 0;
      int sgn = 1;

      fmt++;
      while (1) {
        switch (*(fmt++)) {
          /*
           * Escaped characters.
           */

        case '%':
          STRPTIME_EXPECT('%');
          break;

        case 'n': /* Newline. */
          STRPTIME_EXPECT('\n');
          break;

        case 't': /* Tab. */
          STRPTIME_EXPECT('\t');
          break;

          /*
           * Flags
           */
        case '!': /* Inhibit numerical padding (Roxen-style). */
        case '-': /* Inhibit numerical padding (glibc-style). */
        case '#': /* Inhibit numerical padding (MSVC-style). */
          prefix = 0;
          continue;

        case '^': /* Upper-case (glibc-style). */
          upper_case = 3;
          continue;

        case '~': /* Capitalize (Roxen-style). */
          upper_case = 1;
          continue;

        case 'E': /* Locale dependent alternative form (glibc-style). */
          alt_form = 1;
          continue;

        case 'O': /* Use alternative numeric symbols. */
          alt_num = 1;
          continue;

          /*
           * Formats
           */

        case 'a': /* Abbreviated weekday name. */
          s = pike_strptime_read_str(s, &tm->tm_wday,
                                     internal_strftime_weekdays);
          break;

        case 'A': /* Weekday name. */
          s = pike_strptime_read_str(s, &tm->tm_wday,
                                     internal_strftime_long_weekdays);
          break;

        case 'b': /* Abbreviated month name. */
        case 'h': /* Abbreviated month name (Single Unix Specification). */
          s = pike_strptime_read_str(s, &tm->tm_mon, internal_strftime_months);
          break;

        case 'B': /* Month name. */
          s = pike_strptime_read_str(s, &tm->tm_mon,
                                     internal_strftime_long_months);
          break;

        case 'c': /* Date and time. */
          s = low_pike_strptime(s, "%a %b %e %H:%M:%S %Y", tm, century, ampm);
          break;

        case 'C': /* Century number; 0-prefix. */
          s = pike_strptime_read_int(s, &tmp, 2);
          *century = tmp * 100;
          break;

        case 'd': /* Day of month [1,31]; 0-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_mday, 2);
          break;

        case 'D': /* Date. */
          s = low_pike_strptime(s, "%m/%d/%y", tm, century, ampm);
          break;

        case 'e': /* Day of month [1,31], space-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_mday, 2);
          break;

        case 'F': /* ISO 8601 date. */
          s = low_pike_strptime(s, "%Y-%m-%d", tm, century, ampm);
          break;

        case 'g': /* Short year for the ISO 8601 week containing the day. */
          s = low_pike_strptime(s, "%y", tm, century, ampm);
          break;

        case 'G': /* Year for the ISO 8601 week containing the day. */
          s = low_pike_strptime(s, "%Y", tm, century, ampm);
          break;

        case 'H': /* Hour (24-hour clock) [0,23]; 0-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_hour, 2);
          break;

        case 'I': /* Hour (12-hour clock) [1,12]; 0-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_hour, 2);
          if (s && (tm->tm_hour == 12)) {
            tm->tm_hour = 0;
          }
          break;

        case 'j': /* Day number of year [1,366]; 0-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_yday, 3);
          if (s) {
            tm->tm_yday--;
          }
          break;

        case 'k': /* Hour (24-hour clock); space-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_hour, 2);
          break;

        case 'l': /* Hour (12-hour clock) [1,12]; space-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_hour, 2);
          if (s && (tm->tm_hour == 12)) {
            tm->tm_hour = 0;
          }
          break;

        case 'm': /* Month number [1,12]; 0-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_mon, 2);
          if (s) {
            tm->tm_mon--;
          }
          break;

        case 'M': /* Minute [0,59]; 0-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_min, 2);
          break;

        case 'p': /* AM or PM. */
          s = pike_strptime_read_str(s, ampm, internal_strftime_ampm);
          break;

        case 'P': /* am or pm */
          s = pike_strptime_read_str(s, ampm, internal_strftime_ampm);
          break;

        case 'q': /* Quarter number (Roxen-style). */
          s = pike_strptime_read_int(s, &tmp, 1);
          break;

        case 'r': /* Time in 12-hour clock format with %p. */
          s = low_pike_strptime(s, "%I:%M:%S %p", tm, century, ampm);
          break;

        case 'R': /* 24-hour clock time no seconds. */
          s = low_pike_strptime(s, "%H:%M", tm, century, ampm);
          break;

        case 's': /* Seconds since epoch. */
          s = pike_strptime_read_int(s, &tmp, 16);
          if (s) {
            time_t t = tmp;
            struct tm *tm_tmp = localtime(&t);
            if (tm_tmp) {
              *tm = *tm_tmp;
            }
          }
          break;

        case 'S': /* Seconds [0,60]; 0-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_sec, 2);
          break;

        case 'T': /* 24-hour clock time including seconds. */
          s = low_pike_strptime(s, "%H:%M:%S", tm, century, ampm);
          break;

        case 'u': /* Weekday as a decimal number [1,7], Monday == 1. */
          s = pike_strptime_read_int(s, &tm->tm_wday, 1);
          if (s && (tm->tm_wday == 7)) {
            tm->tm_wday = 0;
          }
          break;

        case 'U': /* Week number of current year [0,53]; 0-prefix,
                   * Sunday is first day of week. */
          s = pike_strptime_read_int(s, &tmp, 2);
          break;

        case 'V': /* ISO week number of the year as a decimal number [01,53];
                   * 0-prefix. */
          s = pike_strptime_read_int(s, &tmp, 2);
          break;

        case 'w': /* Weekday as a decimal number [0,6], Suday == 0. */
          s = pike_strptime_read_int(s, &tm->tm_wday, 1);
          break;

        case 'W': /* Week number of year as a decimal number [00,53],
                   * with Monday as the first day of week 1; 0-prefix. */
          s = pike_strptime_read_int(s, &tmp, 2);
          break;

        case 'x': /* Date in locale preferred format. */
#ifdef HAVE_STRPTIME
          s = strptime(s, "%x", tm);
          if (s) {
            *century = 0;
          }
#else
          s = low_pike_strptime(s, "%F", tm, century, ampm);
#endif
          break;

        case 'X': /* Time in locale preferred format. */
#ifdef HAVE_STRPTIME
          s = strptime(s, "%X", tm);
#else
          s = low_pike_strptime(s, "%T", tm, century, ampm);
#endif
          break;

        case 'y': /* Year [00,99]; 0-prefix. */
          s = pike_strptime_read_int(s, &tmp, 2);
          if (s && *century) {
            /* NB: century == 0 ==> full year already parsed. */
            tm->tm_year = tmp;
          }
          break;

        case 'Y': /* Year [0000,9999]; 0-prefix. */
          s = pike_strptime_read_int(s, &tm->tm_year, 4);
          if (s) {
            tm->tm_year -= 1900;
            *century = 0;
          }
          break;

        case 'z': /* Time zone as hour offset from UTC. */
          sgn = 1;
          if (*s == '+' || *s == ' ') {
            s++;
          } else if (*s == '-') {
            sgn = -1;
            s++;
          }
          s = pike_strptime_read_int(s, &tmp, 4);
          if (s) {
            int h = tmp/100;
            int m = tmp - h * 100;
            tmp = sgn * ((h * 60 + m) * 60);
#ifdef STRUCT_TM_HAS_GMTOFF
            tm->tm_gmtoff = -tmp;
#elif defined(STRUCT_TM_HAS___TM_GMTOFF)
            tm->__tm_gmtoff = -tmp;
#elif defined(HAVE_EXTERNAL_TIMEZONE)
            /* FIXME */
#else
            /* FIXME */
#endif
          }
          break;

        case 'Z': /* Timezone name of abbreviation, or no bytes if
                   * no timezone information exists. */
          /* FIXME! */
          break;

        default:
#if 0
          Pike_fatal("pike_strptime(): Invalid formatting method: "
                     "\"%%%c\" 0x%x.\n", (fmt[-1] & 0xff), fmt[-1]);
#endif
          return NULL;
          break;
        }
        break;
      }
    } else {
      const char *start = fmt;
      while (*fmt && (*fmt != '%')) {
        STRPTIME_EXPECT(*fmt);
        fmt++;
      }
    }
  }

  return s;
}

/* Reverse of string_builder_strftime() above.
 *
 * Behaves as strptime(3C).
 */
PMOD_EXPORT const char *pike_strptime(const char *s,
                                      const char *fmt,
                                      struct tm *tm)
{
  int century = 1950;	/* DWIM marker */
  int ampm = 0;

  s = low_pike_strptime(s, fmt, tm, &century, &ampm);

  if (ampm && (tm->tm_hour < 12)) {
    tm->tm_hour += 12;
  }

  if (century) {
    if (century == 1950) {
      /* DWIM: 1950..2049 */
      if (tm->tm_year < 50) {
        tm->tm_year += 100;
      }
    } else {
      /* 2-digit century offset * 100. */
      tm->tm_year += century - 1900;
    }
  }

  return s;
}

/**
 * Append a disassembly-style entry to a string builder buffer.
 *
 * @param s
 *   string builder buffer.
 *
 * @param address
 *   Start address of memory dump for display.
 *
 * @param start
 *   Actual start address for memory dump (if any).
 *
 * @param end
 *   Actual end address for memory dump (if any). NULL to disable
 *   memory dump.
 *
 * @param opcode
 *   C-string for opcode field.
 *
 * @param params
 *   NULL-terminated array of C-strings for parameters field. These
 *   will be comma-separated on output. NULL to disable.
 *
 * @param comment
 *   C-string with comment. NULL to disable. May contain new-lines.
 *
 * Note: To output the address without a memory dump, call with start and
 *       end set to the same non-NULL value.
 *
 * The base format is:
 *
 *   Start Width Use
 *   -------------------------------
 *       0    18 Address
 *      18     2 Space
 *      20    11 Memory dump
 *      31     2 Space
 *      33     8 Opcode
 *      41     1 Space
 *      42    19 Parameters
 *      61     1 Space
 *      62     1 Comment marker (#)
 *      63     1 Space
 *      64    13 Comment
 *
 * The opcode may overflow into the parameters and comment fields.
 */
PMOD_EXPORT void string_builder_append_disassembly(struct string_builder *s,
						   size_t address,
						   const void *start,
						   const void *end,
						   const char *opcode,
						   const char **params,
						   const char *comment)
{
  const unsigned char *pos = start;
  const unsigned char *pos_end = end;

  while ((pos < pos_end) || opcode || (params && params[0]) ||
	 (comment && comment[0])) {
    size_t i;
    int skip_params = 0;
    int skip_comment = 0;

    if (params && !params[0]) params = NULL;
    if (comment && !comment[0]) comment = NULL;

    if (pos_end) {
      /* Address */
      string_builder_sprintf(s, "0x%016zx  ", address);

      if (pos < pos_end) {
	/* Memory dump */
	for (i = 0; i < 4; i++) {
	  if (pos < pos_end) {
	    string_builder_sprintf(s, "%02x ", *pos);
	    pos++;
	    address++;
	    if (pos >= pos_end) {
	      pos_end = NULL;
	    }
	  } else {
	    string_builder_sprintf(s, "   ");
	  }
	}
      } else {
	pos_end = NULL;
	string_builder_sprintf(s, "%*s", 4*3, "");
      }
    } else {
      string_builder_sprintf(s, "%*s", 18 + 2 + 4*3, "");
    }

    /* Opcode */
    if (opcode) {
      char *opcode_end = strchr(opcode, '\n');
      size_t opcode_len;
      if (opcode_end) {
	opcode_len = opcode_end - opcode;
	opcode_end++;
	skip_params = 1;
      } else {
	opcode_len = strlen(opcode);
      }
      if (!params && !comment) {
	/* Nothing else on the line. */
	string_builder_sprintf(s, " %.*s", (int)opcode_len, opcode);
      } else if (opcode_len < 8) {
	string_builder_sprintf(s, " %.*s%*s",
			       (int)opcode_len, opcode, (int)(8 - opcode_len), "");
      } else if (opcode_len < 29) {
	string_builder_sprintf(s, " %.*s%*s",
			       (int)opcode_len, opcode, (int)(28 - opcode_len), "");
	skip_params = 1;
      } else {
	string_builder_sprintf(s, " %.*s", (int)opcode_len, opcode);
	skip_params = skip_comment = 1;
      }
      opcode = opcode_end;
    } else if (params || comment) {
      /* No need to pad if there's no argument and no comment. */
      string_builder_sprintf(s, " %8s ", "");
    }

    /* Params */
    if (!skip_params) {
      ptrdiff_t bytes_left = 20;
      if (params) {
	do {
	  string_builder_sprintf(s, " %s", params[0]);
	  bytes_left -= strlen(params[0]) + 1;
	  params++;
	  if (params[0]) {
	    string_builder_sprintf(s, ",");
	    bytes_left--;
	  }
	} while (params[0] && (((ptrdiff_t)strlen(params[0])) <= bytes_left));
      }
      if (bytes_left < 0) {
	skip_comment = 1;
      } else if (comment) {
	/* No need to pad if there's no comment. */
	string_builder_sprintf(s, "%*s", (int)bytes_left, "");
      }
    }

    /* Comment */
    if (!skip_comment && comment) {
      const char *ptr = strchr(comment, '\n');
      if (ptr) {
	string_builder_sprintf(s, " # %.*s\n", (int)(ptr - comment), comment);
	comment = ptr + 1;
	if (!comment[0]) comment = NULL;
      } else {
	string_builder_sprintf(s, " # %s\n", comment);
	comment = NULL;
      }
    } else {
      string_builder_sprintf(s, "\n");
    }
  }
}

PMOD_EXPORT void string_builder_append_disassembly_data(struct string_builder *s,
							size_t address,
							const void *start,
							const void *end,
							const char *comment)
{
  const unsigned char *pos = start;
  const unsigned char *pos_end = end;

  while ((pos < pos_end) || (comment && comment[0])) {
    size_t i;
    int skip_comment = 0;

    if (comment && !comment[0]) comment = NULL;

    if (pos_end) {
      /* Address */
      string_builder_sprintf(s, "0x%016zx  ", address);

      if (pos < pos_end) {
	struct pike_string tmp;
	ptrdiff_t buf_len;

	/* Fake a pike_string for use with %q further below. */
	tmp.refs = 1;
	tmp.flags = 0;
	tmp.size_shift = 0;
	tmp.alloc_type = STRING_ALLOC_STATIC;
	tmp.struct_type = STRING_STRUCT_SUBSTRING;
	tmp.min = 0;
	tmp.max = 255;
	tmp.len = 0;		/* Will be increased in the loop below. */
	tmp.hval = 0;
	tmp.next = NULL;
	tmp.str = (char *)pos;

	/* Memory dump */
	for (i = 0; i < 4; i++) {
	  if (pos < pos_end) {
	    string_builder_sprintf(s, "%02x ", *pos);
	    pos++;
	    tmp.len++;
	    address++;
	    if (pos >= pos_end) {
	      pos_end = NULL;
	    }
	  } else {
	    string_builder_sprintf(s, "   ");
	  }
	}

	buf_len = s->s->len;
	if (comment) {
	  string_builder_sprintf(s, " .data    %-20pq", &tmp);
	  if (UNLIKELY(s->s->len > buf_len + 10 + 20)) {
	    /* Paranoia: This probably can't happen.
	     *           Max should be with octal or hex quoting:
	     *             " .data    "   10 +
	     *             "\""            1 +
	     *             "\xxx" * 4    4*4 +
	     *             "\""            1
	     *           ==> 28.
	     */
	    skip_comment = 1;
	  }
	} else {
	  string_builder_sprintf(s, " .data    %pq", &tmp);
	}
      } else if (comment) {
	pos_end = NULL;
	string_builder_sprintf(s, "%*s", 4*3 + 10 + 20, "");
      }
    } else {
      string_builder_sprintf(s, "%*s", 18 + 2 + 4*3 + 10 + 20, "");
    }

    /* Comment */
    if (!skip_comment && (comment && comment[0])) {
      const char *ptr = strchr(comment, '\n');
      if (ptr) {
	string_builder_sprintf(s, " # %.*s\n", (int)(ptr - comment), comment);
	comment = ptr + 1;
	if (!comment[0]) comment = NULL;
      } else {
	string_builder_sprintf(s, " # %s\n", comment);
	comment = NULL;
      }
    } else {
      string_builder_sprintf(s, "\n");
    }
  }
}

PMOD_EXPORT void string_builder_vsprintf_disassembly(struct string_builder *s,
						     size_t address,
						     const void *start,
						     const void *end,
						     const char *comment,
						     const char *fmt,
						     va_list args)
{
  struct string_builder tmp_buf;
  init_string_builder(&tmp_buf, 0);
  string_builder_vsprintf(&tmp_buf, fmt, args);
  string_builder_putchar(&tmp_buf, 0);

  if (tmp_buf.s->size_shift) {
    Pike_fatal("Wide characters are not yet supported here.\n");
  }

  string_builder_append_disassembly(s, address, start, end,
				    tmp_buf.s->str, NULL, comment);

  free_string_builder(&tmp_buf);
}

PMOD_EXPORT void string_builder_sprintf_disassembly(struct string_builder *s,
						    size_t address,
						    const void *start,
						    const void *end,
						    const char *comment,
						    const char *fmt, ...)
{
  va_list args;
  va_start(args, fmt);
  string_builder_vsprintf_disassembly(s, address, start, end,
				      comment, fmt, args);
  va_end(args);
}


PMOD_EXPORT void reset_string_builder(struct string_builder *s)
{
  s->known_shift=0;
  s->s->len=0;
}

PMOD_EXPORT void free_string_builder(struct string_builder *s)
{
  s->s->len = s->malloced;
  free_string(s->s);
  s->s = NULL;
}

PMOD_EXPORT struct pike_string *finish_string_builder(struct string_builder *s)
{
  ptrdiff_t len = s->s->len;
  if (len != s->malloced) {
    s->s->len = s->malloced;	/* Restore the allocated length. */
    s->s = realloc_unlinked_string(s->s, len);
  }
  if(s->known_shift == s->s->size_shift)
    return low_end_shared_string(s->s);
  return end_shared_string(s->s);
}

/**
 * Write the contents of a string_builder buffer to an fd.
 *
 * @param fd
 *   File descriptor to write to.
 *
 * @param s
 *   String builder buffer to write.
 *
 * @returns
 *   Returns the number of bytes written.
 *
 * Removes the data that was written from the buffer.
 */
PMOD_EXPORT ptrdiff_t write_and_reset_string_builder(int fd,
						     struct string_builder *s)
{
  ptrdiff_t bytes = 0;
  if (s && s->s && s->s->len) {
    if (s->s->size_shift) {
      Pike_fatal("Buffer contains wide characters.\n");
    }
    bytes = fd_write(fd, s->s->str, s->s->len);
    if (bytes <= 0) {
    } else if (bytes < s->s->len) {
      s->s->len -= bytes;
      memmove(s->s->str, s->s->str + bytes, s->s->len);
    } else {
      reset_string_builder(s);
    }
  }
  return bytes;
}

/*! @module String
 */

#define PROG_BUFFER_ID	PROG_STRING_BUFFER_ID

/*! @class Buffer
 *!    A buffer, used for building strings. It's
 *!    conceptually similar to a string, but you can only @[add]
 *!    strings to it, and you can only @[get] the value from it once.
 *!
 *!    There is a reason for those seemingly rather odd limitations,
 *!    it makes it possible to do some optimizations that really speed
 *!    things up.
 *!
 *!    You do not need to use this class unless you add very many
 *!    strings together, or very large strings.
 *!
 *! @example
 *!    For the fastest possible operation, write your code like this:
 *!
 *! @code
 *! String.Buffer b = String.Buffer( );
 *!
 *! function add = b->add;
 *!
 *! .. call add several times in code ...
 *!
 *! string result = b->get(); // also clears the buffer
 *! @endcode
 */
PIKECLASS Buffer
{
  CVAR struct string_builder str;
  CVAR int initial;

  PIKEFUN int _size_object()
  {
      if( THIS->str.s )
          RETURN THIS->str.malloced;
      RETURN 0;
  }

  void f_Buffer_get_copy( INT32 args );
  void f_Buffer_get( INT32 args );
  void f_Buffer_add( INT32 args );

  /*! @decl void create(int initial_size)
   *!
   *!   Initializes a new buffer.
   *!
   *!   If no @[initial_size] is specified, 256 is used. If you
   *!   know approximately how big the buffer will be, you can optimize
   *!   the operation of @[add()] (slightly) by passing the size to this
   *!   function.
   */
  PIKEFUN void create( int|void size )
  {
    struct Buffer_struct *str = THIS;
    if( size )
      str->initial = MAXIMUM( size->u.integer, 512 );
    else
      str->initial = 256;
    pop_n_elems(args);
  }

  /*! @decl string _sprintf( int flag, mapping flags )
   *! It is possible to @[sprintf] a String.Buffer object
   *! as @tt{%s@} just as if it was a string.
   */
  PIKEFUN string _sprintf( int flag, mapping flags )
  {
    switch( flag )
    {
      case 'O':
	{
	  struct pike_string *res;
	  struct Buffer_struct *str = THIS;
	  push_static_text( "Buffer(%d /* %d */)" );
	  if( str->str.s )
	  {
	    push_int(str->str.s->len);
	    push_int(str->str.malloced);
	  }
	  else
	  {
	    push_int( 0 );
	    push_int( 0 );
	  }
	  f_sprintf( 3 );
	  dmalloc_touch_svalue(Pike_sp-1);
	  res = Pike_sp[-1].u.string;
	  Pike_sp--;
	  RETURN res;
	}

      case 's':
	{
	  pop_n_elems( args );
	  if( Pike_fp->current_object->refs != 1 )
	    f_Buffer_get_copy( 0 );
	  else
	    f_Buffer_get( 0 );
	}
	return;

      case 't':
	RETURN make_shared_binary_string("Buffer",6);
    }
    pop_n_elems( args );
    push_undefined();
  }

  /*! @decl mixed cast( string type )
   *! It is possible to cast a String.Buffer object to
   *! a @expr{string@} and an @expr{int@}.
   */
  PIKEFUN mixed cast( string type )
    flags ID_PROTECTED;
  {
    if( type == literal_string_string )
    {
      pop_stack();
      if( Pike_fp->current_object->refs != 1 )
	f_Buffer_get_copy( 0 );
      else
	f_Buffer_get( 0 );
      return;
    }

    if( type == literal_int_string )
    {
      struct Buffer_struct *str = THIS;
      pop_stack();
      if( Pike_fp->current_object->refs != 1 )
	f_Buffer_get_copy( 0 );
      else
	f_Buffer_get( 0 );
      o_cast_to_int( );
      return;
    }

    pop_stack();
    push_undefined();
  }

  /*! @decl String.Buffer `+( string|String.Buffer what )
   */
  PIKEFUN object `+( string|Buffer what )
    rawtype tFunc(tOr(tString, tObjIs_BUFFER), tObjIs_BUFFER);
  {
    struct Buffer_struct *str = THIS, *str2;
    struct object *res = fast_clone_object( Buffer_program );
    str2 = OBJ2_BUFFER( res );
    str2->initial = str->initial;
    if( str->str.s )
      init_string_builder_copy (&str2->str, &str->str);
    if( (Pike_fp->current_object->flags & OBJECT_CLEAR_ON_EXIT) )
        res->flags |= OBJECT_CLEAR_ON_EXIT;
    apply( res, "add", 1 );
    RETURN res;
  }

  /*! @decl String.Buffer `+=( string|String.Buffer what )
   */
  PIKEFUN object `+=( string|Buffer what )
    rawtype tFunc(tOr(tString, tObjIs_BUFFER), tObjIs_BUFFER);
  {
    f_Buffer_add( 1 );
    REF_RETURN Pike_fp->current_object;
  }

  /**
   * Return the string_builder that is embedded in
   * a String.Buffer.
   */
  PMOD_EXPORT struct string_builder *
    string_builder_from_string_buffer(struct object *o)
  {
    if (!o) return NULL;

    if (LIKELY(o->prog == Buffer_program))
      return &OBJ2_BUFFER(o)->str;

    return &((struct Buffer_struct *)get_storage(o, Buffer_program))->str;
  }

  /*! @decl int add(string|String.Buffer ... data)
   *!
   *!   Adds @[data] to the buffer.
   *!
   *! @returns
   *!   Returns the size of the buffer.
   *!
   *! @note
   *!   Pike 7.8 and earlier did not support adding @[String.Buffer]s
   *!   directly.
   */
  PIKEFUN int add( string|Buffer ... arg1 )
    rawtype tFuncV(tNone, tOr(tString, tObjIs_BUFFER), tIntPos);
  {
    struct Buffer_struct *str = THIS;

    if (args) {
      int init_from_arg0 = 0, j;
      ptrdiff_t sum = 0;
      int shift = 0;
      for (j=0; j < args; j++) {
	struct pike_string *a;
	if (TYPEOF(Pike_sp[j-args]) == PIKE_T_STRING)
	  a = Pike_sp[j-args].u.string;
	else if ((TYPEOF(Pike_sp[j-args]) != PIKE_T_OBJECT) ||
		   (Pike_sp[j-args].u.object->prog != Buffer_program))
	  SIMPLE_ARG_TYPE_ERROR("add", j+1, "string|String.Buffer");
	else {
	  a = OBJ2_BUFFER(Pike_sp[j-args].u.object)->str.s;
	  if (!a) continue;
	}
	sum += a->len;
	shift |= a->size_shift;
      }
      shift |= str->str.known_shift;
      shift = shift & ~(shift >> 1);
      /* We know it will be a string that really is this wide. */
      str->str.known_shift = shift;

      if (!str->str.s) {
	if (sum <= str->initial)
	  sum = str->initial;
	else
	  sum <<= 1;

	init_string_builder_alloc(&str->str, sum, shift);
      } else
	string_build_mkspace(&str->str, sum, shift);

      for(sum = str->str.s->len, j = 0; j<args; j++) {
	struct pike_string *a;
	if (TYPEOF(Pike_sp[j-args]) == PIKE_T_STRING)
	  a = Pike_sp[j-args].u.string;
	else {
	  a = OBJ2_BUFFER(Pike_sp[j-args].u.object)->str.s;
	  if (!a) continue;
	}
	pike_string_cpy(MKPCHARP_STR_OFF(str->str.s, sum), a);
	sum += a->len;
      }

      str->str.s->len = sum;
    }

    RETURN str->str.s ? str->str.s->len : 0;
  }

  /*! @decl void putchar(int c)
   *! Appends the character @[c] at the end of the string.
   */
  PIKEFUN void putchar(int c) {
    struct Buffer_struct *str = THIS;
    if(!str->str.s)
      init_string_builder_alloc(&str->str, str->initial, 0);
    string_builder_putchar(&str->str, c);
  }

  /*! @decl int sprintf(strict_sprintf_format format, sprintf_args ... args)
   *! Appends the output from @[sprintf] at the end of the string.
   *! Returns the resulting size of the String.Buffer.
   */
  PIKEFUN int sprintf(mixed ... arguments)
    rawtype tFuncV(tAttr("strict_sprintf_format", tOr(tStr, tObj)),
		   tAttr("sprintf_args", tMix), tStr);

  {
    // FIXME: Reset length on exception?
    struct Buffer_struct *str = THIS;
    if(!str->str.s)
      init_string_builder_alloc(&str->str, str->initial, 0);
    low_f_sprintf(args, &str->str);
    RETURN str->str.s->len;
  }

  /*! @decl string get_copy()
   *!
   *!   Get the data from the buffer. Significantly slower than @[get],
   *!   but does not clear the buffer.
   *!
   *! @seealso
   *!   @[get()]
   */
  PIKEFUN string get_copy()
  {
    struct pike_string *str = THIS->str.s;
    ptrdiff_t len;
    if( str && (len = str->len) > 0 )
    {
      char *d = (char *)str->str;
      switch( str->size_shift )
      {
        case 0:
          str=make_shared_binary_string0((p_wchar0 *)d,len);
          break;
        case 1:
          str=make_shared_binary_string1((p_wchar1 *)d,len);
          break;
        case 2:
          str=make_shared_binary_string2((p_wchar2 *)d,len);
          break;
      }
      if( Pike_fp->current_object->flags & OBJECT_CLEAR_ON_EXIT )
          str->flags |= STRING_CLEAR_ON_EXIT;
      RETURN str;
    }
    push_empty_string();
    return;
  }

  /*! @decl string get()
   *!
   *!   Get the data from the buffer.
   *!
   *! @note
   *!   This will clear the data in the buffer
   *!
   *! @seealso
   *!   @[get_copy()], @[clear()]
   */
  PIKEFUN string get( )
  {
    struct Buffer_struct *str = THIS;
    pop_n_elems(args);
    if( str->str.s )
    {
      struct pike_string *s = finish_string_builder( &str->str );
      str->str.malloced = 0;
      str->str.s = NULL;
      if( Pike_fp->current_object->flags & OBJECT_CLEAR_ON_EXIT )
          s->flags |= STRING_CLEAR_ON_EXIT;
      push_string(s);
    }
    else
      push_empty_string();
  }

  /*! @decl void clear()
   *!
   *!   Empty the buffer, and don't care about the old content.
   *!
   *! @note
   *!   This function was not available in Pike 7.8 and earlier.
   *!
   *! @seealso
   *!   @[get()]
   */
  PIKEFUN void clear()
  {
    /* FIXME: Support resetting the initial size? */
    struct Buffer_struct *str = THIS;
    if (str->str.s) {
      /* FIXME: There's also the alternative of using
       *        reset_string_builder() here.
       */
      free_string_builder(&str->str);
      str->str.s = NULL;
    }
  }

  /*! @decl int _sizeof()
   *!
   *!   Returns the size of the buffer.
   */
  PIKEFUN int _sizeof()
    flags ID_PROTECTED;
  {
    struct Buffer_struct *str = THIS;
    RETURN str->str.s ? str->str.s->len : 0;
  }

  /*! @decl int(0..) _search(int character, int|void start, int|void end)
   *!
   *! Search for a @[character] in the buffer, starting the scan
   *! from @[start] and ending at @[end] (inclusive).
   *!
   *! @returns
   *!   Returns to position in the buffer where the character was found
   *!   on success, and @[UNDEFINED] on failure.
   *!
   *! @seealso
   *!   @[Stdio.Buffer()->_search()], @[search()], @[lfun::_search()]
   */
  PIKEFUN int(0..) _search(int character, int|void start, int|void end)
  {
    PCHARP buf = MKPCHARP_STR(THIS->str.s);
    ptrdiff_t len = THIS->str.s->len;
    ptrdiff_t i;

    if (end && (end->u.integer + 1 < len)) {
      len = end->u.integer + 1;
    }
    if (len > 0 && start && (start->u.integer > 0)) {
      INC_PCHARP(buf, start->u.integer);
      len -= start->u.integer;
    }
    if (len <= 0) {
      push_int(-1);
      return;
    }
    if (UNLIKELY(THIS->str.s->size_shift == thirtytwobit)) {
#if SIZEOF_INT_TYPE > 4
      if (UNLIKELY((0x7fffffff < character) || (character < -0x80000000))) {
        push_int(-1);
	return;
      }
#endif
    } else if (UNLIKELY((1L<<(8<<THIS->str.s->size_shift)) <= character) ||
	       UNLIKELY(character < 0)) {
      push_int(-1);
      return;
    }
    for (i = 0; i < len; i++) {
      p_wchar2 c = INDEX_PCHARP(buf, i);
      if (c == character) {
        if(start)
          i += start->u.integer;
	push_int64(i);
	return;
      }
    }
    push_int(-1);
  }

  /*! @decl int(0..) _search(string substring, int|void start, int|void end)
   *!
   *! Search for a @[substring] in the buffer, starting the scan
   *! from @[start] and ending at @[end] (inclusive).
   *!
   *! @returns
   *!   Returns to position in the buffer where the substring was found
   *!   on success, and @[UNDEFINED] on failure.
   *!
   *! @seealso
   *!   @[Stdio.Buffer()->_search()], @[search()], @[lfun::_search()]
   */
  PIKEFUN int(0..) _search(string substring, int|void start, int|void end)
  {
    PCHARP buf = MKPCHARP_STR(THIS->str.s);
    ptrdiff_t len = THIS->str.s->len;
    SearchMojt mojt;
    PCHARP res;

    if (end && (end->u.integer + 1 < len)) {
      len = end->u.integer + 1;
    }
    if (len > 0 && start && (start->u.integer > 0)) {
      INC_PCHARP(buf, start->u.integer);
      len -= start->u.integer;
    }
    if (len < substring->len) {
      push_undefined();
      return;
    }
    if (!substring->len) {
      push_int(0);
      return;
    }
    if (substring->size_shift > THIS->str.s->size_shift) {
      push_undefined();
      return;
    }

    mojt = compile_memsearcher(MKPCHARP_STR(substring), substring->len,
			       len, substring);

    res = mojt.vtab->funcN(mojt.data, buf, len);

    if (!res.ptr) {
      push_undefined();
    } else {
      push_int64((((char *)res.ptr) - ((char *)buf.ptr)) >>
		 THIS->str.s->size_shift);
    }
  }

  INIT
    {
      struct Buffer_struct *str = THIS;
      memset( str, 0, sizeof( *str ) );
    }

  EXIT
    gc_trivial;
    {
      struct Buffer_struct *str = THIS;
      if( str->str.s )
      {
          if( Pike_fp->flags & OBJECT_CLEAR_ON_EXIT )
            secure_zero( str->str.s->str, str->str.s->len );
          free_string_builder( &str->str );
      }
    }

  GC_RECURSE
  {
    if (mc_count_bytes (Pike_fp->current_object) && THIS->str.s)
      mc_counted_bytes += THIS->str.malloced;
  }
}

/*! @endclass
 */

/*! @endmodule String
 */

void init_string_buffer(void)
{
  INIT;
}

void exit_string_buffer(void)
{
  EXIT;
}

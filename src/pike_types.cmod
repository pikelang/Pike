/*
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/

#include "global.h"
#include <ctype.h>
#include "svalue.h"
#include "stralloc.h"
#include "pike_types.h"
#include "array.h"
#include "program.h"
#include "constants.h"
#include "object.h"
#include "multiset.h"
#include "mapping.h"
#include "pike_macros.h"
#include "pike_error.h"
#include "las.h"
#include "lex.h"
#include "pike_memory.h"
#include "bignum.h"
#include "main.h"
#include "opcodes.h"
#include "cyclic.h"
#include "gc.h"
#include "pike_compiler.h"
#include "block_allocator.h"
#include "bitvector.h"
#include "gc_header.h"

#ifdef PIKE_DEBUG
#define PIKE_TYPE_DEBUG
#endif /* PIKE_DEBUG */


/* Number of entries in the struct pike_type hash-table. */
/* 256Kb */
#define PIKE_TYPE_HASH_SIZE	32767

#ifdef PIKE_TYPE_DEBUG
static int indent=0;
#endif

int max_correct_args;

PMOD_EXPORT struct pike_type *string0_type_string;
PMOD_EXPORT struct pike_type *string_type_string;
PMOD_EXPORT struct pike_type *bool_type_string;
PMOD_EXPORT struct pike_type *int_type_string;
PMOD_EXPORT struct pike_type *int_pos_type_string;
PMOD_EXPORT struct pike_type *float_type_string;
PMOD_EXPORT struct pike_type *function_type_string;
PMOD_EXPORT struct pike_type *void_function_type_string;
PMOD_EXPORT struct pike_type *object_type_string;
PMOD_EXPORT struct pike_type *program_type_string;
PMOD_EXPORT struct pike_type *array_type_string;
PMOD_EXPORT struct pike_type *multiset_type_string;
PMOD_EXPORT struct pike_type *mapping_type_string;
PMOD_EXPORT struct pike_type *type_type_string;
PMOD_EXPORT struct pike_type *mixed_type_string;
PMOD_EXPORT struct pike_type *void_type_string;
PMOD_EXPORT struct pike_type *zero_type_string;
PMOD_EXPORT struct pike_type *inheritable_type_string;
PMOD_EXPORT struct pike_type *typeable_type_string;
PMOD_EXPORT struct pike_type *enumerable_type_string;
PMOD_EXPORT struct pike_type *any_type_string;
PMOD_EXPORT struct pike_type *weak_type_string;	/* array|mapping|multiset|function */
struct pike_type *sscanf_type_string;
struct pike_type *sscanf_80_type_string;
PMOD_EXPORT struct pike_type *utf8_type_string;

PMOD_EXPORT struct pike_string *literal_string_string;
PMOD_EXPORT struct pike_string *literal_int_string;
PMOD_EXPORT struct pike_string *literal_float_string;
PMOD_EXPORT struct pike_string *literal_function_string;
PMOD_EXPORT struct pike_string *literal_object_string;
PMOD_EXPORT struct pike_string *literal_program_string;
PMOD_EXPORT struct pike_string *literal_array_string;
PMOD_EXPORT struct pike_string *literal_multiset_string;
PMOD_EXPORT struct pike_string *literal_mapping_string;
PMOD_EXPORT struct pike_string *literal_type_string;
PMOD_EXPORT struct pike_string *literal_mixed_string;

PMOD_EXPORT struct pike_string *unknown_function_string;

/* Special case for converting T_ZERO into int(0) during processing.
 * Note that int(0) is usually automatically converted into T_ZERO,
 * so we need to define the type by hand explicitly here.
 */
static struct pike_type int0_type_string_storage = {
  GC_HEADER_INIT(1),
  0,
  NULL,
  0,
  T_INT,
  NULL, NULL,
};
#define int0_type_string (&int0_type_string_storage)

#ifdef DO_PIKE_CLEANUP
struct pike_type_location *all_pike_type_locations = NULL;
#endif /* DO_PIKE_CLEANUP */

static struct pike_type *a_markers[10], *b_markers[10];

static struct program *implements_a;
static struct program *implements_b;
static int implements_mode;

#ifdef PIKE_DEBUG
void TYPE_STACK_DEBUG(const char *fun)
{
  if (l_flag > 2) {
    fprintf(stderr, "%25s(): stack_depth:%-3ld   mark_stack_depth:%ld\n",
	    fun, (long)(Pike_compiler->type_stackp - type_stack),
	    (long)(Pike_compiler->pike_type_mark_stackp -
		   pike_type_mark_stack));
    if (Pike_compiler->type_stackp != type_stack) {
      fprintf(stderr, "%25s  : top: ", "");
      simple_describe_type(peek_type_stack());
      fprintf(stderr, "\n");
    }
  }
}
#endif /* PIKE_DEBUG */

static void clear_markers(void)
{
  unsigned int e;
  for(e=0;e<NELEM(a_markers);e++)
  {
    if(a_markers[e])
    {
      free_type(a_markers[e]);
      a_markers[e]=0;
    }
    if(b_markers[e])
    {
      free_type(b_markers[e]);
      b_markers[e]=0;
    }
  }
}

void compiler_discard_top_type(void)
{
  TYPE_STACK_DEBUG("discard_top_type");
#ifdef PIKE_DEBUG
  if (pike_type_mark_stack == Pike_compiler->pike_type_mark_stackp) {
    /* Type mark stack empty. */
    if (type_stack == Pike_compiler->type_stackp)
      Pike_fatal("Type stack underflow.\n");
  } else if (!peek_stack_mark())
    Pike_fatal("Type stack underflow.\n");
#endif
  free_type(*(Pike_compiler->type_stackp--));
}

static void low_discard_type (void)
{
  ptrdiff_t len = pop_stack_mark();
  TYPE_STACK_DEBUG("discard_type");
  for (;len > 0; len--) {
    /* Get rid of excess junk. */
    compiler_discard_top_type();
  }
}

void compiler_discard_type (void)
{
  low_discard_type();
  type_stack_mark();
}

static struct pike_type *low_pop_type(void)
{
  TYPE_STACK_DEBUG("low_pop_type");

  return *(Pike_compiler->type_stackp--);
}
#define low_pop_type()	((struct pike_type *)debug_malloc_pass(low_pop_type()))

struct pike_type *debug_pop_type(void)
{
  struct pike_type *t = pop_unfinished_type();
  TYPE_STACK_DEBUG("pop_type");
  type_stack_mark();
  return t;
}

struct pike_type *debug_compiler_pop_type(void)
{
  TYPE_STACK_DEBUG("compiler_pop_type");
  if(Pike_compiler->num_parse_error)
  {
    struct pike_type *res;
    compiler_discard_type();
    add_ref(res = any_type_string);
    return res;
  }else{
    return debug_pop_type();
  }
}

PMOD_EXPORT char *get_name_of_type(TYPE_T t)
{
  switch(t & PIKE_T_MASK)
  {
    case T_ARRAY:	return "array";
    case T_MAPPING:	return "mapping";
    case T_MULTISET:	return "multiset";
    case T_OBJECT:	return "object";
    case T_FUNCTION:	return "function";
    case T_PROGRAM:	return "program";
    case T_STRING:	return "string";
    case T_TYPE:	return "type";
    case T_INT:		return "int";
    case T_FLOAT:	return "float";
    case T_ZERO:	return "zero";
    case T_VOID:	return "void";
    case T_MIXED:	return "mixed";
    default:		return "unknown";

#ifdef PIKE_DEBUG
      /* Let's make it able to describe any type constant in debug mode. */
    case T_UNFINISHED:		return "T_UNFINISHED";
    case T_MANY:		return "T_MANY";
    case PIKE_T_INT_UNTYPED:	return "PIKE_T_INT_UNTYPED";
    case PIKE_T_GET_SET:	return "PIKE_T_GET_SET";
    case PIKE_T_FREE:		return "PIKE_T_FREE";
    case PIKE_T_FUNCTION_ARG:	return "PIKE_T_FUNCTION_ARG";

    case PIKE_T_FIND_LFUN:	return "PIKE_T_FIND_LFUN";
    case PIKE_T_SET_CAR:	return "PIKE_T_SET_CAR";
    case PIKE_T_SET_CDR:	return "PIKE_T_SET_CDR";

    case PIKE_T_ATTRIBUTE:	return "PIKE_T_ATTRIBUTE";
    case PIKE_T_NSTRING:	return "PIKE_T_NSTRING";
    case PIKE_T_LSTRING:	return "PIKE_T_LSTRING";
    case PIKE_T_LARRAY:		return "PIKE_T_LARRAY";
    case PIKE_T_RING:		return "PIKE_T_RING";
    case PIKE_T_NAME:		return "PIKE_T_NAME";
    case PIKE_T_SCOPE:		return "PIKE_T_SCOPE";
    case PIKE_T_TUPLE:		return "PIKE_T_TUPLE";
    case T_ASSIGN:		return "T_ASSIGN";
    case T_DELETED:		return "T_DELETED";
    case PIKE_T_UNKNOWN:	return "PIKE_T_UNKNOWN";
    case T_OBJ_INDEX:		return "T_OBJ_INDEX";
    case T_SVALUE_PTR:		return "T_SVALUE_PTR";
    case T_ARRAY_LVALUE:	return "T_ARRAY_LVALUE";
    case T_NOT:			return "T_NOT";
    case T_AND:			return "T_AND";
    case T_OR:			return "T_OR";

    case T_STORAGE:		return "object storage";
    case T_MAPPING_DATA:	return "mapping_data";
    case T_PIKE_FRAME:		return "pike_frame";
    case T_MULTISET_DATA:	return "multiset_data";
    case T_STRUCT_CALLABLE:	return "callable";
#endif
  }
}


#define TWOT(X,Y) (((X) << 8)+(Y))

static int low_pike_types_le(struct pike_type *a, struct pike_type *b,
			     int array_cnt, unsigned int flags);
static int low_check_indexing(struct pike_type *type,
			      struct pike_type *index_type,
			      node *n);
static void internal_parse_type(const char **s);

/*
 * New and improved type representation system.
 *
 * This representation is new in Pike 7.3.
 *
 * Node:	Car:		Cdr:
 * ---------------------------------------------
 * SCOPE	num vars (int)	type
 * ASSIGN	variable (int)	type
 * NAME		name (string)	type
 * ATTRIBUTE	name (string)	type			Added in 7.7.
 * FUNCTION	type		FUNCTION|MANY
 * MANY		many type	return type
 * RING		type		type			Reserved.
 * TUPLE	type		type			Reserved.
 * MAPPING	index type	value type
 * OR		type (not OR)	type
 * AND		type		type
 * ARRAY	len type	type			len added in 8.1
 * MULTISET	type		-
 * NOT		type		-
 * '0'-'9'	-		-			Marker $0-$9.
 * FLOAT	-		-
 * STRING	len type	ZERO, INT or OR		len:8.1, Range:7.7
 * TYPE		type		-
 * AUTO		type		-			Added in 8.1
 * PROGRAM	type		-
 * MIXED	-		-
 * VOID		-		-
 * ZERO		-		-
 * UNKNOWN	-		-			Represented as NULL
 * INT		min (int)	max (int)
 * OBJECT	implements/is	object id(int)
 * OPERATOR	type		Depends on bit #15.	Added in 8.1
 * TRANSITIVE	fun_type	fun_type		Added in 8.1
 *
 * Operator types:
 * FIND_LFUN	object type	lfun (int)		Added in 8.1
 * GET_RETURN	fun type	-			Added in 8.1
 * THRESHOLD	type		-			Added in 8.1
 * SET_CAR	type		type			Added in 8.1
 * SET_CDR	type		type			Added in 8.1
 * APPLY	fun type	arg type		Added in 8.1
 *
 * Note that the cdr of a FUNCTION is a valid FUNCTION for the rest of
 * the arguments.
 *
 * Note also that functions that don't take any arguments, or just
 * a many argument just have a MANY node, and no FUNCTION node.
 *
 * TRANSITIVE has a car with the current state, and a cdr with the
 * function type to apply.
 *
 */
static struct block_allocator type_allocator = BA_INIT(sizeof(struct pike_type), 128);

PMOD_EXPORT void really_free_pike_type(struct pike_type * t) {
    dmalloc_unregister(t, 0);
    ba_free(&type_allocator, t);
}

ATTRIBUTE((malloc))
PMOD_EXPORT struct pike_type * alloc_pike_type(void) {
    struct pike_type *t = ba_alloc(&type_allocator);
    dmalloc_register(t, sizeof(struct pike_type), DMALLOC_LOCATION());
    gc_init_marker(t);
    return t;
}

PMOD_EXPORT void count_memory_in_pike_types(size_t *n, size_t *s) {
    ba_count_all(&type_allocator, n, s);
}

struct pike_type **pike_type_hash = NULL;
size_t pike_type_hash_size = 0;

void debug_free_type(struct pike_type *t)
{
 loop:
  if (!t) return;
#ifdef DEBUG_MALLOC
  if (t == (struct pike_type *)(size_t)0x55555555) {
    Pike_fatal("Freeing dead type.\n");
  }
#endif /* DEBUG_MALLOC */
  if (!sub_ref(t)) {
    unsigned INT32 hash = t->hash & pike_type_hash_size;
    struct pike_type **t2 = pike_type_hash + hash;
    struct pike_type *car, *cdr;
    unsigned INT32 type;
#ifdef PIKE_DEBUG
    /* PIKE_DEBUG code */
    if (hash > pike_type_hash_size) {
      Pike_fatal("Modulo operation failed for hash:%u, index:%u, size:%u.\n",
		 t->hash, hash, pike_type_hash_size);
    }
    /* End PIKE_DEBUG code */
#endif
    while (*t2) {
      if (*t2 == t) {
	*t2 = t->next;
	break;
      }
      t2 = &((*t2)->next);
    }

    car = t->car;
    cdr = t->cdr;
    type = t->type;

    really_free_pike_type((struct pike_type*)debug_malloc_pass(t));

    /* FIXME: Recursion: Should we use a stack? */
    switch(type & PIKE_T_MASK) {
    case T_FUNCTION:
    case T_MANY:
    case T_TUPLE:
    case T_MAPPING:
    case T_OR:
    case T_AND:
    case PIKE_T_RING:
    case T_ARRAY:
    case T_STRING:
    case PIKE_T_TRANSITIVE:
      /* Free car & cdr */
      free_type(car);
      t = (struct pike_type *) cdr;
      if (t) debug_free_type_preamble (t);
      goto loop;

    case PIKE_T_AUTO:
      if (!car)
	break;
      /* FALLTHRU */
    case T_MULTISET:
    case T_NOT:
    case T_TYPE:
    case T_PROGRAM:
      /* Free car */
      t = (struct pike_type *) car;
      if (t) debug_free_type_preamble (t);
      goto loop;

    case T_SCOPE:
    case T_ASSIGN:
      /* Free cdr */
      t = (struct pike_type *) cdr;
      if (t) debug_free_type_preamble (t);
      goto loop;

    case PIKE_T_ATTRIBUTE:
    case PIKE_T_NAME:
      free_string((struct pike_string *)car);
      t = (struct pike_type *) cdr;
      if (t) debug_free_type_preamble (t);
      goto loop;

    case PIKE_T_OPERATOR:
      /* Free car and maybe cdr. */
      if (type & 0x8000) {
	/* Free cdr. */
	free_type(cdr);
      }
      t = car;
      if (t) debug_free_type_preamble(t);
      goto loop;

#ifdef PIKE_DEBUG
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case T_FLOAT:
    case T_MIXED:
    case T_VOID:
    case T_ZERO:
    case PIKE_T_UNKNOWN:
    case T_INT:
    case T_OBJECT:
      break;

    default:
      Pike_fatal("free_type(): Unhandled type-node: %d\n", type);
      break;
#endif /* PIKE_DEBUG */
    }
  }
}

/* NB: Steals the references to car and cdr. */
static struct pike_type *debug_mk_type(unsigned INT32 type,
				       struct pike_type *car,
				       struct pike_type *cdr,
				       unsigned int flag_method)
{
  /* FIXME: The hash ought to be based on the tree contents, regardless
   *        of what the adresses of the type nodes are.
   */
  struct pike_type *t;
  unsigned INT32 index,
    hash = (unsigned INT32)
    ((ptrdiff_t)type*0x10204081)^
    (0x8003*PTR_TO_INT(car))^
    ~(0x10001*PTR_TO_INT(cdr));

  hash ^= (hash >> 20) ^ (hash >> 12);
  hash ^= (hash >> 7) ^ (hash >> 4);

  index = hash & pike_type_hash_size;
#ifdef PIKE_EXTRA_DEBUG
  static unsigned INT32 extra_debug_index = (unsigned INT32)~0;
#endif /* PIKE_EXTRA_DEBUG */
#ifdef PIKE_DEBUG
  /* PIKE_DEBUG code */
  if ((type & ~PIKE_T_MASK) && ((type & PIKE_T_MASK) != PIKE_T_OPERATOR)) {
    /* The bad type node on OSF/1 seems to be:
     *
     * type: 0xffff
     * car:  valid pointer.
     * cdr:  0x400000000
     * next: 0x100000000
     */
    Pike_fatal("Attempt to create an invalid type node: %d(%s)\n"
	       "  car: %p\n"
	       "  cdr: %p\n",
	       type, get_name_of_type(type),
	       car, cdr);
  }
  if (index > pike_type_hash_size) {
    Pike_fatal("Modulo operation failed for hash:%u, index:%u, "
	       "size:%"PRINTSIZET"d.\n",
	       hash, index, pike_type_hash_size);
  }
  /* End PIKE_DEBUG code */
#endif
#ifdef PIKE_EXTRA_DEBUG
  if ((!~extra_debug_index) &&
      (type == T_FUNCTION) &&
      (car->type == T_STRING) &&
      (cdr->type == T_FUNCTION) &&
      (cdr->car->type == T_STRING) &&
      (cdr->cdr->type == T_MANY) &&
      (cdr->cdr->car->type == T_VOID) &&
      (cdr->cdr->cdr->type == T_STRING)) {
    /* Attempt to detect why we get a core-dump on OSF/1
     * when loading Unicode.so from test_resolv.
     *
     * The problem triggs when the type for normalize() is created.
     * function(string,string:string)
     *	/grubba 2005-02-04
     *
     * Load order:
     *   Module		Hashtable status	Note
     *   Nettle.so	OK
     *   ___Oracle.so	-			load_module() fails.
     *   Image.so	-			loads ok.
     *   Unicode.so	FAIL
     *
     * pike_type node:
     *   Field		Before			After
     *     t		1404b5020		1404b5020
     *     t->type	4 (function)		65535 (unknown)
     *     t->car	1404863f8 (1404863f8)	140557560 (1404863f8)
     *     t->cdr	1404b43d8 (1404b43d8)	400000000 (1404b43d8)
     *     t->next	0			100000000
     *  /grubba 2005-06-03
     */
    extra_debug_index = index;
  }
#endif /* PIKE_EXTRA_DEBUG */
  if (type == PIKE_T_UNKNOWN) return NULL;
  for(t = pike_type_hash[index]; t; t = t->next) {
#ifdef PIKE_EXTRA_DEBUG
    if (index == extra_debug_index) {
      fprintf(stderr,
	      "  %s:%d:PIKE_EXTRA_DEBUG:\n"
	      "    t: %p\n",
	      __FILE__, __LINE__,
	      t);
      fprintf(stderr,
	      "    t->type:%d (%s)\n"
	      "    t->car: %p (%p)\n"
	      "    t->cdr: %p (%p)\n"
	      "    t->next:%p\n",
	      t->type, get_name_of_type(t->type),
	      t->car, car,
	      t->cdr, cdr,
	      t->next);
    }
#endif /* PIKE_EXTRA_DEBUG */
    if ((t->hash == hash) && (t->type == type) &&
	(t->car == car) && (t->cdr == cdr)) {
      /* Free car & cdr as appropriate. */
      switch(type & PIKE_T_MASK) {
      case T_FUNCTION:
      case T_MANY:
      case T_TUPLE:
      case T_MAPPING:
      case T_OR:
      case T_AND:
      case PIKE_T_RING:
      case T_ARRAY:
      case T_STRING:
      case PIKE_T_TRANSITIVE:
	/* Free car & cdr */
	free_type((struct pike_type *)debug_malloc_pass(car));
	free_type((struct pike_type *)debug_malloc_pass(cdr));
	break;

      case T_MULTISET:
      case T_NOT:
      case T_TYPE:
      case T_PROGRAM:
	/* Free car */
	free_type((struct pike_type *)debug_malloc_pass(car));
	break;
     case PIKE_T_AUTO:
      if( car )
         free_type((struct pike_type *)debug_malloc_pass(car));
      break;

      case T_SCOPE:
      case T_ASSIGN:
	/* Free cdr */
	free_type((struct pike_type *)debug_malloc_pass(cdr));
	break;

      case PIKE_T_ATTRIBUTE:
      case PIKE_T_NAME:
	free_string((struct pike_string *)debug_malloc_pass(car));
	free_type((struct pike_type *)debug_malloc_pass(cdr));
	break;

      case PIKE_T_OPERATOR:
	if (type & 0x8000) {
	  free_type((struct pike_type *)debug_malloc_pass(cdr));
	}
	free_type((struct pike_type *)debug_malloc_pass(car));
	break;

#ifdef PIKE_DEBUG
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case T_FLOAT:
      case T_MIXED:
      case T_VOID:
      case T_ZERO:
      case PIKE_T_UNKNOWN:
      case T_INT:
      case T_OBJECT:
	break;

      default:
	Pike_fatal("mk_type(): Unhandled type-node: %d\n", type);
	break;
#endif /* PIKE_DEBUG */
      }
      add_ref((struct pike_type *)debug_malloc_pass(t));
      return t;
    }
  }

#ifdef PIKE_DEBUG
  if ((type == T_OR) && (car->type == T_OR)) {
    Pike_fatal("Invalid CAR to OR node.\n");
  }
#endif

  debug_malloc_pass(t = alloc_pike_type());

  t->refs = 0;
  add_ref(t);	/* For DMALLOC... */
  t->type = type;
  t->flags = flag_method & ~PT_FLAG_MARK_ASSIGN;
  t->car = car;
  t->cdr = cdr;

  t->hash = hash;
  t->next = pike_type_hash[index];
  pike_type_hash[index] = t;

  if (flag_method) {
    if (flag_method == PT_IS_MARKER) {
      t->flags = PT_FLAG_MARKER_0 << (type-'0');
    } else if (type == PIKE_T_SCOPE) {
      /* The scope blocks propagation of markers. */
      t->flags = cdr->flags & ~(PT_FLAG_MARKER|PT_FLAG_ASSIGN);
    } else if (type == T_NOT) {
      if (car) {
	/* NB: We cannot set the PT_FLAG_MIXED flag,
	 *     as inverting a non-mixed type does not
	 *     give mixed.
	 */
	t->flags |= (car->flags ^ ~PT_FLAG_MARK_ASSIGN) & ~PT_FLAG_MIXED;
      }
    } else if (flag_method & PT_COPY_MORE) {
      if (car && (flag_method & PT_COPY_CAR)) {
	t->flags |= car->flags;
      }
      if (cdr && (flag_method & PT_COPY_CDR)) {
	t->flags |= cdr->flags;
      }
    } else {
      if (car && (flag_method & PT_COPY_CAR)) {
	t->flags |= car->flags & PT_FLAG_MARK_ASSIGN;
      }
      if (cdr && (flag_method & PT_COPY_CDR)) {
	t->flags |= cdr->flags & PT_FLAG_MARK_ASSIGN;;
      }
    }
  }

#ifdef DEBUG_MALLOC
  switch(type & PIKE_T_MASK) {
  case T_FUNCTION:
  case T_MANY:
  case T_TUPLE:
  case T_MAPPING:
  case T_OR:
  case T_AND:
  case PIKE_T_RING:
  case T_ARRAY:
  case T_STRING:
  case PIKE_T_TRANSITIVE:
    debug_malloc_pass(car);
    debug_malloc_pass(cdr);
    break;

  case T_MULTISET:
  case T_NOT:
  case T_TYPE:
  case T_PROGRAM:
  case PIKE_T_AUTO:
    debug_malloc_pass(car);
    break;

  case T_ASSIGN:
    t->flags |= PT_FLAG_ASSIGN_0 << PTR_TO_INT(car);
    /* FALLTHRU */
  case T_SCOPE:
    debug_malloc_pass(cdr);
    break;

  case PIKE_T_ATTRIBUTE:
  case PIKE_T_NAME:
    debug_malloc_pass(car);
    debug_malloc_pass(cdr);
    break;

  case PIKE_T_OPERATOR:
    if (type & 0x8000) {
      debug_malloc_pass(cdr);
    }
    debug_malloc_pass(car);
    break;

  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
  case T_FLOAT:
  case T_MIXED:
  case T_VOID:
  case T_ZERO:
  case PIKE_T_UNKNOWN:
  case T_INT:
  case T_OBJECT:
    break;

  default:
    Pike_fatal("mk_type(): Unhandled type-node: %d\n", type);
    break;
  }
#else /* !DEBUG_MALLOC */
  if (type == T_ASSIGN) {
    t->flags |= PT_FLAG_ASSIGN_0 << PTR_TO_INT(car);
  }
#endif /* DEBUG_MALLOC */

  return t;
}

#ifdef DEBUG_MALLOC
#define mk_type(T,CAR,CDR,FLAG)	((struct pike_type *)debug_malloc_pass(debug_mk_type(T,CAR,CDR,FLAG)))
#else /* !DEBUG_MALLOC */
#define mk_type debug_mk_type
#endif /* DEBUG_MALLOC */

struct pike_type **type_stack;
struct pike_type ***pike_type_mark_stack;

ptrdiff_t peek_stack_mark(void)
{
  if(Pike_compiler->pike_type_mark_stackp-1 < pike_type_mark_stack)
    Pike_fatal("Type mark stack underflow\n");

  TYPE_STACK_DEBUG("peek_stack_mark");

  return Pike_compiler->type_stackp - Pike_compiler->pike_type_mark_stackp[-1];
}

ptrdiff_t pop_stack_mark(void)
{
  Pike_compiler->pike_type_mark_stackp--;
  if(Pike_compiler->pike_type_mark_stackp<pike_type_mark_stack)
    Pike_fatal("Type mark stack underflow\n");

  TYPE_STACK_DEBUG("pop_stack_mark");

  return Pike_compiler->type_stackp - *Pike_compiler->pike_type_mark_stackp;
}

void type_stack_pop_to_mark(void)
{
  pop_stack_mark();
  while(Pike_compiler->type_stackp > *Pike_compiler->pike_type_mark_stackp) {
    free_type(*(Pike_compiler->type_stackp--));
  }

  TYPE_STACK_DEBUG("type_stack_pop_to_mark");
}

struct pike_type *debug_peek_type_stack(void)
{
  return *(Pike_compiler->type_stackp);
}

void debug_push_int_type(INT_TYPE min, INT_TYPE max)
{
#if SIZEOF_INT_TYPE > 4
/* a bit kludgy: should maybe really allow 64 bit INT_TYPE */
/* see also extract_type_int */
  if (min<MIN_INT32) min=MIN_INT32;
  else if (min>MAX_INT32) min=MAX_INT32;
  if (max<MIN_INT32) max=MIN_INT32;
  else if (max>MAX_INT32) max=MAX_INT32;
#endif

#ifdef PIKE_DEBUG	/* FIXME: Kludge to support 2^32-1 */
  if (((min>0 && max>0) || (min<0 && max<0)) && min > max)
    Pike_fatal("push_int_type(): Bad integer range:"
	       " min:%"PRINTPIKEINT"d, max:%"PRINTPIKEINT"d.\n",
	       min, max);
#endif /* PIKE_DEBUG */

  if (!min && !max) {
    /* Special case... */
    push_type(T_ZERO);
  } else {
    unsigned int flag_method = 0;
    if ((min <= 0) && (max >= 0)) {
      flag_method = PT_FLAG_NULLABLE;
    }
    *(++Pike_compiler->type_stackp) = mk_type(T_INT,
					      (void *)(ptrdiff_t)min,
					      (void *)(ptrdiff_t)max,
					      flag_method);
  }
  TYPE_STACK_DEBUG("push_int_type");
}

/**
 * Used with arrays and strings.
 *
 * On entry the type stack contains the value type.
 *
 * Generates an array or string type with no length limits.
 */
void debug_push_unlimited_array_type(enum PIKE_TYPE t)
{
  struct compilation * c = MAYBE_THIS_COMPILATION;
#ifdef PIKE_DEBUG
  if ((t != PIKE_T_ARRAY) && (t != PIKE_T_STRING)) {
    Pike_fatal("Invalid type for push_unlimited_array_type(): %s (%d)\n",
	       get_name_of_type(t), t);
  }
#endif
  if (!peek_type_stack()) {
    push_type(PIKE_T_ZERO);
  } else {
    push_int_type(0, MAX_INT32);
  }
  push_type(t);

  TYPE_STACK_DEBUG("push_array_type");
}

static int (*program_id_to_id)(int) = NULL;

PMOD_EXPORT void set_program_id_to_id( int (*to)(int) )
{
    program_id_to_id = to;
}

void debug_push_object_type(int flag, INT32 id)
{
  if( program_id_to_id )
      id = program_id_to_id(id);
  *(++Pike_compiler->type_stackp) = mk_type(T_OBJECT,
                                            (void *)(ptrdiff_t)flag,
                                            (void *)(ptrdiff_t)id, 0);

  TYPE_STACK_DEBUG("push_object_type");
}

void debug_push_object_type_backwards(int flag, INT32 id)
{
  push_object_type(flag, id);
}

void debug_push_scope_type(int level)
{
  *Pike_compiler->type_stackp = mk_type(T_SCOPE,
					(void *)(ptrdiff_t)level,
					*Pike_compiler->type_stackp,
					PT_COPY_MORE|PT_COPY_CDR);

  TYPE_STACK_DEBUG("push_scope_type");
}

void debug_push_assign_type(int marker)
{
  marker -= '0';
#ifdef PIKE_DEBUG
  if ((marker < 0) || (marker > 9)) {
    Pike_fatal("Bad assign marker: %d\n", marker);
  }
#endif /* PIKE_DEBUG */

  *Pike_compiler->type_stackp = mk_type(T_ASSIGN,
					(void *)(ptrdiff_t)marker,
					*Pike_compiler->type_stackp,
					PT_COPY_CDR);
  TYPE_STACK_DEBUG("push_assign_type");
}

void debug_push_type_attribute(struct pike_string *attr)
{
  /* fprintf(stderr, "push_type_attribute(\"%s\")\n", attr->str); */
  add_ref(attr);
  *Pike_compiler->type_stackp = mk_type(PIKE_T_ATTRIBUTE,
					(void *)attr,
					*Pike_compiler->type_stackp,
					PT_COPY_MORE|PT_COPY_CDR);
  TYPE_STACK_DEBUG("push_type_attribute");
}

void debug_push_type_name(struct pike_string *name)
{
  /* fprintf(stderr, "push_type_name(\"%s\")\n", name->str); */
  if ((peek_type_stack() == zero_type_string) && (name->len == 4) &&
      !name->size_shift && !strcmp(name->str, "zero")) {
    /* Do not generate a name node for zero = zero.
     * This simplifies detecting zero.
     */
    return;
  }
  add_ref(name);
  *Pike_compiler->type_stackp = mk_type(PIKE_T_NAME,
					(void *)name,
					*Pike_compiler->type_stackp,
					PT_COPY_MORE|PT_COPY_CDR);
  TYPE_STACK_DEBUG("push_type_name");
}

static struct pike_type *apply_type_operator(enum PIKE_TYPE op,
					     struct pike_type *arg1,
					     struct pike_type *arg2);

void debug_push_type_operator(enum PIKE_TYPE op, struct pike_type *arg)
{
  struct pike_type *t = *Pike_compiler->type_stackp;
  int free_arg = 0;

#ifdef PIKE_DEBUG
  if ((op & PIKE_T_MASK) != 0x80) {
    Pike_fatal("Invalid operator for push_operator: 0x%04x\n", op);
  }
#endif

  /* Attempt to propagate the operator towards the leaf nodes. */
  switch(t?(t->type & PIKE_T_MASK):PIKE_T_UNKNOWN) {
  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
  case T_ASSIGN:
  case PIKE_T_OPERATOR:
  case PIKE_T_SCOPE:
    /* Deferred evaluation. */
    if (op & 0x8000) {
      if (arg) add_ref(arg);
      *Pike_compiler->type_stackp = mk_type(op,
					    *Pike_compiler->type_stackp,
					    arg,
					    PT_COPY_BOTH);
    } else {
      *Pike_compiler->type_stackp = mk_type(op,
					    *Pike_compiler->type_stackp,
					    arg,
					    PT_COPY_CAR);
    }
    break;
  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
    {
      Pike_compiler->type_stackp--;
      push_finished_type(t->cdr);
      push_type_operator(op, arg);
      if (t->type == PIKE_T_NAME) {
	push_type_name((struct pike_string *)t->car);
      } else {
	push_type_attribute((struct pike_string *)t->car);
      }
      free_type(t);
      break;
    }
  case T_NOT:
    {
      /* Unary propagate. */
      int unop = t->type;

      pop_type_stack(t->type);
      push_type_operator(op, arg);
      push_type(unop);
      break;
    }
  case T_AND:
  case T_OR:
    {
      struct pike_type *tmp;
      int binop = t->type;
      /* Propagate. */
      pop_type_stack(t->type);
      tmp = *Pike_compiler->type_stackp;
      Pike_compiler->type_stackp--;
      push_type_operator(op, arg);
      Pike_compiler->type_stackp++;
      *Pike_compiler->type_stackp = tmp;
      push_type_operator(op, arg);
      push_type(binop);
      break;
    }

  default:
    /* Check the second argument. */
    switch(((op & 0x8000) && arg)?(arg->type & PIKE_T_MASK):PIKE_T_UNKNOWN) {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    case T_ASSIGN:
    case PIKE_T_OPERATOR:
    case PIKE_T_SCOPE:
      /* Deferred evaluation. */
      add_ref(arg);
      *Pike_compiler->type_stackp = mk_type(op,
					    *Pike_compiler->type_stackp,
					    arg,
					    PT_COPY_BOTH);
      break;

    default:
      *Pike_compiler->type_stackp = apply_type_operator(op, t, arg);
      free_type(t);
      break;
    }
    break;
  }

  TYPE_STACK_DEBUG("push_type_operator");
}

void debug_push_finished_type(struct pike_type *t)
{
  copy_pike_type(*(++Pike_compiler->type_stackp), t);

  TYPE_STACK_DEBUG("push_finished_type");
}

static void push_reverse_joiner_type(unsigned int type)
{
  /* fprintf(stderr, "push_reverse_joiner_type(%d)\n", type); */

  switch(type & PIKE_T_MASK) {
  case T_OR:
  case T_AND:
    /* Special case: Check if the two top elements are equal. */
    if (Pike_compiler->type_stackp[-1] == Pike_compiler->type_stackp[0]) {
      free_type(*(Pike_compiler->type_stackp--));
      return;
    }
    /* Make a new type of the top two types. */
    --Pike_compiler->type_stackp;
#ifdef PIKE_DEBUG
    if ((*Pike_compiler->type_stackp)->type == type) {
      Pike_fatal("Invalid CAR to push_reverse_joiner_type().\n");
    }
#endif /* PIKE_DEBUG */
    *Pike_compiler->type_stackp = mk_type(type,
					  *Pike_compiler->type_stackp,
					  *(Pike_compiler->type_stackp+1),
					  ((type == T_OR)? PT_COPY_MORE : 0) |
					  PT_COPY_BOTH);
    break;
  default:
    Pike_fatal("Illegal reverse joiner type: %d\n", type);
  }
}
#define push_reverse_joiner_type(T) do {		\
    push_reverse_joiner_type(T);			\
    debug_malloc_touch(debug_peek_type_stack());	\
  } while (0)

static void low_or_pike_types(struct pike_type *t1,
			      struct pike_type *t2,
			      int zero_implied);

void debug_push_type(unsigned int type)
{
  /* fprintf(stderr, "push_type(%d)\n", type); */

  switch(type & PIKE_T_MASK) {
  case T_OR:
  case T_AND:
    /* Special case: Check if the two top elements are equal. */
    if (Pike_compiler->type_stackp[-1] == Pike_compiler->type_stackp[0]) {
      free_type(*(Pike_compiler->type_stackp--));
      break;
    }
    if (!Pike_compiler->type_stackp[0]) {
      Pike_compiler->type_stackp--;
      if ((type & PIKE_T_MASK) == T_AND) {
	free_type(Pike_compiler->type_stackp[0]);
	Pike_compiler->type_stackp[0] = NULL;
      }
      break;
    }
    if (!Pike_compiler->type_stackp[-1]) {
      if ((type & PIKE_T_MASK) == T_AND) {
	free_type(Pike_compiler->type_stackp[0]);
      } else {
	Pike_compiler->type_stackp[-1] = Pike_compiler->type_stackp[0];
      }
      Pike_compiler->type_stackp--;
      break;
    }
    if (type == T_AND) {
      if ((Pike_compiler->type_stackp[0] == any_type_string) ||
	  ((Pike_compiler->type_stackp[0] == mixed_type_string) &&
	   !(Pike_compiler->type_stackp[-1]->flags & PT_FLAG_VOIDABLE))) {
	free_type(low_pop_type());
	break;
      }
      if ((Pike_compiler->type_stackp[-1] == any_type_string) ||
	  ((Pike_compiler->type_stackp[-1] == mixed_type_string) &&
	   !(Pike_compiler->type_stackp[0]->flags & PT_FLAG_VOIDABLE))) {
	struct pike_type *t = low_pop_type();
	free_type(low_pop_type());
	push_finished_type(t);
	free_type(t);
	break;
      }
    }
    if (Pike_compiler->type_stackp[0]->type == type) {
      /* The top type is the same as our type.
       * Split it and join the parts with the other type.
       */
      struct pike_type *top = low_pop_type();
      push_finished_type(top->cdr);
      push_type(type);
      push_finished_type(top->car);
      push_type(type);
      free_type(top);
      break;
    }
    if (type == T_OR) {
      /* check_trans_type(NULL, NULL, type); */
      struct pike_type *t1 = low_pop_type();
      /* check_trans_type(NULL, NULL, type); */
      struct pike_type *t2 = low_pop_type();
      low_or_pike_types(t1, t2, 0);
      free_type(t2);
      free_type(t1);
      break;
    }
    if ((Pike_compiler->type_stackp[0] == int_type_string) &&
	(Pike_compiler->type_stackp[-1]->type == T_INT)) {
      free_type(*(Pike_compiler->type_stackp--));
      break;
    }
    if ((Pike_compiler->type_stackp[-1] == int_type_string) &&
	(Pike_compiler->type_stackp[0]->type == T_INT)) {
      free_type(*(--Pike_compiler->type_stackp));
      Pike_compiler->type_stackp[0] = Pike_compiler->type_stackp[1];
      break;
    }
    if ((Pike_compiler->type_stackp[0]->type == T_STRING) &&
	(Pike_compiler->type_stackp[-1]->type == T_STRING)) {
      struct pike_type *t1 = low_pop_type();
      struct pike_type *t2 = low_pop_type();
      push_finished_type(t1->cdr);
      push_finished_type(t2->cdr);
      push_type(T_AND);
      push_finished_type(t1->car);
      push_finished_type(t2->car);
      push_type(T_AND);
      push_type(T_STRING);
      free_type(t1);
      free_type(t2);
      break;
    }
    /* FALLTHRU */
  case T_ARRAY:
  case T_STRING:
    if ((type == T_ARRAY) || (type == T_STRING)) {
      if (peek_type_stack() == zero_type_string) {
	/* Zero-length ==> unrestricted content. */
	free_type(Pike_compiler->type_stackp[-1]);
	Pike_compiler->type_stackp[-1] = NULL;
      }
    }
    /* FALLTHRU */
  case T_FUNCTION:
  case T_MANY:
  case T_TUPLE:
  case T_MAPPING:
  case PIKE_T_RING:
    /* Make a new type of the top two types. */
    --Pike_compiler->type_stackp;
    *Pike_compiler->type_stackp = mk_type(type,
					  *(Pike_compiler->type_stackp+1),
					  *Pike_compiler->type_stackp,
					  PT_COPY_BOTH);
    break;

  case PIKE_T_TRANSITIVE:
    --Pike_compiler->type_stackp;
    if (!Pike_compiler->type_stackp[1]) {
      /* Shorthand: No car ==> copy from cdr. */
      if (!Pike_compiler->type_stackp[0]) {
	/* Invalid. */
	break;
      }
      Pike_compiler->type_stackp[1] = Pike_compiler->type_stackp[0];
      add_ref(Pike_compiler->type_stackp[1]);
    } else if (!Pike_compiler->type_stackp[0]) {
      /* No recurring function ==> noop. */
      Pike_compiler->type_stackp[0] = Pike_compiler->type_stackp[1];
      break;
    }

    /* Note: Copy flags from car only. */
    *Pike_compiler->type_stackp = mk_type(type,
					  *(Pike_compiler->type_stackp+1),
					  *Pike_compiler->type_stackp,
					  PT_COPY_CAR);
    break;

  case T_PROGRAM:
    if (!*Pike_compiler->type_stackp ||
	(*Pike_compiler->type_stackp)->type != T_OBJECT) {
      struct pike_type *t = (*Pike_compiler->type_stackp);
      while (t && ((t->type == PIKE_T_NAME) || (t->type == PIKE_T_ATTRIBUTE))) {
	t = t->cdr;
      }
      if (!t || (t->type != T_OBJECT)) {
	/* Not a program type, convert it to a type type. */
	type = T_TYPE;
      }
    }
    /* FALLTHRU */
  case T_MULTISET:
  case T_TYPE:
  case PIKE_T_AUTO:
    /* Make a new type of the top type, and put it in car. */
    *Pike_compiler->type_stackp = mk_type(type,
					  *Pike_compiler->type_stackp, NULL,
					  PT_COPY_CAR);
    break;

  case T_NOT:
    /* Make a new type of the top type, and put it in car.
     *
     * Special case: Remove double inversions.
     */
    {
      struct pike_type *t = *Pike_compiler->type_stackp;
      if (!t) {
	Pike_compiler->type_stackp--;
	push_type(T_MIXED);
	push_type(T_VOID);
	push_type(T_OR);
	break;
      }
      if (t->type == T_NOT) {
	*Pike_compiler->type_stackp = t->car;
	add_ref(t->car);
	free_type(t);
	break;
      }
      *Pike_compiler->type_stackp = mk_type(type, t, NULL, PT_COPY_CAR);
    }
    break;

  case T_SCOPE:
  case T_ASSIGN:
  case T_INT:
  case T_OBJECT:
  case PIKE_T_ATTRIBUTE:
  case PIKE_T_NAME:
  default:
    /* Should not occur. */
    Pike_fatal("Unsupported argument to push_type(): %d\n", type);
    break;

  case T_VOID:
    /* Leaf type. */
    *(++Pike_compiler->type_stackp) = mk_type(type, NULL, NULL,
					      PT_FLAG_VOIDABLE);
    break;
  case T_ZERO:
    /* Leaf type. */
    *(++Pike_compiler->type_stackp) = mk_type(type, NULL, NULL,
					      PT_FLAG_NULLABLE);
    break;
  case T_MIXED:
    /* Leaf type. */
    *(++Pike_compiler->type_stackp) = mk_type(type, NULL, NULL,
					      PT_FLAG_MIXED|PT_FLAG_NULLABLE);
    break;
  case T_FLOAT:
  case PIKE_T_UNKNOWN:
    /* Leaf type. */
    *(++Pike_compiler->type_stackp) = mk_type(type, NULL, NULL, 0);
    break;

  case PIKE_T_OPERATOR:
    if (type & 0x8000) {
      struct pike_type *t = *(--Pike_compiler->type_stackp);
      *Pike_compiler->type_stackp = Pike_compiler->type_stackp[1];
      push_type_operator(type, t);
      free_type(t);
    } else {
      push_type_operator(type, NULL);
    }
    break;

  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
    /* Marker. */
    *(++Pike_compiler->type_stackp) = mk_type(type, NULL, NULL, PT_IS_MARKER);
    break;
  }

  TYPE_STACK_DEBUG("push_type");
}

/* Pop one level of types. This is the inverse of push_type() */
int debug_pop_type_stack(unsigned int expected)
{
  struct pike_type *top;
  if(Pike_compiler->type_stackp<type_stack)
    Pike_fatal("Type stack underflow\n");

  top = *(Pike_compiler->type_stackp);
  /* Special case... */
  if (!top || (top->type == T_MIXED) ||
      ((top == any_type_string) && (expected != T_OR))) {
    /* Probably due to an earlier error */
    return 0;
  }

  Pike_compiler->type_stackp--;
#ifdef PIKE_DEBUG
  if ((top->type != expected) &&
      (top->type != PIKE_T_NAME) &&
      (top->type != PIKE_T_ATTRIBUTE)) {
    Pike_fatal("Unexpected type on stack: %d (expected %d)\n", top->type, expected);
  }
#endif /* PIKE_DEBUG */
  /* OPTIMIZE: It looks like this function is always called with
   * expected == T_ARRAY.
   */
  switch(top->type & PIKE_T_MASK) {
  case T_FUNCTION:
  case T_MANY:
  case T_TUPLE:
  case T_MAPPING:
  case T_OR:
  case T_AND:
  case PIKE_T_RING:
  case T_ARRAY:
  case T_STRING:
  case PIKE_T_TRANSITIVE:
    /* Both car & cdr. */
    push_finished_type(top->cdr);
    push_finished_type(top->car);
    break;
  case T_MULTISET:
  case T_NOT:
  case T_TYPE:
  case T_PROGRAM:
  case PIKE_T_AUTO:
    /* car */
    push_finished_type(top->car);
    break;
  case T_SCOPE:
  case T_ASSIGN:
    /* cdr */
    push_finished_type(top->cdr);
    break;
  case T_INT:
  case T_OBJECT:
  case T_FLOAT:
  case T_MIXED:
  case T_VOID:
  case T_ZERO:
  case PIKE_T_UNKNOWN:
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
    /* Leaf */
    break;
  case PIKE_T_ATTRIBUTE:
  case PIKE_T_NAME:
    /* Pop the name and recurse. */
    push_finished_type(top->cdr);
    return pop_type_stack(expected);

  case PIKE_T_OPERATOR:
    if (top->type & 0x8000) {
      push_finished_type(top->cdr);
    }
    push_finished_type(top->car);
    break;

  default:
    Pike_error("pop_type_stack(): Unhandled node type: %d\n", top->type);
  }
  free_type(top);

  TYPE_STACK_DEBUG("pop_type_stack");

  return 1;
}

void debug_push_reverse_type(unsigned int type)
{
  /* fprintf(stderr, "push_reverse_type(%d)\n", type); */

  switch(type & 0x80ff) {
  case T_FUNCTION:
  case T_MANY:
  case T_TUPLE:
  case T_MAPPING:
  case T_OR:
  case T_AND:
  case PIKE_T_RING:
  case PIKE_T_ARRAY:
  case PIKE_T_STRING:
  case PIKE_T_OPERATOR | 0x8000:
  case PIKE_T_TRANSITIVE:
    {
      /* Binary type-node. -- swap the types. */
      struct pike_type *tmp = Pike_compiler->type_stackp[0];
      Pike_compiler->type_stackp[0] = Pike_compiler->type_stackp[-1];
      Pike_compiler->type_stackp[-1] = tmp;
      break;
    }
  }
  push_type(type);

  TYPE_STACK_DEBUG("push_reverse_type");
}

static int is_int_type(struct pike_type *t)
{
 loop:
  switch(t->type & PIKE_T_MASK) {
  case T_INT:
  case T_ZERO:
  case T_VOID:
  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
  case PIKE_T_OPERATOR:
    return 1;
  case T_OR:
  case T_AND:
    return is_int_type(t->car) && is_int_type(t->cdr);
  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
  case PIKE_T_SCOPE:
  case T_ASSIGN:
    t = t->cdr;
    goto loop;
  default:
    return 0;
  }
}

/* The marker_set is used as follows:
 *
 *   PT_FLAG_MARKER_n	Indicates that marker #n should be kept after
 *			expansion.
 *
 *   PT_FLAG_ASSIGN_n	Indicates that the assign to marker #n should
 *			NOT be removed.
 */
static void debug_push_finished_type_with_markers(struct pike_type *type,
						  struct pike_type **markers,
						  INT32 marker_set)
{
  INT32 car_set, cdr_set;
 recurse:
#ifdef PIKE_TYPE_DEBUG
  if (l_flag > 2) {
    fprintf(stderr, "push_finished_type_with_markers((");
    simple_describe_type(type);
    fprintf(stderr, "),..., 0x%08x)...\n", marker_set);
  }
#endif /* PIKE_TYPE_DEBUG */
  if (!type) {
    push_type(PIKE_T_UNKNOWN);
    return;
  }
  /* We need to replace if there are any markers, or if there's a
   * non-masked assign.
   */
  if (!(type->flags & (~marker_set | PT_FLAG_MARKER) & PT_FLAG_MARK_ASSIGN)) {
    /* Nothing to replace in this subtree. */
#ifdef PIKE_TYPE_DEBUG
    if (l_flag > 2) {
      fprintf(stderr, "Nothing to replace in this subtree.\n");
      simple_describe_type(type);
      fprintf(stderr, "\n");
    }
#endif /* PIKE_TYPE_DEBUG */
    if ((marker_set & PT_FLAG_INT_ONLY) && !is_int_type(type)) {
      push_finished_type(int_type_string);
    } else {
      push_finished_type(type);
    }
    return;
  }
  if ((type->type >= '0') && (type->type <= '9')) {
    /* Marker. */
    unsigned int m = type->type - '0';
#ifdef PIKE_TYPE_DEBUG
    if ((l_flag > 2) && m) {
      fprintf(stderr, "Marker $%d: %p.\n", m, markers[m]);
    }
#endif /* PIKE_TYPE_DEBUG */
    if (markers[m]) {
      /* The marker has a value. */
      struct pike_type *type = dmalloc_touch(struct pike_type *, markers[m]);
#ifdef PIKE_TYPE_DEBUG
      if (l_flag > 2) {
	fprintf(stderr, "Marker value.\n");
      }
#endif
      /* FIXME: We probably ought to switch to the other marker set here. */
      markers[m] = NULL;
      push_finished_type_with_markers(type, markers,
				      marker_set & PT_FLAG_INT_ONLY);
      if (type->flags & (PT_FLAG_MARKER|PT_FLAG_ASSIGN)) {
	push_scope_type(0);
      }
      if (markers[m]) free_type(markers[m]);
      markers[m] = dmalloc_touch(struct pike_type *, type);
    } else {
	/* The marker has not been set. */
#ifdef PIKE_TYPE_DEBUG
      if (l_flag > 2) {
	fprintf(stderr, "No marker value.\n");
      }
#endif
    }
    if (marker_set & (PT_FLAG_MARKER_0 << m)) {
      /* The marker should be kept. */
#ifdef PIKE_TYPE_DEBUG
      if (l_flag > 2) {
	fprintf(stderr, "Keep marker.\n");
      }
#endif
      push_type(type->type);
      if (markers[m]) push_type(T_OR);
    } else if (!markers[m]) {
      push_type(PIKE_T_UNKNOWN);
    }
    TYPE_STACK_DEBUG("push_finished_type_with_markers");
    return;
  } else if (type->type == T_ASSIGN) {
    /* Assign. */
    int marker = PTR_TO_INT(type->car);
#ifdef PIKE_TYPE_DEBUG
    if (l_flag > 2) {
      fprintf(stderr, "Assign to marker $%"PRINTPTRDIFFT"d.\n",
	      CAR_TO_INT(type));
    }
#endif /* PIKE_TYPE_DEBUG */
    if (marker_set & (PT_FLAG_ASSIGN_0 << marker)) {
      /* The assignment should be kept as-is. */
#ifdef PIKE_TYPE_DEBUG
      if (l_flag > 2) {
	fprintf(stderr, "Keep assignment.\n");
      }
#endif /* PIKE_TYPE_DEBUG */
      /* Clear the flag. */
      push_finished_type_with_markers(type->cdr, markers,
				      marker_set &
				      ~(PT_FLAG_ASSIGN_0 << marker));
      push_assign_type('0' + marker);
      TYPE_STACK_DEBUG("push_finished_type_with_markers");
      return;
    } else {
#ifdef PIKE_TYPE_DEBUG
      if (l_flag > 2) {
	fprintf(stderr, "Strip assignment.\n");
      }
#endif /* PIKE_TYPE_DEBUG */
      type = type->cdr;
      goto recurse;
    }
  } else if (type->type == PIKE_T_NAME) {
    /* Strip the name, since it won't be correct anymore. */
    type = type->cdr;
    goto recurse;
  } else if (type->type == PIKE_T_ATTRIBUTE) {
    /* Keep the attribute. */
    push_finished_type_with_markers(type->cdr, markers, marker_set);
    push_type_attribute((struct pike_string *)type->car);
    goto done;
  } else if ((type->type & PIKE_T_MASK) == PIKE_T_OPERATOR) {
    push_finished_type_with_markers(type->car, markers, marker_set);
    if (type->type & 0x8000) {
      struct pike_type *t;
      type_stack_mark();
      push_finished_type_with_markers(type->cdr, markers, marker_set);
      t = pop_unfinished_type();
      push_type_operator(type->type, t);
      free_type(t);
    } else {
      push_type_operator(type->type, type->cdr);
    }
    goto done;
  } else if (type->type == PIKE_T_TRANSITIVE) {
    push_finished_type(type->cdr);
    push_finished_type_with_markers(type->car, markers, marker_set);
    push_type(PIKE_T_TRANSITIVE);
    goto done;
  }
  /* FIXME: T_SCOPE */

  if (type->car) {
    /* Keep markers for assigns in the car. */
    cdr_set = marker_set |
      ((type->car->flags & PT_FLAG_ASSIGN)>>PT_ASSIGN_SHIFT);
  } else {
    cdr_set = marker_set;
  }
  if (type->cdr) {
    /* Keep assigns for markers in the cdr. */
    car_set = marker_set |
      ((type->cdr->flags & PT_FLAG_MARKER)<<PT_ASSIGN_SHIFT);
  } else {
    car_set = marker_set;
  }

  if ((type->type == T_OR) || (type->type == T_AND)) {
    /* Special case handling for implicit zero. */
    /* FIXME: Probably ought to use {or,and}_pike_types() here.
     *        Problem is that they may mess with the markers...
     */

    type_stack_mark();
    /* We want to keep markers that have assigns in the car. */
    push_finished_type_with_markers(type->cdr, markers, cdr_set);
    if (type->type == T_OR) {
      struct pike_type *first = pop_type();
      struct pike_type *second;
      struct pike_type *res;
      push_finished_type_with_markers(type->car, markers, car_set);
      second = pop_unfinished_type();
      push_finished_type(res = or_pike_types(first, second, 1));
      free_type(second);
      free_type(first);
      free_type(res);
    } else if (peek_type_stack() == zero_type_string) {
      pop_stack_mark();
    } else {
      type_stack_mark();
      push_finished_type_with_markers(type->car, markers, car_set);
      if (peek_type_stack() == zero_type_string) {
	free_type(pop_unfinished_type());
	free_type(pop_unfinished_type());
	push_finished_type(zero_type_string);
      } else {
	pop_stack_mark();
	pop_stack_mark();
	push_type(T_AND);
      }
    }
  } else {
    /* Make sure to filter invalid nodes from the marker in case
     * it is a string type.
     */
    if (type->type == PIKE_T_STRING) cdr_set |= PT_FLAG_INT_ONLY;
    if (type->cdr) {
      /* In all other cases type->cdr will be a valid node if is not NULL. */
      push_finished_type_with_markers(type->cdr, markers, cdr_set);
    } else {
      switch(type->type) {
      case T_OR:
      case T_AND:
      case T_FUNCTION:
      case T_MANY:
      case T_TUPLE:
      case T_MAPPING:
      case PIKE_T_RING:
      case T_ARRAY:
      case T_STRING:
      case PIKE_T_TRANSITIVE:
	push_type(PIKE_T_UNKNOWN);
	break;
      }
    }
    if (type->car) {
      /* In all other cases type->car will be a valid node if it is not NULL. */
      push_finished_type_with_markers(type->car, markers, car_set);
    } else {
      switch(type->type) {
      case T_OR:
      case T_AND:
      case T_FUNCTION:
      case T_MANY:
      case T_TUPLE:
      case T_MAPPING:
      case PIKE_T_RING:
      case T_ARRAY:
      case T_STRING:
      case PIKE_T_TRANSITIVE:
      case T_PROGRAM:
      case T_MULTISET:
      case T_TYPE:
      case PIKE_T_AUTO:
      case T_NOT:
	push_type(PIKE_T_UNKNOWN);
	break;
      }
    }
    /* push_type has sufficient magic to recreate the type. */
    push_type(type->type);
  }
 done:
  TYPE_STACK_DEBUG("push_finished_type_with_markers");
}

static void push_type_field(TYPE_FIELD field)
{
  field &= (BIT_BASIC|BIT_COMPLEX);
  if (!field) {
    /* No values. */
    push_type(PIKE_T_UNKNOWN);
  } else if (field == (BIT_BASIC|BIT_COMPLEX)) {
    /* All values. */
    push_type(T_MIXED);
  } else {
    /* Check the bits... */
    push_type(PIKE_T_UNKNOWN);

    if (field & BIT_COMPLEX) {
      if (field & BIT_ARRAY) {
	push_type(T_MIXED);
	push_unlimited_array_type(T_ARRAY);
	push_type(T_OR);
      }
      if (field & BIT_MAPPING) {
	push_type(T_MIXED);
	push_type(T_MIXED);
	push_type(T_MAPPING);
	push_type(T_OR);
      }
      if (field & BIT_MULTISET) {
	push_type(T_MIXED);
	push_type(T_MULTISET);
	push_type(T_OR);
      }
      if (field & BIT_OBJECT) {
	push_object_type(0, 0);
	push_type(T_OR);
      }
      if (field & BIT_FUNCTION) {
	push_type(T_VOID);
	push_type(T_MIXED);
	push_type(T_OR);
	push_type(PIKE_T_UNKNOWN);
	push_type(T_MANY);
	push_type(T_OR);
      }
      if (field & BIT_PROGRAM) {
	push_object_type(0, 0);
	push_type(T_PROGRAM);
	push_type(T_OR);
      }
    }
    if (field & BIT_BASIC) {
      if (field & BIT_STRING) {
	push_int_type(MIN_INT32, MAX_INT32);
	push_unlimited_array_type(T_STRING);
	push_type(T_OR);
      }
      if (field & BIT_TYPE) {
	push_type(T_MIXED);
	push_type(T_TYPE);
	push_type(T_OR);
      }
      if (field & BIT_INT) {
	push_int_type(MIN_INT32, MAX_INT32);
	push_type(T_OR);
      }
      if (field & BIT_FLOAT) {
	push_type(T_FLOAT);
	push_type(T_OR);
      }
    }
  }
  TYPE_STACK_DEBUG("push_type_field");
}

INT32 extract_type_int(char *p)
{
  return get_unaligned_be32(p);
}

struct pike_type *debug_pop_unfinished_type(void)
{
  ptrdiff_t len;

  len = pop_stack_mark();

  if (len != 1) {
    Pike_fatal("pop_unfinished_type(): Unexpected len: %"PRINTPTRDIFFT"d\n", len);
  }

  TYPE_STACK_DEBUG("pop_unfinished_type");

  return low_pop_type();
}

/******/

static struct pike_string *internal_parse_type_string(const char **_s)
{
  const unsigned char **s = (const unsigned char **)_s;
  const unsigned char *p;
  struct string_builder tmp;
  while(isspace(**s)) ++*s;
  if(**s != '\"') yyerror("Expected '\"'.");
  else
    ++*s;
  init_string_builder(&tmp, 0);
  p = *s;
  while(1) {
    int c;
    do {
      c = *p++;
    } while ((c > '\\') || ((c != '\"') && (c != '\\') && (c != '\n')));
    string_builder_binary_strcat(&tmp, *_s, p - (1 + *s));
    if (c == '"') {
      *s = ++p;
      break;
    } else if (c == '\\') {
      p_wchar2 buf;
      ptrdiff_t len = 0;
      if (!parse_esc_seq0((p_wchar0 *)p, &buf, &len)) {
	string_builder_putchar(&tmp, buf);
	p += len;
      } else {
	yyerror("Invalid \\-escape.");
      }
    } else {
      yyerror("Expected '\"'.");
      break;
    }
    *s = p;
  }
  return finish_string_builder(&tmp);
}

static void internal_parse_typeA(const char **_s)
{
  char buf[80];
  unsigned int len;
  const unsigned char **s = (const unsigned char **)_s;

  while(isspace(**s)) ++*s;

  for(len=0;isidchar(EXTRACT_UCHAR(s[0]+len));len++)
  {
    if(len>=sizeof(buf)-1) {
      my_yyerror("Buffer overflow in parse_type(\"%s\") (limit %"PRINTSIZET"d).",
		 *s, sizeof(buf));
      push_type(T_MIXED);
      return;
    }
    buf[len] = s[0][len];
  }
  buf[len]=0;
  *s += len;

  switch(buf[0])
  {
    case 'z':
      if(!strcmp(buf,"zero")) { push_type(T_ZERO); break; }
      goto bad_type;

    case 'i':
      if(!strcmp(buf,"int"))
      {
	while(isspace(**s)) ++*s;
	if(**s=='(')
	{
	  INT32 min,max;
	  ++*s;
	  while(isspace(**s)) ++*s;
	  if (**s != '.') {
	    min=strtol((const char *)*s,(char **)s,0);
	    while(isspace(**s)) ++*s;
	  } else {
	    min = MIN_INT32;
	  }
	  if(s[0][0]=='.' && s[0][1]=='.')
	    s[0]+=2;
	  else {
	    yyerror("Missing .. in integer type.");
	  }

	  while(isspace(**s)) ++*s;
	  if (**s != ')') {
	    max=strtol((const char *)*s,(char **)s,0);
	    while(isspace(**s)) ++*s;
	  } else {
	    max = MAX_INT32;
	  }

	  if(**s != ')') yyerror("Missing ')' in integer range.");
	  else
	    ++*s;
	  push_int_type(min, max);
	}else{
	  push_int_type(MIN_INT32, MAX_INT32);
	}
	break;
      }
      goto bad_type;

    case 'f':
      if(!strcmp(buf,"function"))
      {
	while(isspace(**s)) ++*s;
	if(**s == '(')
	{
	  int nargs = 0;
	  ++*s;
	  while(isspace(**s)) ++*s;
	  while(1)
	  {
	    if(**s == ':')
	    {
	      push_type(T_VOID);
	      break;
	    }
	    internal_parse_type(_s);
	    if(**s==',')
	    {
	      nargs++;
	      ++*s;
	      while(isspace(**s)) ++*s;
	    }
	    else if(s[0][0]=='.' && s[0][1]=='.' && s[0][2]=='.')
	    {
	      *s+=3;
	      while(isspace(**s)) ++*s;
	      if(**s != ':') {
		yyerror("Missing ':' after ... in function type.");
		--*s;
	      }
	      break;
	    } else {
	      nargs++;
	    }
	  }
	  /* Skip the colon. */
	  ++*s;
	  internal_parse_type(_s);  /* return type */
	  push_reverse_type(T_MANY);

	  while (nargs-- > 0) {
	    push_reverse_type(T_FUNCTION);
	  }

	  if(**s != ')') yyerror("Missing ')' in function type.");
	  else
	    ++*s;
	}else{
	  push_type(T_VOID);
	  push_type(T_MIXED);
	  push_type(T_OR);
	  push_type(T_VOID);
	  push_type(T_ZERO);
	  push_type(T_OR);
	  push_type(T_MANY);
	}
	break;
      }
      if(!strcmp(buf,"float")) { push_type(T_FLOAT); break; }
      goto bad_type;

    case 'o':
      if(!strcmp(buf,"object"))
      {
	while(isspace(**s)) ++*s;
	if(**s == '(') /* object({,is,implements} {id,this_program}) */
	{
	  int is = 0, id;
	  ++*s;
	  while(isspace(**s)) ++*s;
	  if( **s != 'i' )
	    goto no_is_implements;
	  ++*s;
	  if( **s == 's' ) {
	    ++*s;
	    if (**s != ' ') {
	      goto bad_type;
	    }
	    is = 1;
	    ++*s;
	  } else {
	    if (strncmp((const char *)*s, "mplements ", 10)) {
	      goto bad_type;
	    }
	    *s += 10;
	  }
	  while(isspace(**s)) ++*s;
	no_is_implements:
	  if( !**s )
	    goto bad_type;
	  if (!strncmp((const char *)*s, "this_program", 12)) {
	    id = Pike_compiler->new_program->id;
	    *s += 12;
	  } else {
	    id = atoi( (const char *)*s );
	    while( **s >= '0' && **s <= '9' )
	      ++*s;
	  }
	  while(isspace(**s)) ++*s;
	  if( !**s || **s != ')' )
	    goto bad_type;
	  ++*s;
	  push_object_type(is, id);
	}
	else
	  push_object_type(0, 0);
	break;
      }
      goto bad_type;


    case 'p':
      if(!strcmp(buf,"program")) {
	push_object_type(0, 0);
	push_type(T_PROGRAM);
	break;
      }
      goto bad_type;


    case 's':
      if(!strcmp(buf,"string")) {
	while(isspace(**s)) ++*s;
	if(**s == '(')
	{
	  INT32 min,max;
	  ++*s;
	  while(isspace(**s)) ++*s;
	  if (**s != '.') {
	    min=strtol((const char *)*s,(char **)s,0);
	    while(isspace(**s)) ++*s;
	  } else {
	    min = MIN_INT32;
	  }
	  if(s[0][0]=='.' && s[0][1]=='.')
	    s[0]+=2;
	  else {
	    yyerror("Missing .. in integer type.");
	  }

	  while(isspace(**s)) ++*s;
	  if (**s != ')') {
	    max=strtol((const char *)*s,(char **)s,0);
	    while(isspace(**s)) ++*s;
	  } else {
	    max = MAX_INT32;
	  }
	  if(**s != ')') yyerror("Missing ')' in string width.");
	  else
	    ++*s;
	  push_int_type(min, max);
	} else {
	  push_finished_type(int_type_string);
	}
	push_unlimited_array_type(T_STRING);
	break;
      }
      goto bad_type;

    case 'v':
      if(!strcmp(buf,"void")) { push_type(T_VOID); break; }
      goto bad_type;

    case 't':
      if (!strcmp(buf,"tuple"))
      {
	while(isspace(**s)) ++*s;
	if(**s == '(')
	{
	  ++*s;
	  internal_parse_type(_s);
	  if(**s != ',') yyerror("Expected ','.");
	  else
	    ++*s;
	  internal_parse_type(_s);
	  if(**s != ')') yyerror("Expected ')'.");
	  else
	    ++*s;
	}else{
	  push_type(T_MIXED);
	  push_type(T_MIXED);
	}
	push_reverse_type(T_TUPLE);
	break;
      }
      /* FIXME: Handle type(T) */
      if(!strcmp(buf,"type")) { push_type(T_MIXED); push_type(T_TYPE); break; }
      goto bad_type;

    case 'm':
      if(!strcmp(buf,"mixed")) { push_type(T_MIXED); break; }
      if(!strcmp(buf,"mapping"))
      {
	while(isspace(**s)) ++*s;
	if(**s == '(')
	{
	  ++*s;
	  internal_parse_type(_s);
	  if(**s != ':') yyerror("Expected ':'.");
	  else
	    ++*s;
	  internal_parse_type(_s);
	  if(**s != ')') yyerror("Expected ')'.");
	  else
	    ++*s;
	}else{
	  push_type(T_MIXED);
	  push_type(T_MIXED);
	}
	push_reverse_type(T_MAPPING);
	break;
      }
      if(!strcmp(buf,"multiset"))
      {
	while(isspace(**s)) ++*s;
	if(**s == '(')
	{
	  ++*s;
	  internal_parse_type(_s);
	  if(**s != ')') yyerror("Expected ')'.");
	  else
	    ++*s;
	}else{
	  push_type(T_MIXED);
	}
	push_type(T_MULTISET);
	break;
      }
      goto bad_type;

    case 'u':
      if(!strcmp(buf,"unknown")) { push_type(PIKE_T_UNKNOWN); break; }
      goto bad_type;

    case 'a':
      if(!strcmp(buf,"array"))
      {
	while(isspace(**s)) ++*s;
	if(**s == '(')
	{
	  ++*s;
	  internal_parse_type(_s);
	  if(**s != ')') yyerror("Expected ')'.");
	  else
	    ++*s;
	}else{
	  push_type(T_MIXED);
	}
	push_unlimited_array_type(T_ARRAY);
	break;
      }
      goto bad_type;

    case '_':
      if (!strcmp(buf, "__attribute__")) {
	while(isspace(**s)) ++*s;
	if(**s == '(')
	{
	  struct pike_string *attr;
	  ++*s;
	  attr = internal_parse_type_string(_s);
	  while(isspace(**s)) ++*s;
	  if(**s != ',') yyerror("Expected ','.");
	  else
	    ++*s;
	  internal_parse_type(_s);
	  if(**s != ')') yyerror("Expected ')'.");
	  else
	    ++*s;
	  push_type_attribute(attr);
	  free_string(attr);
	}else{
	  push_type(T_MIXED);
	}
	break;
      } else if (!strcmp(buf, "__deprecated__")) {
	struct pike_string *deprecated_string;
	MAKE_CONST_STRING(deprecated_string, "deprecated");
	while(isspace(**s)) ++*s;
	if(**s == '(')
	{
	  ++*s;
	  internal_parse_type(_s);
	  if(**s != ')') yyerror("Expected ')'.");
	  else
	    ++*s;
	}else{
	  push_type(T_MIXED);
	}
	push_type_attribute(deprecated_string);
	break;
      }
      goto bad_type;

    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      if(atoi(buf)<10)
      {
	while(isspace(**s)) ++*s;
	if(**s=='=')
	{
	  ++*s;
	  internal_parse_type(_s);
	  push_assign_type(buf[0]);
	}else{
	  push_type(buf[0]);
	}
	break;
      }
      /* FALLTHRU */

    default:
  bad_type:
      push_type(T_MIXED);
      my_yyerror("Couldn't parse type. (%s).", buf);
  }

  while(isspace(**s)) ++*s;
}


static void internal_parse_typeB(const char **s)
{
  while(isspace(EXTRACT_UCHAR(*s))) ++*s;
  switch(**s)
  {
  case '!': case '~':
    ++*s;
    internal_parse_typeB(s);
    push_type(T_NOT);
    break;

  case '(':
    ++*s;
    internal_parse_type(s);
    while(isspace(EXTRACT_UCHAR(*s))) ++*s;
    if(**s != ')') {
      yyerror("Expected ')' in type.");
    }
    ++*s;
    break;

  default:

    internal_parse_typeA(s);
  }
}

static void internal_parse_typeCC(const char **s)
{
  internal_parse_typeB(s);

  while(isspace(EXTRACT_UCHAR(*s))) ++*s;

  while(**s == '*')
  {
    ++*s;
    while(isspace(EXTRACT_UCHAR(*s))) ++*s;
    push_unlimited_array_type(T_ARRAY);
  }
}

static void internal_parse_typeC(const char **s)
{
  internal_parse_typeCC(s);

  if(**s == '&')
  {
    ++*s;
    internal_parse_typeC(s);
    push_reverse_type(T_AND);
  }
}

static void internal_parse_type(const char **s)
{
  internal_parse_typeC(s);

  while(**s == '|')
  {
    ++*s;
    internal_parse_typeC(s);
    push_type(T_OR);
  }
}

/* This function is used when adding simul efuns so that
 * the types for the functions can be easily stored in strings.
 * It takes a string on the exact same format as Pike and returns a type
 * struct.
 */
struct pike_type *parse_type(const char *s)
{
  struct pike_type *ret;
#ifdef PIKE_DEBUG
  struct pike_type **ts=Pike_compiler->type_stackp;
  struct pike_type ***ptms=Pike_compiler->pike_type_mark_stackp;
#endif

  /* fprintf(stderr, "parse_type(\"%s\")...\n", s); */

  TYPE_STACK_DEBUG("parse_type");

  type_stack_mark();

  internal_parse_type(&s);

  if( *s )
    yyerror("Extra junk at end of type definition.");

  ret=pop_unfinished_type();

#ifdef PIKE_DEBUG
  if(ts!=Pike_compiler->type_stackp || ptms!=Pike_compiler->pike_type_mark_stackp)
    Pike_fatal("Type stack whacked in parse_type.\n");
#endif

  return ret;
}

void simple_describe_type(struct pike_type *s)
{
  safe_pike_fprintf(stderr, "%pT", s);
}

static void low_describe_int_range(struct string_builder *s,
				   struct pike_type *t)
{
  if (!t || (t == int_type_string)) return;
 loop:
  switch(t->type) {
  case T_ZERO:
    string_builder_strcat(s, "zero");
    break;
  case T_INT:
    {
      INT32 min=CAR_TO_INT(t);
      INT32 max=CDR_TO_INT(t);

      if (min == max) {
	string_builder_sprintf(s, "%ld", (long) min);
      } else if (!min && (max != MAX_INT32) && !(max & (max + 1))) {
	int j = 0;
	while (max) {
	  max >>= 1;
	  j++;
	}
	string_builder_sprintf(s, "%dbit", j);
      } else {
	if (min != MIN_INT32) {
	  string_builder_sprintf(s, "%ld..", (long)min);
	} else {
	  string_builder_strcat(s, "..");
	}
	if (max != MAX_INT32) {
	  string_builder_sprintf(s, "%ld", (long)max);
	}
      }
    }
    break;
  case T_ASSIGN:
    string_builder_sprintf(s, "$%td = (", CAR_TO_INT(t));
    low_describe_int_range(s, t->cdr);
    string_builder_strcat(s, ")");
    break;
  case T_OR:
    low_describe_int_range(s, t->car);
    string_builder_strcat(s, " | ");
    t = t->cdr;
    goto loop;
  default:
    low_describe_type(s, t);
    break;
  }
}

void low_describe_type(struct string_builder *s, struct pike_type *t)
{
#ifdef PIKE_DEBUG
  DECLARE_CYCLIC();
#endif
  fatal_check_c_stack(1024);
  if (!t) {
    string_builder_strcat(s, "__unknown__");
    return;
  }
#ifdef PIKE_DEBUG
  if (BEGIN_CYCLIC(s, t)) {
    Pike_fatal("Circular type!\n");
  }
  SET_CYCLIC_RET(1);
#endif
  switch(t->type)	/* NB: No masking here! */
  {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      string_builder_putchar(s, '$');
      string_builder_putchar(s, t->type);
      break;

    case T_ASSIGN:
      string_builder_sprintf(s, "($%d=%pT)", (int)CAR_TO_INT(t), t->cdr);
      break;

    case T_SCOPE:
      string_builder_sprintf(s, "scope(%d,%pT)", (int)CAR_TO_INT(t), t->cdr);
      break;

    case T_TUPLE:
      string_builder_sprintf(s, "[%pT,%pT]", t->car, t->cdr);
      break;

    case T_VOID: string_builder_strcat(s, "void"); break;
    case T_ZERO: string_builder_strcat(s, "zero"); break;
    case T_MIXED: string_builder_strcat(s, "mixed"); break;
    case PIKE_T_UNKNOWN: string_builder_strcat(s, "unknown"); break;

    case T_INT:
      string_builder_strcat(s, "int");

      if (t == int_type_string) break;

      string_builder_putchar(s, '(');
      low_describe_int_range(s, t);
      string_builder_putchar(s, ')');
      break;

    case T_FLOAT: string_builder_strcat(s, "float"); break;
    case T_PROGRAM:
      if ((t->car->type == T_OBJECT) &&
	  (!t->car->cdr)) {
	string_builder_strcat(s, "program");
      } else {
        string_builder_sprintf(s, "program(%pT)", t->car);
      }
      break;
    case T_OBJECT:
      if (t->cdr)
      {
	struct svalue sval;
	if (t->car) {
	  string_builder_strcat(s, "object(is ");
	} else {
	  string_builder_strcat(s, "object(implements ");
	}
	/* We need to save the global buffer, in case id_to_program()
	 * starts running Pike code. */
	sval.u.program = id_to_program(CDR_TO_INT(t));
	if (sval.u.program) {
	  SET_SVAL_TYPE(sval, T_PROGRAM);
	  SET_SVAL_SUBTYPE(sval, 0);
          string_builder_sprintf(s, "%pO)", &sval);
	} else {
	  string_builder_sprintf(s, "%"PRINTPTRDIFFT"d)", CDR_TO_INT(t));
	}
      }else{
	string_builder_strcat(s, "object");
      }
      break;

    case T_STRING:
      {
	string_builder_strcat(s, "string");
	if ((t->cdr == int_type_string) && (t->car == int_pos_type_string)) {
	  break;
	}
	string_builder_putchar(s, '(');
	if (t->car == zero_type_string) {
	  /* Zero-length string. */
	  string_builder_strcat(s, "zero:");
	} else {
	  if (t->car != int_pos_type_string) {
	    low_describe_int_range(s, t->car);
	    string_builder_strcat(s, ": ");
	  }
	  low_describe_int_range(s, t->cdr);
	}
	string_builder_putchar(s, ')');
	break;
      }
    case T_TYPE:
      string_builder_sprintf(s, "type(%pT)", t->car);
      break;

    case PIKE_T_NAME:
      string_builder_sprintf(s, "{ %pS = %pT }",
			     (struct pike_string *)t->car, t->cdr);
      break;

    case PIKE_T_ATTRIBUTE:
      {
	struct pike_string *deprecated;
	MAKE_CONST_STRING(deprecated, "deprecated");
	if (((struct pike_string *)t->car) == deprecated) {
          string_builder_sprintf(s, "__deprecated__(%pT)", t->cdr);
	} else if (t == utf8_type_string) {
	  string_builder_sprintf(s, "utf8_string");
	} else {
	  struct svalue sval;
	  SET_SVAL(sval, PIKE_T_STRING, 0, string,
		   (struct pike_string *)t->car);
          string_builder_sprintf(s, "__attribute__(%pO, %pT)", &sval, t->cdr);
	}
      }
      break;

    case T_FUNCTION:
    case T_MANY:
    {
      if(t->type == T_MANY &&
	 ((!t->cdr && !t->car) ||
	  (t->cdr && t->cdr->type == T_OR &&
	   ((t->cdr->car->type == T_MIXED && t->cdr->cdr->type == T_VOID) ||
	    (t->cdr->cdr->type == T_MIXED && t->cdr->car->type == T_VOID)) &&
	   (!t->car ||
	    t->car->type == T_ZERO ||
	    (t->car->type == T_OR &&
	     ((t->car->car->type == T_ZERO && t->car->cdr->type == T_VOID) ||
	      (t->car->cdr->type == T_ZERO && t->car->car->type == T_VOID)))))))
      {
	/* function == function(zero...:mixed|void) or
	 *             function(zero|void...:mixed|void)
	 */
	string_builder_strcat(s, "function");
	/* done */
	break;
      } else {
	int arg = 0;
	string_builder_strcat(s, "function(");
	while(t && (t->type == T_FUNCTION))
	{
	  if(arg++) string_builder_strcat(s, ", ");
	  low_describe_type(s, t->car);
	  t = t->cdr;
	}
	if (!t || (t->type != T_MANY)) {
          string_builder_sprintf(s, ", @%pT)", t);
	} else {
	  if(!t->car || (t->car->type != T_VOID))
	  {
	    if(arg++) string_builder_strcat(s, ", ");
	    if (t->car) low_describe_type(s, t->car);
	    string_builder_strcat(s, " ...");
	  }
	  t = t->cdr;
          string_builder_sprintf(s, " : %pT)", t);
	}
      }
      break;
    }

    case T_ARRAY:
      string_builder_strcat(s, "array");
      if ((t->cdr == mixed_type_string) && (t->car == int_pos_type_string)) {
	break;
      }
      string_builder_putchar(s, '(');
      if (t->car == zero_type_string) {
	/* Zero-length array. */
	string_builder_strcat(s, "zero:");
      } else {
	if (t->car != int_pos_type_string) {
	  low_describe_int_range(s, t->car);
	  string_builder_putchar(s, ':');
	  if (t->cdr != mixed_type_string) {
	    string_builder_putchar(s, ' ');
	  }
	}
	if (t->cdr != mixed_type_string) {
          string_builder_sprintf(s, "%pT", t->cdr);
	}
      }
      string_builder_putchar(s, ')');
      break;

    case T_MULTISET:
      if(t->car != mixed_type_string) {
        string_builder_sprintf(s, "multiset(%pT)", t->car);
      } else {
	string_builder_strcat(s, "multiset");
      }
      break;

    case T_NOT:
      if (t->car && (t->car->type > T_NOT)) {
        string_builder_sprintf(s, "~(%pT)", t->car);
      } else {
        string_builder_sprintf(s, "~%pT", t->car);
      }
      break;

    case PIKE_T_RING:
      /* FIXME: Should be renumbered for correct parenthesing. */
      string_builder_sprintf(s, "(%pT)\260(%pT)", t->car, t->cdr);
      break;

    case T_OR:
      if (t->car && (t->car->type > T_OR)) {
        string_builder_sprintf(s, "(%pT)", t->car);
      } else {
	low_describe_type(s, t->car);
      }
      string_builder_strcat(s, " | ");
      if (t->cdr && (t->cdr->type > T_OR)) {
        string_builder_sprintf(s, "(%pT)", t->cdr);
      } else {
	low_describe_type(s, t->cdr);
      }
      break;

    case T_AND:
      if (t->car && (t->car->type > T_AND)) {
        string_builder_sprintf(s, "(%pT)", t->car);
      } else {
	low_describe_type(s, t->car);
      }
      string_builder_strcat(s, " & ");
      if (t->cdr && (t->cdr->type > T_AND)) {
        string_builder_sprintf(s, "(%pT)", t->cdr);
      } else {
	low_describe_type(s, t->cdr);
      }
      break;

    case T_MAPPING:
      if ((t->car != mixed_type_string) || (t->cdr != mixed_type_string)) {
        string_builder_sprintf(s, "mapping(%pT:%pT)", t->car, t->cdr);
      } else {
	string_builder_strcat(s, "mapping");
      }
      break;

    case PIKE_T_AUTO:
      if (t->car && (t->car->type != T_ZERO)) {
        string_builder_sprintf(s, "auto(%pT)", t->car);
      } else {
	string_builder_strcat(s, "auto");
      }
      break;

    case PIKE_T_FIND_LFUN:
      string_builder_sprintf(s, "find_lfun(%pT, %pq)",
			     t->car, lfun_strings[CDR_TO_INT(t)]);
      break;

    case PIKE_T_TRANSITIVE:
      string_builder_sprintf(s, "transitive(%pT, %pT)", t->car, t->cdr);
      break;

    default:
      {
	if ((t->type & PIKE_T_MASK) == PIKE_T_OPERATOR) {
	  switch(t->type) {
	  case PIKE_T_GET_RETURN:
	    string_builder_strcat(s, "get_return");
	    break;
	  case PIKE_T_THRESHOLD:
	    string_builder_strcat(s, "threshold");
	    break;
	  case PIKE_T_SET_CAR:
	    string_builder_strcat(s, "set_car");
	    break;
	  case PIKE_T_SET_CDR:
	    string_builder_strcat(s, "set_cdr");
	    break;
	  default:
	    string_builder_sprintf(s, "operator(0x%04x)", t->type);
	    break;
	  }
          string_builder_sprintf(s, "(%pT", t->car);
	  if (t->type & 0x8000) {
            string_builder_sprintf(s, ",%pT)", t->cdr);
	  } else if (t->cdr) {
	    string_builder_sprintf(s, ",0x%08tx)", CDR_TO_INT(t));
	  } else {
	    string_builder_strcat(s, ")");
	  }
	} else {
	  string_builder_sprintf(s, "unknown code(%d)", t->type);
	}
	break;
      }
  }
#ifdef PIKE_DEBUG
  END_CYCLIC();
#endif
}

struct pike_string *describe_type(struct pike_type *type)
{
  struct string_builder s;
  ONERROR err;
  init_string_builder(&s, 0);
  SET_ONERROR(err, free_string_builder, &s);
  low_describe_type(&s, type);
  UNSET_ONERROR(err);
  return finish_string_builder(&s);
}


/******/

static TYPE_T low_compile_type_to_runtime_type(struct pike_type *t)
{
  switch(t?t->type:PIKE_T_UNKNOWN)	/* Note: No masking here. */
  {
  case PIKE_T_RING:
  case PIKE_T_SET_CAR:
  case PIKE_T_SET_CDR:
    return low_compile_type_to_runtime_type(t->car);

  case T_OR:
    {
      TYPE_T car_t = low_compile_type_to_runtime_type(t->car);
      TYPE_T cdr_t = low_compile_type_to_runtime_type(t->cdr);
      if (car_t == cdr_t)
	return car_t;
      if (car_t == PIKE_T_VOID) {
	car_t = PIKE_T_ZERO;
      }
      if (cdr_t == PIKE_T_VOID) {
	cdr_t = PIKE_T_ZERO;
      }
      if ((car_t == PIKE_T_ZERO) && (cdr_t != PIKE_T_FLOAT)) {
	return cdr_t;
      }
      if ((cdr_t == PIKE_T_ZERO) && (car_t != PIKE_T_FLOAT)) {
	return car_t;
      }
    }
    /* FALLTHRU */

  case T_TUPLE:
    /* FIXME: Shouldn't occur/should be converted to array? */
    /* FALLTHRU */
  default:
    return T_MIXED;

  case T_SCOPE:
  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
    return low_compile_type_to_runtime_type(t->cdr);

  case T_MANY:
  case PIKE_T_FIND_LFUN:
    return T_FUNCTION;

  case T_ARRAY:
  case T_MAPPING:
  case T_MULTISET:

  case T_OBJECT:
  case T_PROGRAM:
  case T_FUNCTION:

  case T_STRING:
  case T_TYPE:
  case T_INT:
  case T_FLOAT:
  case T_ZERO:
  case T_VOID:
    return t->type;
  }
}

TYPE_T compile_type_to_runtime_type(struct pike_type *t)
{
  TYPE_T ret = low_compile_type_to_runtime_type(t);

  if ((ret == PIKE_T_ZERO) || (ret == PIKE_T_VOID)) {
    return PIKE_T_INT;
  }
  return ret;
}

/**
 * Check whether a type is for a __deprecated__ value.
 *
 * @param t
 *   Type to check.
 */
int deprecated_typep(struct pike_type *t)
{
  struct pike_string *deprecated_string;
  MAKE_CONST_STRING(deprecated_string, "deprecated");

  while (t) {
    switch(t->type & PIKE_T_MASK) {
    case PIKE_T_ATTRIBUTE:
      if (((struct pike_string*)t->car) == deprecated_string) {
	return 1;
      }
      /* FALLTHRU */
    case PIKE_T_SCOPE:
    case T_ASSIGN:
    case PIKE_T_NAME:
      t = t->cdr;
      continue;
    case PIKE_T_OPERATOR:
    case PIKE_T_TRANSITIVE:
      t = t->car;
      continue;
    }
    break;
  }
  return 0;
}

/**
 * Get the range for an integer type.
 *
 * @param t
 *   Integer type to check.
 *
 * @param range
 *   Array of two elements (min, max) before calling the
 *   function, the array should be initialized to (max, min).
 *
 * Returns 1 if t contained an integer type. This also implies
 * that range has been updated accordingly.
 *
 * Returns 0 if t did not contain any integer type. The range
 * array will be left unmodified in this case.
 */
int get_int_type_range(struct pike_type *t, INT_TYPE *range)
{
  int ret = 0;
 loop:
  switch(t?t->type:PIKE_T_UNKNOWN) {
  case T_INT:
    {
      INT_TYPE min = CAR_TO_INT(t);
      INT_TYPE max = CDR_TO_INT(t);
      if (range[0] > min) range[0] = min;
      if (range[1] < max) range[1] = max;
      return 1;
    }
    break;
  case T_ZERO:
  case T_VOID:
    if (range[0] > 0) range[0] = 0;
    if (range[1] < 0) range[1] = 0;
    return 1;
  case T_SCOPE:
  case T_ASSIGN:
  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
    t = t->cdr;
    goto loop;
  case T_OR:
  case T_AND:
    ret = ret | get_int_type_range(t->car, range);
    t = t->cdr;
    goto loop;
  case T_MIXED:
    t = int_type_string;
    goto loop;
  default:
    break;
  }
  return ret;
}

static void low_or_pike_types(struct pike_type *t1,
			      struct pike_type *t2,
			      int zero_implied);

/* Push either t1, t2 or the OR of t1 and t2.
 * Returns -1 if t1 was pushed.
 *          0 if the OR was pushed. (Successful join)
 *          1 if t2 was pushed.
 *
 * zero_implied: One of:
 *          0 the zero type (if any) must be explicit in the result.
 *          1 the zero type is implicit.
 *          2 zero is explicit and integers are regarded as masks (cf enums).
 *          3 zero is implicit and integers are regarded as masks (cf enums).
 */
static int lower_or_pike_types(struct pike_type *t1,
			       struct pike_type *t2,
			       int zero_implied,
			       int elem_on_stack)
{
  int ret = 0;
  struct pike_type *t = NULL;
  struct pike_type *top = NULL;
#if 0
  fprintf(stderr, "    lower_or_pike_types(");
  simple_describe_type(t1);
  fprintf(stderr, ", ");
  simple_describe_type(t2);
  fprintf(stderr, ")\n");
#endif
  if (t1 == t2) {
    t = t1;
  } else if (!t1) {
    t = t2;
    ret = 1;
  } else if (!t2) {
    t = t1;
    ret = -1;
  } else if ((zero_implied & 1) && (t1->type == T_ZERO)) {
    t = t2;
  } else if ((zero_implied & 1) && (t2->type == T_ZERO)) {
    t = t1;
  } else if ((t1->type == T_NOT) && pike_types_le(t1->car, t2, 0, 0)) {
    t = mixed_type_string;
  } else if ((t2->type == T_NOT) && pike_types_le(t2->car, t1, 0, 0)) {
    t = mixed_type_string;
  } else if ((t1->type ^ '0') < (t2->type ^ '0')) {
    /* Note: Adjusted order to get markers first. */
    t = t1;
    ret = -1;
  } else if ((t1->type ^ '0') > (t2->type ^ '0')) {
    /* Note: Adjusted order to get markers first. */
    t = t2;
    ret = 1;
  } else {
#ifdef PIKE_DEBUG
    if (t1->type != t2->type) {
      Pike_fatal("Lost track of types t1->type: %d, t2->type: %d\n",
		 t1->type, t2->type);
    }
#endif /* PIKE_DEBUG */
    switch(t1->type) {
    case T_INT:
      if (CAR_TO_INT(t1) < CAR_TO_INT(t2)) {
	t = t1;
	ret = -1;
      } else {
	t = t2;
	ret = 1;
      }
      break;
    case T_STRING:
      {
	low_or_pike_types(t1->cdr, t2->cdr, 0);
	push_unlimited_array_type(T_STRING);
	return 0;
      }
      break;
    case T_OBJECT:
      if (!CDR_TO_INT(t1)) {
	t = t1;
      } else if (!CDR_TO_INT(t2)) {
	t = t2;
      } else if (CDR_TO_INT(t1) < CDR_TO_INT(t2)) {
	t = t1;
	ret = -1;
      } else {
	t = t2;
	ret = 1;
      }
      break;
    case T_MAPPING:
      if (!t1->car) {
	t = t1;
	ret = -1;
	break;
      }
      if (!t2->car) {
	t = t2;
	ret = 1;
	break;
      }
      if (t1->car->type < t2->car->type) {
	t = t1;
	ret = -1;
	break;
      }
      if (t1->car->type > t2->car->type) {
	t = t2;
	ret = 1;
	break;
      }
      if (!t1->cdr) {
	t = t1;
	ret = -1;
	break;
      }
      if (!t2->cdr) {
	t = t2;
	ret = 1;
	break;
      }
      if (t1->cdr->type < t2->cdr->type) {
	t = t1;
	ret = -1;
	break;
      }
      if (t1->cdr->type > t2->cdr->type) {
	t = t2;
	ret = 1;
	break;
      }
      t = t1;
      ret = -1;
      break;
    case T_ARRAY:
      if (!t1->cdr) {
	if (!t2->cdr) {
	  /* Probably not reached as t1 and t2 ought to be equal. */
	  t = t1;
	  ret = 0;
	  break;
	}
	t = t1;
	ret = -1;
	break;
      }
      if (!t2->cdr) {
	t = t2;
	ret = 1;
	break;
      }
      if (t1->cdr->type < t2->cdr->type) {
	t = t1;
	ret = -1;
	break;
      } else if (t1->cdr->type > t2->cdr->type) {
	t = t2;
	ret = 1;
	break;
      }
      if (t1 < t2) {
	t = t1;
	ret = -1;
      } else {
	t = t2;
	ret = 1;
      }
      break;
    case T_MULTISET:
      if (!t1->car) {
	if (!t2->car) {
	  t = t1;
	  ret = 0;
	  break;
	}
	t = t1;
	ret = -1;
	break;
      }
      if (!t2->car) {
	t = t2;
	ret = 1;
	break;
      }
      if (t1->car->type < t2->car->type) {
	t = t1;
	ret = -1;
	break;
      } else if (t1->car->type > t2->car->type) {
	t = t2;
	ret = 1;
	break;
      }
      /* FALLTHRU */
    default:
#if 0
      if (pike_types_le(t1, t2, 0, 0)) {
	t = t2;
      } else if (pike_types_le(t2, t1, 0, 0)) {
	t = t1;
      } else
#endif /* 0 */
	if (t1 < t2) {
	t = t1;
	ret = -1;
      } else {
	t = t2;
	ret = 1;
      }
      break;
    }
  }
  if (!elem_on_stack) {
    if (t) {
      push_finished_type(t);
    } else {
      push_type(PIKE_T_UNKNOWN);
    }
  } else if (!t) {
    /* No need to do anything. */
  } else if ((top = peek_type_stack())->type != t->type) {
    if ((zero_implied & 1) && (top->type == T_ZERO)) {
      Pike_compiler->type_stackp--;
      free_type(top);
      push_finished_type(t);
    } else if ((zero_implied & 1) && (t->type == T_ZERO)) {
      /* The zero is implied. */
    } else {
      push_finished_type(t);
    }
  } else if (t == top) {
    /* No need to do anything. */
  } else {
    switch(t?t->type:PIKE_T_UNKNOWN) {
    case T_FLOAT:
    case T_MIXED:
    case T_VOID:
    case T_ZERO:
      /* There can only be one. */
      break;
    case T_INT:
      {
	INT32 min1 = CAR_TO_INT(t);
	INT32 max1 = CDR_TO_INT(t);
	INT32 min2 = CAR_TO_INT(top);
	INT32 max2 = CDR_TO_INT(top);

	if (zero_implied & 1) {
	  if (min1 == 1) min1 = 0;
	  if (min2 == 1) min2 = 0;
	  if (max1 == -1) max1 = 0;
	  if (max2 == -1) max2 = 0;
	}

	if (zero_implied & 2) {
	  /* Or between integer masks.
	   * This is a bit more lenient than the default further below,
	   * and is used for generating the type for enums.
	   */

	  /* Ensure that zero is always in the range.
	   * This also ensures that there'll be an overlap.
	   */
	  if (max1 < 0) max1 = 0;
	  if (max2 < 0) max2 = 0;
	  if (min1 > 0) min1 = 0;
	  if (min2 > 0) min2 = 0;

	  /* Both max values are now >= 0, so this or is safe. */
	  max1 |= max2;

	  if ((min1 < 0) && (min2 < 0)) {
	    min1 &= min2;
	  }
	}

	if ((max2 < MAX_INT32) && (min1 > max2 + 1)) {
	  /* No overlap. */
	  push_finished_type(t);
#ifdef PIKE_DEBUG
	} else if ((max1 < MAX_INT32) && (min2 > max1 + 1)) {
	  /* No overlap and wrong order! */
	  Pike_fatal("Bad integer ordering in lower_or_pike_types().\n");
#endif
	} else {
	  Pike_compiler->type_stackp--;
	  free_type(top);
	  /* Overlap */
	  min1 = MINIMUM(min1, min2);
	  max1 = MAXIMUM(max1, max2);

	  push_int_type(min1, max1);
	}
      }
      break;
    case T_STRING:
      {
	Pike_compiler->type_stackp--;
	low_or_pike_types(t->cdr, top->cdr, 1);
	push_unlimited_array_type(T_STRING);
	free_type(top);
      }
      break;
    case T_OBJECT:
      if (CDR_TO_INT(top)) {
	push_finished_type(t);
      }
      break;
    case T_ARRAY:
      Pike_compiler->type_stackp--;
      low_or_pike_types(t->cdr, top->cdr, zero_implied);
      push_unlimited_array_type(t->type);
      free_type(top);
      break;
    case T_MULTISET:
      Pike_compiler->type_stackp--;
      low_or_pike_types(t->car, top->car, zero_implied);
      push_type(t->type);
      free_type(top);
      break;
    case T_MAPPING:
      if (t->car == top->car) {
	Pike_compiler->type_stackp--;
	push_finished_type(t->car);
	low_or_pike_types(t->cdr, top->cdr, zero_implied);
	push_reverse_type(T_MAPPING);
	free_type(top);
	break;
      } else if (t->cdr == top->cdr) {
	Pike_compiler->type_stackp--;
	push_finished_type(t->cdr);
	low_or_pike_types(t->car, top->car, zero_implied);
	push_type(T_MAPPING);
	free_type(top);
	break;
      }
      /* FALLTHRU */
    default:
      if (t < top) {
	Pike_compiler->type_stackp--;
	push_finished_type(t);
	push_finished_type(top);
	free_type(top);
      } else {
	push_finished_type(t);
      }
      break;
    }
  }
  return ret;
}

static void low_or_pike_types(struct pike_type *t1,
			      struct pike_type *t2,
			      int zero_implied)
{
#ifdef PIKE_DEBUG
  struct pike_type *arg1 = t1;
  struct pike_type *arg2 = t2;
#endif
  fatal_check_c_stack(1024);
#if 0
  fprintf(stderr, "  low_or_pike_types(");
  simple_describe_type(t1);
  fprintf(stderr, ", ");
  simple_describe_type(t2);
  fprintf(stderr, ")\n");
#endif
  if(!t1)
  {
    push_finished_type(t2);
  }
  else if((!t2) ||
	  ((t2->type == T_ZERO) &&
	   ((zero_implied & 1) || (t1->flags & PT_FLAG_NULLABLE)))) {
    push_finished_type(t1);
  }
  else if ((t1->type == T_ZERO) &&
	   ((zero_implied & 1) || (t2->flags & PT_FLAG_NULLABLE))) {
    push_finished_type(t2);
  }
  else if (t1 == t2) {
    push_finished_type(t1);
  }
  else if ((t1->flags & (PT_FLAG_MIXED|PT_FLAG_VOIDABLE)) ==
	   (PT_FLAG_MIXED|PT_FLAG_VOIDABLE)) {
    push_finished_type(t1);
  }
  else if ((t2->flags & (PT_FLAG_MIXED|PT_FLAG_VOIDABLE)) ==
	   (PT_FLAG_MIXED|PT_FLAG_VOIDABLE)) {
    push_finished_type(t2);
  }
  else if ((t1->type == T_MIXED) && (t2->type != T_VOID)) {
    push_finished_type(t1);
    if (t2->flags & PT_FLAG_VOIDABLE) {
      push_type(T_VOID);
      push_type(T_OR);
    }
  } else if ((t2->type == T_MIXED) && (t1->type != T_VOID)) {
    push_finished_type(t2);
    if (t1->flags & PT_FLAG_VOIDABLE) {
      push_type(T_VOID);
      push_type(T_OR);
    }
  }
  else if ((t1->type == T_OR) || (t2->type == T_OR)) {
    int on_stack = 0;
    type_stack_mark();
    while (t1 || t2) {
      struct pike_type *a = t1;
      struct pike_type *b = t2;
      struct pike_type *n1 = NULL;
      struct pike_type *n2 = NULL;
      int val;
      if (t1 && t1->type == T_OR) {
	a = t1->car;
	n1 = t1->cdr;
      }
      if (t2 && t2->type == T_OR) {
	b = t2->car;
	n2 = t2->cdr;
      }
#ifdef PIKE_DEBUG
      if (a && b && ((a->type == T_OR) || (b->type == T_OR))) {
	fprintf(stderr, "  low_or_pike_types(");
	simple_describe_type(arg1);
	fprintf(stderr, ", ");
	simple_describe_type(arg2);
	fprintf(stderr, ")\n  a:");
	simple_describe_type(a);
	fprintf(stderr, "\n  b:");
	simple_describe_type(b);
	fprintf(stderr, ")\n");
	Pike_fatal("Invalid type to lower_or_pike_types!\n");
      }
#endif
      val = lower_or_pike_types(a, b, zero_implied, on_stack);
      if (val <= 0) t1 = n1;
      if (val >= 0) t2 = n2;
      on_stack = 1;
    }
    on_stack = pop_stack_mark();
    while (on_stack > 1) {
      push_reverse_joiner_type(T_OR);
      on_stack--;
    }
  }
  else {
    int val;
    type_stack_mark();
    val = lower_or_pike_types(t1, t2, zero_implied, 0);
    if (val < 0) {
      lower_or_pike_types(NULL, t2, zero_implied, 1);
    } else if (val > 0) {
      lower_or_pike_types(t1, NULL, zero_implied, 1);
    } else {
      pop_stack_mark();
      return;
    }
    for (val = pop_stack_mark(); val > 1; val--) {
      push_reverse_joiner_type(T_OR);
    }
  }
}

struct pike_type *or_pike_types(struct pike_type *a,
				struct pike_type *b,
				int zero_implied)
{
  struct pike_type *res;
  type_stack_mark();
  low_or_pike_types(a, b, zero_implied);
  res = pop_unfinished_type();
#if 0
  fprintf(stderr, "  ==> ");
  simple_describe_type(res);
  fprintf(stderr, "\n");
#endif
  return res;
}

struct pike_type *and_pike_types(struct pike_type *a,
				 struct pike_type *b)
{
  return type_binop(PT_BINOP_AND, a, b, 0, 0, 0);
}

static struct pike_type *low_object_lfun_type(struct pike_type *t, short lfun)
{
  struct program *p;
  int i;
  while ((t->type == PIKE_T_NAME) || (t->type == PIKE_T_ATTRIBUTE)) {
    t = t->cdr;
  }
#ifdef PIKE_DEBUG
  if (t->type != T_OBJECT) {
    fprintf(stderr, "Invalid type to low_object_lfun_type(");
    simple_describe_type(t);
    fprintf(stderr, ", \"%s\")\n", lfun_names[lfun]);
    Pike_fatal("Invalid type to low_object_lfun_type: %d (expected OBJECT).\n",
	       t->type);
  }
#endif /* PIKE_DEBUG */
  p = id_to_program(CDR_TO_INT(t));
  if(!p) return 0;
  i=FIND_LFUN(p, lfun);
  if(i==-1) return 0;
  return ID_FROM_INT(p, i)->type;
}

/**
 * This function differs from low_object_lfun_type() above in
 * that it handles more cases, falls back to the default lfun
 * type (with a warning), and adds a reference to the returned
 * type.
 */
static struct pike_type *find_lfun_type(struct pike_type *t, int lfun)
{
  struct pike_type *ret = NULL;
  struct pike_type *tmp;

 loop:
  if (!t) return NULL;

  switch(t->type) {
  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
    t = t->cdr;
    goto loop;

  case T_OBJECT:
    {
      struct program *p = NULL;
      if (t->cdr) {
	p = id_to_program(CDR_TO_INT(t));
      }
      if (p) {
	int f = FIND_LFUN(p, lfun);

	if (f != -1) {
	  struct identifier *id = ID_FROM_INT(p, f);
	  ret = id->type;
	  add_ref(ret);
	  return ret;
	}
#if 0
	ref_push_string(lfun_strings[lfun]);
	yytype_report(REPORT_WARNING, NULL, 0, NULL,
		      NULL, 0, t,
		      1, "Expected object implementing lfun::%s().");
#endif
	return NULL;
      }
      break;
    }
  case T_PROGRAM:
    t = t->car;
    goto loop;

  case T_FUNCTION:
  case T_MANY:
    t = t->cdr;
    goto loop;

  case T_OR:
  case T_AND:
    ret = find_lfun_type(t->car, lfun);
    tmp = find_lfun_type(t->cdr, lfun);
    if (!ret) {
      if (!tmp) return NULL;
      if (t->type == T_AND) {
	free_type(tmp);
      } else {
	ret = tmp;
      }
    } else if (tmp) {
      type_stack_mark();
      push_finished_type(ret);
      free_type(ret);
      push_finished_type(tmp);
      free_type(tmp);
      push_type(t->type);
      return pop_unfinished_type();
    }
    return ret;

  case T_MIXED:
    break;

  case T_ZERO:
  case T_VOID:
  default:
    return NULL;
  }

#if 0
  {
    /* FIXME: This does not work, as lfun_types contains narrow types
     *        (zero for arguments, etc), while we here want the wide type
     *        (mixed for arguments, etc).
     */
    struct svalue *s;
    s = low_mapping_string_lookup(lfun_types, lfun_strings[lfun]);

#ifdef PIKE_DEBUG
    if (!s) {
      Pike_fatal("Unknown lfun: %s\n", STR0(lfun_strings[lfun]));
    }
#endif

    if (TYPEOF(*s) == PIKE_T_TYPE) {
      ret = s->u.type;
      add_ref(ret);
      return ret;
    }
  }

  return NULL;
#else
  add_ref(function_type_string);
  return function_type_string;
#endif
}



/******/

struct remap_state {
  unsigned char map[0x40];
  unsigned INT32 allocated;
  struct mapping *markers[2];
  struct mapping *state;
};

#ifdef PIKE_NULL_IS_SPECIAL
#define INIT_REMAP_STATE(REMAP) do {			\
    memset(&REMAP, 0, sizeof(struct remap_state));	\
    REMAP.markers[0] = NULL;				\
    REMAP.markers[1] = NULL;				\
    REMAP.state = NULL;					\
  } while(0)
#else
#define INIT_REMAP_STATE(REMAP) do {			\
    memset(&REMAP, 0, sizeof(struct remap_state));	\
  } while(0)
#endif
static inline void exit_remap_state(struct remap_state *remap)
{
  if (remap && remap->markers[0]) {
    free_mapping(remap->markers[0]);
    remap->markers[0] = NULL;
  }
  if (remap && remap->markers[1]) {
    free_mapping(remap->markers[1]);
    remap->markers[1] = NULL;
  }
  if (remap && remap->state) {
    free_mapping(remap->state);
    remap->state = NULL;
  }
}
#define EXIT_REMAP_STATE(REMAP) exit_remap_state(&REMAP)

#ifdef PIKE_DEBUG
static void simple_describe_remap_state(struct remap_state *remap)
{
  int i;
  if (!remap) {
    fprintf(stderr, "remap: NULL\n");
    return;
  }
  fprintf(stderr, "remap:\n");
  for(i = 0; i < 0x40; i++) {
    if (remap->map[i]) {
      fprintf(stderr, "$%c%d ==> $%d\n",
	      (i & 0x20)?((i & 0x10)?'d':'c'):((i & 0x10)?'b':'a'),
	      i & 0xf, remap->map[i] & 0xf);
    }
  }
  if (remap->markers[0]) {
    fprintf(stderr, "markers[0]:\n");
    simple_describe_mapping(remap->markers[0]);
  }
  if (remap->markers[1]) {
    fprintf(stderr, "markers[1]:\n");
    simple_describe_mapping(remap->markers[1]);
  }
  if (remap->state) {
    fprintf(stderr, "state:\n");
    simple_describe_mapping(remap->state);
  }
}
#else
#define simple_describe_remap_state(X)	do { (X); } while(0)
#endif

static int alloc_remap_marker(struct remap_state *remap, int marker,
			      enum pt_remap_flags flags)
{
  int ret;

  marker = marker & 0x0f;

  if (!remap || (flags & PT_FLAG_REMAP_INHIBIT)) return '0' | marker;

  if (flags & PT_FLAG_REMAP_SWAP_MARKERS) marker |= 0x10;
  if (flags & PT_FLAG_REMAP_ALTERNATE) marker |= 0x20;

  if ((ret = remap->map[marker])) return ret;

  for (ret = 0; ret < 10; ret++) {
    if (!(remap->allocated & (1 << ret))) {
      remap->allocated |= (1 << ret);
      ret |= '0';
      remap->map[marker] = ret;
      return ret;
    }
  }

  return 0;
}

static int remap_marker(struct remap_state *remap, int marker,
			enum pt_remap_flags flags)
{
  int ret;

  marker = marker & 0x0f;

  if (!remap || (flags & PT_FLAG_REMAP_INHIBIT)) return '0' | marker;

  if (flags & PT_FLAG_REMAP_SWAP_MARKERS) marker |= 0x10;
  if (flags & PT_FLAG_REMAP_ALTERNATE) marker |= 0x20;

  if ((ret = remap->map[marker])) return ret;

  for (ret = 0; ret < 10; ret++) {
    if (!(remap->allocated & (1 << ret))) {
      remap->allocated |= (1 << ret);
      ret |= '0';
      remap->map[marker] = ret;
      return ret;
    }
  }

  return 0;
}

static void free_marker(struct remap_state *remap, int marker,
			enum pt_remap_flags flags)
{
  int m;

  if (!remap || (flags & PT_FLAG_REMAP_INHIBIT)) return;

  marker &= 0x0f;

  if (flags & PT_FLAG_REMAP_SWAP_MARKERS) marker |= 0x10;
  if (flags & PT_FLAG_REMAP_ALTERNATE) marker |= 0x20;

  if (!(m = remap->map[marker])) return;

  remap->map[marker] = 0;
  remap->allocated &= ~(1 << (m & 0x0f));
}

static int lookup_marker(struct remap_state *remap, int marker,
			 enum pt_remap_flags flags,
			 struct pike_type **result_type)
{
  struct svalue key, *val = NULL;
  int marker_set = !!(flags & PT_FLAG_REMAP_SWAP_MARKERS);

  if (!remap || !remap->markers[marker_set] || !marker) {
    return 0;
  }

  SET_SVAL(key, T_INT, NUMBER_NUMBER, integer, marker);

  val = low_mapping_lookup(remap->markers[marker_set], &key);
  if (!val) return 0;

  if ((TYPEOF(*val) == PIKE_T_TYPE) && val->u.type) {
    add_ref(val->u.type);
    *result_type = val->u.type;
  } else {
    *result_type = NULL;
  }
  return 1;
}
#define lookup_marker(REMAP, M, F, RES) (lookup_marker(REMAP, M, F, RES)?(debug_malloc_pass(*(RES)),1):0)

static void store_marker(struct remap_state *remap, int marker,
			 struct pike_type *value, enum pt_remap_flags flags)
{
  struct svalue key, val, *old;
  struct pike_type *both = NULL;
  int marker_set = !!(flags & PT_FLAG_REMAP_SWAP_MARKERS);

  if (!remap || !marker) return;

  if (flags & PT_FLAG_REMAP_NO_STORE_MARKERS) return;

  if (!remap->markers[marker_set]) {
    remap->markers[marker_set] = allocate_mapping(10);
  }

  SET_SVAL(key, T_INT, NUMBER_NUMBER, integer, marker);
  old = low_mapping_lookup(remap->markers[marker_set], &key);
  if (value) {
    if (old && (TYPEOF(*old) == T_TYPE)) {
      value = both = or_pike_types(old->u.type, value, 0);
    }
    SET_SVAL(val, T_TYPE, 0, type, value);
  } else if (!(old && TYPEOF(*old) == T_TYPE)) {
    SET_SVAL(val, T_INT, NUMBER_NUMBER, integer, 0);
  } else {
    return;
  }
  mapping_insert(remap->markers[marker_set], &key, &val);
  free_type(both);
}
#define store_marker(REMAP, M, T, F) store_marker(REMAP, M, debug_malloc_pass(T), F)

/**
 * Copy marker assignments from remap->markers to
 * their corresponding T_ASSIGN nodes (aka backpatch).
 *
 * Leave the result on the type stack.
 */
static void push_and_fixup_markers(struct pike_type *t,
				   struct remap_state *remap,
				   enum pt_remap_flags flags)
{
  int marker_set = !!(flags & PT_FLAG_REMAP_SWAP_MARKERS);

  if (!t || !(t->flags & PT_FLAG_ASSIGN) || !remap ||
      !remap->markers[marker_set]) {
    /* Type t does not contain any marker assignments,
     * or the remap state has no markers set.
     */
    push_finished_type(t);
    return;
  }
  /* NB: Many of the cases in the switch below are unreached
   *     as they never contain a T_ASSIGN and thus are
   *     handled by the PT_FLAG_ASSIGN test above.
   */
  switch(t->type & (0x8000 | PIKE_T_MASK)) {
  case T_ASSIGN:
    {
      int marker = '0' + CAR_TO_INT(t);
      struct pike_type *t2 = NULL;
      if (lookup_marker(remap, marker | 0x100, flags, &t2)) {
	push_finished_type(t2);
	free_type(t2);
      } else {
	push_finished_type(t->cdr);
      }
      push_assign_type(marker);
    }
    break;

  case PIKE_T_NAME:
    push_and_fixup_markers(t->cdr, remap, flags);
    push_type_name((struct pike_string *)(t->car));
    break;

  case PIKE_T_ATTRIBUTE:
    push_and_fixup_markers(t->cdr, remap, flags);
    push_type_attribute((struct pike_string *)(t->car));
    break;

  case T_SCOPE:
    push_and_fixup_markers(t->cdr, remap, flags);
    push_scope_type(CAR_TO_INT(t));
    break;

  case T_MULTISET:
  case T_NOT:
  case T_TYPE:
  case PIKE_T_AUTO:
  case T_PROGRAM:
    /* t->car is node. */
    push_and_fixup_markers(t->car, remap, flags);
    push_type(t->type);
    break;

  case PIKE_T_OPERATOR:
    push_finished_type(t->car);
    push_type_operator(t->type, t->cdr);
    break;

  case T_FUNCTION:
  case T_MANY:
  case PIKE_T_RING:
  case T_TUPLE:
  case T_MAPPING:
  case T_OR:
  case T_AND:
  case T_ARRAY:
  case T_STRING:
  case PIKE_T_OPERATOR | 0x8000:
    /* t->car and t->cdr are nodes. */
    push_and_fixup_markers(t->cdr, remap, flags);
    push_and_fixup_markers(t->car, remap, flags);
    push_type(t->type);
    break;

  case PIKE_T_TRANSITIVE:
    push_finished_type(t->cdr);
    push_and_fixup_markers(t->car, remap, flags);
    push_type(t->type);
    break;

  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
  case T_MIXED:
  case T_VOID:
  case T_ZERO:
  case T_FLOAT:
  case T_INT:
  case T_OBJECT:
    /* Leaf type. */
    push_finished_type(t);
    break;

  default:
    Pike_fatal("Unsupported type in push_and_fixup_markers().\n");
  }
}

static void push_remap_markers(struct pike_type *t,
			       struct remap_state *remap,
			       enum pt_remap_flags flags)
{
  if (!t || (flags & PT_FLAG_REMAP_INHIBIT) ||
      (!remap && !(flags & PT_FLAG_REMAP_EVAL_MARKERS))) {
    push_finished_type(t);
    return;
  }

  /* FIXME: Use the type flags to detect whether we can just push
   *        the type verbatim.
   */

  switch(t->type & PIKE_T_MASK) {
  case T_ASSIGN:
    {
      int marker = alloc_remap_marker(remap, CAR_TO_INT(t), flags);

      if (!(flags & PT_FLAG_REMAP_EVAL_MARKERS)) {
	push_remap_markers(t->cdr, remap, flags);
	push_assign_type(marker);
      } else {
	struct pike_type *old = NULL;
	struct pike_type *new = t->cdr;
	lookup_marker(remap, marker, flags, &old);
	if (new) {
	  if (old) {
	    new = or_pike_types(old, new, 0);
	  } else {
	    add_ref(new);
	  }
	  store_marker(remap, marker, new, flags);
	  free_type(new);
	}
	free_type(old);
	push_remap_markers(t->cdr, remap, flags);
      }

      if (flags & PT_FLAG_REMAP_BOTH_MARKERS) {
	marker = alloc_remap_marker(remap, CAR_TO_INT(t),
				    flags ^ PT_FLAG_REMAP_SWAP_MARKERS);

	if (!(flags & PT_FLAG_REMAP_EVAL_MARKERS)) {
	  push_assign_type(marker);
	} else {
	  struct pike_type *old = NULL;
	  struct pike_type *new = t->cdr;
	  lookup_marker(remap, marker,
			flags ^ PT_FLAG_REMAP_SWAP_MARKERS, &old);
	  if (old) {
	    new = or_pike_types(old, new, 0);
	  } else {
	    add_ref(new);
	  }
	  store_marker(remap, marker, new, flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	  free_type(new);
	  free_type(old);
	  push_remap_markers(t->cdr, remap, flags ^ PT_FLAG_REMAP_SWAP_MARKERS);

	  switch(flags & PT_FLAG_REMAP_BOTH_MARKERS_MASK) {
	  case PT_FLAG_REMAP_BOTH_MARKERS_AND:
	    push_type(T_AND);
	    break;
	  case PT_FLAG_REMAP_BOTH_MARKERS_OR:
	    push_type(T_OR);
	    break;
	  default:
	    Pike_fatal("Unsupported marker joining method.\n");
	    break;
	  }
	}
      }
      break;
    }

  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
    {
      int marker = remap_marker(remap, t->type, flags);
      struct pike_type *value = NULL;

      if (lookup_marker(remap, marker, flags, &value)) {
	push_finished_type(value);
	free_type(value);
	if (marker && (flags & PT_FLAG_REMAP_KEEP_MARKERS)) {
	  push_type(marker);
	  push_type(T_OR);
	}
      } else if (flags & PT_FLAG_REMAP_EVAL_MARKERS) {
	/* Marker without matching assign.
	 * NB: Not an error. Consider
	 *
	 *       function($0 = mixed...: $0|float)
	 *
	 *     when evaluating the $0|float to get the
	 *     return value, $0 will not be bound.
	 */
	push_type(PIKE_T_UNKNOWN);
      } else {

	/* Remap the marker. */

	if (!marker) {
	  /* FIXME: Improve error handling here. */
	  push_type(T_MIXED);
	} else {
	  push_type(marker);
	}
      }

      if (flags & PT_FLAG_REMAP_BOTH_MARKERS) {
	marker = remap_marker(remap, t->type,
			      flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	value = NULL;
	if (lookup_marker(remap, marker,
			  flags ^ PT_FLAG_REMAP_SWAP_MARKERS, &value)) {
	  push_finished_type(value);
	  free_type(value);
	} else if (flags & PT_FLAG_REMAP_EVAL_MARKERS) {
	  /* Marker without matching assign. */
	  /* FIXME: Report error? */
	  push_type(T_MIXED);
	} else {

	  /* Remap the marker. */

	  if (!marker) {
	    /* FIXME: Improve error handling here. */
	    push_type(T_MIXED);
	  } else {
	    push_type(marker);
	  }
	}

	switch(flags & PT_FLAG_REMAP_BOTH_MARKERS_MASK) {
	case PT_FLAG_REMAP_BOTH_MARKERS_AND:
	  push_type(T_AND);
	  break;
	case PT_FLAG_REMAP_BOTH_MARKERS_OR:
	  push_type(T_OR);
	  break;
	default:
	  Pike_fatal("Unsupported marker joining method.\n");
	  break;
	}
      }
      break;
    }

  case PIKE_T_NAME:
    push_remap_markers(t->cdr, remap, flags);
    push_type_name((struct pike_string *)(t->car));
    break;

  case PIKE_T_ATTRIBUTE:
    push_remap_markers(t->cdr, remap, flags);
    push_type_attribute((struct pike_string *)(t->car));
    break;

  case T_SCOPE:
    push_remap_markers(t->cdr, remap, flags);
    push_scope_type(CAR_TO_INT(t));
    break;

  case PIKE_T_OPERATOR:
    push_remap_markers(t->car, remap, flags);

    if (t->type & 0x8000) {
      push_remap_markers(t->cdr, remap, flags);
      push_reverse_type(t->type);
    } else {
      switch(t->type) {
      case PIKE_T_GET_RETURN:
      case PIKE_T_THRESHOLD:
	push_type_operator(t->type, NULL);
	break;
      case PIKE_T_FIND_LFUN:
	push_type_operator(t->type, t->cdr);
	break;
      default:
	Pike_fatal("Unsupported operator %d in push_remap_markers().\n",
		   t->type);
	break;
      }
    }
    break;

    /* Verbatim */
  case T_OBJECT:
  case T_VOID:
  case T_ZERO:
  case T_INT:
  case T_FLOAT:
  case PIKE_T_MIXED:
    push_finished_type(t);
    break;

    /* Unary */
  case T_PROGRAM:
  case T_MULTISET:
  case T_NOT:
  case T_TYPE:
  case PIKE_T_AUTO:
    push_remap_markers(t->car, remap, flags);
    push_type(t->type);
    break;

    /* Binary */
  case T_OR:
  case T_AND:
  case T_FUNCTION:
  case T_MANY:
  case T_TUPLE:
  case T_MAPPING:
  case PIKE_T_RING:
  case T_ARRAY:
  case T_STRING:
    push_remap_markers(t->car, remap, flags);
    push_remap_markers(t->cdr, remap, flags);
    push_reverse_type(t->type);
    break;

    /* Special */
  case PIKE_T_TRANSITIVE:
    push_remap_markers(t->car, remap, flags);
    push_finished_type(t->cdr);
    push_reverse_type(t->type);
    break;
  }
}

/**
 * Remap markers (if any) in the type.
 */
static struct pike_type *remap_markers(struct pike_type *t,
				       struct remap_state *remap,
				       enum pt_remap_flags flags)
{
  if (!t) return NULL;

  if (flags & PT_FLAG_REMAP_TRACE) {
    fprintf(stderr, "remap_markers(");
    simple_describe_type(t);
    fprintf(stderr, ", {");
    simple_describe_mapping(remap?remap->markers[0]:NULL);
    simple_describe_mapping(remap?remap->markers[1]:NULL);
    fprintf(stderr, "}, %p, 0x%02x)\n", remap, flags);
  }

  type_stack_mark();
  push_remap_markers(t, remap, flags);

  if (flags & PT_FLAG_REMAP_TRACE) {
    fprintf(stderr, "remap ==> ");
    simple_describe_type(peek_type_stack());
    fprintf(stderr, "\n");
  }
  return pop_unfinished_type();
}

static void push_expand_transitive_remap(struct pike_type *cont,
					 struct pike_type *trans,
					 struct remap_state *remap,
					 enum pt_remap_flags flags,
					 int num_args)
{
  struct pike_type *tmp;
  TYPE_STACK_DEBUG("expand_transitive_remap");
  switch(cont->type & PIKE_T_MASK) {
  case T_OR: case T_AND:
    push_expand_transitive_remap(cont->cdr, trans, remap, flags, num_args);
    push_expand_transitive_remap(cont->car, trans, remap, flags, num_args);
    push_type(cont->type);
    break;
  case PIKE_T_FUNCTION:
    /*
     * transitive(function(a, b, ...:c), X)
     *
     * ==>
     *
     * function(a, @transitive(function(b, ...:c), X)
     */
    push_expand_transitive_remap(cont->cdr, trans, remap, flags, num_args + 1);
    push_finished_type(cont->car);
    push_type(cont->type);
    break;
  case T_MANY:
    if (num_args) {
      /* No need to expand further for now. */
      push_finished_type(trans);
      push_finished_type(cont);
      push_type(PIKE_T_TRANSITIVE);
    } else {
      /* Two cases:
       *
       * transitive(function(:x), function(x, a, b, ...: c))
       *
       * ==>
       *
       * function(:x) | expand(transitive(function(a, b, ...: c),
       *                                  function(x, a, b, ...:c)))
       *
       * And
       *
       * transitive(function(t...:x), function(x, a, b, ...: c))
       *
       * ==>
       *
       * function(t...:x) |
       *   function(t, @transitive(function(t...:x),
       *                           function(x, a, b, c, ...:c)))) |
       *   expand(transitive(function(a, b, ...: c),
       *                     function(x, a, b, ...:c)))
       */
      DECLARE_CYCLIC();

      push_finished_type(cont);

      if (!BEGIN_CYCLIC(cont, trans)) {
	struct call_state cs;

	SET_CYCLIC_RET(1);

	/* Check many arg. */
	if (cont->car != void_type_string) {
	  push_finished_type(trans);
	  push_finished_type(cont);
	  push_type(PIKE_T_TRANSITIVE);
	  push_finished_type(cont->car);
	  push_type(PIKE_T_FUNCTION);
	  push_type(T_OR);
	}

	/* Expand the return value from cont. */
	push_remap_markers(cont->cdr, remap, flags|PT_FLAG_REMAP_EVAL_MARKERS);
	INIT_CALL_STATE(cs, NULL);
	tmp = low_new_check_call(trans, peek_type_stack(), 0, &cs, NULL);
	FREE_CALL_STATE(cs);
	compiler_discard_top_type();

	if (tmp) {
	  /* Valid recursion. */
	  push_expand_transitive_remap(tmp, trans, remap, flags, 0);
	  free_type(tmp);
	  push_type(T_OR);
	}
      }
      END_CYCLIC();
    }
    break;
  case PIKE_T_OPERATOR:
    if (num_args) {
      /* No need to expand futher for now. */
      push_finished_type(trans);
      push_finished_type(cont);
      push_type(PIKE_T_TRANSITIVE);
    } else {
      /* We have no idea. */
      push_type(PIKE_T_MIXED);
    }
    break;
  case PIKE_T_MIXED:
    push_type(PIKE_T_MIXED);
    break;
  case T_VOID:
    push_type(T_VOID);
    break;
  default:
    /* Unsupported. */
    fprintf(stderr, "Attempting to expand unsupported type: ");
    simple_describe_type(cont);
    fprintf(stderr, "\n");
    push_finished_type(function_type_string);
    Pike_fatal("Attempt to expand unsupported type: %d\n", cont->type);
    break;
  }
}

/* Partially expand transitive types, so that eg matching
 * against function types works as expected.
 *
 * NB: Misnomer!
 *     No remapping actually performed in the expansion stage!
 *     Remapping only done when copying trans function to
 *     cont function and when evaluating the cont function's
 *     result.
 */
static struct pike_type *expand_transitive_remap(struct pike_type *fun,
						 struct remap_state *remap,
						 enum pt_remap_flags flags)
{
  assert(fun->type == PIKE_T_TRANSITIVE);

#ifdef PIKE_DEBUG
  if (l_flag > 2) {
    fprintf(stderr, "expand_transitive_remap(");
    simple_describe_type(fun);
    fprintf(stderr, ")\n");
    simple_describe_remap_state(remap);
  }
#endif

  type_stack_mark();
  push_expand_transitive_remap(fun->car, fun->cdr, remap, flags, 0);

#ifdef PIKE_DEBUG
  if (l_flag > 2) {
    fprintf(stderr, "expand_transitive_remap(");
    simple_describe_type(fun);
    fprintf(stderr, ") ==> ");
    simple_describe_type(peek_type_stack());
    fprintf(stderr, "\n");
  }
#endif

  return pop_unfinished_type();
}

static struct pike_type *low_intersect_types(struct pike_type *a,
					     struct pike_type *b,
					     struct remap_state *remap,
					     enum pt_cmp_flags aflags,
					     enum pt_cmp_flags bflags,
					     enum pt_remap_flags remap_flags);

static void push_binop(enum pt_binop op)
{
  struct pike_type *a, *b;
  switch(op) {
  case PT_BINOP_AND:
    push_type(T_AND);
    break;
  case PT_BINOP_OR:
    push_type(T_OR);
    break;
  case PT_BINOP_B:
    a = low_pop_type();
    b = low_pop_type();
    push_finished_type(b);
    free_type(a);
    free_type(b);
    break;
  case PT_BINOP_A:
    a = low_pop_type();
    b = low_pop_type();
    push_finished_type(a);
    free_type(a);
    free_type(b);
    break;
  case PT_BINOP_ALL:
    a = low_pop_type();
    b = low_pop_type();
    push_type(T_MIXED);
    free_type(a);
    free_type(b);
    break;
  case PT_BINOP_NONE:
    a = low_pop_type();
    b = low_pop_type();
    push_type(PIKE_T_UNKNOWN);
    free_type(a);
    free_type(b);
    break;
  case PT_BINOP_MINUS:
  case PT_BINOP_INVERSE_MINUS:
    /* One of the minterms. */
    if (op & PT_BINOP_NOT_B) {
      a = low_pop_type();
      push_type(T_NOT);
      push_finished_type(a);
      free_type(a);
    }
    if (op & PT_BINOP_NOT_A) {
      push_type(T_NOT);
    }
    push_type(T_AND);
    break;
  case PT_BINOP_NOR:
    push_type(T_OR);
    push_type(T_NOT);
    break;
  default:
    {
      enum pt_binop inv_op = (~op) & PT_BINOP_ALL;

      if (!(inv_op & (inv_op - 1))) {
	/* An inverted minterm. */
	if (inv_op & PT_BINOP_NOT_B) {
	  a = low_pop_type();
	  push_type(T_NOT);
	  push_finished_type(a);
	  push_type(T_NOT);
	  free_type(a);
	}
	if (inv_op & PT_BINOP_NOT_A) {
	  push_type(T_NOT);
	}
	push_type(T_OR);
	break;
      }
      /* FIXME: XOR, NXOR */
      Pike_fatal("Unsupported binary type operation: 0x%02x\n", op);
    }
  }
}

#if 0 /* unused */
static void push_reverse_binop(enum pt_binop op)
{
  /* Swap bits 1 & 2 in op to reverse the meanings of the arguments. */
  push_binop((op & PT_BINOP_XNOR) |
	     ((op & PT_BINOP_MINUS) ? PT_BINOP_INVERSE_MINUS : 0) |
	     ((op & PT_BINOP_INVERSE_MINUS) ? PT_BINOP_MINUS : 0));
}
#endif

/**
 * Low-level set operation (AND, MINUS, OR, etc) on two types.
 *
 * Note:
 *   There are two major operating modes; the external, where
 *   the two types have unrelated markers, which then need to
 *   be remapped in the result, and the internal, where the
 *   two types have related markers (this mode is used mainly
 *   when evaluating a type).
 *
 * The internal mode is indicated via the remap state being NULL.
 */
static struct pike_type *lower_type_binop(enum pt_binop op,
					  struct pike_type *a,
					  struct pike_type *b,
					  struct remap_state *remap,
					  enum pt_cmp_flags aflags,
					  enum pt_cmp_flags bflags,
					  enum pt_remap_flags remap_flags);
static struct pike_type *low_type_binop(enum pt_binop op,
					struct pike_type *a,
					struct pike_type *b,
					struct remap_state *remap,
					enum pt_cmp_flags aflags,
					enum pt_cmp_flags bflags,
					enum pt_remap_flags remap_flags)
{
#ifdef DEBUG_MALLOC
#define low_type_binop(OP, A, B, REMAP, AFLAGS, BFLAGS, REMAP_FLAGS)	\
  ((struct pike_type *)							\
   debug_malloc_pass(low_type_binop(OP, debug_malloc_pass(A),		\
				    debug_malloc_pass(B),		\
				    debug_malloc_pass(REMAP),		\
				    AFLAGS, BFLAGS, REMAP_FLAGS)))
#endif /* DEBUG_MALLOC */
  struct pike_type *ret;
  DECLARE_CYCLIC();

  if (BEGIN_CYCLIC3(a, b, (ptrdiff_t)op)) {
    END_CYCLIC();

    if (op & PT_BINOP_AND) {
      return remap_markers(a, remap, remap_flags);
    }
    return NULL;
  }
  SET_CYCLIC_RET(1);

  if (remap_flags & PT_FLAG_REMAP_TRACE) {
    fprintf(stderr, "low_type_binop(0x%04x, ", op);
    simple_describe_type(a);
    fprintf(stderr, ", ");
    simple_describe_type(b);
    fprintf(stderr, ", %p, 0x%04x, 0x%04x, 0x%02x)\n",
	    remap, aflags, bflags, remap_flags);

    ret = debug_malloc_pass(lower_type_binop(op, a, b, remap,
					     aflags, bflags, remap_flags));

    fprintf(stderr, "ret: ");
    simple_describe_type(ret);
    fprintf(stderr, "\n");

    END_CYCLIC();
    return ret;
  }

  ret = debug_malloc_pass(lower_type_binop(op, a, b, remap,
					   aflags, bflags, remap_flags));
  END_CYCLIC();
  return ret;
}
static struct pike_type *lower_type_binop(enum pt_binop op,
					struct pike_type *a,
					struct pike_type *b,
					struct remap_state *remap,
					enum pt_cmp_flags aflags,
					enum pt_cmp_flags bflags,
					enum pt_remap_flags remap_flags)
{
  struct pike_type *tmp, *tmp2, *ret;
  struct pike_type *aret = NULL, *bret = NULL;
  struct compilation *c = MAYBE_THIS_COMPILATION;
  enum pt_cmp_flags tmp_flags;

 recur:
  switch(op) {
  case PT_BINOP_AND:
  case PT_BINOP_MINUS:
    break;
  case PT_BINOP_INVERSE_MINUS:
    tmp = a;
    a = b;
    b = tmp;
    tmp_flags = aflags;
    aflags = bflags;
    bflags = tmp_flags;
    remap_flags ^= PT_FLAG_REMAP_SWAP_MARKERS;
    op = PT_BINOP_MINUS;
    break;
  case PT_BINOP_NOR:
    type_stack_mark();
    push_remap_markers(a, remap, remap_flags);
    push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    push_type(T_OR);
    push_type(T_NOT);
    return pop_unfinished_type();
  case PT_BINOP_OR:
    type_stack_mark();
    push_remap_markers(a, remap, remap_flags);
    push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    push_type(T_OR);
    return pop_unfinished_type();

  case PT_BINOP_XOR:
    /* A XOR B == (A OR B) - (A AND B) */
    tmp = low_type_binop(PT_BINOP_OR, a, b, remap,
			 aflags, bflags, remap_flags);
    if (!tmp) return NULL;

    tmp2 = low_type_binop(PT_BINOP_AND, a, b, remap,
			  aflags, bflags, remap_flags);
    if (!tmp2) return tmp;

    ret = low_type_binop(PT_BINOP_MINUS, tmp, tmp2, NULL, 0, 0,
			 remap_flags & PT_FLAG_REMAP_INEXACT);
    free_type(tmp);
    free_type(tmp2);
    return ret;

  case PT_BINOP_XNOR:
    /* A XNOR B == (A NAND B) - (A NOR B) */
    tmp = low_type_binop(PT_BINOP_NAND, a, b, remap,
			 aflags, bflags, remap_flags);
    if (!tmp) return NULL;

    tmp2 = low_type_binop(PT_BINOP_NOR, a, b, remap,
			  aflags, bflags, remap_flags);
    if (!tmp2) return tmp;

    ret = low_type_binop(PT_BINOP_MINUS, tmp, tmp2, NULL, 0, 0,
			 remap_flags & PT_FLAG_REMAP_INEXACT);
    free_type(tmp);
    free_type(tmp2);
    return ret;

  default:
    /* Make the C-compiler happy. */
#ifdef PIKE_DEBUG
    Pike_fatal("Unsupported binary type operation: 0x%02x\n", op);
#endif
    break;
  }

 full_loop:
  if (a == b) {
    if (op & PT_BINOP_AND) {
      /* FIXME: Perform masking of remap_flags here. */
      return remap_markers(a, remap,
			   remap_flags | PT_FLAG_REMAP_BOTH_MARKERS_AND);
    } else {
      return NULL;
    }
  }

  /* First check for markers. */
  switch(a?a->type:PIKE_T_UNKNOWN) {
  case T_ASSIGN:
    {
      int marker;
      tmp = low_type_binop(PT_BINOP_AND, a->cdr, b, remap,
			   aflags, bflags,
			   (remap_flags & ~PT_FLAG_REMAP_INEXACT) |
			   PT_FLAG_REMAP_EVAL_MARKERS);

      marker = alloc_remap_marker(remap, CAR_TO_INT(a), remap_flags);
      if (remap_flags & PT_FLAG_REMAP_TRACE) {
	fprintf(stderr, "$%d = ", marker);
	simple_describe_type(tmp);
	fprintf(stderr, "\n");
	simple_describe_remap_state(remap);
      }
      /* Marker value */
      store_marker(remap, marker, tmp, remap_flags);

      if (op != PT_BINOP_AND) {
	if ((op == PT_BINOP_MINUS) && !tmp) {
	  tmp = a->cdr;
	  if (tmp) add_ref(tmp);
	} else if ((op == PT_BINOP_MINUS) && (tmp == a->cdr)) {
	  free_type(tmp);
	  tmp = NULL;
	} else {
	  free_type(tmp);
	  tmp = low_type_binop(op, a->cdr, b, remap,
			       aflags, bflags, remap_flags);
	}
      }

      if (remap_flags & PT_FLAG_REMAP_TRACE) {
	fprintf(stderr, "$%d = ", marker | 0x100);
	simple_describe_type(tmp);
	fprintf(stderr, " (backpatch value)\n");
	simple_describe_remap_state(remap);
      }
      /* Value to backpatch. */
      store_marker(remap, marker | 0x100, tmp, remap_flags);

      if (!tmp) return NULL;

      type_stack_mark();
      push_finished_type(tmp);
      push_assign_type(marker);
      free_type(tmp);
      return pop_unfinished_type();
    }
  }
  switch(b?b->type:PIKE_T_UNKNOWN) {
  case T_ASSIGN:
    {
      int marker;
      tmp = low_type_binop(PT_BINOP_AND, a, b->cdr, remap,
			   aflags, bflags,
			   (remap_flags & ~PT_FLAG_REMAP_INEXACT) |
			   PT_FLAG_REMAP_EVAL_MARKERS);

      marker = alloc_remap_marker(remap, CAR_TO_INT(b),
				  remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      if (remap_flags & PT_FLAG_REMAP_TRACE) {
	fprintf(stderr, "$%d = ", marker);
	simple_describe_type(tmp);
	fprintf(stderr, "\n");
	simple_describe_remap_state(remap);
      }
      /* Marker value */
      store_marker(remap, marker, tmp,
		   remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);

      if (op != PT_BINOP_AND) {
	if ((op == PT_BINOP_MINUS) && !tmp) {
	  tmp = a;
	  if (tmp) add_ref(tmp);
	} else if ((op == PT_BINOP_MINUS) && (tmp == a)) {
	  free_type(tmp);
	  tmp = NULL;
	} else {
	  free_type(tmp);
	  tmp = low_type_binop(op, a, b->cdr, remap,
			       aflags, bflags, remap_flags);
	}
      }

      if (remap_flags & PT_FLAG_REMAP_TRACE) {
	fprintf(stderr, "$%d = ", marker | 0x100);
	simple_describe_type(tmp);
	fprintf(stderr, " (backpatch value)\n");
	simple_describe_remap_state(remap);
      }
      /* Value to backpatch. */
      store_marker(remap, marker | 0x100, tmp,
		   remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);

      /* NB: We can only keep the marker assignment in the PT_BINOP_AND
       *     case.
       *
       * See also the b->type == '0'..'9' case further below.
       */
      if ((op == PT_BINOP_AND) && tmp) {
	type_stack_mark();
	push_finished_type(tmp);
	push_assign_type(marker);
	free_type(tmp);
	tmp = pop_unfinished_type();
      }

      return tmp;
    }
  }

  /* Check consolidated types. */
  switch(a?a->type:PIKE_T_UNKNOWN) {
  case T_OR:
    /* (a1 | a2) op b  <==> (a1 op b) | (a2 op b) */
    {
      struct mapping *orig_markers = NULL;
      struct mapping *orig_markers_other = NULL;
      int marker_set = !!(remap_flags & PT_FLAG_REMAP_SWAP_MARKERS);
      if (remap) {
	/* Do not propagate marker changes between the branches
	 * of the T_OR node.
	 *
	 * FIXME: It is theoretically possible to propagate marker
	 *        changes up if they are compatible in both branches.
	 */
	orig_markers = remap->markers[marker_set];
	remap->markers[marker_set] = copy_mapping(orig_markers);
        orig_markers_other = remap->markers[marker_set ^ 1];
        remap->markers[marker_set ^ 1] = copy_mapping(orig_markers_other);
      }
      tmp = low_type_binop(op, a->car, b, remap, aflags, bflags, remap_flags);
      if (remap && !tmp) {
        /* Unification failed, discard other side marker changes */
        do_free_mapping(remap->markers[marker_set ^ 1]);
        remap->markers[marker_set ^ 1] = orig_markers_other;
      } else if(orig_markers_other)
        free_mapping(orig_markers_other);
      /* NB: We need to examine b closer even in inexact mode if
       *     there are marker assignments in b.
       */
      if ((remap_flags & PT_FLAG_REMAP_INEXACT) && tmp &&
	  !(b->flags & PT_FLAG_ASSIGN)) {
	if ((op == PT_BINOP_AND) || (op == PT_BINOP_MINUS)) {
	  if (orig_markers) {
	    do_free_mapping(remap->markers[marker_set]);
	    remap->markers[marker_set] = orig_markers;
	  }
	  free_type(tmp);

	  return remap_markers(a, remap, remap_flags);
	}
      }
      if (orig_markers) {
	do_free_mapping(remap->markers[marker_set]);
	remap->markers[marker_set] = copy_mapping(orig_markers);
      }
      tmp2 = low_type_binop(op, a->cdr, b, remap, aflags, bflags, remap_flags);
      if (orig_markers) {
	do_free_mapping(remap->markers[marker_set]);
	remap->markers[marker_set] = orig_markers;
      }
    }
#if 0
    if ((op & PT_BINOP_NOT_A) || (aflags & PT_FLAG_CMP_INSEPARABLE)) {
      if (!tmp2) {
	free_type(tmp);
	return NULL;
      }
      if (!tmp) {
	free_type(tmp2);
	return NULL;
      }
    } else {
      if (!tmp2) return tmp;
      if (!tmp) return tmp2;
    }
#else
    if (!tmp2) return tmp;
    if (!tmp) return tmp2;
#endif

    type_stack_mark();
    push_finished_type(tmp);
    push_finished_type(tmp2);
    push_reverse_type(T_OR);
    free_type(tmp);
    free_type(tmp2);
    return pop_unfinished_type();

  case T_AND:
    tmp = low_type_binop(op, a->car, b, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    tmp2 = low_type_binop(op, a->cdr, b, remap, aflags, bflags, remap_flags);
    if (!tmp2) {
      free_type(tmp);
      return NULL;
    }

    switch(op) {
    case PT_BINOP_AND:
      /* NB: Attempt to avoid keeping the result from inverted types,
       *     in order to reduce type expansion.
       */
      if (a->car->type == T_NOT) {
	/* (!a1 & a2) & b  <==>  (a2 & b) & !a1 */
	free_type(tmp);
	tmp = remap_markers(a->car, remap, remap_flags);
      } else if (a->cdr->type == T_NOT) {
	/* (a1 & !a2) & b  <==>  (a1 & b) & !a2 */
	free_type(tmp2);
	tmp2 = remap_markers(a->cdr, remap, remap_flags);
      }
      break;
    default:
      /* Make the C-compiler happy. */
      break;
    }

    type_stack_mark();
    push_finished_type(tmp);
    push_finished_type(tmp2);
    push_reverse_type(T_AND);
    free_type(tmp);
    free_type(tmp2);
    return pop_unfinished_type();
  }
  switch(b?b->type:PIKE_T_UNKNOWN) {
  case T_OR:
    {
      struct mapping *orig_markers = NULL;
      struct mapping *orig_markers_other = NULL;
      int marker_set = !(remap_flags & PT_FLAG_REMAP_SWAP_MARKERS);
      if (remap) {
	/* Do not propagate marker changes between the branches
	 * of the T_OR node.
	 *
	 * FIXME: It is theoretically possible to propagate marker
	 *        changes up if they are compatible in both branches.
	 */
	orig_markers = remap->markers[marker_set];
	remap->markers[marker_set] = copy_mapping(orig_markers);
        orig_markers_other = remap->markers[marker_set ^ 1];
        remap->markers[marker_set ^ 1] = copy_mapping(orig_markers_other);
      }

      tmp = low_type_binop(op, a, b->car, remap, aflags, bflags, remap_flags);
      if (remap && !tmp) {
        /* Unification failed, discard other side marker changes */
        do_free_mapping(remap->markers[marker_set ^ 1]);
        remap->markers[marker_set ^ 1] = orig_markers_other;
      } else if(orig_markers_other)
        free_mapping(orig_markers_other);
      if (remap_flags & PT_FLAG_REMAP_INEXACT) {
	if (tmp && (op == PT_BINOP_AND)) {
	  if (orig_markers) {
	    do_free_mapping(remap->markers[marker_set]);
	    remap->markers[marker_set] = orig_markers;
	  }
	  free_type(tmp);
	  add_ref(a);
	  return a;
	} else if (!tmp && (op == PT_BINOP_MINUS)) {
	  if (orig_markers) {
	    do_free_mapping(remap->markers[marker_set]);
	    remap->markers[marker_set] = orig_markers;
	  }
	  return NULL;
	}
      }
      if (orig_markers) {
	do_free_mapping(remap->markers[marker_set]);
	remap->markers[marker_set] = copy_mapping(orig_markers);
      }
      if ((op == PT_BINOP_MINUS) || (op == PT_BINOP_OR)) {
	/* Special case to avoid excessively complicated expressions
	 * in the result.
	 *
	 *   A - (B | C)  ==  (A - B) - C
	 * rather than
	 *   A - (B | C)  ==  (A - B) & (A - C)
	 *
	 *   A | (B | C)  ==  (A | B) | C
	 * rather than
	 *   A | (B | C)  ==  (A | B) | (A | C)
	 */
	tmp2 = remap_markers(b->cdr, remap,
			     remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	if (remap_flags & PT_FLAG_REMAP_TRACE) {
	  fprintf(stderr, "tmp: ");
	  simple_describe_type(tmp);
	  fprintf(stderr, "\ntmp2: ");
	  simple_describe_type(tmp2);
	  fprintf(stderr, "\nop: 0x%04x\n", op);
	}
	ret = low_type_binop(op, tmp, tmp2, remap, aflags, bflags,
			     remap_flags | PT_FLAG_REMAP_INHIBIT);
	if (remap_flags & PT_FLAG_REMAP_TRACE) {
	  fprintf(stderr, "tmp op tmp2: ");
	  simple_describe_type(ret);
	  fprintf(stderr, "\n");
	}
	if (orig_markers) {
	  do_free_mapping(remap->markers[marker_set]);
	  remap->markers[marker_set] = orig_markers;
	}
	free_type(tmp);
	free_type(tmp2);
	return ret;
      }
      /* op		secondary
       * 0  0000	0		0000
       * 1  0001	7		0111
       * 2  0010	1	        0001
       * 3  0011	1, 3, 5, 7	0011
       * 4  0100	7		0111
       * 5  0101	7		0111
       * 6  0110	-
       * 7  0111	7		0111
       * 8  1000	1		0001
       * 9  1001	-
       * 10 1010	1		0001
       * 11 1011	1		0001
       * 12 1100	1, 3, 5, 7	0011
       * 13 1101	7		0111
       * 14 1110	1		0001
       * 15 1111	15		1111
       *
       * Note that secondary ops 1 and 7 are swapped for T_AND and T_OR.
       */
      tmp2 = low_type_binop(op, a, b->cdr, remap, aflags, bflags, remap_flags);
      if (orig_markers) {
	do_free_mapping(remap->markers[marker_set]);
	remap->markers[marker_set] = orig_markers;
      }
    }

    /* FIXME: XOR and XNOR not supported cf above. */
    if ("071377-71-11371f"[op] == '1') {
      /* Secondary operator is AND. */
      if (!tmp2) {
	free_type(tmp);
	return NULL;
      }
      if (!tmp) {
	free_type(tmp2);
	return NULL;
      }

      type_stack_mark();
      push_finished_type(tmp);
      push_finished_type(tmp2);
      push_reverse_type(T_AND);
    } else {
      /* Secondary operator is OR. */
      if (!tmp2) return tmp;
      if (!tmp) return tmp2;

      type_stack_mark();
      push_finished_type(tmp);
      push_finished_type(tmp2);
      push_reverse_type(T_OR);
    }
    free_type(tmp);
    free_type(tmp2);
    return pop_unfinished_type();

  case T_AND:
    /* op	secondary
     * 0  0000	0		0000
     * 1  0001	1		0001
     * 2  0010	7		0111
     * 3  0011	1, 3, 5, 7	0011
     * 4  0100	1		0001
     * 5  0101	1		0001
     * 6  0110	-
     * 7  0111	1		0001
     * 8  1000	7		0111
     * 9  1001	-
     * 10 1010	7		0111
     * 11 1011	7		0111
     * 12 1100	1, 3, 5, 7	0011
     * 13 1101	1		0001
     * 14 1110	7		0111
     * 15 1111	15		1111
     *
     * Note that secondary ops 1 and 7 are swapped for T_AND and T_OR.
     */
    tmp = low_type_binop(op, a, b->car, remap, aflags, bflags, remap_flags);
    tmp2 = low_type_binop(op, a, b->cdr, remap, aflags, bflags, remap_flags);

    /* FIXME: XOR and XNOR not supported cf above. */
    if ("017311-17-77317f"[op] == '1') {
      /* Secondary operator is AND. */
      if (!tmp2) {
	free_type(tmp);
	return NULL;
      }
      if (!tmp) {
	free_type(tmp2);
	return NULL;
      }

      if ((b->type == T_AND) && (op == PT_BINOP_AND)) {
	/* NB: Attempt to avoid keeping the result from inverted types,
	 *     in order to reduce type expansion.
	 */
	if (b->car->type == T_NOT) {
	  free_type(tmp);
	  tmp = remap_markers(b->car, remap,
			      remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	} else if (b->cdr->type == T_NOT) {
	  free_type(tmp2);
	  tmp2 = remap_markers(b->cdr, remap,
			       remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	}
      }

      type_stack_mark();
      push_finished_type(tmp);
      push_finished_type(tmp2);
      push_reverse_type(T_AND);
    } else {
      /* Secondary operator is OR. */
      if (!tmp2) return tmp;
      if (!tmp) return tmp2;

      type_stack_mark();
      push_finished_type(tmp);
      push_finished_type(tmp2);
      push_reverse_type(T_OR);
    }
    free_type(tmp);
    free_type(tmp2);

    return pop_unfinished_type();
  }

  /* Attributes and names. */
  switch(a?a->type:PIKE_T_UNKNOWN) {
  case PIKE_T_NAME:
    tmp = low_type_binop(op, a->cdr, b, remap, aflags, bflags, remap_flags);
    if (!tmp) {
      return NULL;
    }
    if (tmp != a->cdr) {
      return tmp;
    }
    type_stack_mark();
    push_finished_type(tmp);
    push_type_name((struct pike_string *)(a->car));
    free_type(tmp);

    return pop_unfinished_type();
  case PIKE_T_ATTRIBUTE:
    if (b && (b->type == PIKE_T_ATTRIBUTE) && (b->car == a->car)) {
      /* Types a and b have the same attribute.
       *
       * Do NOT call pop_type_attribute() (or push_type_attribute())
       * in this case.
       */
      tmp = low_type_binop(op, a->cdr, b->cdr, remap,
			   aflags, bflags, remap_flags);
      if (!tmp) {
	return NULL;
      }
    } else {
      tmp = low_type_binop(op, a->cdr, b, remap, aflags, bflags, remap_flags);

      if (!tmp) {
	if (c && (op == PT_BINOP_MINUS)) {
	  ref_push_string((struct pike_string *)a->car);
	  ref_push_type_value(a->cdr);
	  ref_push_type_value(b);
	  if (remap) {
	    if (!remap->state) {
	      remap->state = allocate_mapping(4);
	    }
	    ref_push_mapping(remap->state);
	    safe_apply_current2(PC_POP_TYPE_ATTRIBUTE_FUN_NUM, 4,
				"pop_type_attribute");
	  } else {
	    safe_apply_current2(PC_POP_TYPE_ATTRIBUTE_FUN_NUM, 3,
				"pop_type_attribute");
	  }
	  if ((TYPEOF(Pike_sp[-1]) == T_INT) &&
	      (SUBTYPEOF(Pike_sp[-1]) == NUMBER_NUMBER) &&
	      (!Pike_sp[-1].u.integer)) {
	    /* Forced mismatch. */
	    pop_stack();
	    return remap_markers(a, remap, remap_flags);
	  }
	  if (TYPEOF(Pike_sp[-1]) == PIKE_T_TYPE) {
	    /* Alternative type for a. */
	    tmp = low_type_binop(op, Pike_sp[-1].u.type, b, remap,
				 aflags, bflags, remap_flags);
	    pop_stack();
	    return tmp;
	  }
	  pop_stack();
	}
	return NULL;
      }
    }

    type_stack_mark();
    push_finished_type(tmp);
    if (op == PT_BINOP_AND || op == PT_BINOP_MINUS) {
      push_type_attribute((struct pike_string *)(a->car));
    }
    free_type(tmp);

    return pop_unfinished_type();
  case T_SCOPE:
    tmp = low_type_binop(PT_BINOP_AND, a->cdr, b, remap,
			 aflags | PT_FLAG_CMP_INSEPARABLE, bflags,
			 PT_FLAG_REMAP_INEXACT | remap_flags);
    free_type(tmp);
    if ((!tmp) ^ (op != PT_BINOP_AND)) {
      return NULL;
    }

    type_stack_mark();
    if (op == PT_BINOP_AND) {
      push_remap_markers(a, remap, remap_flags);
    } else {
      push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      push_remap_markers(a, remap, remap_flags);
      push_binop(op);
    }

    return pop_unfinished_type();
  }
  switch(b?b->type:PIKE_T_UNKNOWN) {
  case PIKE_T_NAME:
    tmp = low_type_binop(op, a, b->cdr, remap, aflags, bflags, remap_flags);
    if (!tmp) {
      return NULL;
    }
    if (tmp != b->cdr) {
      return tmp;
    }
    type_stack_mark();
    push_finished_type(tmp);
    push_type_name((struct pike_string *)(b->car));
    free_type(tmp);

    return pop_unfinished_type();
  case PIKE_T_ATTRIBUTE:
    tmp = low_type_binop(op, a, b->cdr, remap, aflags, bflags, remap_flags);
    if (!tmp) {
      if (a && c && (op == PT_BINOP_MINUS)) {
	ref_push_string((struct pike_string *)b->car);
	ref_push_type_value(a);
	ref_push_type_value(b->cdr);
	if (remap) {
	  if (!remap->state) {
	    remap->state = allocate_mapping(4);
	  }
	  ref_push_mapping(remap->state);
	  safe_apply_current2(PC_PUSH_TYPE_ATTRIBUTE_FUN_NUM, 4,
			      "push_type_attribute");
	} else {
	  safe_apply_current2(PC_PUSH_TYPE_ATTRIBUTE_FUN_NUM, 3,
			      "push_type_attribute");
	}
	if ((TYPEOF(Pike_sp[-1]) == T_INT) &&
	    (SUBTYPEOF(Pike_sp[-1]) == NUMBER_NUMBER) &&
	    (!Pike_sp[-1].u.integer)) {
	  /* Forced mismatch. */
	  pop_stack();
	  return remap_markers(a, remap, remap_flags);
	}
	if (TYPEOF(Pike_sp[-1]) == PIKE_T_TYPE) {
	  /* Alternative type for b. */
	  tmp = low_type_binop(op, a, Pike_sp[-1].u.type, remap,
			       aflags, bflags, remap_flags);
	  pop_stack();
	  return tmp;
	}
	pop_stack();
      }
      return NULL;
    }

    type_stack_mark();
    push_finished_type(tmp);
    if (op == PT_BINOP_AND) {
      push_type_attribute((struct pike_string *)(b->car));
    }
    free_type(tmp);

    return pop_unfinished_type();
  case T_SCOPE:
    tmp = low_type_binop(PT_BINOP_AND, a, b->cdr, remap,
			 aflags, bflags | PT_FLAG_CMP_INSEPARABLE,
			 PT_FLAG_REMAP_INEXACT | remap_flags);
    free_type(tmp);
    if ((!tmp) ^ (op != PT_BINOP_AND)) {
      return NULL;
    }

    type_stack_mark();
    push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    if (op != PT_BINOP_AND) {
      push_remap_markers(a, remap, remap_flags);
      push_binop(op);
    }

    return pop_unfinished_type();
  }

  /*
   * NB: At this point a and b are either NULL, a basic type or a marker.
   */

 loop:
  switch(a ? a->type : PIKE_T_UNKNOWN) {
  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
    {
      int marker = remap_marker(remap, a->type, remap_flags);
      a = NULL;

      if (!marker) {
	break;
      }

      if (!lookup_marker(remap, marker, remap_flags, &a)) {
	break;
      }

      tmp = low_type_binop(op, a, b, remap, aflags, bflags, remap_flags);

      free_type(a);

      store_marker(remap, marker, tmp, remap_flags);
      if ((op == PT_BINOP_AND) || (op == PT_BINOP_MINUS)) {
	store_marker(remap, marker | 0x100, tmp, remap_flags);
      }

      if (!tmp) {
	return NULL;
      }
      if (remap_flags & PT_FLAG_REMAP_EVAL_MARKERS) {
	return tmp;
      }
      free_type(tmp);

      type_stack_mark();
      push_type(marker);

      return pop_unfinished_type();
    }
  }
  switch(b ? b->type : PIKE_T_UNKNOWN) {
  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
    {
      int marker = remap_marker(remap, b->type,
				remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      b = NULL;

      if (!marker) {
	break;
      }

      if (!lookup_marker(remap, marker,
			 remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS, &b)) {
	break;
      }

      tmp = low_type_binop(op, a, b, remap, aflags, bflags, remap_flags);

      free_type(b);

      /* FIXME: Do we need to invert for PT_BINOP_MINUS here? */
      store_marker(remap, marker, tmp,
		   remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);

      /* NB: We can only keep the marker in the PT_BINOP_AND case,
       *     as in the other cases we do not have the corresponding
       *     assignment in the result.
       *
       * See also the b->type == T_ASSIGN case further above.
       */
      if ((op == PT_BINOP_AND) && tmp) {
	store_marker(remap, marker | 0x100, tmp,
		     remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);

	if (remap_flags & PT_FLAG_REMAP_EVAL_MARKERS) {
	  return tmp;
	}
	free_type(tmp);
	type_stack_mark();
	push_type(marker);

	return pop_unfinished_type();
      }

      return tmp;
    }
  }

  /* Handle a or b being NULL. */
  /* NB: We know that a != b due to an earlier test. */
  if (!a) {
    if (op & PT_BINOP_INVERSE_MINUS) {
      if (!((b == void_type_string) && (aflags & PT_FLAG_CMP_VOIDABLE)) &&
	  !((b == zero_type_string) && (aflags & PT_FLAG_CMP_NULLABLE))) {
	add_ref(b);
	return b;
      }
    }
    return NULL;
  }
  if (!b) {
    if (op & PT_BINOP_MINUS) {
      if (!((a == void_type_string) && (bflags & PT_FLAG_CMP_VOIDABLE)) &&
	  !((a == zero_type_string) && (bflags & PT_FLAG_CMP_NULLABLE))) {
	add_ref(a);
	return a;
      }
    }
    return NULL;
  }

  /*
   * NB: At this point a and b are basic types.
   */

  /* Check implicit casting. */
  switch(TWOT(a->type & PIKE_T_MASK, b->type & PIKE_T_MASK)) {
  case TWOT(T_PROGRAM, T_PROGRAM):
    if (a->car == object_type_string) {
      if (op & PT_BINOP_AND) {
	return remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      }
    }
    if (b->car == object_type_string) {
      if (op & PT_BINOP_AND) {
	return remap_markers(a, remap, remap_flags);
      }
      return NULL;
    }
    /* FALLTHRU */
  case TWOT(T_PROGRAM, T_TYPE):
  case TWOT(T_PROGRAM, T_FUNCTION):
  case TWOT(T_PROGRAM, T_MANY):
  case TWOT(T_PROGRAM, PIKE_T_TRANSITIVE):
    aret = a->car;
    a = low_object_lfun_type(aret, LFUN_CREATE);
    if (a) goto loop;

    type_stack_mark();
    push_finished_type(aret);
    push_type(PIKE_T_UNKNOWN);
    push_type(T_MANY);
    a = pop_unfinished_type();

    ret = low_type_binop(op, a, b, remap, aflags, bflags, remap_flags);
    free_type(a);
    return ret;

  case TWOT(T_FUNCTION, T_PROGRAM):
  case TWOT(T_MANY, T_PROGRAM):
  case TWOT(PIKE_T_TRANSITIVE, T_PROGRAM):
    bret = b->car;
    b = low_object_lfun_type(bret, LFUN_CREATE);
    if (b) goto loop;

    type_stack_mark();
    push_finished_type(bret);
    push_type(PIKE_T_UNKNOWN);
    push_type(T_MANY);
    b = pop_unfinished_type();

    ret = low_type_binop(op, a, b, remap, aflags, bflags, remap_flags);
    free_type(b);
    return ret;

  case TWOT(T_OBJECT, T_FUNCTION):
  case TWOT(T_OBJECT, T_MANY):
  case TWOT(T_OBJECT, T_PROGRAM):
  case TWOT(T_OBJECT, PIKE_T_TRANSITIVE):
    tmp = low_object_lfun_type(a, LFUN_CALL);
    if (!tmp) {
      break;
    }
    a = tmp;
    goto loop;

  case TWOT(T_FUNCTION, T_OBJECT):
  case TWOT(T_MANY, T_OBJECT):
  case TWOT(T_PROGRAM, T_OBJECT):
  case TWOT(PIKE_T_TRANSITIVE, T_OBJECT):
    tmp = low_object_lfun_type(b, LFUN_CALL);
    if (!tmp) {
      break;
    }
    b = tmp;
    goto loop;

  case TWOT(PIKE_T_TRANSITIVE, T_MANY):
    if (op == PT_BINOP_AND) {
      if ((b->car != void_type_string) &&
	  !(aflags & PT_FLAG_CMP_KEEP_TRANSITIVE)) {
	tmp = expand_transitive_remap(a, remap, remap_flags);
	ret = low_type_binop(op, tmp, b, remap,
			     aflags|PT_FLAG_CMP_KEEP_TRANSITIVE,
			     bflags, remap_flags);
	free_type(tmp);
	return ret;
      }
      type_stack_mark();
      tmp = low_type_binop(op, a->car, b, remap, aflags, bflags, remap_flags);
      push_finished_type(tmp);
      if ((tmp || !a->car) && (b->car != void_type_string)) {
	free_type(tmp);
	tmp = low_type_binop(op, a->cdr, b, NULL, aflags, bflags, remap_flags);
	if (tmp) {
	  push_finished_type(tmp);
	  free_type(tmp);
	  push_reverse_type(PIKE_T_TRANSITIVE);
	}
      }
      return pop_unfinished_type();
    } else if (op == PT_BINOP_MINUS) {
      if ((!b->car || (b->car == zero_type_string)) &&
	  ((b->cdr == mixed_type_string) || (b->cdr == any_type_string))) {
	return NULL;
      }

      if (b->car != void_type_string) {
	type_stack_mark();
	push_remap_markers(a, remap, remap_flags);
	push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	push_type(T_NOT);
	push_reverse_type(T_AND);
	return pop_unfinished_type();
      }
    }
    /* FALLTHRU */

  case TWOT(PIKE_T_TRANSITIVE, T_FUNCTION):
    tmp = expand_transitive_remap(a, remap, remap_flags);
    ret = low_type_binop(op, tmp, b, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

  case TWOT(T_MANY, PIKE_T_TRANSITIVE):
    if (op == PT_BINOP_AND) {
      if ((a->car != void_type_string) &&
	  !(bflags & PT_FLAG_CMP_KEEP_TRANSITIVE)) {
	tmp = expand_transitive_remap(b, remap,
				      remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	ret = low_type_binop(op, a, tmp, remap, aflags,
			     bflags|PT_FLAG_CMP_KEEP_TRANSITIVE, remap_flags);
	free_type(tmp);
	return ret;
      }

      tmp = low_type_binop(op, a, b->car, remap, aflags, bflags, remap_flags);
      if (tmp || (a->car == void_type_string)) {
	return tmp;
      }

      type_stack_mark();
      push_finished_type(tmp);
      free_type(tmp);

      push_finished_type(b->cdr);
      push_reverse_type(PIKE_T_TRANSITIVE);

      return pop_unfinished_type();
    } else if (!a->car || (a->car == void_type_string)) {
      return low_type_binop(op, a, b->car ? b->car : b->cdr, remap,
			    aflags, bflags, remap_flags);
    }
    /* FALLTHRU */
  case TWOT(T_FUNCTION, PIKE_T_TRANSITIVE):
    tmp = expand_transitive_remap(b, remap,
				  remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    ret = low_type_binop(op, a, tmp, remap, aflags, bflags, remap_flags);
    free_type(tmp);

    return ret;

  case TWOT(PIKE_T_TRANSITIVE, PIKE_T_TRANSITIVE):
    type_stack_mark();
    push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    push_remap_markers(a, remap, remap_flags);
    push_binop(op);
    ret = pop_unfinished_type();
    return ret;

  case TWOT(T_FUNCTION, PIKE_T_OPERATOR):
  case TWOT(PIKE_T_OPERATOR, T_FUNCTION):
  case TWOT(T_MANY, PIKE_T_OPERATOR):
  case TWOT(PIKE_T_OPERATOR, T_MANY):
    type_stack_mark();
    push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    push_remap_markers(a, remap, remap_flags);
    push_binop(op);

    return pop_unfinished_type();

  case TWOT(T_FUNCTION, T_FUNCTION):
  case TWOT(T_FUNCTION, T_MANY):
  case TWOT(T_MANY, T_FUNCTION):
  case TWOT(T_MANY, T_MANY):
    {
      int nargs;
      struct pike_type *ai = a;
      struct pike_type *bi = b;
      enum pt_cmp_flags avoidable = 0;
      enum pt_cmp_flags bvoidable = 0;

      if ((b->type == T_MANY) && !b->car &&
	  ((b->cdr == mixed_type_string) || (b->cdr == any_type_string))) {
	/* Common case.
	 * function(__unknown__...:mixed) or function(__unknown__...:mixed|void)
	 */
	if (op == PT_BINOP_AND) {
	  return remap_markers(a, remap, remap_flags);
	}
	return NULL;
      }
      if ((a->type == T_MANY) && !a->car &&
	  ((a->cdr == mixed_type_string) || (a->cdr == any_type_string))) {
	/* Common case.
	 * function(__unknown__...:mixed) or function(__unknown__...:mixed|void)
	 */
	if (op == PT_BINOP_AND) {
	  return remap_markers(b, remap,
			       remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	}
	add_ref(a);
	return a;
      }

      if ((aflags|bflags) & PT_FLAG_CMP_INEXACT_FUN) {
	avoidable |= PT_FLAG_CMP_INEXACT_ARG;
	bvoidable |= PT_FLAG_CMP_INEXACT_ARG;

	aret = mixed_type_string;
	bret = mixed_type_string;
      }

      type_stack_mark();

      switch(op) {
      case PT_BINOP_AND:
	/* NB: For simplicity in the (common case)
	 *       many(assign(m, mixed), m),
	 *     we expand the many node (as required) to
	 *       function(assign(m, mixed), many(assign(m, mixed), m)),
	 *     and leave it to the evaluator to join the multiple
	 *     assignments with or. The alternative (and stricter) would
	 *     be to allocate a new marker for each step of the expansion
	 *     and to have explicit or nodes:
	 *       function(assign(m1, mixed),
	 *                many(assign(m2, mixed), or(m1, m2))).
	 */
	while(1) {
	  /* Invariant:
	   *   ai->type and bi->type are either T_FUNCTION or T_MANY.
	   */

	  /* Check the argument. */

	  /* NB: The MANY argument is always voidable. */
	  if (ai->type == T_MANY) avoidable |= PT_FLAG_CMP_VOIDABLE;
	  if (bi->type == T_MANY) bvoidable |= PT_FLAG_CMP_VOIDABLE;

#if 0
	  fprintf(stderr, "arg_check(op: 0x%x, ", op);
	  simple_describe_type(ai);
	  fprintf(stderr, " (%d), ", avoidable);
	  simple_describe_type(bi);
	  fprintf(stderr, " (%d))\n\n", bvoidable);
#endif

	  /* FIXME: Use implicit nullable for legacy types? */
	  if (((ai->flags|bi->flags) & PT_FLAG_ASSIGN) &&
	      !(remap_flags & PT_FLAG_REMAP_NO_STORE_MARKERS)) {
	    /* Make sure that markers are set properly. */
	    tmp = low_type_binop(PT_BINOP_AND, ai->car, bi->car, remap,
				 avoidable, bvoidable,
				 remap_flags);
	    if (!tmp) {
	      remap_flags |= PT_FLAG_REMAP_NO_STORE_MARKERS;
	    } else free_type(tmp);
	  }
	  /* NOTE: Intentional use of PT_BINOP_OR below!
	   *       Note that for function types a larger type for
	   *       the arguments implies that the function type
	   *       is stricter. This is a DeMorgan-style effect
	   *       due to the implicit ALL and EXIST operators
	   *       for arguments in function types. Eg there are
	   *       many more functions that accept 0 as an argument
	   *       than there are functions that accept any integer.
	   *       Thus function(int:mixed) is a stricter type
	   *       than function(zero:mixed).
	   */
	  tmp = low_type_binop(PT_BINOP_OR, ai->car, bi->car, remap,
			       avoidable, bvoidable,
			       remap_flags | PT_FLAG_REMAP_NO_STORE_MARKERS);

	  /* Advance to the next argument. */
	  if (ai->type == T_FUNCTION) {
	    ai = ai->cdr;
	  }
	  if (bi->type == T_FUNCTION) {
	    bi = bi->cdr;
	  }
	  if ((ai->type != T_FUNCTION) && (ai->type != T_MANY)) {
	    if (aret) {
	      Pike_fatal("Unsupported type operation.\n");
	    }
	    free_type(tmp);
	    break;
	  }
	  if ((bi->type != T_FUNCTION) && (bi->type != T_MANY)) {
	    if (bret) {
	      Pike_fatal("Unsupported type operation.\n");
	    }
	    free_type(tmp);
	    break;
	  }

	  if (remap_flags & PT_FLAG_REMAP_TRACE) {
	    fprintf(stderr, "tmp: ");
	    simple_describe_type(tmp);
	    fprintf(stderr, "\n");
	  }

	  push_finished_type(tmp);
	  free_type(tmp);

	  if (avoidable & bvoidable & PT_FLAG_CMP_VOIDABLE) {
	    /* Time to check the return types. */

	    if (!aret) aret = ai->cdr;
	    if (!bret) bret = bi->cdr;

	    tmp = low_type_binop(op, aret, bret, remap,
				 PT_FLAG_CMP_VOID_IS_ZERO,
				 PT_FLAG_CMP_VOID_IS_ZERO,
				 remap_flags);

	    if (remap_flags & PT_FLAG_REMAP_TRACE) {
	      fprintf(stderr, "ret_tmp: ");
	      simple_describe_type(tmp);
	      fprintf(stderr, "\n");
	    }
	    if (!tmp) goto function_fail;

	    nargs = peek_stack_mark();

	    push_finished_type(tmp);
	    free_type(tmp);

	    nargs--;
	    push_reverse_type(T_MANY);

	    while (nargs--) {
	      push_reverse_type(T_FUNCTION);
	    }

	    return pop_unfinished_type();
	  }
	}
	break;

      case PT_BINOP_MINUS:
	/* Subtraction (A - B)
	 *
	 * T_FUNCTION(A, X) - T_FUNCTION(B, Y)  ==
	 *
	 *   B - A ==   &&  X - Y == 
	 *		 ==>  				# Full overlap
	 *
	 *   B - A ==   &&  X - Y == Z			# Argument overlap
	 *               ==>  T_FUNCTION(A, Z)		# (Recurse)
	 *
	 *   B - A == B  ==>  T_FUNCTION(A, X)		# No overlap
	 *						# No need to recurse
	 *
	 *   B - A == C  &&  X - Y == Z			# Partial overlap
	 *		 ==>  T_FUNCTION(A - B, X) |	# Keep and
	 *		      T_FUNCTION(A, Z)		# Recurse
	 *
	 *   T_FUNCTION(A - B, X) | T_FUNCTION(A, X - Y)
	 *
	 * T_MANY analogous with T_MANY substituted for T_FUNCTION above.
	 */

	/* Check the argument. */

	/* NB: The MANY argument is always voidable. */
	if (ai->type == T_MANY) avoidable |= PT_FLAG_CMP_VOIDABLE;
	if (bi->type == T_MANY) bvoidable |= PT_FLAG_CMP_VOIDABLE;

#if 0
	fprintf(stderr, "arg_check(op: 0x%x, ", op);
	simple_describe_type(ai);
	fprintf(stderr, " (%d), ", avoidable);
	simple_describe_type(bi);
	fprintf(stderr, " (%d))\n\n", bvoidable);
#endif

	if (!bi->car) {
	  /* Common case */
	  tmp = NULL;
	} else {
	  /* FIXME: Use implicit nullable for legacy types?
	   * FIXME: What about PT_FLAG_CMP_VOID_IS_NULL?
	   */
	  tmp = low_type_binop(PT_BINOP_MINUS, bi->car, ai->car, remap,
			       bvoidable | PT_FLAG_CMP_INSEPARABLE,
			       avoidable | PT_FLAG_CMP_INSEPARABLE,
			       remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	  if (tmp) {
	    /* No or not full overlap. */

	    if ((ai->car == void_type_string) &&
		(aflags & PT_FLAG_CMP_IGNORE_EXTRA_ARGS)) {
	      /* End of argument list for a, and it is valid to end the
	       * argument list here (void matched), and a implicitly
	       * ignores any further arguments.
	       */
	      free_type(tmp);
	      tmp = NULL;
	    } else {
	      if (tmp == bi->car) {
		/* Common case, no overlap. */
		pop_stack_mark();
		free_type(tmp);

		return remap_markers(ai, remap, remap_flags);
	      }
	      free_type(tmp);

	      tmp = low_type_binop(PT_BINOP_MINUS, ai->car, bi->car, remap,
				   avoidable | PT_FLAG_CMP_INSEPARABLE,
				   bvoidable | PT_FLAG_CMP_INSEPARABLE,
				   remap_flags);

	      if (tmp == ai->car) {
		/* No overlap.
		 *
		 * The first overlap test likely failed due
		 * to remapping.
		 */
		pop_stack_mark();
		free_type(tmp);

		return remap_markers(ai, remap, remap_flags);
	      }

	      push_remap_markers(ai->cdr, remap, remap_flags);
	      push_finished_type(tmp);
	      push_type(ai->type);
	      free_type(tmp);
	      tmp = NULL;
	    }
	  }
	}

	/* Advance to the next argument. */
	if (ai->type == T_FUNCTION) {
	  ai = ai->cdr;
	}
	if (bi->type == T_FUNCTION) {
	  bi = bi->cdr;
	}
	if ((ai->type != T_FUNCTION) && (ai->type != T_MANY)) {
	  if (aret) {
	    Pike_fatal("Unsupported type operation.\n");
	  }
	}
	if ((bi->type != T_FUNCTION) && (bi->type != T_MANY)) {
	  if (bret) {
	    Pike_fatal("Unsupported type operation.\n");
	  }
	}

	if (avoidable & bvoidable & PT_FLAG_CMP_VOIDABLE) {
	  /* Both a & b are T_MANY. Check the return type. */
	  if (!aret) aret = ai->cdr;
	  if (!bret) bret = bi->cdr;

	  /* NB: Ignore the return type if matching against void or mixed. */
	  if ((bret != void_type_string) && (bret != mixed_type_string)) {
	    tmp = low_type_binop(PT_BINOP_MINUS, aret, bret, remap,
				 PT_FLAG_CMP_VOIDABLE|PT_FLAG_CMP_VOID_IS_ZERO,
				 0, remap_flags);

	    if (tmp) {
	      /* Not full overlap for the return value. */
	      push_finished_type(tmp);
	      push_remap_markers(ai->car, remap, remap_flags);
	      push_type(T_MANY);
	      free_type(tmp);
	    } else {
	      push_type(PIKE_T_UNKNOWN);
	    }
	  } else {
	    push_type(PIKE_T_UNKNOWN);
	  }
	} else {
	  /* Recurse. */
	  tmp = low_type_binop(PT_BINOP_MINUS, ai, bi, remap,
			       aflags, bflags, remap_flags);

	  if (tmp) {
	    push_finished_type(tmp);
	    push_remap_markers(a->car, remap, remap_flags);
	    push_type(PIKE_T_FUNCTION);
	    free_type(tmp);
	  } else {
	    push_type(PIKE_T_UNKNOWN);
	  }
	}

	while (peek_stack_mark() > 1) {
	  push_type(T_OR);
	}

	return pop_unfinished_type();

      default:
        /* Fall back to the complex function case below. */
	break;
      }

      /* Either of ai and/or bi is a complex type. */

      if (op != PT_BINOP_AND) {
	compiler_discard_type();

	push_remap_markers(b, remap,
			   remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	push_remap_markers(a, remap, remap_flags);

	push_binop(op);

	return pop_unfinished_type();
      }

      nargs = peek_stack_mark();
#if 0
      fprintf(stderr, "op: 0x%04x\n"
	      "ai: ", op);
      simple_describe_type(ai);
      fprintf(stderr, "\nbi: ");
      simple_describe_type(bi);
      fprintf(stderr, "\n");
#endif
      tmp = low_type_binop(op, ai, bi, remap, aflags, bflags, remap_flags);
      push_finished_type(tmp);
      free_type(tmp);

      while (nargs--) {
	push_reverse_type(T_FUNCTION);
      }

      return pop_unfinished_type();

    function_fail:
      low_discard_type();

      return NULL;
    }

  case TWOT(T_VOID, T_ZERO):
    if (aflags & PT_FLAG_CMP_VOID_IS_ZERO) {
      a = zero_type_string;
      goto full_loop;
    }
    if (op & PT_BINOP_AND) {
      if (bflags & PT_FLAG_CMP_VOIDABLE) {
	/* Return void. */
	add_ref(a);
	return a;
      }
      if (aflags & PT_FLAG_CMP_NULLABLE) {
	/* Return zero. */
	add_ref(b);
	return b;
      }
    } else if (op & PT_BINOP_MINUS) {
      if (!(bflags & PT_FLAG_CMP_VOIDABLE)) {
	/* Return void. */
	add_ref(a);
	return a;
      }
    }
    return NULL;

  case TWOT(T_ZERO, T_VOID):
    if (bflags & PT_FLAG_CMP_VOID_IS_ZERO) {
      b = zero_type_string;
      goto full_loop;
    }
    if (op & PT_BINOP_AND) {
      if (aflags & PT_FLAG_CMP_VOIDABLE) {
	/* Return void. */
	add_ref(b);
	return b;
      }
      if (bflags & PT_FLAG_CMP_NULLABLE) {
	/* Return zero. */
	add_ref(a);
	return a;
      }
    } else if (op & PT_BINOP_MINUS) {
      if (!(bflags & PT_FLAG_CMP_NULLABLE)) {
	/* Return zero. */
	add_ref(a);
	return a;
      }
    }
    return NULL;

  case TWOT(T_ZERO, T_INT):
    if (!(bflags & PT_FLAG_CMP_NULLABLE)) {
      a = int0_type_string;
    }
    break;

  case TWOT(T_INT, T_ZERO):
    if (!(aflags & PT_FLAG_CMP_NULLABLE)) {
      b = int0_type_string;
    }
    break;

  case TWOT(T_TYPE, T_TYPE):
    tmp = low_type_binop(op, a->car, b->car, remap,
			 0, 0, remap_flags);
    if (!tmp) return NULL;

    type_stack_mark();
    push_finished_type(tmp);
    if (a->type == b->type) {
      push_type(a->type);
    } else {
      push_type(T_TYPE);
    }
    free_type(tmp);
    return pop_unfinished_type();

  case TWOT(T_TYPE, T_PROGRAM):
  case TWOT(T_TYPE, T_FUNCTION):
  case TWOT(T_TYPE, T_MANY):
  case TWOT(T_TYPE, PIKE_T_TRANSITIVE):
    type_stack_mark();
    push_finished_type(a->car);
    push_type(T_VOID);
    push_type(T_MANY);
    push_type(T_MIXED);
    push_type(T_FUNCTION);
    tmp = pop_unfinished_type();

    ret = low_type_binop(op, tmp, b, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

  case TWOT(T_FUNCTION, T_TYPE):
  case TWOT(T_MANY, T_TYPE):
  case TWOT(PIKE_T_TRANSITIVE, T_TYPE):
    type_stack_mark();
    push_finished_type(b->car);
    push_type(T_VOID);
    push_type(T_MANY);
    push_type(T_MIXED);
    push_type(T_FUNCTION);
    tmp = pop_unfinished_type();

    ret = low_type_binop(op, a, tmp, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

#if 0
    /* FIXME: */
  case PIKE_T_RING:
#endif
  }

  if (a->type != b->type) {
    if (a->type == T_VOID) {
      if (bflags & PT_FLAG_CMP_VOIDABLE) {
	b = a;
	goto recur;
      }
      if (aflags & PT_FLAG_CMP_VOID_IS_ZERO) {
	a = zero_type_string;
	goto recur;
      }
      if ((aflags & PT_FLAG_CMP_NULLABLE) && (op == PT_BINOP_AND)) {
	a = zero_type_string;
	goto recur;
      }
    }
    if (b->type == T_VOID) {
      if (op & PT_BINOP_AND) {
	if (aflags & PT_FLAG_CMP_VOIDABLE) {
	  a = b;
	  goto recur;
	}
      }
      if ((bflags & PT_FLAG_CMP_VOID_IS_ZERO) ||
	  ((bflags & PT_FLAG_CMP_NULLABLE) && (a->type != T_MIXED))) {
	b = zero_type_string;
	goto recur;
      }
    }

    if (a->type != T_VOID) {
      if (b->type == T_MIXED) {
	switch(op & PT_BINOP_B) {
	case 0:
	  return NULL;
	case PT_BINOP_AND:
	  return remap_markers(a, remap, remap_flags);
	case PT_BINOP_INVERSE_MINUS:
	  if (bflags & PT_FLAG_CMP_INSEPARABLE) {
	    return NULL;
	  }
	  type_stack_mark();
	  push_remap_markers(a, remap, remap_flags);
	  push_type(T_NOT);
	  return pop_unfinished_type();
	default:
	  return remap_markers(b, remap,
			       remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	}
      }
    }
    if (b->type != T_VOID) {
      if (a->type == T_MIXED) {
	switch(op & PT_BINOP_A) {
	case 0:
	  return NULL;
	case PT_BINOP_AND:
	  return remap_markers(b, remap,
			       remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	case PT_BINOP_MINUS:
	  if (aflags & PT_FLAG_CMP_INSEPARABLE) {
	    return NULL;
	  }
	  type_stack_mark();
	  push_remap_markers(b, remap,
			     remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	  push_type(T_NOT);
	  return pop_unfinished_type();
	default:
	  return remap_markers(a, remap, remap_flags);
	}
      }
    }

    if (a->type == T_NOT) {
      /* Rotate the opcode 2 bits.
       *
       * This converts A to ~A and vice versa.
       */
      op = ((op << 2) | (op >> 2)) & PT_BINOP_ALL;
      return low_type_binop(op, a->car, b, remap,
			    aflags, bflags, remap_flags);
    }
    if (b->type == T_NOT) {
      /* Swap the bits of the opcode pairwise.
       *
       * This converts B to ~B and vice versa.
       */
      op = (((op & PT_BINOP_B) << 1) | ((op >> 1) & PT_BINOP_B)) & PT_BINOP_ALL;
      return low_type_binop(op, a, b->car, remap,
			    aflags, bflags, remap_flags);
    }

    /* NB: TWOT(T_INT, T_ZERO) and TWOT(T_ZERO, T_INT) have
     *     been handled above.
     */
    if (((a->type == T_ZERO) || (a->type == T_INT)) &&
	(bflags & PT_FLAG_CMP_NULLABLE)) {
      /* FIXME: Only valid for AND and MINUS. */
      b = zero_type_string;
      bflags &= ~PT_FLAG_CMP_NULLABLE;
      goto recur;
    }
    if (((b->type == T_ZERO) || (b->type == T_INT)) &&
	(aflags & PT_FLAG_CMP_NULLABLE)) {
      /* FIXME: Only valid for AND and MINUS. */
      if (op == PT_BINOP_AND) {
	a = zero_type_string;
      }
      aflags &= ~PT_FLAG_CMP_NULLABLE;
      goto recur;
    }

    if (((a->type & PIKE_T_MASK) == PIKE_T_OPERATOR) ||
	((b->type & PIKE_T_MASK) == PIKE_T_OPERATOR)) {
      type_stack_mark();
      push_remap_markers(b, remap,
			 remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      push_remap_markers(a, remap, remap_flags);
      push_binop(op);
      return pop_unfinished_type();
    }

    /* NB: We know that a and b do not intersect, so the operations
     *     come in pairs and complementary pairs.
     */
    type_stack_mark();
    switch(op) {
    case PT_BINOP_NONE:
    case PT_BINOP_AND:
      pop_stack_mark();
      return NULL;
    case PT_BINOP_NAND:
    case PT_BINOP_ALL:
      push_type(T_MIXED);
      break;

    case PT_BINOP_MINUS:
    case PT_BINOP_A:
      push_remap_markers(a, remap, remap_flags);
      break;
    case PT_BINOP_NOT_A:
    case PT_BINOP_NOT_A_OR_B:
      if (aflags & PT_FLAG_CMP_INSEPARABLE) {
	pop_stack_mark();
	return NULL;
      }
      push_remap_markers(a, remap, remap_flags);
      push_type(T_NOT);
      break;

    case PT_BINOP_INVERSE_MINUS:
    case PT_BINOP_B:
      push_remap_markers(b, remap,
			 remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      break;
    case PT_BINOP_NOT_B:
    case PT_BINOP_A_OR_NOT_B:
      if (bflags & PT_FLAG_CMP_INSEPARABLE) {
	pop_stack_mark();
	return NULL;
      }
      push_remap_markers(b, remap,
			 remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      push_type(T_NOT);
      break;

    case PT_BINOP_OR:
    case PT_BINOP_XOR:
      push_remap_markers(b, remap,
			 remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      push_remap_markers(a, remap, remap_flags);
      push_type(T_OR);
      break;
    case PT_BINOP_NOR:
    case PT_BINOP_XNOR:
      if ((aflags | bflags) & PT_FLAG_CMP_INSEPARABLE) {
	pop_stack_mark();
	return NULL;
      }
      push_remap_markers(b, remap,
			 remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      push_remap_markers(a, remap, remap_flags);
      push_type(T_OR);
      push_type(T_NOT);
      break;
    }

    return pop_unfinished_type();
  }

  /* Invariant: a->type == b->type. */

  if ((aflags|bflags) & PT_FLAG_CMP_NO_SUBTYPES) {
    /* No need to look at the subtypes or ranges. */
    goto done;
  }

  switch(a->type) {
  case T_NOT:
    /* Reverse the order of the bits.
     *
     *   1 <=> 8	AND <=> NOR
     *   2 <=> 4	MINUS <=> INVERSE_MINUS
     *
     * This inverts both A and B.
     */
    {
      int i;
      enum pt_binop newop = 0;
      for (i = 0; i < 4; i++) {
	newop <<= 1;
	if (op & 1) {
	  newop |= 1;
	}
	op >>= 1;
      }
      return low_type_binop(newop, a->car, b->car, remap,
			    aflags, bflags, remap_flags);
    }

  case T_VOID:
  case T_ZERO:
  case T_FLOAT:
    /* Not reached. Should be handled by the a == b test at
     * the beginning of the function.
     */
    Pike_fatal("Type hashing has duplicates.\n");
    return NULL;

  case T_INT:
    {
      INT32 bounds[6] = { MIN_INT32, };	/* Start sentinel. */
      int ab[6] = { 0, 0, };
      int i;
      int nbounds = 1;
      INT32 bound;

      /*
       * Implementation notes:
       *
       * bounds[] contains the values where the set changes in order
       * from smallest to largest. It always contains at least the
       * start sentinel value (MIN_INT32) at position 0.
       *
       * ab[] contains one bit for each of a and b indicating whether
       * the corresponding value in bounds[] is a member of a and/or b.
       *
       * nbounds contains the number of valid entries in bounds[] and ab[].
       *
       * To avoid issues with overflow and similar the end sentinel
       * (ie MAX_INT32 + 1) is not in bounds[].
       *
       * NB: The bits in ab are selected so that they match
       *     the shifts for the minterms in enum pt_binop.
       *
       * bounds[] and ab[] are created with insert sort.
       */
      bound = CAR_TO_INT(a);
      for (i = nbounds; i-- && bounds[i] > bound;) {
	ab[i] |= 2;
      }
      if (bounds[i] < bound) {
	/* We need to insert a bound. */
	memmove(bounds + i + 1, bounds + i,
		sizeof(bounds[i]) * (nbounds - i));
	memmove(ab + i + 1,
		ab + i, sizeof(ab[i]) * (nbounds - i));
	i++;
	nbounds++;
	bounds[i] = bound;
	ab[i] |= 2;
      } else if (bounds[i] == bound) {
	ab[i] |= 2;
      }

      bound = CDR_TO_INT(a);
      if (bound < MAX_INT32) {
	bound++;
	for (i = nbounds; i-- && bounds[i] > bound;) {
	  ab[i] &= ~2;
	}
	if (bounds[i] < bound) {
	  /* We need to insert a bound. */
	  memmove(bounds + i + 1, bounds + i,
		  sizeof(bounds[i]) * (nbounds - i));
	  memmove(ab + i + 1,
		  ab + i, sizeof(ab[i]) * (nbounds - i));
	  i++;
	  nbounds++;
	  bounds[i] = bound;
	  ab[i] &= ~2;
	} else if (bounds[i] == bound) {
	  ab[i] &= ~2;
	}
      }

      bound = CAR_TO_INT(b);
      for (i = nbounds; i-- && bounds[i] > bound;) {
	ab[i] |= 1;
      }
      if (bounds[i] < bound) {
	/* We need to insert a bound. */
	memmove(bounds + i + 1,
		bounds + i, sizeof(bounds[i]) * (nbounds - i));
	memmove(ab + i + 1,
		ab + i, sizeof(ab[i]) * (nbounds - i));
	i++;
	nbounds++;
	bounds[i] = bound;
	ab[i] |= 1;
      } else if (bounds[i] == bound) {
	ab[i] |= 1;
      }

      bound = CDR_TO_INT(b);
      if (bound < MAX_INT32) {
	bound++;
	for (i = nbounds; i-- && bounds[i] > bound;) {
	  ab[i] &= ~1;
	}
	if (bounds[i] < bound) {
	  /* We need to insert a bound. */
	  memmove(bounds + i + 1, bounds + i,
		  sizeof(bounds[i]) * (nbounds - i));
	  memmove(ab + i + 1,
		  ab + i, sizeof(ab[i]) * (nbounds - i));
	  i++;
	  nbounds++;
	  bounds[i] = bound;
	  ab[i] &= ~1;
	} else if (bounds[i] == bound) {
	  ab[i] &= ~1;
	}
      }

      type_stack_mark();

      for (i = 0; i < nbounds;) {
	bound = MAX_INT32;
	for (;i < nbounds; i++) {
	  if ((PT_BINOP_NOR >> ab[i]) & op) {
	    /* Found start of range. */
	    bound = bounds[i];
	    break;
	  }
	}
	if (i == nbounds) break;
	for (; i < nbounds; i++) {
	  if (!((PT_BINOP_NOR >> ab[i]) & op)) {
	    /* Found end of range. */
	    break;
	  }
	}
	if (i < nbounds) {
	  push_int_type(bound, bounds[i]-1);
	} else {
	  push_int_type(bound, MAX_INT32);
	}
      }

      if (remap_flags & PT_FLAG_REMAP_TRACE) {
	fprintf(stderr, "bounds: ");
	for (i = 0; i < nbounds; i++) {
	  fprintf(stderr, "%s%d[0b%d%d]", i?", ":"", bounds[i],
		  (ab[i]>>1) & 1, ab[i] & 1);
	}
	fprintf(stderr, "\n");
	if (!peek_stack_mark()) {
	  fprintf(stderr, "==> NULL\n");
	}
      }

      nbounds = peek_stack_mark();
      if (!nbounds) {
	pop_stack_mark();
	return NULL;
      }

      if ((op == PT_BINOP_MINUS) && (aflags & PT_FLAG_CMP_INSEPARABLE)) {
	if ((nbounds != 1) || (peek_type_stack() != a)) {
	  low_discard_type();
	  return NULL;
	}
      }

      /* NB: Loop starts at 1! */
      for (i = 1; i < nbounds; i++) {
	push_type(T_OR);
      }

      if (remap_flags & PT_FLAG_REMAP_TRACE) {
	fprintf(stderr, "==> ");
	simple_describe_type(peek_type_stack());
	fprintf(stderr, "\n");
      }

      return pop_unfinished_type();
    }

  case T_ARRAY:
  case T_MAPPING:
  case T_STRING:
    {
      enum pt_cmp_flags subflags = 0;

      if ((aflags|bflags) & PT_FLAG_CMP_INEXACT_ARG) {
	subflags = PT_FLAG_CMP_NO_SUBTYPES;
      }

      /* FIXME: Handle PT_FLAG_CMP_INSEPARABLE. */
      /* FIXME: The recursive op should probably be inverted. */
      tmp = low_type_binop(op, a->car, b->car, remap,
			   subflags, subflags, remap_flags);
      if (!tmp && (op == PT_BINOP_AND) && a->car && b->car) {
	return NULL;
      }

      subflags |= PT_FLAG_CMP_VOID_IS_ZERO;

      if ((a->type != T_STRING) && (op != PT_BINOP_AND)) {
	/* Mappings may always result in UNDEFINED on indexing.
	 * Arrays are typically initialized to all zeroes.
	 * Any void values have been up-converted to zeroes.
	 */
	subflags |= PT_FLAG_CMP_NULLABLE;
      }

      tmp2 = low_type_binop(op, a->cdr, b->cdr, remap,
			    subflags, subflags, remap_flags);

      if (!tmp2 && (op == PT_BINOP_MINUS || (a->cdr && b->cdr))) {
	if (op == PT_BINOP_AND) {
	  free_type(tmp);
	  return NULL;
	} else if (!tmp) {
	  return NULL;
	}
      }
    }
    type_stack_mark();
    if (op == PT_BINOP_MINUS) {
      if (tmp) {
	if (tmp2) {
	  /* There is a partial overlap for both indices (car)
	   * and values (cdr). Keep the original types and
	   * defer the operation to later.
	   */
	  free_type(tmp2);
	  push_remap_markers(a, remap, remap_flags);
	  push_remap_markers(b, remap,
			     remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
	  push_type(T_NOT);
	  push_reverse_type(T_AND);
	} else {
	  push_remap_markers(a->cdr, remap, remap_flags);
	  push_finished_type(tmp);
	  push_type(a->type);
	}
	free_type(tmp);
      } else if (tmp2) {
	push_finished_type(tmp2);
	push_remap_markers(a->car, remap, remap_flags);
	push_type(a->type);
	free_type(tmp2);
      } else {
	push_type(PIKE_T_UNKNOWN);
      }
    } else {
      /* PT_BINOP_AND */
      push_finished_type(tmp);
      push_finished_type(tmp2);
      push_reverse_type(a->type);
      free_type(tmp);
      free_type(tmp2);
    }
    return pop_unfinished_type();

  case T_MULTISET:
  case T_PROGRAM:
  case T_TYPE:
    {
      enum pt_cmp_flags subflags = 0;

      if ((a->type == T_MULTISET) &&
	  ((aflags|bflags) & PT_FLAG_CMP_INEXACT_ARG)) {
	subflags = PT_FLAG_CMP_NO_SUBTYPES;
      }

      /* FIXME: Handle PT_FLAG_CMP_INSEPARABLE. */
      tmp = low_type_binop(op, a->car, b->car, remap,
			   subflags, subflags, remap_flags);
      if (!tmp && ((op != PT_BINOP_AND) || (a->car && b->car))) {
	return NULL;
      }
    }

    type_stack_mark();
    push_finished_type(tmp);
    push_type(a->type);
    free_type(tmp);

    return pop_unfinished_type();

  case T_OBJECT:
    /* FIXME: Handle PT_FLAG_CMP_INSEPARABLE. */
    switch(op) {
    case PT_BINOP_AND:
      if (!a->cdr) {
	add_ref(b);
	return b;
      }
      if (!b->cdr) {
	add_ref(a);
	return a;
      }
      if (a->cdr == b->cdr) {
	/* We know that they differ due to the a == b test at
	 * the befinning of the function. The only way they
	 * can differ is that car differs. There are only two
	 * valid values for car, so select the stricter (ie 'is-a')
	 */
	type_stack_mark();
	push_object_type(1, CDR_TO_INT(a));
	return pop_unfinished_type();
      }
      if (a->car && b->car) {
	/* This is only possible if a->cdr == b->cdr, but that is
	 * handled above.
	 */
	return NULL;
      }
      {
	struct program *ap = id_to_program(CDR_TO_INT(a));
	struct program *bp = id_to_program(CDR_TO_INT(b));

	if (!b->car && implements(ap, bp)) {
	  add_ref(a);
	  return a;
	}
	if (!a->car && implements(bp, ap)) {
	  add_ref(b);
	  return b;
	}
	if ((a->car != b->car) || !is_compatible(ap, bp)) {
	  /* It is not possible to implement a class that
	   * implements both of the classes.
	   */
	  return NULL;
	}
      }
      break;
    case PT_BINOP_MINUS:
      if (!b->cdr) {
	return NULL;
      }
      if (a->cdr) {
	if (a->cdr == b->cdr) {
	  return NULL;
	}
	if (a->car && b->car) {
	  /* This is only possible if a->cdr == b->cdr, but that is
	   * handled above.
	   */
	  add_ref(a);
	  return a;
	}
	{
	  struct program *ap = id_to_program(CDR_TO_INT(a));
	  struct program *bp = id_to_program(CDR_TO_INT(b));

	  if (!b->car && implements(ap, bp)) {
	    return NULL;
	  }
	  if (!is_compatible(ap, bp)) {
	    add_ref(a);
	    return a;
	  }
	}
      }
      break;
    default:
      break;
    }

    type_stack_mark();
    push_finished_type(b);
    push_finished_type(a);
    push_binop(op);
    return pop_unfinished_type();
  }

 done:
  /* Leaf type. Most likely not reached. */
  if (op & PT_BINOP_AND) {
    add_ref(a);
    return a;
  }
  return NULL;
}

struct pike_type *type_binop(enum pt_binop op,
			     struct pike_type *a,
			     struct pike_type *b,
			     enum pt_cmp_flags aflags,
			     enum pt_cmp_flags bflags,
			     enum pt_remap_flags remap_flags)
{
  struct remap_state remap;
  struct pike_type *ret;

#ifdef PIKE_DEBUG
  if (l_flag > 2) {
    remap_flags |= PT_FLAG_REMAP_TRACE;
  }
#endif

  INIT_REMAP_STATE(remap);

  ret = low_type_binop(op, a, b, &remap, aflags, bflags, remap_flags);

  if ((remap.markers[0] || remap.markers[1]) && ret &&
      ((op == PT_BINOP_AND) || (op == PT_BINOP_MINUS))) {
    /* We may need to backpatch marker restrictions. */
#ifdef PIKE_DEBUG
    if (l_flag > 1) {
      fprintf(stderr, "Back-patching markers.\n"
	      "Original result: ");
      simple_describe_type(ret);
      fprintf(stderr, "\nMarkers[0]: ");
      simple_describe_mapping(remap.markers[0]);
      fprintf(stderr, "\nMarkers[1]: ");
      simple_describe_mapping(remap.markers[1]);
      fprintf(stderr, "\n");
    }
#endif
    type_stack_mark();
    push_and_fixup_markers(ret, &remap, remap_flags);
    free_type(ret);
    ret = pop_unfinished_type();
#ifdef PIKE_DEBUG
    if (l_flag > 1) {
      fprintf(stderr, "Result after back-patching: ");
      simple_describe_type(ret);
      fprintf(stderr, "\n");
    }
#endif
  }

  EXIT_REMAP_STATE(remap);

  return ret;
}

/**
 * Low-level subtraction (aka And-not) of two types.
 *
 * Note:
 *   There are two major operating modes; the external, where
 *   the two types have unrelated markers, which then need to
 *   be remapped in the result, and the internal, where the
 *   two types have related markers (this mode is used mainly
 *   when evaluating a type).
 *
 * The internal mode is indicated via the remap state being NULL.
 */
static struct pike_type *low_subtract_types(struct pike_type *a,
					    struct pike_type *b,
					    struct remap_state *remap,
					    enum pt_cmp_flags aflags,
					    enum pt_cmp_flags bflags,
					    enum pt_remap_flags remap_flags)
{
  struct pike_type *tmp, *tmp2, *ret;
  struct pike_type *aret = NULL, *bret = NULL;
  enum pt_cmp_flags avoidable;
  enum pt_cmp_flags bvoidable;

  if (!a || !b) return NULL;

  if (a == b) {
    return NULL;
  }

  /* First check for markers. */
  switch(a->type) {
  case T_ASSIGN:
    {
      int marker = alloc_remap_marker(remap, CAR_TO_INT(a), remap_flags);
      tmp = low_subtract_types(a->cdr, b, remap, aflags, bflags, remap_flags);
      if (tmp) {
	type_stack_mark();
	push_finished_type(tmp);
	push_assign_type(marker);
	free_type(tmp);
	return pop_unfinished_type();
      }
      free_marker(remap, CAR_TO_INT(a), remap_flags);
      return NULL;
    }

  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
    {
      int marker = remap_marker(remap, a->type, remap_flags);
      if (!marker) return NULL;

      tmp = remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      if (!tmp) return NULL;
      type_stack_mark();
      push_finished_type(tmp);
      push_type(T_NOT);
      push_type(marker);
      push_reverse_type(T_AND);
      free_type(tmp);
      return pop_unfinished_type();
    }
  }
  switch(b->type) {
  case T_ASSIGN:
    {
      int marker = alloc_remap_marker(remap, CAR_TO_INT(b),
				      remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      tmp = low_subtract_types(a, b->cdr, remap, aflags, bflags, remap_flags);
      if (tmp) {
	type_stack_mark();
	push_finished_type(tmp);
	push_assign_type(marker);
	free_type(tmp);
	return pop_unfinished_type();
      }
      free_marker(remap, CAR_TO_INT(b),
		  remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      return NULL;
    }

  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
    {
      int marker = remap_marker(remap, b->type,
				remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      if (!marker) return NULL;

      tmp = remap_markers(a, remap, remap_flags);
      if (!tmp) return NULL;
      type_stack_mark();
      push_finished_type(tmp);
      push_type(marker);
      push_type(T_NOT);
      push_reverse_type(T_AND);
      free_type(tmp);
      return pop_unfinished_type();
    }
  }

  /* Attributes and names. */
  switch(a->type) {
  case PIKE_T_NAME:
    tmp = low_subtract_types(a->cdr, b, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_type_name((struct pike_string *)(a->car));
    free_type(tmp);
    return pop_unfinished_type();
  case PIKE_T_ATTRIBUTE:
    tmp = low_subtract_types(a->cdr, b, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_type_attribute((struct pike_string *)(a->car));
    free_type(tmp);
    return pop_unfinished_type();
  case T_SCOPE:
    tmp = low_subtract_types(a->cdr, b, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_scope_type(CAR_TO_INT(a));
    free_type(tmp);
    return pop_unfinished_type();
  }
  switch(b->type) {
  case PIKE_T_NAME:
    tmp = low_subtract_types(a, b->cdr, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    /* FIXME: Is this a good idea? */
    push_type_name((struct pike_string *)(b->car));
    free_type(tmp);
    return pop_unfinished_type();
  case PIKE_T_ATTRIBUTE:
    tmp = low_subtract_types(a, b->cdr, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    /* FIXME: Is this a good idea? */
    push_type_attribute((struct pike_string *)(b->car));
    free_type(tmp);
    return pop_unfinished_type();
  case T_SCOPE:
    tmp = low_subtract_types(a, b->cdr, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_scope_type(CAR_TO_INT(b));
    free_type(tmp);
    return pop_unfinished_type();
  }

  /* Check consolidated types. */
  switch(a->type) {
  case T_OR:
  case T_AND:
    tmp = low_subtract_types(a->car, b, remap, aflags, bflags, remap_flags);
    if (!tmp && (a->type == T_AND)) return NULL;
    tmp2 = low_subtract_types(a->cdr, b, remap, aflags, bflags, remap_flags);
    if (!tmp2) {
      if (a->type == T_OR) return tmp;
      free_type(tmp);
      return NULL;
    }
    if (!tmp) {
      return tmp2;
    }
    type_stack_mark();
    push_finished_type(tmp);
    push_finished_type(tmp2);
    push_reverse_type(a->type);
    free_type(tmp);
    free_type(tmp2);
    return pop_unfinished_type();
  }
  switch(b->type) {
  case T_OR:
    /* DeMorgan
     *
     * a & ~(b1 | b2) <==> a & ~b1 & ~b2
     */
    tmp = low_subtract_types(a, b->car, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    /* NB: We need to remap b->cdr separately to avoid remapping
     *     markers in a and b->car twice.
     */
    tmp2 = remap_markers(b->cdr, remap,
			 remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    ret = low_subtract_types(tmp, tmp2, NULL, aflags, bflags, 0);
    free_type(tmp);
    free_type(tmp2);
    return ret;

  case T_AND:
    /* DeMorgan
     *
     * a & ~(b1 & b2) <==> a & (~b1 | ~b2) <==> (a & ~b1) | (a & ~b2)
     */
    tmp = low_subtract_types(a, b->car, remap, aflags, bflags, remap_flags);
    tmp2 = low_subtract_types(a, b->cdr, remap, aflags, bflags, remap_flags);
    if (!tmp2) return tmp;
    ret = or_pike_types(tmp, tmp2, 0);
    free_type(tmp);
    free_type(tmp2);
    return ret;
  }

  /* NB: Complex types from this point onwards are containers,
   *     and the voidable property does not propagate into them.
   */
  avoidable = aflags & PT_FLAG_CMP_VOIDABLE;
  aflags &= ~PT_FLAG_CMP_VOIDABLE;
  bvoidable = bflags & PT_FLAG_CMP_VOIDABLE;
  bflags &= ~PT_FLAG_CMP_VOIDABLE;

  /* Check implicit casting. */
 loop:
  switch(TWOT(a->type & PIKE_T_MASK, b->type & PIKE_T_MASK)) {
  case TWOT(T_PROGRAM, T_FUNCTION):
  case TWOT(T_PROGRAM, T_MANY):
    aret = a->car;
    a = low_object_lfun_type(aret, LFUN_CREATE);
    if (!a) {
      a = void_function_type_string;
    }
    goto loop;

  case TWOT(T_FUNCTION, T_PROGRAM):
  case TWOT(T_MANY, T_PROGRAM):
    bret = b->car;
    b = low_object_lfun_type(bret, LFUN_CREATE);
    if (!b) {
      b = void_function_type_string;
    }
    goto loop;

  case TWOT(T_OBJECT, T_FUNCTION):
  case TWOT(T_OBJECT, T_MANY):
  case TWOT(T_OBJECT, T_PROGRAM):
  case TWOT(T_OBJECT, PIKE_T_TRANSITIVE):
    a = low_object_lfun_type(a, LFUN_CALL);
    if (!a) return NULL;
    goto loop;

  case TWOT(T_FUNCTION, T_OBJECT):
  case TWOT(T_MANY, T_OBJECT):
  case TWOT(T_PROGRAM, T_OBJECT):
  case TWOT(PIKE_T_TRANSITIVE, T_OBJECT):
    b = low_object_lfun_type(b, LFUN_CALL);
    if (!b) return NULL;
    goto loop;

  case TWOT(PIKE_T_TRANSITIVE, T_FUNCTION):
  case TWOT(PIKE_T_TRANSITIVE, T_MANY):
  case TWOT(PIKE_T_TRANSITIVE, T_PROGRAM):
  case TWOT(PIKE_T_TRANSITIVE, PIKE_T_TRANSITIVE):
    tmp = expand_transitive_remap(a, remap, remap_flags);
    ret = low_subtract_types(tmp, b, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

  case TWOT(T_FUNCTION, PIKE_T_TRANSITIVE):
  case TWOT(T_MANY, PIKE_T_TRANSITIVE):
  case TWOT(T_PROGRAM, PIKE_T_TRANSITIVE):
    tmp = expand_transitive_remap(b, remap,
				  remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    ret = low_subtract_types(a, tmp, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

  case TWOT(T_FUNCTION, PIKE_T_OPERATOR):
  case TWOT(PIKE_T_OPERATOR, T_FUNCTION):
    type_stack_mark();
    push_finished_type(a);
    push_finished_type(b);
    push_type(T_NOT);
    push_reverse_type(T_AND);
    return pop_unfinished_type();

  case TWOT(T_FUNCTION, T_FUNCTION):
  case TWOT(T_FUNCTION, T_MANY):
  case TWOT(T_MANY, T_FUNCTION):
  case TWOT(T_MANY, T_MANY):
    /*
     * function(a1, a2, a3...:aa) & ~function(b1, b2, b3...:bb)
     *
     * <==>
     *
     *   If
     *     All ai & ~bi == ai
     *   Then
     *     function(a1, a2, a3...:aa)
     *
     *   If
     *     All ai & ~bi == 
     *   Then
     *     
     *
     *   Otherwise
     *     Keep for later evaluation.
     */
    {
      struct pike_type *ai = a;
      struct pike_type *bi = b;
      int got_empty = 0;
      int got_full = 0;

      while(1) {
	/* Invariant:
	 *   a->type and b->type are either T_FUNCTION or T_MANY.
	 */
	enum pt_cmp_flags avoidable = 0;
	enum pt_cmp_flags bvoidable = 0;

	/* Check the argument. */

	/* NB: The MANY argument is always voidable. */
	if (ai->type == T_MANY) avoidable |= PT_FLAG_CMP_VOIDABLE;
	if (bi->type == T_MANY) bvoidable |= PT_FLAG_CMP_VOIDABLE;

	tmp = low_subtract_types(ai->car, bi->car, NULL,
				 aflags | avoidable, bflags | bvoidable,
				 remap_flags);
	if (!tmp) {
	  if (got_full) break;
	  got_empty = 1;
	} else {
	  if (tmp == ai) {
	    got_full = 1;
	  } else {
	    free_type(tmp);
	    break;
	  }
	  free_type(tmp);
	  if (got_empty) break;
	}

	if (avoidable && bvoidable) {
	  /* Time to check the return types. */

	  if (!aret) aret = ai->cdr;
	  if (!bret) bret = bi->cdr;

	  tmp = low_subtract_types(aret, bret, NULL, aflags, bflags,
				   remap_flags);
	  if (!tmp) {
	    if (got_full) break;
	    got_empty = 1;
	  } else {
	    if (tmp == aret) {
	      got_full = 1;
	    } else {
	      free_type(tmp);
	      break;
	    }
	    free_type(tmp);
	    if (got_empty) break;
	  }

	  if (!got_full) {
	    return NULL;
	  }

	  type_stack_mark();
	  push_remap_markers(a, remap, remap_flags);
	  return pop_unfinished_type();
	}

	/* Advance to the next argument. */
	if (ai->type == T_FUNCTION) {
	  ai = ai->cdr;
	}
	if (bi->type == T_FUNCTION) {
	  bi = bi->cdr;
	}
	if ((ai->type != T_FUNCTION) && (ai->type != T_MANY)) {
	  break;
	}
	if ((bi->type != T_FUNCTION) && (bi->type != T_MANY)) {
	  break;
	}
      }

      /* Either of a and/or b is a complex type, or a partial overlap. */

      type_stack_mark();
      push_remap_markers(a, remap, remap_flags);
      push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      push_type(T_NOT);
      push_reverse_type(T_AND);

      return pop_unfinished_type();
    }

  case TWOT(T_ZERO, T_INT):
    if ((CAR_TO_INT(b) <= 0) && (CDR_TO_INT(b) >= 0)) {
      return NULL;
    }
    add_ref(a);
    return a;

  case TWOT(T_INT, T_ZERO):
    if ((CAR_TO_INT(a) > 0) || (CDR_TO_INT(a) < 0)) {
      add_ref(a);
      return a;
    }
    type_stack_mark();
    if (CAR_TO_INT(a) < 0) {
      push_int_type(CAR_TO_INT(a), -1);
    }
    if (CDR_TO_INT(a) > 0) {
      push_int_type(1, CDR_TO_INT(a));
      if (CAR_TO_INT(a) < 0) {
	push_reverse_type(T_OR);
      }
    }
    return pop_unfinished_type();

    /* T_TYPE and T_PROGRAM are essentially the same thing. */
  case TWOT(T_TYPE, T_TYPE):
  case TWOT(T_TYPE, T_PROGRAM):
  case TWOT(T_PROGRAM, T_TYPE):
  case TWOT(T_PROGRAM, T_PROGRAM):
    tmp = low_subtract_types(a->car, b->car, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;

    type_stack_mark();
    push_finished_type(tmp);
    if (a->type == b->type) {
      push_type(a->type);
    } else {
      push_type(T_TYPE);
    }
    free_type(tmp);
    return pop_unfinished_type();

  case TWOT(T_TYPE, T_FUNCTION):
  case TWOT(T_TYPE, T_MANY):
  case TWOT(T_TYPE, PIKE_T_TRANSITIVE):
    type_stack_mark();
    push_finished_type(a->car);
    push_type(T_VOID);
    push_type(T_MANY);
    push_type(T_MIXED);
    push_type(T_FUNCTION);
    tmp = pop_unfinished_type();

    ret = low_subtract_types(tmp, b, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

  case TWOT(T_FUNCTION, T_TYPE):
  case TWOT(T_MANY, T_TYPE):
  case TWOT(PIKE_T_TRANSITIVE, T_TYPE):
    type_stack_mark();
    push_finished_type(b->car);
    push_type(T_VOID);
    push_type(T_MANY);
    push_type(T_MIXED);
    push_type(T_FUNCTION);
    tmp = pop_unfinished_type();

    ret = low_subtract_types(a, tmp, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

#if 0
    /* FIXME: */
  case PIKE_T_RING:
#endif
  }

  if (a->type == T_VOID) {
    if (bvoidable) {
      return NULL;
    }
    add_ref(a);
    return a;
  }
  if (b->type == T_VOID) {
    add_ref(a);
    return a;
  }

  if (b->type == T_MIXED) {
    /* NB: a being void has been handled above. */
    return NULL;
  }
  if (a->type == T_MIXED) {
    type_stack_mark();
    push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    push_type(T_NOT);
    return pop_unfinished_type();
  }

  if (b->type == T_NOT) {
    return low_intersect_types(a, b->car, remap, aflags, bflags, remap_flags);
  }
  if (a->type == T_NOT) {
    /* DeMorgan and(not(a), not(b)) <==> not(or(a, b)) */
    type_stack_mark();
    push_remap_markers(a->car, remap, remap_flags);
    push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    push_type(T_OR);
    push_type(T_NOT);
    return pop_unfinished_type();
  }

  if (a->type != b->type) {
    if (((a->type & PIKE_T_MASK) == PIKE_T_OPERATOR) ||
	((b->type & PIKE_T_MASK) == PIKE_T_OPERATOR)) {
      type_stack_mark();
      push_remap_markers(a, remap, remap_flags);
      push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      push_type(T_NOT);
      push_reverse_type(T_AND);
      return pop_unfinished_type();
    }
    add_ref(a);
    return a;
  }

  switch(a->type) {
  case T_VOID:
  case T_ZERO:
  case T_FLOAT:
    /* Not reached. Should be handled by the a == b test at
     * the beginning of the function.
     */
    Pike_fatal("Type hashing has duplicates.\n");
    return NULL;

  case T_INT:
    {
      INT32 alow,blow;
      INT32 ahigh,bhigh;

      alow = CAR_TO_INT(a);
      blow = CAR_TO_INT(b);
      ahigh = CDR_TO_INT(a);
      bhigh = CDR_TO_INT(b);

      if ((blow > ahigh) || (bhigh < alow)) {
	/* No Overlap */
	add_ref(a);
	return a;
      }

      type_stack_mark();
      if (blow > alow) {
	push_int_type(alow, blow - 1);
      }
      if (bhigh < ahigh) {
	push_int_type(bhigh + 1, ahigh);
      }
      switch(peek_stack_mark()) {
      case 2:
	push_type(T_OR);
	break;
      case 1:
	break;
      case 0:
	return NULL;
      }
      return pop_unfinished_type();
    }

  case T_ARRAY:
  case T_MAPPING:
  case T_STRING:
    tmp = low_subtract_types(a->car, b->car, remap,
			     aflags, bflags, remap_flags);
    tmp2 = low_subtract_types(a->cdr, b->cdr, remap,
			      aflags, bflags, remap_flags);
    if (!tmp && !tmp2) return NULL;
    type_stack_mark();
    if (tmp) {
      push_finished_type(a->cdr);
      push_finished_type(tmp);
      push_reverse_type(a->type);
      free_type(tmp);
    }
    if (tmp2) {
      push_finished_type(tmp2);
      push_finished_type(a->car);
      push_reverse_type(a->type);
      free_type(tmp2);
    }
    if (peek_stack_mark() == 2) push_type(T_OR);
    return pop_unfinished_type();

  case T_MULTISET:
  case T_PROGRAM:
  case T_TYPE:
    tmp = low_subtract_types(a->car, b->car, remap,
			     aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_type(a->type);
    return pop_unfinished_type();

  case T_OBJECT:
    if (!b->cdr) {
      return NULL;
    }
    if (a->cdr) {
      if (a->cdr == b->cdr) {
	return NULL;
      }
      if (a->car && b->car) {
	/* This is only possible if a->cdr == b->cdr, but that is
	 * handled above.
	 */
	add_ref(a);
	return a;
      }
      {
	struct program *ap = id_to_program(CDR_TO_INT(a));
	struct program *bp = id_to_program(CDR_TO_INT(b));

	if (!b->car && implements(ap, bp)) {
	  return NULL;
	}
	if (!is_compatible(ap, bp)) {
	  add_ref(a);
	  return a;
	}
      }
    }

    type_stack_mark();
    push_finished_type(b);
    push_type(T_NOT);
    push_finished_type(a);
    push_type(T_AND);
    return pop_unfinished_type();
  }

  /* Leaf type. */
  return NULL;
}

struct pike_type *subtract_types(struct pike_type *a,
				 struct pike_type *b,
				 enum pt_cmp_flags aflags,
				 enum pt_cmp_flags bflags,
				 enum pt_remap_flags remap_flags)
{
  struct remap_state remap;
  struct pike_type *sub_res;

  INIT_REMAP_STATE(remap);

  sub_res = low_subtract_types(a, b, &remap, aflags, bflags, remap_flags);

  EXIT_REMAP_STATE(remap);

  return sub_res;
}

/**
 * Low-level intersection (aka And) of two types.
 *
 * Note:
 *   There are two major operating modes; the external, where
 *   the two types have unrelated markers, which then need to
 *   be remapped in the result, and the internal, where the
 *   two types have related markers (this mode is used mainly
 *   when evaluating a type).
 *
 * The internal mode is indicated via the remap state being NULL.
 */
static struct pike_type *low_intersect_types(struct pike_type *a,
					     struct pike_type *b,
					     struct remap_state *remap,
					     enum pt_cmp_flags aflags,
					     enum pt_cmp_flags bflags,
					     enum pt_remap_flags remap_flags)
{
  struct pike_type *tmp, *tmp2, *ret;
  struct pike_type *aret = NULL, *bret = NULL;
  enum pt_cmp_flags avoidable;
  enum pt_cmp_flags bvoidable;

  if (!a || !b) return NULL;

  if (a == b) {
    /* FIXME: Perform masking of remap_flags here. */
    return remap_markers(a, remap,
			 remap_flags | PT_FLAG_REMAP_BOTH_MARKERS_AND);
  }

  /* First check for markers. */
  switch(a->type) {
  case T_ASSIGN:
    {
      int marker = alloc_remap_marker(remap, CAR_TO_INT(a), remap_flags);
      tmp = low_intersect_types(a->cdr, b, remap, aflags, bflags, remap_flags);
      if (tmp) {
	type_stack_mark();
	push_finished_type(tmp);
	push_assign_type(marker);
	free_type(tmp);
	return pop_unfinished_type();
      }
      free_marker(remap, CAR_TO_INT(a), remap_flags);
      return NULL;
    }
  }
  switch(b->type) {
  case T_ASSIGN:
    {
      int marker = alloc_remap_marker(remap, CAR_TO_INT(b),
				      remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      tmp = low_intersect_types(a, b->cdr, remap, aflags, bflags, remap_flags);
      if (tmp) {
	type_stack_mark();
	push_finished_type(tmp);
	push_assign_type(marker);
	free_type(tmp);
	return pop_unfinished_type();
      }

      free_marker(remap, CAR_TO_INT(b),
		  remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      return NULL;
    }
  }

  /* Attributes and names. */
  switch(a->type) {
  case PIKE_T_NAME:
    tmp = low_intersect_types(a->cdr, b, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_type_name((struct pike_string *)(a->car));
    free_type(tmp);
    return pop_unfinished_type();
  case PIKE_T_ATTRIBUTE:
    tmp = low_intersect_types(a->cdr, b, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_type_attribute((struct pike_string *)(a->car));
    free_type(tmp);
    return pop_unfinished_type();
  case T_SCOPE:
    tmp = low_intersect_types(a->cdr, b, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_scope_type(CAR_TO_INT(a));
    free_type(tmp);
    return pop_unfinished_type();
  }
  switch(b->type) {
  case PIKE_T_NAME:
    tmp = low_intersect_types(a, b->cdr, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_type_name((struct pike_string *)(b->car));
    free_type(tmp);
    return pop_unfinished_type();
  case PIKE_T_ATTRIBUTE:
    tmp = low_intersect_types(a, b->cdr, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_type_attribute((struct pike_string *)(b->car));
    free_type(tmp);
    return pop_unfinished_type();
  case T_SCOPE:
    tmp = low_intersect_types(a, b->cdr, remap, aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_scope_type(CAR_TO_INT(b));
    free_type(tmp);
    return pop_unfinished_type();
  }

  /* Check consolidated types. */
  switch(a->type) {
  case T_OR:
    tmp = low_intersect_types(a->car, b, remap, aflags, bflags, remap_flags);
    tmp2 = low_intersect_types(a->cdr, b, remap, aflags, bflags, remap_flags);
    if (!tmp2) return tmp;
    if (!tmp) return tmp2;

    type_stack_mark();
    push_finished_type(tmp);
    push_finished_type(tmp2);
    push_reverse_type(T_OR);
    free_type(tmp);
    free_type(tmp2);
    return pop_unfinished_type();

  case T_AND:
    /* NB: Attempt to avoid keeping the result from inverted types,
     *     in order to reduce type expansion.
     */
    if (a->car->type == T_NOT) {
      tmp2 = low_intersect_types(a->cdr, b, remap, aflags, bflags, remap_flags);
      if (!tmp2) return NULL;
      tmp = low_intersect_types(a->car, b, remap, aflags, bflags, remap_flags);
      if (!tmp) {
	free_type(tmp2);
	return NULL;
      }
      free_type(tmp);
      tmp = remap_markers(a->car, remap, remap_flags);
    } else {
      tmp = low_intersect_types(a->car, b, remap, aflags, bflags, remap_flags);
      if (!tmp) return NULL;
      tmp2 = low_intersect_types(a->cdr, b, remap, aflags, bflags, remap_flags);
      if (!tmp2) {
	free_type(tmp);
	return NULL;
      }
      if (a->cdr->type == T_NOT) {
	free_type(tmp2);
	tmp2 = remap_markers(a->cdr, remap, remap_flags);
      }
    }

    type_stack_mark();
    push_finished_type(tmp);
    push_finished_type(tmp2);
    push_reverse_type(T_AND);
    free_type(tmp);
    free_type(tmp2);
    return pop_unfinished_type();
  }
  switch(b->type) {
  case T_OR:
    tmp = low_intersect_types(a, b->car, remap, aflags, bflags, remap_flags);
    tmp2 = low_intersect_types(a, b->cdr, remap, aflags, bflags, remap_flags);
    if (!tmp2) return tmp;
    if (!tmp) return tmp2;

    type_stack_mark();
    push_finished_type(tmp);
    push_finished_type(tmp2);
    push_reverse_type(T_OR);
    free_type(tmp);
    free_type(tmp2);
    return pop_unfinished_type();

  case T_AND:
    /* NB: Attempt to avoid keeping the result from inverted types,
     *     in order to reduce type expansion.
     */
    if (b->car->type == T_NOT) {
      tmp = low_intersect_types(a, b->cdr, remap, aflags, bflags, remap_flags);
      if (!tmp) return NULL;
      tmp2 = low_intersect_types(a, b->car, remap, aflags, bflags, remap_flags);
      if (tmp2) {
	free_type(tmp2);
	tmp2 = remap_markers(b->car, remap,
			     remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      }
    } else {
      tmp = low_intersect_types(a, b->car, remap, aflags, bflags, remap_flags);
      if (!tmp) return NULL;
      tmp2 = low_intersect_types(a, b->cdr, remap, aflags, bflags, remap_flags);
      if (tmp2 && (b->cdr->type == T_NOT)) {
	free_type(tmp2);
	tmp2 = remap_markers(b->cdr, remap,
			     remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      }
    }
    if (!tmp2) {
      free_type(tmp);
      return NULL;
    }

    type_stack_mark();
    push_finished_type(tmp);
    push_finished_type(tmp2);
    push_reverse_type(T_AND);
    free_type(tmp);
    free_type(tmp2);
    return pop_unfinished_type();
  }

  /* NB: Complex types from this point onwards are containers,
   *     and the voidable property does not propagate into them.
   */
  avoidable = aflags & PT_FLAG_CMP_VOIDABLE;
  aflags &= ~PT_FLAG_CMP_VOIDABLE;
  bvoidable = bflags & PT_FLAG_CMP_VOIDABLE;
  bflags &= ~PT_FLAG_CMP_VOIDABLE;

  /* Check implicit casting. */
 loop:
  switch(TWOT(a->type & PIKE_T_MASK, b->type & PIKE_T_MASK)) {
  case TWOT(T_PROGRAM, T_FUNCTION):
  case TWOT(T_PROGRAM, T_MANY):
    aret = a->car;
    a = low_object_lfun_type(aret, LFUN_CREATE);
    if (!a) {
      a = void_function_type_string;
    }
    goto loop;

  case TWOT(T_FUNCTION, T_PROGRAM):
  case TWOT(T_MANY, T_PROGRAM):
    bret = b->car;
    b = low_object_lfun_type(bret, LFUN_CREATE);
    if (!b) {
      b = void_function_type_string;
    }
    goto loop;

  case TWOT(T_OBJECT, T_FUNCTION):
  case TWOT(T_OBJECT, T_MANY):
  case TWOT(T_OBJECT, T_PROGRAM):
  case TWOT(T_OBJECT, PIKE_T_TRANSITIVE):
    a = low_object_lfun_type(a, LFUN_CALL);
    if (!a) return NULL;
    goto loop;

  case TWOT(T_FUNCTION, T_OBJECT):
  case TWOT(T_MANY, T_OBJECT):
  case TWOT(T_PROGRAM, T_OBJECT):
  case TWOT(PIKE_T_TRANSITIVE, T_OBJECT):
    b = low_object_lfun_type(b, LFUN_CALL);
    if (!b) return NULL;
    goto loop;

  case TWOT(PIKE_T_TRANSITIVE, T_FUNCTION):
  case TWOT(PIKE_T_TRANSITIVE, T_MANY):
  case TWOT(PIKE_T_TRANSITIVE, T_PROGRAM):
  case TWOT(PIKE_T_TRANSITIVE, PIKE_T_TRANSITIVE):
    tmp = expand_transitive_remap(a, remap, remap_flags);
    ret = low_intersect_types(tmp, b, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

  case TWOT(T_FUNCTION, PIKE_T_TRANSITIVE):
  case TWOT(T_MANY, PIKE_T_TRANSITIVE):
  case TWOT(T_PROGRAM, PIKE_T_TRANSITIVE):
    tmp = expand_transitive_remap(b, remap,
				  remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
    ret = low_intersect_types(a, tmp, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

  case TWOT(T_FUNCTION, PIKE_T_OPERATOR):
  case TWOT(PIKE_T_OPERATOR, T_FUNCTION):
    type_stack_mark();
    push_finished_type(a);
    push_finished_type(b);
    push_reverse_type(T_AND);
    return pop_unfinished_type();

  case TWOT(T_FUNCTION, T_FUNCTION):
  case TWOT(T_FUNCTION, T_MANY):
  case TWOT(T_MANY, T_FUNCTION):
  case TWOT(T_MANY, T_MANY):
    /* NB: For simplicity in the (common case)
     *       many(assign(m, mixed), m),
     *     we expand the many node (as required) to
     *       function(assign(m, mixed), many(assign(m, mixed), m)),
     *     and leave it to the evaluator to join the multiple
     *     assignments with or. The alternative (and stricter) would
     *     be to allocate a new marker for each step of the expansion
     *     and to have explicit or nodes:
     *       function(assign(m1, mixed), many(assign(m2, mixed), or(m1, m2))).
     */
    {
      int nargs;

      type_stack_mark();
      type_stack_mark();	/* To keep track of the number of args. */

      while(1) {
	/* Invariant:
	 *   a->type and b->type are either T_FUNCTION or T_MANY.
	 */
	enum pt_cmp_flags avoidable = 0;
	enum pt_cmp_flags bvoidable = 0;

	/* Check the argument. */

	/* NB: The MANY argument is always voidable. */
	if (a->type == T_MANY) avoidable |= PT_FLAG_CMP_VOIDABLE;
	if (b->type == T_MANY) bvoidable |= PT_FLAG_CMP_VOIDABLE;

	tmp = low_intersect_types(a->car, b->car, remap,
				  aflags | avoidable,
				  bflags | bvoidable,
				  remap_flags);
	if (!tmp) {
	  if (avoidable && bvoidable) {
	    /* NB: The VOIDABLE flag only affects comparisons with
	     *     explicit void. If both arguments have implicit void,
	     *     and nothing other in common, we arrive here.
	     */
	    push_type(T_VOID);
	  } else {
	    goto function_fail;
	  }
	}
	push_finished_type(tmp);
	free_type(tmp);

	if (avoidable && bvoidable) {
	  /* Time to check the return types. */

	  if (!aret) aret = a->cdr;
	  if (!bret) bret = b->cdr;

	  tmp = low_intersect_types(aret, bret, remap,
				    aflags, bflags, remap_flags);
	  if (!tmp) goto function_fail;

	  nargs = pop_stack_mark();

	  push_finished_type(tmp);
	  free_type(tmp);

	  nargs--;
	  push_reverse_type(T_MANY);

	  while (nargs--) {
	    push_reverse_type(T_FUNCTION);
	  }
	  return pop_unfinished_type();
	}

	/* Advance to the next argument. */
	if (a->type == T_FUNCTION) {
	  a = a->cdr;
	}
	if (b->type == T_FUNCTION) {
	  b = b->cdr;
	}
	if ((a->type != T_FUNCTION) && (a->type != T_MANY)) {
	  if (aret) {
	    Pike_fatal("Unsupported type operation.\n");
	  }
	  break;
	}
	if ((b->type != T_FUNCTION) && (b->type != T_MANY)) {
	  if (bret) {
	    Pike_fatal("Unsupported type operation.\n");
	  }
	  break;
	}
      }

      nargs = pop_stack_mark();

      /* Either of a and/or b is a complex type. */
      tmp = remap_markers(a, remap, remap_flags);
      push_finished_type(tmp);
      free_type(tmp);

      tmp = remap_markers(b, remap, remap_flags);
      push_finished_type(tmp);
      free_type(tmp);

      push_reverse_type(T_AND);

      while (nargs--) {
	push_reverse_type(T_FUNCTION);
      }
      return pop_unfinished_type();

    function_fail:
      low_discard_type();
      pop_stack_mark();
      return NULL;
    }

  case TWOT(T_VOID, T_ZERO):
    /* Return zero. */
    add_ref(b);
    return b;

  case TWOT(T_ZERO, T_VOID):
    /* Return zero. */
    add_ref(a);
    return a;

  case TWOT(T_ZERO, T_INT):
    if ((CAR_TO_INT(b) <= 0) && (CDR_TO_INT(b) >= 0)) {
      add_ref(a);
      return a;
    }
    return NULL;

  case TWOT(T_INT, T_ZERO):
    if ((CAR_TO_INT(a) <= 0) && (CDR_TO_INT(a) >= 0)) {
      add_ref(b);
      return b;
    }
    return NULL;

    /* T_TYPE and T_PROGRAM are essentially the same thing. */
  case TWOT(T_TYPE, T_TYPE):
  case TWOT(T_TYPE, T_PROGRAM):
  case TWOT(T_PROGRAM, T_TYPE):
  case TWOT(T_PROGRAM, T_PROGRAM):
    tmp = low_intersect_types(a->car, b->car, remap,
			      aflags, bflags, remap_flags);
    if (!tmp) return NULL;

    type_stack_mark();
    push_finished_type(tmp);
    if (a->type == b->type) {
      push_type(a->type);
    } else {
      push_type(T_TYPE);
    }
    free_type(tmp);
    return pop_unfinished_type();

  case TWOT(T_TYPE, T_FUNCTION):
  case TWOT(T_TYPE, T_MANY):
  case TWOT(T_TYPE, PIKE_T_TRANSITIVE):
    type_stack_mark();
    push_finished_type(a->car);
    push_type(T_VOID);
    push_type(T_MANY);
    push_type(T_MIXED);
    push_type(T_FUNCTION);
    tmp = pop_unfinished_type();

    ret = low_intersect_types(tmp, b, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

  case TWOT(T_FUNCTION, T_TYPE):
  case TWOT(T_MANY, T_TYPE):
  case TWOT(PIKE_T_TRANSITIVE, T_TYPE):
    type_stack_mark();
    push_finished_type(b->car);
    push_type(T_VOID);
    push_type(T_MANY);
    push_type(T_MIXED);
    push_type(T_FUNCTION);
    tmp = pop_unfinished_type();

    ret = low_intersect_types(a, tmp, remap, aflags, bflags, remap_flags);
    free_type(tmp);
    return ret;

#if 0
    /* FIXME: */
  case PIKE_T_RING:
#endif
  }

  if (a->type == T_VOID) {
    if (bvoidable) {
      add_ref(a);
      return a;
    }
    return NULL;
  }
  if (b->type == T_VOID) {
    if (avoidable) {
      add_ref(b);
      return b;
    }
    return NULL;
  }

  if (a->type == T_MIXED) {
    return remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
  }
  if (b->type == T_MIXED) {
    return remap_markers(a, remap, remap_flags);
  }

  if (a->type == T_NOT) {
    if (b->type == T_NOT) {
      /* DeMorgan and(not(a), not(b)) <==> not(or(a, b)) */
      type_stack_mark();
      push_remap_markers(a->car, remap, remap_flags);
      push_remap_markers(b->car, remap,
			 remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      push_type(T_OR);
      push_type(T_NOT);
      return pop_unfinished_type();
    }
    /* NB: Swapped argument order! */
    return low_subtract_types(b, a->car, remap, bflags, aflags,
			      remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
  }
  if (b->type == T_NOT) {
    return low_subtract_types(a, b->car, remap, aflags, bflags, remap_flags);
  }

  switch(a->type) {
  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
    {
      int marker = remap_marker(remap, a->type, remap_flags);
      if (!marker) return NULL;

      tmp = remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      if (!tmp) return NULL;
      type_stack_mark();
      push_finished_type(tmp);
      push_type(marker);
      push_reverse_type(T_AND);
      free_type(tmp);
      return pop_unfinished_type();
    }
  }
  switch(b->type) {
  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
    {
      int marker = remap_marker(remap, b->type,
				remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      if (!marker) return NULL;

      tmp = remap_markers(a, remap, remap_flags);
      if (!tmp) return NULL;
      type_stack_mark();
      push_finished_type(tmp);
      push_type(marker);
      push_reverse_type(T_AND);
      free_type(tmp);
      return pop_unfinished_type();
    }
  }

  if (a->type != b->type) {
    if (((a->type & PIKE_T_MASK) == PIKE_T_OPERATOR) ||
	((b->type & PIKE_T_MASK) == PIKE_T_OPERATOR)) {
      type_stack_mark();
      push_remap_markers(a, remap, remap_flags);
      push_remap_markers(b, remap, remap_flags ^ PT_FLAG_REMAP_SWAP_MARKERS);
      push_reverse_type(T_AND);
      return pop_unfinished_type();
    }
    return NULL;
  }

  switch(a->type) {
  case T_VOID:
  case T_ZERO:
  case T_FLOAT:
    /* Not reached. Should be handled by the a == b test at
     * the beginning of the function.
     */
    Pike_fatal("Type hashing has duplicates.\n");
    return NULL;

  case T_INT:
    {
      INT32 i1,i2;
      INT32 upper_bound, lower_bound;
      i1 = CDR_TO_INT(a);
      i2 = CDR_TO_INT(b);
      upper_bound = MINIMUM(i1,i2);

      i1 = CAR_TO_INT(a);
      i2 = CAR_TO_INT(b);
      lower_bound = MAXIMUM(i1,i2);

      if (upper_bound < lower_bound) {
	/* No overlap! */
	return NULL;
      }

      type_stack_mark();
      push_int_type(lower_bound, upper_bound);
      return pop_unfinished_type();
    }

  case T_ARRAY:
  case T_MAPPING:
  case T_STRING:
    tmp = low_intersect_types(a->car, b->car, remap,
			      aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    tmp2 = low_intersect_types(a->cdr, b->cdr, remap,
			       aflags, bflags, remap_flags);
    if (!tmp2) {
      free_type(tmp);
      return NULL;
    }
    type_stack_mark();
    push_finished_type(tmp);
    push_finished_type(tmp2);
    push_reverse_type(a->type);
    free_type(tmp);
    free_type(tmp2);
    return pop_unfinished_type();

  case T_MULTISET:
  case T_PROGRAM:
  case T_TYPE:
    tmp = low_intersect_types(a->car, b->car, remap,
			      aflags, bflags, remap_flags);
    if (!tmp) return NULL;
    type_stack_mark();
    push_finished_type(tmp);
    push_type(a->type);
    return pop_unfinished_type();

  case T_OBJECT:
    if (!a->cdr) {
      add_ref(b);
      return b;
    }
    if (!b->cdr) {
      add_ref(a);
      return a;
    }
    if (a->cdr == b->cdr) {
      /* We know that they differ due to the a == b test at
       * the befinning of the function. The only way they
       * can differ is that car differs. There are only two
       * valid values for car, so select the stricter (ie 'is-a')
       */
      type_stack_mark();
      push_object_type(1, CDR_TO_INT(a));
      return pop_unfinished_type();
    }
    if (a->car && b->car) {
      /* This is only possible if a->cdr == b->cdr, but that is
       * handled above.
       */
      return NULL;
    }
    {
      struct program *ap = id_to_program(CDR_TO_INT(a));
      struct program *bp = id_to_program(CDR_TO_INT(b));

      if (!b->car && implements(ap, bp)) {
	add_ref(a);
	return a;
      }
      if (!a->car && implements(bp, ap)) {
	add_ref(b);
	return b;
      }
      if ((a->car == b->car) && is_compatible(ap, bp)) {
	/* Both car must be 0 due to test above.
	 * It is possible to implement a class that
	 * implements both of the classes.
	 */
	type_stack_mark();
	push_finished_type(a);
	push_finished_type(b);
	push_reverse_type(T_AND);
	return pop_unfinished_type();
      }
      return NULL;
    }
  }

  /* Leaf type. */
  add_ref(a);
  return a;
}

struct pike_type *intersect_types(struct pike_type *a,
				  struct pike_type *b,
				  enum pt_cmp_flags aflags,
				  enum pt_cmp_flags bflags,
				  enum pt_remap_flags remap_flags)
{
  struct remap_state remap;
  struct pike_type *and_res;

  INIT_REMAP_STATE(remap);

  and_res = low_intersect_types(a, b, &remap, aflags, bflags, remap_flags);

  EXIT_REMAP_STATE(remap);

  return and_res;
}

/*
 * match two type strings, return zero if they don't match, and return
 * the part of 'a' that _did_ match if it did.
 */
static struct pike_type *low_match_types2(struct pike_type *a,
					  struct pike_type *b,
					  int flags);
static struct pike_type *low_match_types(struct pike_type *a,
					 struct pike_type *b,
					 int flags)
{
  struct pike_type *ret = NULL;
  DECLARE_CYCLIC();
#ifdef PIKE_TYPE_DEBUG
  int e;
  char *s;

  if (l_flag>2) {
    fprintf(stderr, "%*slow_match_types(", indent*2, "");
    simple_describe_type(a);
    fprintf(stderr, ",\n");
    fprintf(stderr, "%*s%s", indent*2, "", "                ");
    simple_describe_type(b);
    fprintf(stderr, ",\n");
    fprintf(stderr, "%*s%s", indent*2, "", "                ");

    if (flags) {
      int f = 0;
      if (flags & A_EXACT) {
	fprintf(stderr, "A_EXACT");
	f = 1;
      }
      if (flags & B_EXACT) {
	if (f) {
	  fprintf(stderr, " | ");
	}
	fprintf(stderr, "B_EXACT");
	f = 1;
      }
      if (flags & NO_MAX_ARGS) {
	if (f) {
	  fprintf(stderr," | ");
	}
	fprintf(stderr, "NO_MAX_ARGS");
	f = 1;
      }
      if (flags & NO_SHORTCUTS) {
	if (f) {
	  fprintf(stderr, " | ");
	}
	fprintf(stderr, "NO_SHORTCUTS");
	f = 1;
      }
    } else {
      fputc('0', stderr);
    }
    fprintf(stderr, ");\n");
    indent++;
  }
#endif

  if ((a == b) || (!a)) {
    ret = a;
    if (ret) add_ref(ret);
  } else {
    ret = BEGIN_CYCLIC(a, b);
    if (!ret) {
      SET_CYCLIC_RET(a);

      ret = low_match_types2(a, b, flags);
    } else {
      add_ref(ret);
    }
    END_CYCLIC();
  }

#ifdef PIKE_TYPE_DEBUG
  if (l_flag>2) {
    indent--;
    fprintf(stderr, "%*s= ", indent*2, "");
    if(ret)
      simple_describe_type(ret);
    else
      fprintf(stderr, "NULL");
    fputc('\n', stderr);
  }
#endif
  return ret;
}

static void push_expand_transitive_type(struct pike_type *cont,
					struct pike_type *trans,
					struct pike_type **markers,
					int num_args)
{
  struct pike_type *tmp;
  TYPE_STACK_DEBUG("expand_transitive");
  switch(cont?(cont->type & PIKE_T_MASK):PIKE_T_UNKNOWN) {
  case PIKE_T_UNKNOWN:
    if (!trans) {
      push_type(PIKE_T_UNKNOWN);
    } else {
      /* A car of __unknown__ is short-hand for having it identical
       * to the cdr.
       */
      push_expand_transitive_type(trans, trans, markers, num_args);
    }
    break;
  case T_OR: case T_AND:
    push_expand_transitive_type(cont->cdr, trans, markers, num_args);
    push_expand_transitive_type(cont->car, trans, markers, num_args);
    push_type(cont->type);
    break;
  case PIKE_T_FUNCTION:
    /*
     * transitive(function(a, b, ...:c), X)
     *
     * ==>
     *
     * function(a, @transitive(function(b, ...:c), X)
     */
    push_expand_transitive_type(cont->cdr, trans, markers, num_args + 1);
    push_finished_type(cont->car);
    push_type(cont->type);
    break;
  case T_MANY:
    if (num_args) {
      /* No need to expand further for now. */
      push_finished_type(trans);
      push_finished_type(cont);
      push_type(PIKE_T_TRANSITIVE);
    } else {
      /* Two cases:
       *
       * transitive(function(:x), function(x, a, b, ...: c))
       *
       * ==>
       *
       * function(:x) | expand(transitive(function(a, b, ...: c),
       *                                  function(x, a, b, ...:c)))
       *
       * And
       *
       * transitive(function(t...:x), function(x, a, b, ...: c))
       *
       * ==>
       *
       * function(t...:x) |
       *   function(t, @transitive(function(t...:x),
       *                           function(x, a, b, c, ...:c)))) |
       *   expand(transitive(function(a, b, ...: c),
       *                     function(x, a, b, ...:c)))
       */
      DECLARE_CYCLIC();

      push_finished_type_with_markers(cont, markers, 0);

      if (!BEGIN_CYCLIC(cont, trans)) {
	struct call_state cs;

	SET_CYCLIC_RET(1);

	/* Check many arg. */
	push_finished_type_with_markers(cont->car, markers, 0);
	if (peek_type_stack() != void_type_string) {
	  push_finished_type(trans);
	  push_finished_type(cont);
	  push_type(PIKE_T_TRANSITIVE);
	  push_reverse_type(PIKE_T_FUNCTION);
	  push_type(T_OR);
	} else {
	  compiler_discard_top_type();
	}

	push_finished_type_with_markers(cont->cdr, markers, 0);
	INIT_CALL_STATE(cs, NULL);
	tmp = low_new_check_call(trans, peek_type_stack(), 0, &cs, NULL);
	FREE_CALL_STATE(cs);
	compiler_discard_top_type();

	if (tmp) {
	  /* Valid recursion. */
	  push_expand_transitive_type(tmp, trans, markers, 0);
	  free_type(tmp);
	  push_type(T_OR);
	}
      }
      END_CYCLIC();
    }
    break;
  case PIKE_T_OPERATOR:
    if (num_args) {
      /* No need to expand futher for now. */
      push_finished_type(trans);
      push_finished_type(cont);
      push_type(PIKE_T_TRANSITIVE);
    } else {
      /* We have no idea. */
      push_type(PIKE_T_MIXED);
    }
    break;
  case PIKE_T_MIXED:
    push_type(PIKE_T_MIXED);
    break;
  case T_VOID:
    push_type(T_VOID);
    break;
  default:
    /* Unsupported. */
    fprintf(stderr, "Attempting to expand unsupported type: ");
    simple_describe_type(cont);
    fprintf(stderr, "\n");
    push_finished_type(function_type_string);
    Pike_fatal("Attempt to expand unsupported type: %d\n", cont->type);
    break;
  }
}

/* Partially expand transitive types, so that eg matching
 * against function types works as expected.
 */
static struct pike_type *expand_transitive(struct pike_type *fun,
					   struct pike_type **markers,
					   int UNUSED(flags))
{
  assert(fun->type == PIKE_T_TRANSITIVE);
  assert(markers);

  type_stack_mark();
  push_expand_transitive_type(fun->car, fun->cdr, markers, 0);

  return pop_unfinished_type();
}

static struct pike_type *low_match_types2(struct pike_type *a,
					  struct pike_type *b,
					  int flags)
{
  int correct_args;
  struct pike_type *ret = NULL;
  struct pike_type *tmp;

#ifdef PIKE_DEBUG
  fatal_check_c_stack(1024);
#endif

  if (!a) {
    if (b) {
      add_ref(b);
      return b;
    }
    return NULL;
  } else if (!b) {
    add_ref(a);
    return a;
  }

  switch(a->type & PIKE_T_MASK)
  {
  case T_AND:
    ret = low_match_types(a->car, b, flags);
    if(!ret) return 0;
    free_type(ret);
    return low_match_types(a->cdr, b, flags);

  case T_OR:
    ret = low_match_types(a->car, b, flags);
    if(ret && !(flags & NO_SHORTCUTS)) return ret;
    if(ret)
    {
      struct pike_type *t = low_match_types(a->cdr, b, flags);
      if (t) {
	type_stack_mark();
	push_finished_type(ret);
	push_finished_type(t);
	push_type(T_OR);
	free_type(ret);
	free_type(t);
	ret = pop_unfinished_type();
      }
      return ret;
    }else{
      return low_match_types(a->cdr, b, flags);
    }

  case PIKE_T_RING:
    return low_match_types(a->car, b, flags);

  case PIKE_T_SCOPE:
  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
    return low_match_types(a->cdr, b, flags);

  case T_NOT:
    ret = low_match_types(a->car, b, (flags ^ B_EXACT ) | NO_MAX_ARGS);
    if (ret) {
      free_type(ret);
      return 0;
    }
    /* We know that a->car and b do not overlap, it is thus safe
     * to use mixed|void in place of a to get proper values for
     * any markers in b.
     */
    return low_match_types(any_type_string, b, flags);

  case T_ASSIGN:
    {
      int m = CAR_TO_INT(a);
      ret = low_match_types(a->cdr, b, flags);
      if(ret && (!a_markers[m] || b->type != T_VOID))
      {
	struct pike_type *filtered_b = NULL;

#ifdef PIKE_DEBUG
	if ((m < 0) || (m > 9)) {
	  Pike_fatal("marker out of range: $%d\n", m);
	}
#endif /* PIKE_DEBUG */

	type_stack_mark();
	push_finished_type_with_markers(b, b_markers, 0);
	tmp = pop_unfinished_type();

	filtered_b = type_binop(PT_BINOP_AND,
				tmp, a->cdr,
				PT_FLAG_CMP_NULLABLE,
				PT_FLAG_CMP_NULLABLE,
				PT_FLAG_REMAP_INHIBIT);
	free_type(tmp);
	tmp = filtered_b;

	type_stack_mark();
	low_or_pike_types(a_markers[m], tmp, 0);
	if(a_markers[m]) free_type(a_markers[m]);
	free_type(tmp);
	a_markers[m] = pop_unfinished_type();

#ifdef PIKE_TYPE_DEBUG
	if (l_flag>2) {
	  fprintf(stderr, "%*sa_markers[%d]=",
		  indent*2, "", m);
	  simple_describe_type(a_markers[m]);
	  fputc('\n', stderr);
	}
#endif
#ifdef PIKE_DEBUG
	if(a_markers[m] && (a_markers[m]->type == m+'0'))
	  Pike_fatal("Cyclic type!\n");
#endif
      }
      return ret;
    }
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    {
      int m = a->type - '0';
      if(a_markers[m])
      {
	struct pike_type *t = a_markers[m];
#ifdef PIKE_DEBUG
	if(a_markers[m]->type == a->type)
	  Pike_fatal("Cyclic type!\n");
	if(a_markers[m]->type == T_OR &&
	   a_markers[m]->car->type == a->type)
	  Pike_fatal("Cyclic type!\n");
#endif
	a_markers[m] = NULL;
	ret = low_match_types(t, b, flags);
	if (a_markers[m]) {
	  a_markers[m] = or_pike_types(tmp = a_markers[m], t, 0);
	  free_type(tmp);
	  free_type(t);
	} else {
	  a_markers[m] = t;
	}
	return ret;
      }
      else {
	return low_match_types(mixed_type_string, b, flags);
      }
    }

  case PIKE_T_OPERATOR:
    {
      /* First match car & cdr against mixed to evaluate markers.
       * It also applies any related type operators.
       */
      struct pike_type *t;
      struct pike_type *t1 = low_match_types(a->car, any_type_string, flags);
      if (a->type & 0x8000) {
	struct pike_type *t2 = low_match_types(a->cdr, any_type_string, flags);
	t = apply_type_operator(a->type, t1, t2);
	free_type(t2);
      } else {
	t = apply_type_operator(a->type, t1, a->cdr);
      }
      free_type(t1);

      if (!t) return NULL;
      ret = low_match_types(t, b, flags);
      free_type(t);
      return ret;
    }

  case PIKE_T_TRANSITIVE:
    {
#if 1
      struct pike_type *t = expand_transitive(a, a_markers, flags);
      ret = low_match_types(t, b, flags);
      free_type(t);
      return ret;
#else
      /* FIXME */
      add_ref(a);
      return a;
#endif
    }
  }

  switch(b->type & PIKE_T_MASK)
  {
  case T_AND:
    ret = low_match_types(a, b->car, flags);
    if(!ret) return 0;
    free_type(ret);
    return low_match_types(a, b->cdr, flags);

  case T_OR:
    ret = low_match_types(a, b->car, flags);
    if(ret && !(flags & NO_SHORTCUTS)) return ret;
    if(ret)
    {
      struct pike_type *t = low_match_types(a, b->cdr, flags);
      if (t) {
	type_stack_mark();
	push_finished_type(ret);
	push_finished_type(t);
	push_type(T_OR);
	free_type(ret);
	free_type(t);
	ret = pop_unfinished_type();
      }
      return ret;
    }else{
      return low_match_types(a, b->cdr, flags);
    }

  case PIKE_T_RING:
    return low_match_types(a, b->car, flags);

  case PIKE_T_SCOPE:
  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
    return low_match_types(a, b->cdr, flags);

  case T_NOT:
    ret = low_match_types(a, b->car, (flags ^ A_EXACT ) | NO_MAX_ARGS);
    if (ret) {
      free_type(ret);
      return 0;
    }
    /* We know that a and b->car do not overlap, it is thus safe
     * to use mixed|void in place of b to get proper values for
     * any markers in a.
     */
    return low_match_types(a, any_type_string, flags);

  case T_ASSIGN:
    {
      int m = CAR_TO_INT(b);
      ret = low_match_types(a, b->cdr, flags);
      if(ret && (!b_markers[m] || a->type != T_VOID))
      {
	struct pike_type *filtered_a = NULL;

	type_stack_mark();
	push_finished_type_with_markers(a, a_markers, 0);
	tmp=pop_unfinished_type();

	filtered_a = type_binop(PT_BINOP_AND,
				tmp, b->cdr,
				PT_FLAG_CMP_NULLABLE,
				PT_FLAG_CMP_NULLABLE,
				PT_FLAG_REMAP_INHIBIT);
	free_type(tmp);
	tmp = filtered_a;

	type_stack_mark();
	low_or_pike_types(b_markers[m], tmp, 0);
	if(b_markers[m]) free_type(b_markers[m]);
	free_type(tmp);
	b_markers[m] = pop_unfinished_type();
#ifdef PIKE_TYPE_DEBUG
	if (l_flag>2) {
	  fprintf(stderr, "%*sb_markers[%d]=",
		  indent*2, "", m);
	  simple_describe_type(b_markers[m]);
	  fputc('\n', stderr);
	}
#endif
#ifdef PIKE_DEBUG
	if(b_markers[m] && (b_markers[m]->type == m+'0'))
	  Pike_fatal("Cyclic type!\n");
#endif
      }
      return ret;
    }
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    {
      int m = b->type - '0';
      if(b_markers[m])
      {
	struct pike_type *t = b_markers[m];
#ifdef PIKE_DEBUG
	if(b_markers[m]->type == b->type)
	  Pike_fatal("Cyclic type!\n");
#endif
	b_markers[m] = NULL;
	ret = low_match_types(a, t, flags);
	if (b_markers[m]) {
	  b_markers[m] = or_pike_types(tmp = b_markers[m], t, 0);
	  free_type(tmp);
	  free_type(t);
	} else {
	  b_markers[m] = t;
	}
	return ret;
      }
      else {
	return low_match_types(a, mixed_type_string, flags);
      }
    }

  case PIKE_T_OPERATOR:
    {
      /* First match car & cdr against mixed to evaluate markers.
       * It also applies any related type operators.
       */
      struct pike_type *t;
      struct pike_type *t1 = low_match_types(any_type_string, b->car, flags);
      if (b->type & 0x8000) {
	struct pike_type *t2 = low_match_types(any_type_string, b->cdr, flags);
	t = apply_type_operator(b->type, t1, t2);
	free_type(t2);
      } else {
	t = apply_type_operator(b->type, t1, b->cdr);
      }
      free_type(t1);

      if (!t) return NULL;
      ret = low_match_types(a, t, flags);
      free_type(t);
      return ret;
    }

  case PIKE_T_TRANSITIVE:
    {
#if 1
      struct pike_type *t = expand_transitive(b, b_markers, flags);
      ret = low_match_types(a, t, flags);
      free_type(t);
      return ret;
#else
      /* FIXME */
      add_ref(a);
      return a;
#endif
    }
  }

  /* 'mixed' matches anything */

  if(((a->type == T_MIXED) ||
      ((a->type == T_ZERO) && !(flags & (A_EXACT|B_EXACT)))) &&
     (b->type != T_VOID))
  {
    ret = NULL;
    switch(b->type)
    {
      /* These types can contain sub-types */
      case T_ARRAY:
	ret = low_match_types(array_type_string, b, flags);
	break;
      case T_MAPPING:
	ret = low_match_types(mapping_type_string, b, flags);
	break;
      case T_FUNCTION:
      case T_MANY:
	ret = low_match_types(function_type_string, b, flags);
	break;
      case T_MULTISET:
	ret = low_match_types(multiset_type_string, b, flags);
	break;
    }
#if 0
    if (a->type == T_ZERO) {
      if (ret) free_type(ret);
      ret = a;
      add_ref(ret);
    } else if (!ret) {
      ret = b;
      add_ref(ret);
    }
#else
    if (ret) free_type(ret);
    ret = a;
    add_ref(ret);
#endif
    return ret;
  }

  if(((b->type == T_MIXED) ||
      ((b->type == T_ZERO) && !(flags & (A_EXACT|B_EXACT)))) &&
     (a->type != T_VOID))
  {
    ret = NULL;
    switch(a->type)
    {
      /* These types can contain sub-types */
      case T_ARRAY:
	ret = low_match_types(a, array_type_string, flags);
	break;
      case T_MAPPING:
	ret = low_match_types(a, mapping_type_string, flags);
	break;
      case T_FUNCTION:
      case T_MANY:
	ret = low_match_types(a, function_type_string, flags);
	break;
      case T_MULTISET:
	ret = low_match_types(a, multiset_type_string, flags);
	break;
    }
#if 0
    if (b->type == T_ZERO) {
      if (ret) free_type(ret);
      ret = b;
      add_ref(ret);
    } else if (!ret) {
      ret = a;
      add_ref(ret);
    }
#else
    if (ret) free_type(ret);
    ret = a;
    add_ref(ret);
#endif
    return ret;
  }

  /* Special cases (tm) */
  switch(TWOT(a->type, b->type))
  {
  case TWOT(T_PROGRAM, T_FUNCTION):
  case TWOT(T_FUNCTION, T_PROGRAM):
  case TWOT(T_PROGRAM, T_MANY):
  case TWOT(T_MANY, T_PROGRAM):
    /* FIXME: Should look at the sub-type of the program
     * to determine the prototype to use.
     */
    add_ref(a);
    return a;

  case TWOT(PIKE_T_TYPE, T_FUNCTION):
  case TWOT(PIKE_T_TYPE, T_MANY):
    /* Convert the type to a casting function. */
    type_stack_mark();
    push_finished_type(a->car);
    push_type(T_VOID);
    push_type(T_MANY);
    push_type(T_MIXED);
    push_type(T_FUNCTION);
    ret = a;
    a = pop_unfinished_type();
    if (low_match_types(a, b, flags)) {
      free_type(a);
      add_ref(ret);
      return ret;
    }
    free_type(a);
    return NULL;

  case TWOT(T_FUNCTION, PIKE_T_TYPE):
  case TWOT(T_MANY, PIKE_T_TYPE):
    /* Convert the type to a casting function. */
    type_stack_mark();
    push_finished_type(b->car);
    push_type(T_VOID);
    push_type(T_MANY);
    push_type(T_MIXED);
    push_type(T_FUNCTION);
    b = pop_unfinished_type();
    ret = low_match_types(a, b, flags);
    free_type(b);
    return ret;

  case TWOT(PIKE_T_TYPE, T_PROGRAM):
  case TWOT(T_PROGRAM, PIKE_T_TYPE):
    return low_match_types(a->car, b->car, flags);

  case TWOT(T_OBJECT, T_FUNCTION):
  case TWOT(T_OBJECT, T_MANY):
  {
    struct pike_type *s;
    if((s = low_object_lfun_type(a, LFUN_CALL))) {
       return low_match_types(s, b, flags);
    }
    if (flags & B_EXACT) {
      /* A function isn't an object */
      return 0;
    }
    add_ref(a);
    return a;
  }

  case TWOT(T_FUNCTION, T_OBJECT):
  case TWOT(T_MANY, T_OBJECT):
  {
    struct pike_type *s;
    if((s=low_object_lfun_type(b, LFUN_CALL)))
       return low_match_types(a, s, flags);
    if (flags & A_EXACT) {
      /* A function isn't an object */
      return 0;
    }
    add_ref(a);
    return a;
  }
  case TWOT(T_INT, T_ZERO):
  {
    if ((CAR_TO_INT(a) > 0) || (CDR_TO_INT(a) < 0)) {
      return 0;
    }
    add_ref(a);
    return a;
  }
  case TWOT(T_ZERO, T_INT):
  {
    if ((CAR_TO_INT(b) > 0) || (CDR_TO_INT(b) < 0)) {
      return 0;
    }
    add_ref(a);
    return a;
  }
  case TWOT(T_FUNCTION, T_FUNCTION):
  case TWOT(T_FUNCTION, T_MANY):
  case TWOT(T_MANY, T_FUNCTION):
  case TWOT(T_MANY, T_MANY):
    ret = a;
    correct_args=0;
    while ((a->type == T_FUNCTION) || (b->type == T_FUNCTION))
    {
      struct pike_type *a_tmp, *b_tmp;

      if ((a->type != T_FUNCTION) && (a->type != T_MANY)) break;
      if ((b->type != T_FUNCTION) && (b->type != T_MANY)) break;

      a_tmp = a->car;
      if (a->type == T_FUNCTION)
      {
	a = a->cdr;
      }

      b_tmp = b->car;
      if (b->type == T_FUNCTION)
      {
	b = b->cdr;
      }

      if(!(tmp = low_match_types(a_tmp, b_tmp,
				 (flags | NO_MAX_ARGS) & ~(A_EXACT|B_EXACT)))) {
	return 0;
      }
      free_type(tmp);
      if(++correct_args > max_correct_args)
	if(!(flags & NO_MAX_ARGS))
	  max_correct_args=correct_args;
    }

    if ((a->type != T_MANY) || (b->type != T_MANY)) {
      /* Handle the generic case. */
      return low_match_types(a, b, flags);
    }

    /* check the 'many' type */
    if(b->car && (b->car->type != T_VOID) &&
       a->car && (a->car->type != T_VOID))
    {
      if(!(tmp = low_match_types(a->car, b->car,
				 (flags | NO_MAX_ARGS) & ~(A_EXACT|B_EXACT)))) {
	return 0;
      }
      free_type(tmp);
    }
    if(!(flags & NO_MAX_ARGS))
       max_correct_args=MAX_INT32;
    /* check the returntype */
    a = a->cdr;
    b = b->cdr;
    if (a && b) {
      if ((b->type == T_VOID) && (a->type != T_VOID)) {
	/* Promote b to a function returning zero. */
	if (!(tmp = low_match_types(a, zero_type_string,
				    flags & ~(A_EXACT|B_EXACT)))) {
	  return 0;
	}
	free_type(tmp);
      } else if ((a->type == T_VOID) && (b->type != T_VOID)) {
	/* Promote a to a function returning zero. */
	if(!(tmp = low_match_types(zero_type_string, b,
				   flags & ~(A_EXACT|B_EXACT)))) {
	  return 0;
	}
	free_type(tmp);
      } else {
	if(!(tmp = low_match_types(a, b, flags & ~(A_EXACT|B_EXACT)))) {
	  return 0;
	}
	free_type(tmp);
      }
    }
    add_ref(ret);
    return ret;
  }

  if(a->type != b->type) return 0;

  ret=a;
  switch(a->type)
  {
  case T_MAPPING:
    if(!(tmp = low_match_types(a->car, b->car,
			       flags & ~(A_EXACT|B_EXACT)))) {
      return 0;
    }
    free_type(tmp);
    if(!(tmp = low_match_types(a->cdr, b->cdr,
			       flags & ~(A_EXACT|B_EXACT)))) {
      return 0;
    }
    free_type(tmp);
    break;

  case T_OBJECT:
#if 0
    if(a->cdr || b->cdr)
    {
      fprintf(stderr,"Type match1: ");
      simple_describe_type(a);
      fprintf(stderr,"Type match2: ");
      simple_describe_type(b);
    }
#endif

    /* object(* 0) matches any object */
    if(!a->cdr || !b->cdr) break;

    /* object(* x) =? object(* x) */
    if (a->cdr == b->cdr) break;

    /* Note: In Pike 7.4 and earlier the following was only done
     *       when a->car != b->car.
     */
    {
      struct program *ap,*bp;
      ap = id_to_program(CDR_TO_INT(a));
      bp = id_to_program(CDR_TO_INT(b));

      if(!ap || !bp) break;

      implements_mode = 0;

      if (!is_compatible(implements_a=ap,implements_b=bp)) {
	return 0;
      }
    }
    break;

  case T_INT:
  {
    INT32 amin = CAR_TO_INT(a);
    INT32 amax = CDR_TO_INT(a);

    INT32 bmin = CAR_TO_INT(b);
    INT32 bmax = CDR_TO_INT(b);

    if(amin > bmax || bmin > amax) return 0;
    break;
  }

  case T_ARRAY:
  case T_STRING:
    if (!a->cdr || !b->cdr)
      break;

    if(!(tmp = low_match_types(a->cdr, b->cdr,
			       flags & ~(A_EXACT|B_EXACT)))) {
      return 0;
    }
    free_type(tmp);
    /* FALLTHRU */

  case T_PROGRAM:
  case T_TYPE:
  case T_MULTISET:
    if(!(tmp = low_match_types(a->car, b->car,
			       flags & ~(A_EXACT|B_EXACT)))) {
      return 0;
    }
    free_type(tmp);
    break;

  case T_FLOAT:
  case T_ZERO:
  case T_VOID:
  case T_MIXED:
    break;
#ifdef PIKE_DEBUG
  default:
    Pike_fatal("Error in type string.\n");
#endif
  }

  if (ret) add_ref(ret);
  return ret;
}

/*
 * Check the partial ordering relation.
 *
 *                 mixed
 *
 * int float string program function object
 *
 *                 zero
 *
 *                 void
 *
 * Note that non-destructive operations are assumed.
 * ie it's assumed that calling a function(mapping(string|int:string|int):void)
 * with a mapping(int:int) won't change the type of the mapping after the
 * operation.
 */
static int low_pike_types_le2(struct pike_type *a, struct pike_type *b,
			      int array_cnt, unsigned int flags);
static int low_pike_types_le(struct pike_type *a, struct pike_type *b,
			     int array_cnt, unsigned int flags)
{
  int res;
  DECLARE_CYCLIC();

#ifdef PIKE_TYPE_DEBUG
  if (l_flag>2) {
#if 0
    struct compilation *c = MAYBE_THIS_COMPILATION;
    if (c && c->lex.current_file)
      fprintf (stderr, "%*s%s:%d:\n", indent * 2, "",
	       c->lex.current_file->str, c->lex.current_line);
#endif
    fprintf(stderr, "%*slow_pike_types_le(", indent*2, "");
    simple_describe_type(a);
    fprintf(stderr, ",\n%*s", indent*2 + 18, "");
    simple_describe_type(b);
    fprintf(stderr, ",\n%*s%d, 0x%08x);\n",
	    indent*2 + 18, "", array_cnt, flags);
    indent++;
  }
#endif /* PIKE_TYPE_DEBUG */

  if (!(res = (int)(ptrdiff_t)BEGIN_CYCLIC(a, b))) {
    SET_CYCLIC_RET(1);

    res = low_pike_types_le2(a, b, array_cnt, flags);
  }
  END_CYCLIC();

#ifdef PIKE_TYPE_DEBUG
  if (l_flag>2) {
    indent--;

    fprintf(stderr, "%*s= %d\n", indent*2, "", res);
  }
#endif /* PIKE_TYPE_DEBUG */
  return res;
}

static int low_pike_types_le2(struct pike_type *a, struct pike_type *b,
			      int array_cnt, unsigned int flags)
{
  struct compilation *c = MAYBE_THIS_COMPILATION;
  int ret;

 recurse:
#if 0
  fprintf(stderr, "low_pike_types_le(%d, %d, %d, 0x%08x)\n",
	  a->type, b->type, array_cnt, flags);
#endif /* 0 */

  if(a == b) return 1;

  if (!a) return 1;
  if (!b) return 0;

#ifdef TYPE_GROUPING
  if (b->type != T_OR) {
    flags &= ~LE_B_GROUPED;
  }
#endif

  switch(b->type & PIKE_T_MASK)
  {
  case T_AND:
    /* OK, if a is a subset of both parts. */
    ret = low_pike_types_le(a, b->car, array_cnt, flags);
    if(!ret) return 0;
    b = b->cdr;
    goto recurse;

  case T_OR:
    /* OK if a is a subset of either of the parts,
     * unless we are grouped, in which case both
     * parts need to be a subset.
     */
    ret = low_pike_types_le(a, b->car, array_cnt, flags);
#ifdef TYPE_GROUPING
    if (!ret != !(flags & LE_B_GROUPED)) {
      if ((a->flags | b->flags) & PT_FLAG_ASSIGN) {
	/* Note: Needed for side effects... */
	low_pike_types_le(a, b->cdr, array_cnt, flags);
      }
      return ret;
    }
#else
    if (ret) return ret;
#endif
    b = b->cdr;
    goto recurse;

  case PIKE_T_RING:
    b = b->car;
    goto recurse;

  case PIKE_T_ATTRIBUTE:
    if (!c) {
      b = b->cdr;
      goto recurse;
    }
    if (!low_pike_types_le(a, b->cdr, array_cnt, flags|LE_STRICT_FUN)) return 0;
    ref_push_string((struct pike_string *)b->car);
    ref_push_type_value(a);
    ref_push_type_value(b->cdr);
    safe_apply_current2(PC_PUSH_TYPE_ATTRIBUTE_FUN_NUM, 3,
			"push_type_attribute");
    if ((TYPEOF(Pike_sp[-1]) == T_INT) &&
	(SUBTYPEOF(Pike_sp[-1]) == NUMBER_NUMBER) &&
	(!Pike_sp[-1].u.integer)) {
      pop_stack();
      return 0;
    }
    pop_stack();
    return 1;
  case PIKE_T_SCOPE:
#ifdef TYPE_GROUPING
    flags |= LE_B_GROUPED;
#endif
    /* FALLTHRU */
  case PIKE_T_NAME:
    b = b->cdr;
    goto recurse;

  case T_NOT:
    /* Some common cases. */
    if (a && (a->type == T_NOT)) {
      /* ~A <= ~B   <=>   B <= A */
      struct pike_type *tmp = b->car;
      b = a->car;
      a = tmp;
      array_cnt = -array_cnt;
#ifdef TYPE_GROUPING
      if ((flags & LE_A_B_GROUPED) &&
	  ((flags & LE_A_B_GROUPED) != LE_A_B_GROUPED)) {
	flags ^= LE_A_B_GROUPED;
      }
#endif
      flags ^= LE_A_B_SWAPPED;
      goto recurse;
    }
    switch(b->car?b->car->type:PIKE_T_UNKNOWN) {
    case T_NOT:
      b = b->car->car;
      goto recurse;
    case T_MIXED:
      b = zero_type_string;
      goto recurse;
    case T_ZERO:
    case T_VOID:
    case PIKE_T_UNKNOWN:
      b = mixed_type_string;
      goto recurse;
    }
    if (low_pike_types_le(a, b->car, array_cnt, flags)) {
      return 0;
    }
    flags ^= LE_A_B_SWAPPED;
#ifdef TYPE_GROUPING
    if (flags & LE_A_B_GROUPED) {
      if ((flags & LE_A_B_GROUPED) == LE_A_B_GROUPED) {
	flags ^= LE_A_B_GROUPED;
      }
    } else {
      flags |= LE_A_B_GROUPED;
    }
#endif
    /* FIXME: This is wrong... */
    return !low_pike_types_le(b->car, a, -array_cnt, flags);

  case T_ASSIGN: {
    struct pike_type **aa_markers = a_markers;
    struct pike_type **bb_markers = b_markers;
    int m = CAR_TO_INT(b);
    ret = low_pike_types_le(a, b->cdr, array_cnt, flags);

    if (flags & LE_A_B_SWAPPED) {
      aa_markers = b_markers;
      bb_markers = a_markers;
    }

    if(ret && (!bb_markers[m] || a->type != T_VOID))
    {
      int m = CAR_TO_INT(b);
      struct pike_type *tmp;
      int i;

      type_stack_mark();
      push_finished_type_with_markers(a, aa_markers, 0);
      for(i = array_cnt; i < 0; i++)
	push_unlimited_array_type(T_ARRAY);
      tmp=pop_unfinished_type();

      type_stack_mark();
      low_or_pike_types(bb_markers[m], tmp, 0);
      if(bb_markers[m]) free_type(bb_markers[m]);
      free_type(tmp);
      bb_markers[m] = pop_unfinished_type();
#ifdef PIKE_TYPE_DEBUG
      if (l_flag>2) {
	if (flags & LE_A_B_SWAPPED) {
	  fprintf(stderr, "%*sa_markers[%c]=",
		  indent * 2, "", (char)(m+'0'));
	  simple_describe_type(a_markers[m]);
	} else {
	  fprintf(stderr, "%*sb_markers[%c]=",
		  indent * 2, "", (char)(m+'0'));
	  simple_describe_type(b_markers[m]);
	}
	fprintf(stderr, "\n");
      }
#endif
    }
    return ret;
  }
  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
    {
      int m = b->type - '0';
      if (flags & LE_A_B_SWAPPED) {
	if(a_markers[m]) {
	  b = a_markers[m];
	} else {
	  b = mixed_type_string;
	}
      } else {
	if(b_markers[m]) {
	  b = b_markers[m];
	} else {
	  b = mixed_type_string;
	}
      }
      goto recurse;
    }

  case PIKE_T_OPERATOR:
    {
      struct pike_type *t1 = b->car;
      struct pike_type *t2 = b->cdr;
      if (t1 && (t1->type >= '0') && (t1->type <= '9')) {
	t1 = ((flags & LE_A_B_SWAPPED)?a_markers:b_markers)[t1->type - '0'];
      }
      if ((b->type & 0x8000) && t2 && (t2->type >= '0') && (t2->type <= '9')) {
	t2 = ((flags & LE_A_B_SWAPPED)?a_markers:b_markers)[t2->type - '0'];
      }
      t1 = apply_type_operator(b->type, t1, t2);
      if (!t1) return 0;
      ret = low_pike_types_le(a, t1, array_cnt, flags);
      free_type(t1);
      return ret;
    }

  case PIKE_T_TRANSITIVE:
    {
      struct pike_type *t =
	expand_transitive(b, ((flags & LE_A_B_SWAPPED)?a_markers:b_markers), 0);
      ret = low_pike_types_le(a, t, array_cnt, flags);
      free_type(t);
      return ret;
    }
  }

#ifdef TYPE_GROUPING
  if (a->type != T_OR) {
    flags &= ~LE_A_GROUPED;
  }
#endif

  switch(a->type & PIKE_T_MASK)
  {
  case T_AND:
    /* OK if either of the parts is a subset. */
    /* FIXME: What if b also contains an AND? */
    ret = low_pike_types_le(a->car, b, array_cnt, flags);
    if(!ret) {
      a = a->cdr;
      goto recurse;
    }
    if ((a->flags | b->flags) & PT_FLAG_ASSIGN) {
      /* Note that we need to recurse, since there are T_ASSIGN nodes
       * in the cdr that need to be executed.
       */
      low_pike_types_le(a->cdr, b, array_cnt, flags);
    }
    return 1;

  case T_OR:
    /* OK, if both of the parts are a subset,
     * unless we are grouped, in which case
     * only one part needs to be a subset.
     */
    if (a->car->type == T_VOID) {
      /* Special case for T_VOID */
      /* FIXME: Should probably be handled as T_ZERO. */
#ifdef TYPE_GROUPING
      if (flags & LE_A_GROUPED) return 1;
#endif
      a = a->cdr;
      goto recurse;
    } else {
      ret = low_pike_types_le(a->car, b, array_cnt, flags);
#ifdef TYPE_GROUPING
      if (!ret == !(flags & LE_A_GROUPED)) {
	if ((a->flags | b->flags) & PT_FLAG_ASSIGN) {
	  /* Note: Needed for side effects... */
	  low_pike_types_le(a->cdr, b, array_cnt, flags);
	}
	return ret;
      }
#else
      if (!ret) return 0;
#endif
      if (a->cdr->type == T_VOID) {
	/* Special case for T_VOID */
	/* FIXME: Should probably be handled as T_ZERO. */
	return 1;
      } else {
	a = a->cdr;
	goto recurse;
      }
    }

  case PIKE_T_RING:
    a = a->car;
    goto recurse;

  case PIKE_T_SCOPE:
#ifdef TYPE_GROUPING
    flags |= LE_A_GROUPED;
#endif
    /* FALLTHRU */
  case PIKE_T_NAME:
    a = a->cdr;
    goto recurse;
  case PIKE_T_ATTRIBUTE:
    if ((b->type == PIKE_T_ATTRIBUTE) && (a->car == b->car)) {
      a = a->cdr;
      b = b->cdr;
      goto recurse;
    }
    if (!c) {
      a = a->cdr;
      goto recurse;
    }
    if (!low_pike_types_le(a->cdr, b, array_cnt, flags)) return 0;
    ref_push_string((struct pike_string *)a->car);
    ref_push_type_value(a->cdr);
    ref_push_type_value(b);
    safe_apply_current2(PC_POP_TYPE_ATTRIBUTE_FUN_NUM, 3,
			"pop_type_attribute");
    if ((TYPEOF(Pike_sp[-1]) == T_INT) &&
	(SUBTYPEOF(Pike_sp[-1]) == NUMBER_NUMBER) &&
	(!Pike_sp[-1].u.integer)) {
      pop_stack();
      return 0;
    }
    pop_stack();
    return 1;

  case T_NOT:
    if (b->type == T_NOT) {
      struct pike_type *tmp = a->car;
      a = b->car;
      b = tmp;
      array_cnt = -array_cnt;
      flags ^= LE_A_B_SWAPPED;
#if 0
#ifdef TYPE_GROUPING
      if (flags & LE_A_B_GROUPED) {
	if ((flags & LE_A_B_GROUPED) == LE_A_B_GROUPED) {
	  flags ^= LE_A_B_GROUPED;
	}
      } else {
	flags |= LE_A_B_GROUPED;
      }
#endif
#endif
      goto recurse;
    }
    /* Some common cases. */
    switch(a->car?a->car->type:PIKE_T_UNKNOWN) {
    case T_NOT:
      a = a->car->car;
      goto recurse;
    case T_MIXED:
      a = zero_type_string;
      goto recurse;
    case T_ZERO:
    case T_VOID:
    case PIKE_T_UNKNOWN:
      a = mixed_type_string;
      goto recurse;
    }
    if (low_pike_types_le(a->car, b, array_cnt, flags)) {
      return 0;
    }
    flags ^= LE_A_B_SWAPPED;
#if 0
#ifdef TYPE_GROUPING
    if (flags & LE_A_B_GROUPED) {
      if ((flags & LE_A_B_GROUPED) == LE_A_B_GROUPED) {
	flags ^= LE_A_B_GROUPED;
      }
    } else {
      flags |= LE_A_B_GROUPED;
    }
#endif
#endif
    /* FIXME: This is wrong... */
    return !low_pike_types_le(b, a->car, -array_cnt, flags);

  case T_ASSIGN: {
    struct pike_type **aa_markers = a_markers;
    struct pike_type **bb_markers = b_markers;
    int m = CAR_TO_INT(a);
    ret = low_pike_types_le(a->cdr, b, array_cnt, flags);

    if (flags & LE_A_B_SWAPPED) {
      aa_markers = b_markers;
      bb_markers = a_markers;
    }

    if(ret && (!aa_markers[m] || (b->type != T_VOID)))
    {
      struct pike_type *tmp;
      int i;

      type_stack_mark();
      push_finished_type_with_markers(b, bb_markers, 0);
      for(i=array_cnt; i > 0; i--)
	push_unlimited_array_type(T_ARRAY);
      tmp=pop_unfinished_type();

      type_stack_mark();
      low_or_pike_types(aa_markers[m], tmp, 0);
      if(aa_markers[m]) free_type(aa_markers[m]);
      free_type(tmp);
      aa_markers[m] = pop_unfinished_type();
#ifdef PIKE_TYPE_DEBUG
      if (l_flag>2) {
	if (flags & LE_A_B_SWAPPED) {
	  fprintf(stderr, "%*sb_markers[%c]=",
		  indent * 2, "", (char)(m+'0'));
	  simple_describe_type(b_markers[m]);
	} else {
	  fprintf(stderr, "%*sa_markers[%c]=",
		  indent * 2, "", (char)(m+'0'));
	  simple_describe_type(a_markers[m]);
	}
	fprintf(stderr, "\n");
      }
#endif
    }
    return ret;
  }
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    {
      int m = a->type - '0';
      if (flags & LE_A_B_SWAPPED) {
	if(b_markers[m]) {
	  a = b_markers[m];
	} else {
	  a = mixed_type_string;
	}
      } else {
	if(a_markers[m]) {
	  a = a_markers[m];
	} else {
	  a = mixed_type_string;
	}
      }
      goto recurse;
    }

  case PIKE_T_OPERATOR:
    {
      struct pike_type *t1 = a->car;
      struct pike_type *t2 = a->cdr;
      if (t1 && (t1->type >= '0') && (t1->type <= '9')) {
	t1 = ((flags & LE_A_B_SWAPPED)?b_markers:a_markers)[t1->type - '0'];
      }
      if ((a->type & 0x8000) && t2 && (t2->type >= '0') && (t2->type <= '9')) {
	t2 = ((flags & LE_A_B_SWAPPED)?b_markers:a_markers)[t2->type - '0'];
      }
      t1 = apply_type_operator(a->type, t1, t2);
      if (!t1) return 0;
      ret = low_pike_types_le(t1, b, array_cnt, flags);
      free_type(t1);
      return ret;
    }

  case PIKE_T_TRANSITIVE:
    {
      struct pike_type *t =
	expand_transitive(a, ((flags & LE_A_B_SWAPPED)?b_markers:a_markers), 0);
      ret = low_pike_types_le(t, b, array_cnt, flags);
      free_type(t);
      return ret;
    }
  }

  if ((array_cnt < 0) && (b->type == T_ARRAY)) {
    while (b->type == T_ARRAY) {
      b = b->cdr;
      if (!++array_cnt) break;
    }
    goto recurse;
  } else if ((array_cnt > 0) && (a->type == T_ARRAY)) {
    while (a->type == T_ARRAY) {
      a = a->cdr;
      if (!--array_cnt) break;
    }
    goto recurse;
  }

  /* NOTE: void only matches void. */
  if (a->type == T_VOID) {
    /* void <= any_type */
    if (array_cnt >= 0) {
      /* !array(void) */
      if (!array_cnt && (b->type == T_VOID)) {
	return 1;
      }
      return 0;
    }
  }

  if (b->type == T_VOID) {
    if (array_cnt <= 0) {
      /* !array(void) */
      return 0;
    }
  }

  if (b->type == T_MIXED) {
    /* any_type <= 'mixed' */
    if (array_cnt <= 0) {
      /* !array(mixed) */
      return 1;
    }
  }

  if (a->type == T_MIXED) {
    if (array_cnt >= 0) {
      /* !array(mixed) */
      return 0;
    }
  }

  if (a->type == T_ZERO) {
    /* void <= zero <= any_type */
    if (array_cnt >= 0) {
      /* !array(zero) */
      if (!(flags & LE_EXPLICIT_ZERO) ||
	  ((b->type == T_INT) && !array_cnt)) {
	return 1;
      }
    }
  }

  if (b->type == T_ZERO) {
    if (array_cnt <= 0) {
      /* !array(zero) */
      return 0;
    }
  }

  /* Special cases (tm) */
  switch(TWOT(a->type, b->type))
  {
  case TWOT(T_PROGRAM, T_FUNCTION):
  case TWOT(T_FUNCTION, T_PROGRAM):
  case TWOT(T_PROGRAM, T_MANY):
  case TWOT(T_MANY, T_PROGRAM):
    /* FIXME: Not really... Should check the return value. */
    /* FIXME: Should also look at the subtype of the program. */
    return 1;

  case TWOT(PIKE_T_TYPE, T_FUNCTION):
  case TWOT(PIKE_T_TYPE, T_MANY):
    /* Convert the type to a casting function. */
    type_stack_mark();
    push_finished_type(a->car);
    push_type(T_VOID);
    push_type(T_MANY);
    push_type(T_MIXED);
    push_type(T_FUNCTION);
    a = pop_unfinished_type();
    if (low_pike_types_le(a, b, array_cnt, flags)) {
      free_type(a);
      return 1;
    }
    free_type(a);
    return 0;

  case TWOT(T_FUNCTION, PIKE_T_TYPE):
  case TWOT(T_MANY, PIKE_T_TYPE):
    /* Convert the type to a casting function. */
    type_stack_mark();
    push_finished_type(b->car);
    push_type(T_VOID);
    push_type(T_MANY);
    push_type(T_MIXED);
    push_type(T_FUNCTION);
    b = pop_unfinished_type();
    if (low_pike_types_le(a, b, array_cnt, flags)) {
      free_type(b);
      return 1;
    }
    free_type(b);
    return 0;

  case TWOT(PIKE_T_TYPE, T_PROGRAM):
  case TWOT(T_PROGRAM, PIKE_T_TYPE):
    return low_pike_types_le(a->car, b->car, array_cnt, flags);

  case TWOT(T_OBJECT, T_FUNCTION):
  case TWOT(T_OBJECT, T_MANY):
    {
      if((a = low_object_lfun_type(a, LFUN_CALL))) {
	goto recurse;
      }
      return 1;
    }

  case TWOT(T_FUNCTION, T_OBJECT):
  case TWOT(T_MANY, T_OBJECT):
    {
      if((b=low_object_lfun_type(b, LFUN_CALL))) {
	goto recurse;
      }
      return 1;
    }

  case TWOT(T_FUNCTION, T_ARRAY):
  case TWOT(T_MANY, T_ARRAY):
    {
      while (b && (b->type == T_ARRAY)) {
	b = b->cdr;
	array_cnt++;
      }
      goto recurse;
    }

  case TWOT(T_ARRAY, T_FUNCTION):
  case TWOT(T_ARRAY, T_MANY):
    {
      while (a && (a->type == T_ARRAY)) {
	a = a->cdr;
	array_cnt--;
      }
      goto recurse;
    }

  case TWOT(T_FUNCTION, T_FUNCTION):
  case TWOT(T_FUNCTION, T_MANY):
  case TWOT(T_MANY, T_FUNCTION):
    /*
     * function(A...:B) <= function(C...:D)	iff C <= A && B <= D
     */
    /*
     * function(:int) <= function(int:int)
     * function(int|string:int) <= function(int:int)
     * function(:int) <= function(:void)
     * function(string:int) != function(int:int)
     * function(int:int) != function(:int)
     *
     * FIXME: Enforcing of all required arguments?
     */
    while((a->type == T_FUNCTION) || (b->type == T_FUNCTION))
    {
      struct pike_type *a_tmp, *b_tmp;

      if ((a->type != T_FUNCTION) && (a->type != T_MANY)) break;
      if ((b->type != T_FUNCTION) && (b->type != T_MANY)) break;

      a_tmp = a->car;
      if (a->type == T_FUNCTION)
      {
	a = a->cdr;
      }

      b_tmp = b->car;
      if (b->type == T_FUNCTION)
      {
	b = b->cdr;
      }

      if ((a_tmp && (a_tmp->type != T_VOID)) || (flags & LE_STRICT_FUN)) {
	/* Note: flags never has grouping at this point. */
	if (!low_pike_types_le(b_tmp, a_tmp, 0, flags ^ LE_A_B_SWAPPED)) {
	  return 0;
	}
      } else if (flags & LE_TYPE_SVALUE) {
	/* Note: flags never has grouping at this point. */
	if (!low_pike_types_le(b_tmp, zero_type_string, 0,
			       flags ^ LE_A_B_SWAPPED)) {
	  return 0;
	}
      }
    }

    if ((a->type != T_MANY) || (b->type != T_MANY)) {
      /* Handle the generic case. */
      return low_pike_types_le(a, b, array_cnt, flags);
    }

    /* FALLTHRU */
  case TWOT(T_MANY, T_MANY):
    /* check the 'many' type */
    if (a->car && (a->car->type != T_VOID) &&
	b->car && (b->car->type != T_VOID)) {
      /* Note: flags never has grouping at this point. */
      if (!low_pike_types_le(b->car, a->car, 0, flags ^ LE_A_B_SWAPPED)) {
	return 0;
      }
    } else if ((flags & LE_TYPE_SVALUE) && (a->car->type != b->car->type)) {
      if (a->car->type == T_VOID) {
	/* Note: flags never has grouping at this point. */
	if (!low_pike_types_le(b->car, zero_type_string, 0,
			       flags ^ LE_A_B_SWAPPED)) {
	  return 0;
	}
      } else {
	/* Note: flags never has grouping at this point. */
	if (!low_pike_types_le(zero_type_string, a->car, 0,
			       flags ^ LE_A_B_SWAPPED)) {
	  return 0;
	}
      }
    }

    a = a->cdr;
    b = b->cdr;

    /* check the returntype */
    if (flags & LE_TYPE_SVALUE) return 1;
    /* FIXME: Check array_cnt */
    if (a && b && (b->type != T_VOID) && (a->type != T_VOID)) {
      if(!low_pike_types_le(a, b, array_cnt, flags)) return 0;
    }
    return 1;
  }

  if(a->type != b->type) return 0;

  if (array_cnt) return 0;

  switch(a->type)
  {
  case T_MAPPING:
    if (flags & LE_TYPE_SVALUE) return 1;
    /*
     *  mapping(A:B) <= mapping(C:D)   iff A <= C && B <= D.
     */
    if(!low_pike_types_le(a->car, b->car, 0, flags)) return 0;
    array_cnt = 0;
    a = a->cdr;
    b = b->cdr;
    goto recurse;

  case T_OBJECT:
#if 0
    if(a->cdr || b->cdr)
    {
      fprintf(stderr,"Type match1: ");
      simple_describe_type(a);
      fprintf(stderr,"Type match2: ");
      simple_describe_type(b);
    }
#endif

    /*
     * object(0|1 x) <= object(0|1 0)
     * object(0|1 0) <=! object(0|1 !0)
     * object(1 x) <= object(0|1 x)
     * object(1 x) <= object(1 y)	iff x == y
     * object(1 x) <= object(0 y)	iff x implements y
     * Not WEAK_OBJECTS:
     *   object(0 x) <= object(0 y)	iff x implements y
     * WEAK_OBJECTS:
     *   object(0 x) <= object(0 y)	iff x is_compatible y
     */

    /* object(* 0) matches any object */
    if(!b->cdr)
      return 1;

    if(!a->cdr)
      return 0;

    /* The 'is' flag is now ignored.
     *	/grubba 2003-11-11
     */

    if (a->cdr == b->cdr)
      return 1;

    {
      struct program *ap = id_to_program(CDR_TO_INT(a));
      struct program *bp = id_to_program(CDR_TO_INT(b));

#if 0
      fprintf(stderr,
	      "id_to_program(%d) ==> %p\n"
	      "id_to_program(%d) ==> %p\n",
	      CDR_TO_INT(a), ap,
	      CDR_TO_INT(b), bp);
#endif /* 0 */

      if (!ap || !bp) {
	/* Shouldn't happen... */
	/* fprintf(stderr, "ap:%p bp:%p\n", ap, bp); */
	return 0;
      }
      if ((flags & LE_WEAK_OBJECTS) && !a->car) {
	implements_mode = 0;
#if 0
	fprintf(stderr, "  is_compat(%p(%d), %p(%d))\n",
		ap, ap->id, bp, bp->id);
#endif /* 0 */
	return is_compatible(implements_a=ap, implements_b=bp);
      }
      implements_mode = 1;
#if 0
      fprintf(stderr, "  implements(%p(%d), %p(%d))\n",
	      ap, ap->id, bp, bp->id);
#endif /* 0 */
      return implements(implements_a=ap, implements_b=bp);
    }
    break;

  case T_INT:
  {
    INT32 amin = CAR_TO_INT(a);
    INT32 amax = CDR_TO_INT(a);

    INT32 bmin = CAR_TO_INT(b);
    INT32 bmax = CDR_TO_INT(b);

    /* Handle implicit zero... */
    if (amin == 1) amin = 0;
    if (bmin == 1) bmin = 0;
    if (amax == -1) amax = 0;
    if (bmax == -1) bmax = 0;

    if(amin < bmin || amax > bmax) return 0;
    break;
  }


  case T_TYPE:
  case T_PROGRAM:
  case T_MULTISET:
    if (flags & LE_TYPE_SVALUE) return 1;
    a = a->car;
    b = b->car;
    array_cnt = 0;
    goto recurse;

  case T_ARRAY:
  case T_STRING:
    if (flags & LE_TYPE_SVALUE) return 1;
    if (!a->car) return 1;
    if (!low_pike_types_le(a->car, b->car, 0, flags)) return 0;
    a = a->cdr;
    b = b->cdr;
    array_cnt = 0;
    goto recurse;

  case T_FLOAT:
  case T_ZERO:
  case T_VOID:
  case T_MIXED:
    break;

#ifdef PIKE_DEBUG
  default:
    Pike_fatal("Error in type string.\n");
#endif
  }
  return 1;
}

/*
 * Check the function parameters.
 * Note: The difference between this function, and pike_types_le()
 *       is the more lenient check for T_OR, and the handling of T_ARRAY.
 */
int strict_check_call(struct pike_type *fun_type,
		      struct pike_type *arg_type)
{
  while ((fun_type->type == T_OR) ||
	 (fun_type->type == T_ARRAY) ||
	 (fun_type->type == PIKE_T_SCOPE)) {
    if (fun_type->type == T_OR) {
      int res = strict_check_call(fun_type->car, arg_type);
      if (res) return res;
      fun_type = fun_type->cdr;
    } else if (fun_type->type == PIKE_T_SCOPE) {
      fun_type = fun_type->cdr;
    } else {
      fun_type = fun_type->cdr;
    }
  }
  return low_pike_types_le(fun_type, arg_type, 0, 0);
}

/*
 * Check validity of soft-cast.
 * Note: This uses a weaker check of function arguments, since
 *       people get confused otherwise.
 */
int check_soft_cast(struct pike_type *to, struct pike_type *from)
{
  return low_pike_types_le(to, from, 0, LE_WEAK_OBJECTS);
}

/**
 * Return the return type from a function call (old API).
 *
 * @param a
 *   The function type.
 *
 * @param b
 *   The function type for the arguments.
 *
 * See also check_call().
 */
static int low_get_return_type(struct pike_type *a, struct pike_type *b)
{
  struct compilation *c = THIS_COMPILATION;
  struct call_state cs;

  CHECK_COMPILER();

  if (!a) return 0;

  add_ref(a);

  push_type(PIKE_T_UNKNOWN);

  INIT_CALL_STATE(cs, NULL);

  do {
    struct pike_type *cont;

    if (!b || b->type == T_MANY ||
	(b->car && (b->car->flags & PT_FLAG_VOIDABLE))) {
      struct pike_type *tmp = new_get_return_type(a, &cs, 0);

      if (tmp) {
	push_finished_type(tmp);
	push_type(T_OR);

	free_type(tmp);
      }

      if (!b || !b->car ||
	  ((b->type == T_MANY) && (b->car == void_type_string))) {
	break;
      }
    }

#ifdef PIKE_DEBUG
    if ((b->type != T_MANY) && (b->type != T_FUNCTION)) {
      Pike_fatal("Invalid argument type to check_call().\n");
    }
#endif

    cont = low_new_check_call(a, b->car, 0, &cs, NULL);

    free_type(a);
    a = cont;

    if (!a) break;

    if (b->type == T_FUNCTION) b = b->cdr;
  } while(1);

  FREE_CALL_STATE(cs);

#if 0
  fprintf(stderr, "==> ");
  simple_describe_type(peek_type_stack());
  fprintf(stderr, "\n\n");
#endif

  free_type(a);

  if (peek_type_stack()) {
    return 1;
  }

  compiler_discard_top_type();

  return 0;
}


int match_types(struct pike_type *a, struct pike_type *b)
{
  struct pike_type *res;
#ifdef PIKE_EXTRA_DEBUG
  struct remap_state remap;
  struct pike_type *tmp, *tmp2;

  INIT_REMAP_STATE(remap);

  tmp = low_type_binop(PT_BINOP_AND, a, b, &remap, 0, 0, 0);

  clear_mapping(remap.markers);

  tmp2 = remap_markers(tmp, &remap, PT_FLAG_REMAP_EVAL_MARKERS);

  EXIT_REMAP_STATE(remap);
#endif

  clear_markers();
  res = low_match_types(a, b, 0);
  free_type(res);

#ifdef PIKE_EXTRA_DEBUG
  if ((!!res) != (!!tmp2)) {
    fprintf(stderr, "match_types mismatch!\n"
	    "a: ");
    simple_describe_type(a);
    fprintf(stderr, "\nb: ");
    simple_describe_type(b);
    fprintf(stderr, "\nres: ");
    simple_describe_type(res);
    fprintf(stderr, "\ntmp: ");
    simple_describe_type(tmp);
    fprintf(stderr, "\ntmp2: ");
    simple_describe_type(tmp2);
    fprintf(stderr, "\n\n");
  }

  free_type(tmp);
  free_type(tmp2);
  free_mapping(markers);
#endif

  return !!res;
}

int pike_types_le(struct pike_type *a, struct pike_type *b,
		  enum pt_cmp_flags aflags, enum pt_cmp_flags bflags)
{
  struct remap_state remap;
  struct pike_type *tmp, *tmp2 = NULL;
#ifdef PIKE_EXTRA_DEBUG
  int res;
  struct pike_type **save_type_stackp = Pike_compiler->type_stackp;
  struct pike_type ***save_mark_stackp = Pike_compiler->pike_type_mark_stackp;
#endif

  INIT_REMAP_STATE(remap);

  tmp = low_type_binop(PT_BINOP_MINUS, a, b, &remap, aflags, bflags,
		       PT_FLAG_REMAP_INEXACT);

  if (tmp) {
    clear_mapping(remap.markers[0]);
    clear_mapping(remap.markers[1]);

    tmp2 = remap_markers(tmp, &remap, PT_FLAG_REMAP_EVAL_MARKERS);
  }

#ifdef PIKE_EXTRA_DEBUG
  clear_markers();
  res = low_pike_types_le(a, b, 0, 0);

  if ((save_type_stackp != Pike_compiler->type_stackp) ||
      (save_mark_stackp != Pike_compiler->pike_type_mark_stackp) ||
      (res != !tmp2)) {
    struct pike_type *tmp3;

    fprintf(stderr, "pike_types_le mismatch!\n"
	    "a: ");
    simple_describe_type(a);
    fprintf(stderr, "\nb: ");
    simple_describe_type(b);
    fprintf(stderr, "\nres: %d\ntmp: ", res);
    simple_describe_type(tmp);
    fprintf(stderr, "\ntmp2: ");
    simple_describe_type(tmp2);
    fprintf(stderr, "\n\n");

    clear_mapping(remap.markers[0]);
    clear_mapping(remap.markers[1]);

    tmp3 = low_type_binop(PT_BINOP_MINUS, a, b, &remap,
			  aflags, bflags, PT_FLAG_REMAP_TRACE);
    fprintf(stderr, "tmp3: ");
    simple_describe_type(tmp3);
    fprintf(stderr, "\n\n");

    if ((save_type_stackp != Pike_compiler->type_stackp) ||
	(save_mark_stackp != Pike_compiler->pike_type_mark_stackp)) {
      Pike_fatal("Stack level corruption!\n"
		 "type stack: %p (expected: %p)\n"
		 "mark stack: %p (expected: %p)\n",
		 Pike_compiler->type_stackp, save_type_stackp,
		 Pike_compiler->pike_type_mark_stackp, save_mark_stackp);
    }

    free_type(tmp3);
  }
#endif

  EXIT_REMAP_STATE(remap);

  free_type(tmp);
  free_type(tmp2);

  return !tmp2;
}

/**
 * Check whether a (after) is a valid variant overload of b (before).
 *
 * Returns 0 if a shadows all cases of b (ie b will never be used).
 *
 * Returns 1 otherwise.
 */
int check_variant_overload(struct pike_type *a, struct pike_type *b)
{
  /* NOTE: This test is non-intuitive. The intuitive test would be
   *       b - a == , but that does not work.
   *
   * Consider
   *
   *   a: function(:mixed)
   *   b: function(__unknown__ ...:mixed)
   *
   * ie
   *
   *   a: "The set of functions that accept 0 arguments."
   *   b: "The set of functions that accept any number of arguments."
   *
   * b - a will then result in , even though b actually can handle
   * some cases that a can't.
   */
  struct pike_type *diff =
    type_binop(PT_BINOP_MINUS, a, b,
	       PT_FLAG_CMP_INEXACT_FUN, PT_FLAG_CMP_INEXACT_FUN, 0);
  if (diff) {
    free_type(diff);
    return 1;
  }
  return 0;
}


/* FIXME, add the index */
static struct pike_type *low_index_type(struct pike_type *t,
					struct pike_type *index_type,
					node *n)
#ifdef DEBUG_MALLOC
#define low_index_type(X,Y,Z) ((struct pike_type *)debug_malloc_pass(low_index_type((X),(Y),(Z))))
#endif
{
  struct pike_type *tmp;
  struct program *p;
  int pragmas = 0;

  if (n) {
    struct compilation *c = THIS_COMPILATION;
    CHECK_COMPILER();
    pragmas = c->lex.pragmas;
  }

  switch(low_check_indexing(t, index_type, n))
  {
    case 0: return 0;
    case -1:
      add_ref(zero_type_string);
      return zero_type_string;
  }

  while(t &&
	((t->type == PIKE_T_NAME) ||
	 (t->type == PIKE_T_ATTRIBUTE) ||
	 (t->type == T_ASSIGN) ||
	 (t->type == T_SCOPE))) {
    t = t->cdr;
  }
  if (!t) {
    add_ref(mixed_type_string);
    return mixed_type_string;
  }
  while(index_type &&
	((index_type->type == PIKE_T_NAME) ||
	 (index_type->type == PIKE_T_ATTRIBUTE) ||
	 (index_type->type == T_ASSIGN) ||
	 (index_type->type == T_SCOPE))) {
    index_type = index_type->cdr;
  }

  switch(t->type)
  {
  case T_OBJECT:
  {
    p = id_to_program(CDR_TO_INT(t));

  comefrom_int_index:
    if(p && n)
    {
      INT32 i;
      if(n->token == F_ARROW)
      {
	if((i=FIND_LFUN(p,LFUN_ARROW))!=-1)
	{
	  struct pike_type *ret = NULL;
	  struct call_state cs;

	  INIT_CALL_STATE(cs, lfun_strings[LFUN_ARROW]);
	  add_ref(tmp = ID_FROM_INT(p, i)->type);
	  tmp = new_check_call(tmp, CDR(n), &cs, 0);
	  if (tmp) {
	    ret = new_get_return_type(tmp, &cs, 0);
	    free_type(tmp);
	  }
	  FREE_CALL_STATE(cs);

	  if (ret) return ret;

	  /* Invalid type for lfun::`->(). */
	  add_ref(mixed_type_string);
	  return mixed_type_string;
	}
      }else{
	if((i=FIND_LFUN(p,LFUN_INDEX)) != -1)
	{
	  struct pike_type *ret = NULL;
	  struct call_state cs;

	  INIT_CALL_STATE(cs, lfun_strings[LFUN_INDEX]);
	  add_ref(tmp = ID_FROM_INT(p, i)->type);
	  tmp = new_check_call(tmp, CDR(n), &cs, 0);
	  if (tmp) {
	    ret = new_get_return_type(tmp, &cs, 0);
	    free_type(tmp);
	  }
	  FREE_CALL_STATE(cs);

	  if (ret) return ret;
	  /* Invalid type for lfun::`[](). */
	  add_ref(mixed_type_string);
	  return mixed_type_string;
	}
      }
      if(CDR(n)->token == F_CONSTANT && TYPEOF(CDR(n)->u.sval) == T_STRING)
      {
	i = find_shared_string_identifier(CDR(n)->u.sval.u.string, p);
	if(i==-1)
	{
	  add_ref(mixed_type_string);
	  return mixed_type_string;
	}else{
	  add_ref(ID_FROM_INT(p, i)->type);
	  return ID_FROM_INT(p, i)->type;
	}
      }
    }
  }
  /* FALLTHRU */

  default:
    add_ref(mixed_type_string);
    return mixed_type_string;

  case PIKE_T_TYPE:
    {
      /* NB: Currently indexing is only supported for type(object)
       *     in order to keep it compatible with program(object).
       */
      struct pike_type *tmp = type_binop(PT_BINOP_AND,
					 t->car, object_type_string,
					 0, 0, 0);
      if (!tmp) {
	return NULL;
      }
      free_type(tmp);
    }
    /* FALLTHRU */

  case T_PROGRAM:
    {
      /* Programs may only be indexed with strings. */
      struct pike_type *tmp = type_binop(PT_BINOP_AND,
					 index_type, string_type_string,
					 0, 0, 0);
      if (!tmp) {
	return NULL;
      }
      free_type(tmp);
      add_ref(mixed_type_string);
      return mixed_type_string;
    }

  case T_MIXED:
    if (pragmas & ID_STRICT_TYPES) {
      yywarning("Indexing mixed.");
    }
    add_ref(mixed_type_string);
    return mixed_type_string;

  case T_INT:
    p=bignum_program;
    goto comefrom_int_index;

  case T_ZERO:
  case PIKE_T_RING:
  case T_VOID:
  case T_FLOAT:
    return 0;

  case T_OR:
  {
    struct pike_type *a,*b;
    a = low_index_type(t->car, index_type, n);
    b = low_index_type(t->cdr, index_type,n);
    if(!b) return a;
    if(!a) return b;
    type_stack_mark();
    low_or_pike_types(a,b,1);
    free_type(a);
    free_type(b);
    return pop_unfinished_type();
  }

  case T_AND:
    /* FIXME: Shouldn't both branches be looked at? */
    return low_index_type(t->cdr, index_type, n);

  case T_STRING: /* always int */
    {
      if (!t->car || (t->car->type == T_ZERO)) {
	yywarning("Indexing the empty string.");
      }
      if (t->cdr) {
	add_ref(t->cdr);
      }
      return t->cdr;
    }

  case T_MULTISET: /* always int(0..1) */
    type_stack_mark();
    push_int_type(0, 1);
    return pop_unfinished_type();

  case T_MAPPING:
    type_stack_mark();
    push_finished_type(t->cdr);
    push_type(T_ZERO);
    push_type(T_OR);
    return pop_unfinished_type();;

  case T_ARRAY:
    {
      struct pike_type *str_type;

      if ((str_type = type_binop(PT_BINOP_AND, index_type, string_type_string,
				 0, 0, 0))) {
	struct pike_type *a;
	if((a = low_index_type(t->cdr, str_type, n))) {
	  /* Possible to index the array with a string. */
	  free_type(str_type);

	  type_stack_mark();
	  push_finished_type(a);
	  free_type(a);
	  push_unlimited_array_type(T_ARRAY);

	  if (match_types(int_type_string, index_type)) {
	    /* Also possible to index the array with an int. */
	    push_finished_type(t->cdr);
	    push_type(T_OR);
	  }

	  return pop_unfinished_type();
	}
	free_type(str_type);
      }
      if (t->cdr && match_types(int_type_string, index_type)) {
	/* Possible to index the array with an int. */
	add_ref(t->cdr);
	return t->cdr;
      }
      /* Bad index type. */
      return 0;
    }
  }
}

/**
 * Returns the type resulting from indexing type with index_type.
 *
 * The node n is used to determine whether the indexing method
 * is `[]() (the default) or `->().
 *
 * See also key_type().
 */
struct pike_type *index_type(struct pike_type *type,
			     struct pike_type *index_type,
			     node *n)
{
  struct pike_type *t;
  clear_markers();
  t = low_index_type(type, index_type, n);
  return t;
}

#ifdef DEBUG_MALLOC
#define low_range_type(X,Y,Z) ((struct pike_type *)debug_malloc_pass(debug_low_range_type((X),(Y),(Z))))
#else
#define low_range_type debug_low_range_type
#endif

/* FIXME, add the index
 *
 * FIXME: Is the above fixme valid for this function too?
 */
static struct pike_type *debug_low_range_type(struct pike_type *t,
					      struct pike_type *index1_type,
					      struct pike_type *index2_type)
{
  struct compilation *c = THIS_COMPILATION;
  struct pike_type *tmp;
  struct program *p;

  CHECK_COMPILER();

  while((t->type == PIKE_T_NAME) ||
	(t->type == PIKE_T_ATTRIBUTE)) {
    t = t->cdr;
  }
  if (index1_type)
    while((index1_type->type == PIKE_T_NAME) ||
	  (index1_type->type == PIKE_T_ATTRIBUTE)) {
      index1_type = index1_type->cdr;
    }
  if (index2_type)
    while((index2_type->type == PIKE_T_NAME) ||
	  (index2_type->type == PIKE_T_ATTRIBUTE)) {
      index2_type = index2_type->cdr;
    }

  switch(t->type)
  {
  case T_OBJECT:
  {
    p = id_to_program(CDR_TO_INT(t));

    if(p)
    {
      INT32 i;

      if((i = FIND_LFUN(p, LFUN_RANGE)) != -1)
      {
	struct pike_type *call_type = NULL;
	type_stack_mark();
	push_finished_type(mixed_type_string);
	push_finished_type(void_type_string);
	push_type(T_OR);			/* Return type */
	push_finished_type(void_type_string);	/* Many type */
	push_type(T_MANY);
	push_int_type (INDEX_FROM_BEG, OPEN_BOUND); /* arg4 type */
	push_type(T_FUNCTION);
	if (index2_type)			/* arg3 type */
	  push_finished_type(index2_type);
	else
	  push_type (T_ZERO);
	push_type(T_FUNCTION);
	push_int_type (INDEX_FROM_BEG, OPEN_BOUND); /* arg2 type */
	push_type(T_FUNCTION);
	if (index1_type)			/* arg1 type */
	  push_finished_type(index1_type);
	else
	  push_type (T_ZERO);
	push_type(T_FUNCTION);
	call_type = pop_unfinished_type();

	if((tmp = check_call(call_type, ID_FROM_INT(p, i)->type, 0))) {
	  free_type(call_type);
	  return tmp;
	}
	free_type(call_type);

	add_ref(mixed_type_string);
	return mixed_type_string;
      }

      if((i = FIND_LFUN(p, LFUN_INDEX)) != -1)
      {
	/* FIXME: Should check for a _sizeof operator if from-the-end
	 * indexing is done. */

	struct pike_type *call_type = NULL;
	/* FIXME: function_type_string should be replaced with something
	 * derived from type_string
	 */
	type_stack_mark();
	push_finished_type(mixed_type_string);
	push_finished_type(void_type_string);
	push_type(T_OR);			/* Return type */
	push_finished_type(void_type_string);	/* Many type */
	push_type(T_MANY);
	if (index2_type)			/* arg2 type */
	  push_finished_type(index2_type);
	else
	  push_int_type (MAX_INT_TYPE, MAX_INT_TYPE);
	push_type(T_FUNCTION);
	if (index1_type)			/* arg1 type */
	  push_finished_type(index1_type);
	else
	  push_type (T_ZERO);
	push_type(T_FUNCTION);
	call_type = pop_unfinished_type();

	if((tmp = check_call(call_type, ID_FROM_INT(p, i)->type, 0))) {
	  free_type(call_type);
	  return tmp;
	}
	free_type(call_type);

	add_ref(mixed_type_string);
	return mixed_type_string;
      }

      yywarning("Ranging object without index operator.");
      return 0;
    }
    if (c->lex.pragmas & ID_STRICT_TYPES) {
      yywarning("Ranging generic object.");
    }
    add_ref(mixed_type_string);
    return mixed_type_string;
  }

  case T_MIXED:
    if (c->lex.pragmas & ID_STRICT_TYPES) {
      yywarning("Ranging mixed.");
    }
    add_ref(mixed_type_string);
    return mixed_type_string;

  case T_INT:
  case T_ZERO:
  case T_TYPE:
  case PIKE_T_RING:
  case T_VOID:
  case T_FLOAT:
  case T_MULTISET:
  case T_MAPPING:
    /* Illegal range operation. */
    /* FIXME: Strict type warning. */
    return 0;

  case T_ARRAY: /* FIXME: cdr */
  case T_STRING:
    /* Check that the index types are compatible with int. */
    {
      /* FIXME: Validate index1 and index2 type against index type. */
      if (index1_type && !match_types(int_type_string, index1_type)) {
	ref_push_type_value(t);
	yytype_report(REPORT_WARNING, NULL, 0, int_type_string,
		      NULL, 0, index1_type,
		      1, "Bad argument 1 to range operator on %O.");
	/* Bad index1 type. */
	return 0;
      }
      if (index2_type && !match_types(int_type_string, index2_type)) {
	ref_push_type_value(t);
	yytype_report(REPORT_WARNING, NULL, 0, int_type_string,
		      NULL, 0, index2_type,
		      1, "Bad argument 2 to range operator on %O.");
	/* Bad index2 type. */
	return 0;
      }
      /* FIXME: Adjust index type of result to be from
       *        min(index1) to max(index2).
       * FIXME: Do we need to check against the index type too?
       */
    }
    /* FALLTHROUGH */
  default:
    /* Identity. */
    add_ref(t);
    return t;

  case T_OR:
  {
    struct pike_type *a,*b;
    a = low_range_type(t->car, index1_type, index2_type);
    b = low_range_type(t->cdr, index1_type, index2_type);
    if(!b) return a;
    if(!a) return b;
    type_stack_mark();
    low_or_pike_types(a,b,1);
    free_type(a);
    free_type(b);
    return pop_unfinished_type();
  }

  case T_AND:
    /* FIXME: Shouldn't both branches be looked at? */
    return low_range_type(t->cdr, index1_type, index2_type);
  }
}

struct pike_type *range_type(struct pike_type *type,
			     struct pike_type *index1_type,
			     struct pike_type *index2_type)
{
  struct pike_type *t;
  clear_markers();
  t = low_range_type(type, index1_type, index2_type);
  if(!t) {
    yytype_report(REPORT_ERROR, NULL, 0, NULL, NULL, 0, NULL,
		  0, "Invalid range operation.");
    copy_pike_type(t, type);
  }
  return t;
}


static struct pike_type *low_array_value_type(struct pike_type *arr_t)
{
  struct pike_type *res = NULL;
  struct pike_type *sub_t;

  while (arr_t->type == T_OR) {
    sub_t = low_array_value_type(arr_t->car);
    arr_t = arr_t->cdr;
    if (sub_t) {
      if (res) {
	struct pike_type *new = or_pike_types(res, sub_t, 1);
	free_type(res);
	free_type(sub_t);
	res = new;
      } else {
	res = sub_t;
      }
    }
  }
  if (arr_t->type != T_ARRAY)
    return res;

  copy_pike_type(sub_t, arr_t->cdr);

  if (res) {
    struct pike_type *new = or_pike_types(res, sub_t, 1);
    free_type(res);
    free_type(sub_t);
    return new;
  }
  return sub_t;
}

struct pike_type *array_value_type(struct pike_type *array_type)
{
  struct pike_type *t = low_array_value_type(array_type);
  if (!t) {
    copy_pike_type(t, mixed_type_string);
  }
  return t;
}


#ifdef DEBUG_MALLOC
#define low_key_type(X,Y) ((struct pike_type *)debug_malloc_pass(debug_low_key_type((X),(Y))))
#else
#define low_key_type debug_low_key_type
#endif

/* FIXME, add the index */
static struct pike_type *debug_low_key_type(struct pike_type *t, node *n)
{
  switch(t?t->type:PIKE_T_UNKNOWN)
  {
  case T_OBJECT:
  {
    struct program *p = id_to_program(CDR_TO_INT(t));
    if(p && n)
    {
      if(n->token == F_ARROW)
      {
	int i;
	if((i = FIND_LFUN(p,LFUN_ARROW))!=-1 ||
	   (i = FIND_LFUN(p,LFUN_ASSIGN_ARROW))!=-1)
	{
	  /* Get the type of the first argument of the function. */
	  struct pike_type *res =
	    get_first_arg_type(ID_FROM_INT(p, i)->type, CALL_NOT_LAST_ARG);
	  if (res) return res;
	  /* FIXME: Warn? */
	  add_ref(string_type_string);
	  return string_type_string;
	}
      }else{
	int i;
	if((i = FIND_LFUN(p,LFUN_INDEX)) != -1 ||
	   (i = FIND_LFUN(p,LFUN_ASSIGN_INDEX)) != -1)
	{
	  /* Get the type of the first argument of the function. */
	  struct pike_type *res =
	    get_first_arg_type(ID_FROM_INT(p, i)->type, CALL_NOT_LAST_ARG);
	  if (res) return res;
	  /* FIXME: Warn? */
	  add_ref(mixed_type_string);
	  return mixed_type_string;
	}
      }
    }
    add_ref(string_type_string);
    return string_type_string;
  }

  case PIKE_T_MIXED:
    add_ref(mixed_type_string);
    return mixed_type_string;

  default:
    case PIKE_T_UNKNOWN:
    case T_VOID:
    case T_ZERO:
    case T_TYPE:
    case PIKE_T_RING:
    case T_FLOAT:
    case T_INT:
      return NULL;

  case T_OR:
  {
    struct pike_type *a,*b;
    a = low_key_type(t->car, n);
    b = low_key_type(t->cdr, n);
    if(!b) return a;
    if(!a) return b;
    type_stack_mark();
    low_or_pike_types(a,b,1);
    free_type(a);
    free_type(b);
    return pop_unfinished_type();
  }

  case T_AND:
  {
    struct pike_type *a,*b;
    a = low_key_type(t->car, n);
    b = low_key_type(t->cdr, n);
    t = and_pike_types(a, b);
    free_type(a);
    free_type(b);
    return t;
  }

  case T_NOT:
    t = low_key_type(t->car, n);
    type_stack_mark();
    push_finished_type(t);
    push_type(T_NOT);
    free_type(t);
    return pop_unfinished_type();

  case PIKE_T_SCOPE:
  case PIKE_T_ASSIGN:
  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
    return low_key_type(t->cdr, n);

  case T_ARRAY:
  case T_STRING:
  case T_MAPPING:
  case T_MULTISET:
    /* FIXME: Arrays may also be indexed with strings when
     *        strings are valid indices for their values.
     */
    copy_pike_type(t, t->car);
    return t;
  }
}

/**
 * Returns the type of valid indices of type.
 *
 * The node n is used to determine whether the indexing method
 * is `[]() (the default) or `->().
 *
 * See also index_type().
 */
struct pike_type *key_type(struct pike_type *type, node *n)
{
  struct pike_type *t;
  clear_markers();
  t = low_key_type(type,n);
  return t;
}


/* Returns whether a value of type 'type' may be indexed with a value
 * of type 'index_type'. Returns -1 if the indexing operation is valid,
 * but will always fail.
 * The node 'n' is the node with the indexing operator.
 */
static int low_check_indexing(struct pike_type *type,
			      struct pike_type *index_type,
			      node *n)
{
  if (!type) return 0;
  switch(type->type)
  {
  case T_OR:
    return low_check_indexing(type->car, index_type, n) ||
      low_check_indexing(type->cdr, index_type, n);

  case T_AND:
    return low_check_indexing(type->car, index_type, n) &&
      low_check_indexing(type->cdr, index_type, n);

  case T_NOT:
    return low_check_indexing(type->car, index_type, n) != 1;

  case PIKE_T_ATTRIBUTE:
    if (low_check_indexing(type->cdr, index_type, n)) {
      /* Valid index, so let's check if the attribute
       * handler has any other opinion.
       */
      ref_push_string((struct pike_string *)type->car);
      ref_push_type_value(type->cdr);
      ref_push_type_value(index_type);
      safe_apply_current2(PC_INDEX_TYPE_ATTRIBUTE_FUN_NUM, 3,
			  "index_type_attribute");
      if ((TYPEOF(Pike_sp[-1]) == T_INT) &&
	  (SUBTYPEOF(Pike_sp[-1]) == NUMBER_NUMBER) &&
	  (!Pike_sp[-1].u.integer)) {
	pop_stack();
	return 0;
      }
      pop_stack();
      return 1;
    }
    return 0;

  case PIKE_T_NAME:
  case T_ASSIGN:
  case T_SCOPE:
    return low_check_indexing(type->cdr, index_type, n);

  case T_ARRAY:
    if(match_types(string_type_string, index_type) &&
       low_check_indexing(type->cdr, index_type, n))
      return 1;
    /* FALLTHRU */
  case T_STRING:
    if (!match_types(int_type_string, index_type)) return 0;
    /* FIXME: Convert max(type->car) into int(-max..max-1), and check
     *        it against the index_type.
     */
    return 1;

  case T_OBJECT:
  {
    struct program *p = id_to_program(CDR_TO_INT(type));
    if(p)
    {
      int i = -1;
      /* Check against the LFUN types. */
      if(n && (n->token == F_ARROW))
      {
	(i = FIND_LFUN(p,LFUN_ARROW))!=-1 ||
	  (i = FIND_LFUN(p,LFUN_ASSIGN_ARROW));
      }else{
	(i = FIND_LFUN(p,LFUN_INDEX))!=-1 ||
	  (i = FIND_LFUN(p,LFUN_ASSIGN_INDEX));
      }
      if (i != -1) {
	struct call_state cs;
	INIT_CALL_STATE(cs, NULL);
	type = low_new_check_call(ID_FROM_INT(p, i)->type, index_type,
				  CALL_NOT_LAST_ARG, &cs, NULL);
	FREE_CALL_STATE(cs);
	if (type) {
	  free_type(type);
	  return 1;
	}
	return 0;
      }
      return match_types(string_type_string, index_type);
    }else{
      return 1;
    }
  }

  case T_MULTISET:
  case T_MAPPING:
    /* FIXME: Why -1 and not 0?
     *
     *  - There were complaints when people got compilation errors
     *    for indexing operations that would always fail.
     */
    if (type->car) {
      return match_types(type->car, index_type) ? 1 : -1;
    } else {
      /* NB: Lots of ancient code uses ([])[0] to generate UNDEFINED. */
      return 1;
    }

  case T_FUNCTION:
    while ((type = type->cdr) && (type->type == T_FUNCTION))
      ;
    if (!type) return 0;

    if (type->type != T_MANY) return 0;

    /* FALLTHRU */

  case T_MANY:
    type = type->cdr;
    if (!type || (type->type != T_OBJECT) || !type->car)
      return 0;
    /* function(... : object(is foo)) -- ie probably program(foo). */

    /* FALLTHRU */

    case T_INT:
    case T_PROGRAM:
    case PIKE_T_TYPE:
      /* NB: In some circumstances program(X) gets converted into type(X). */
      return match_types(string_type_string, index_type);

  case T_MIXED:
    return 1;

  default:
    return 0;
  }
}

int check_indexing(struct pike_type *type,
		   struct pike_type *index_type,
		   node *n)
{
  return low_check_indexing(type, index_type, n);
}

static int low_count_arguments(struct pike_type *q)
{
  int num=0, num2;

  switch(q->type & PIKE_T_MASK)
  {
    case T_OR:
      num = low_count_arguments(q->car);
      num2 = low_count_arguments(q->cdr);
      if(num<0 && num2>0) return num;
      if(num2<0 && num>0) return num2;
      if(num2<0 && num<0) return ~num>~num2?num:num2;
      return num>num2?num:num2;

    case T_AND:
      num = low_count_arguments(q->car);
      num2 = low_count_arguments(q->cdr);
      if(num<0 && num2>0) return num2;
      if(num2<0 && num>0) return num;
      if(num2<0 && num<0) return ~num<~num2?num:num2;
      return num<num2?num:num2;

    case PIKE_T_NAME:
    case PIKE_T_ATTRIBUTE:
    case T_ASSIGN:
    case T_SCOPE:
      return low_count_arguments(q->cdr);

    default: return MAX_INT32;

    case PIKE_T_OPERATOR:
      {
	struct pike_type *t = apply_type_operator(q->type, q->car, q->cdr);
	if (!t) return 0;
	num = low_count_arguments(t);
	free_type(t);
	return num;
      }

    case PIKE_T_TRANSITIVE:
      num = low_count_arguments(q->car);
      if (num == MAX_INT32) return num;
      if (num < 0) return num;
      return ~num;

    case T_FUNCTION:
      while(q->type == T_FUNCTION)
      {
	num++;
	q = q->cdr;
      }

      if (q->type != T_MANY) {
	num2 = low_count_arguments(q);
	if (num2 == MAX_INT32) return num2;
	if (num2 < 0) {
	  num += ~num2;
	  return ~num;
	}
	return num + num2;
      }

      /* FALLTHRU */
    case T_MANY:
      q = q->car;
      if(!q || (q->type != T_VOID)) return ~num;
      return num;
  }
}

/* Count the number of arguments for a funciton type.
 * return -1-n if the function can take number of arguments
 * >= n  (varargs)
 */
int count_arguments(struct pike_type *s)
{
  return low_count_arguments(s);
}


static int low_minimum_arguments(struct pike_type *q)
{
  int num;

  switch(q->type)
  {
    case T_OR:
    case T_AND:
      return MAXIMUM(low_count_arguments(q->car),
		     low_count_arguments(q->cdr));

    default: return 0;

    case PIKE_T_NAME:
    case PIKE_T_ATTRIBUTE:
    case T_ASSIGN:
    case T_SCOPE:
      return low_minimum_arguments(q->cdr);

    case T_FUNCTION:
      num = 0;
      while(q->type == T_FUNCTION)
      {
	struct pike_type *t;
	if ((t = low_match_types(void_type_string, q->car, B_EXACT))) {
	  free_type(t);
	  return num;
	}

	num++;
	q = q->cdr;
      }
      return num;
    case T_MANY:
      return 0;
  }
}

/* Count the minimum number of arguments for a function type.
 */
int minimum_arguments(struct pike_type *s)
{
  int ret;

  ret = low_minimum_arguments(s);

#if 0
  fprintf(stderr,"minimum_arguments(");
  simple_describe_type(s);
  fprintf(stderr," ) -> %d\n",ret);
#endif

  return ret;
}

/**
 * Return the return type from a function call (old API).
 *
 * @param type
 *   The function type.
 *
 * @param args
 *   The function type for the arguments.
 *
 * See also low_get_return_type().
 */
struct pike_type *check_call(struct pike_type *args,
			     struct pike_type *type,
			     int strict)
{
  clear_markers();
  type_stack_mark();
  max_correct_args=0;

  if(low_get_return_type(type, args))
  {
    if (strict) {
      if (!strict_check_call(type, args)) {
	struct pike_type *func_zero_type;

	MAKE_CONSTANT_TYPE(func_zero_type, tFuncV(tNone,tZero,tMix));

	if (!low_pike_types_le(type, func_zero_type, 0, 0)) {
	  yytype_report(REPORT_WARNING, NULL, 0, function_type_string,
			NULL, 0, type,
			0, "Calling non-function value.");
	} else {
	  yytype_report(REPORT_WARNING, NULL, 0, type,
			NULL, 0, args,
			0, "Arguments not strictly compatible.");
	}

	free_type(func_zero_type);
      }
    }
    return pop_unfinished_type();
  }else{
    pop_stack_mark();
    return 0;
  }
}

/* Get the type for the specified argument in a function type.
 * Argument number -1 is the return type.
 * True arguments are counted from zero.
 */
struct pike_type *get_argument_type(struct pike_type *fun, int arg_no)
{
  struct pike_type *tmp, *tmp2;

 loop:
  switch(fun->type & PIKE_T_MASK) {
  case T_OR:
    fun = or_pike_types(tmp = get_argument_type(fun->car, arg_no),
			tmp2 = get_argument_type(fun->cdr, arg_no),
			1);
    free_type(tmp);
    free_type(tmp2);
    return fun;

  case PIKE_T_OPERATOR:
    tmp = apply_type_operator(fun->type, fun->car, fun->cdr);
    if (!tmp) return NULL;
    tmp2 = get_argument_type(tmp, arg_no);
    free_type(tmp);
    return tmp2;

  case PIKE_T_TRANSITIVE:
    if (arg_no < 0) {
      fun = fun->cdr;
      goto loop;
    }

    tmp2 = expand_transitive(fun, a_markers, 0);
    tmp = get_argument_type(tmp2, arg_no);
    free_type(tmp2);
    return tmp;

  case T_FUNCTION:
    if (arg_no > 0) {
      arg_no--;
      fun = fun->cdr;
      goto loop;
    }
    /* FALLTHRU */
  case T_MANY:
    if (arg_no < 0) {
      add_ref(fun->cdr);
      return fun->cdr;
    }
    safe_add_ref(fun->car);
    return fun->car;

  case T_MIXED:
    add_ref(fun);
    return fun;

  case T_ARRAY:
    if (arg_no < 0) {
      type_stack_mark();
      push_finished_type(fun = get_argument_type(fun->cdr, arg_no));
      push_unlimited_array_type(T_ARRAY);
      free_type(fun);
      return pop_unfinished_type();
    }
    return get_argument_type(fun->car, arg_no);

  case PIKE_T_ATTRIBUTE:
    type_stack_mark();
    push_finished_type(tmp = get_argument_type(fun->cdr, arg_no));
    push_type_attribute((struct pike_string *)(fun->car));
    free_type(tmp);
    return pop_unfinished_type();

  case PIKE_T_SCOPE:
  case T_ASSIGN:
  case PIKE_T_NAME:
    fun = fun->cdr;
    goto loop;

  default:
#if 0
    fprintf(stderr,
	    "Failed to resolve argument type for argument %d.\n"
	    "Type: ",
	    arg_no);
    simple_describe_type(fun);
    fprintf(stderr, "\n"
	    "Node type: %d\n",
	    fun->type);
#endif
    add_ref(zero_type_string);
    return zero_type_string;
  }
}

/* Get the resulting type from a soft cast.
 *
 * Flags:
 *   1 SOFT_WEAKER	Weaker type.
 */
struct pike_type *soft_cast(struct pike_type *soft_type,
			    struct pike_type *orig_type,
			    int flags)
{
  if (flags & SOFT_WEAKER) {
    return type_binop(PT_BINOP_AND, orig_type, soft_type,
		      PT_FLAG_CMP_NULLABLE, 0, 0);
  } else {
    return type_binop(PT_BINOP_AND, orig_type, soft_type, 0, 0, 0);
  }
}

/**
 * Check whether sval is a valid value for a variable of
 * type type.
 *
 * Returns 1 if ok, and 0 (zero) otherwise.
 */
static int match_type_svalue(struct pike_type *type,
			     int flags,
			     struct svalue *sval)
{
  int res = 0;
  struct pike_type *sub;
 loop:
  switch(type->type) {
  case T_SCOPE:
  case T_ASSIGN:
  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
    type = type->cdr;
    goto loop;
  case T_OR:
    res = match_type_svalue(type->car, 0, sval) ||
      match_type_svalue(type->cdr, 0, sval);
    break;
  case T_AND:
    res = match_type_svalue(type->car, 0, sval) &&
      match_type_svalue(type->cdr, 0, sval);
    break;
  case T_NOT:
    flags ^= CALL_INVERTED_TYPES;
    type = type->car;
    goto loop;
  case T_VOID:
    /* Allow UNDEFINED for voidable arguments. */
    res = (TYPEOF(*sval) == T_INT) && !sval->u.integer && SUBTYPEOF(*sval);
    break;
  case T_ZERO:
    res = SAFE_IS_ZERO(sval);
    break;
  case PIKE_T_TYPE:
    res = 1;
    break;
  case PIKE_T_PROGRAM:
  case PIKE_T_FUNCTION:
  case T_MANY:
    {
      struct pike_type *t = NULL;
      /* Identify if sval is callable. */
      if (TYPEOF(*sval) == PIKE_T_OBJECT) {
	struct program *p;
	int f;
	struct identifier *id;
	if (!sval->u.object || !(p = sval->u.object->prog)) break;
	p = p->inherits[SUBTYPEOF(*sval)].prog;
	if ((f = FIND_LFUN(p, LFUN_CALL)) == -1) break;
	id = ID_FROM_INT(p, f);
	t = id->type;
	res = 1;
      } else {
	res =
	  (TYPEOF(*sval) == T_FUNCTION) ||
	  (TYPEOF(*sval) == T_PROGRAM) ||
	  (TYPEOF(*sval) == T_ARRAY) ||
	  (TYPEOF(*sval) == T_TYPE);
      }
      /* FIXME: Check arguments */
      /* FIXME: Check return type */
    }
    break;
  case PIKE_T_MIXED:
    res = 1;
    break;
  case PIKE_T_OBJECT:
    if( TYPEOF( *sval ) == PIKE_T_OBJECT )
    {
      struct object *o = sval->u.object;
      if( o->prog )
      {
        if( !type->cdr )
        {
          res = 1;
        }
        else
        {
          struct program *mark = id_to_program( CDR_TO_INT( type ) );
          if( mark == o->prog )
            res = 1;
          else if( type->car )
            res = is_compatible( o->prog, mark );
          else
            res = implements( o->prog, mark );
        }
      }
    }
    break;
  case PIKE_T_STRING:
    if( TYPEOF( *sval ) == PIKE_T_STRING )
    {
      sub = type->cdr;
      if (sub->type == T_ZERO)
      {
        res = (sval->u.string->len == 0);
	break;
      }
      else if( sub->type == PIKE_T_INT )
      {
        struct pike_string *s = sval->u.string;
        INT32 min = CAR_TO_INT( sub ), max = CDR_TO_INT( sub );
        INT32 string_min, string_max;
        int checked = 0;

        check_string_range( s, 1, &string_min, &string_max );

        if( min != MIN_INT32 )
        {
          if( string_min < min )
          {
            if( s->size_shift )
              check_string_range( s, 0, &string_min, &string_max );
            if( string_min < min )
              goto do_return;
            checked = 1;
          }
        }

        if( max != MIN_INT32 )
        {
          if( string_max > max )
          {
            if( s->size_shift && !checked )
              check_string_range( s, 0, NULL, &string_max );

            if( string_max > max )
              goto do_return;
          }
        }
      }
      res = 1;
    }
    break;
  case PIKE_T_INT:
    if( TYPEOF( *sval ) == PIKE_T_INT )
    {
      INT_TYPE current = sval->u.integer;
      INT32 min, max;
      min = CAR_TO_INT( type );
      max = CDR_TO_INT( type );
      if( min != MIN_INT32 )
      {
        if( current < min )
          break;
      }
      if( max != MAX_INT32 )
      {
        if( current > max )
          break;
      }
      res = 1;
    }
    /* FIXME: Objects that emulate integers? */
    else if( TYPEOF(*sval) == PIKE_T_OBJECT )
    {
      if( is_bignum_object(sval->u.object) )
      {
        INT32 min = CAR_TO_INT( type );
        INT32 max = CDR_TO_INT( type );
        if( min != MIN_INT32 && max != MAX_INT32 )
        {
          struct svalue tmp;
          TYPEOF(tmp)=PIKE_T_INT;
          if( min != MIN_INT32 )
          {
            tmp.u.integer = min;
            if( is_lt( sval, &tmp ) )
              break;
          }
          if( max != MAX_INT32 )
          {
            tmp.u.integer = max;
            if( is_gt( sval, &tmp ) )
              break;
          }
        }
        res = 1;
      }
    }
    break;
  default:
    res = (type->type == TYPEOF(*sval));
    break;
  }
 do_return:
  if (flags & CALL_INVERTED_TYPES) return !res;
  return res;
}

/**
 * Check whether sval is a valid first argument to fun_type.
 *
 * Returns NULL on failure.
 *
 * Returns continuation function type on success.
 *
 * Used by the variant dispatcher.
 */
struct pike_type *check_call_svalue(struct pike_type *fun_type,
				    INT32 flags,
				    struct svalue *sval)
{
  struct pike_type *res = NULL;
  struct pike_type *tmp;
  struct pike_type *tmp2;
  INT32 array_cnt = 0;

#ifdef PIKE_DEBUG
  if (Pike_interpreter.trace_level > 2) {
    fprintf(stderr, "    check_call_svalue(");
    simple_describe_type(fun_type);
    fprintf(stderr, ", 0x%08x, ", flags);
    debug_describe_svalue(sval);
    fprintf(stderr, ")...\n");
  }
#endif /* PIKE_DEBUG */

 loop:
  /* Count the number of array levels. */
  while(fun_type->type == PIKE_T_ARRAY) {
    array_cnt++;
    fun_type = fun_type->cdr;
  }

  switch(fun_type->type) {
  case T_SCOPE:
    /* FIXME: Save and restore the corresponding marker set. */
  case T_ASSIGN:
  case PIKE_T_NAME:
    fun_type = fun_type->cdr;
    goto loop;

  case PIKE_T_ATTRIBUTE:
    fun_type = fun_type->cdr;
    goto loop;

  case T_OR:
    res = check_call_svalue(fun_type->car, flags, sval);
    if (!res) {
      fun_type = fun_type->cdr;
      goto loop;
    }
    tmp = check_call_svalue(fun_type->cdr, flags, sval);
    if (!tmp) break;
    res = or_pike_types(tmp2 = res, tmp, 1);
    free_type(tmp);
    free_type(tmp2);
    break;

  case T_AND:
    res = check_call_svalue(fun_type->car, flags, sval);
    if (!res) break;
    tmp = check_call_svalue(fun_type->cdr, flags, sval);
    if (!tmp) {
      free_type(res);
      res = NULL;
      break;
    }
    if (res == tmp) {
      /* Common case. */
      free_type(tmp);
      break;
    }
    /* and_pike_types() doesn't handle and of functions
     * in the way we want here.
     */
    type_stack_mark();
    push_finished_type(tmp);
    push_finished_type(res);
    push_type(T_AND);
    free_type(tmp);
    free_type(res);
    res = pop_unfinished_type();
    break;

  case T_NOT:
    fun_type = fun_type->car;
    flags ^= CALL_INVERTED_TYPES;
    goto loop;

  case PIKE_T_TYPE:
    /* FIXME: Check that the cast is valid. */
    type_stack_mark();
    push_finished_type(fun_type->car);
    push_type(T_VOID);
    push_type(T_MANY);
    res = pop_unfinished_type();
    break;

  case PIKE_T_PROGRAM:
    tmp = low_object_lfun_type(fun_type->car, LFUN_CREATE);
    if (!tmp) {
      /* No create() -- No arguments. */
      /* FIXME: Multiple cases:
       *          Untyped object.		function(mixed...:obj)
       *          Failed to lookup program id.	function(mixed...:obj)
       *          Program does not have a create().	function(:obj)
       *
       * We simply ignore the args.
       */

      type_stack_mark();
      push_finished_type(fun_type->car);
      push_type(T_MIXED);
      push_type(T_VOID);
      push_type(T_OR);
      push_type(T_MANY);
      fun_type = pop_unfinished_type();
    } else {
      fun_type = zzap_function_return(tmp, fun_type->car);
    }
    res = check_call_svalue(fun_type, flags, sval);
    free_type(fun_type);
    break;

  case PIKE_T_OBJECT:
    fun_type = low_object_lfun_type(fun_type, LFUN_CALL);
    if (fun_type) goto loop;

    /* FIXME: Multiple cases:
     *          Untyped object.				mixed
     *          Failed to lookup program id.		mixed
     *          Program does not have the lfun `()().	NULL
     */

    /* FALLTHRU */
  case PIKE_T_MIXED:
    copy_pike_type(res, mixed_type_string);
    break;

  case PIKE_T_FUNCTION:
    /* Note: Use the low variants of pike_types_le and match_types,
     *       so that markers get set and kept. */
    if (match_type_svalue(fun_type->car, flags, sval)) {
      add_ref(res = fun_type->cdr);
      break;
    }
    res = NULL;
    break;
  case T_MANY:
    /* Note: Use the low variants of pike_types_le and match_types,
     *       so that markers get set and kept. */
    if (match_type_svalue(fun_type->car, flags, sval)) {
      add_ref(res = fun_type);
      break;
    }
    res = NULL;
    break;
  default:
    /* Not a callable. */
    break;
  }

  if (!array_cnt || !res) {
#ifdef PIKE_DEBUG
    if (Pike_interpreter.trace_level > 2) {
      if (res) {
	fprintf(stderr, "    ==> ");
	simple_describe_type(res);
      } else {
	fprintf(stderr, "    ==> NULL");
      }
      fprintf(stderr, "\n");
    }
#endif /* PIKE_DEBUG */
    return res;
  }

  type_stack_mark();
  push_finished_type(res);
  free_type(res);
  while(array_cnt--) {
    push_unlimited_array_type(PIKE_T_ARRAY);
  }
  res = pop_unfinished_type();

#ifdef PIKE_DEBUG
  if (Pike_interpreter.trace_level > 2) {
    fprintf(stderr, "    ==> ");
    simple_describe_type(res);
    fprintf(stderr, "\n");
  }
#endif /* PIKE_DEBUG */

  return res;
}

/* Check whether arg_type may be used as the type of the first argument
 * in a call to fun_type.
 *
 * The first argument has no OR or AND nodes.
 *
 * Returns NULL on failure.
 *
 * Returns continuation function type on success.
 */
static struct pike_type *lower_new_check_call(struct pike_type *fun_type,
					      struct pike_type *arg_type,
					      INT32 flags,
					      struct call_state *cs,
					      struct svalue *sval
#ifdef PIKE_TYPE_DEBUG
					      , INT32 indent
#define CHECK_CALL_ARGS	, indent+1
#else
#define CHECK_CALL_ARGS
#endif /* PIKE_TYPE_DEBUG */
					      )
{
  struct compilation *c = MAYBE_THIS_COMPILATION;
  struct pike_type *res = NULL;
  struct pike_type *tmp;
  struct pike_type *tmp2;
  INT32 array_cnt = 0;

#ifdef PIKE_DEBUG
  if (l_flag>2) {
    fprintf(stderr, "%*slower_new_check_call(", indent*2, "");
    simple_describe_type(fun_type);
    fprintf(stderr, ", ");
    simple_describe_type(arg_type);
    fprintf(stderr, ", 0x%04x, %p(argno:%d), %p)...\n",
	    flags, cs, cs?cs->argno:-1, sval);
  }
#endif /* PIKE_DEBUG */

 loop:
  /* Count the number of array levels. */
  while(fun_type && (fun_type->type == PIKE_T_ARRAY)) {
    array_cnt++;
    fun_type = fun_type->cdr;
  }

  switch(fun_type?(fun_type->type & PIKE_T_MASK):PIKE_T_UNKNOWN) {
  case T_SCOPE:
    /* FIXME: Save and restore the corresponding marker set. */
  case T_ASSIGN:
  case PIKE_T_NAME:
    fun_type = fun_type->cdr;
    goto loop;

  case PIKE_T_ATTRIBUTE:
    res = lower_new_check_call(fun_type->cdr, arg_type, flags,
			       cs, sval CHECK_CALL_ARGS);
    if (!res) return NULL;
    if (c) {
      if (!cs->m) {
	cs->m = allocate_mapping(0);
      }
      ref_push_string((struct pike_string *)fun_type->car);
      ref_push_type_value(res);
      ref_push_mapping(cs->m);
      safe_apply_current2(PC_APPLY_TYPE_ATTRIBUTE_FUN_NUM, 3,
			  "apply_type_attribute");
      if ((TYPEOF(Pike_sp[-1]) == T_INT) &&
	  (SUBTYPEOF(Pike_sp[-1]) == NUMBER_NUMBER) &&
	  (!Pike_sp[-1].u.integer)) {
	pop_stack();
	free_type(res);
	return NULL;
      }
      pop_stack();
    }
    type_stack_mark();
    push_finished_type(res);
    push_type_attribute((struct pike_string *)fun_type->car);
    free_type(res);
    res = pop_unfinished_type();
    break;

  case T_OR:
    type_stack_mark();
    push_type(PIKE_T_UNKNOWN);
    for (;fun_type->type == T_OR; fun_type = fun_type->cdr) {
      res = lower_new_check_call(fun_type->car, arg_type, flags,
				 cs, sval CHECK_CALL_ARGS);
      if (!res) continue;
      push_finished_type(res);
      free_type(res);
      push_type(T_OR);
    }
    if (fun_type) {
      res = lower_new_check_call(fun_type, arg_type, flags,
				 cs, sval CHECK_CALL_ARGS);
      if (res) {
	push_finished_type(res);
	free_type(res);
	push_type(T_OR);
      }
    }
    res = pop_unfinished_type();
    break;

  case T_AND:
    res = lower_new_check_call(fun_type->car, arg_type, flags,
			       cs, sval CHECK_CALL_ARGS);
    if (!res) break;
    tmp = lower_new_check_call(fun_type->cdr, arg_type, flags,
			       cs, sval CHECK_CALL_ARGS);
    if (!tmp) {
      free_type(res);
      res = NULL;
      break;
    }
    if (res == tmp) {
      /* Common case. */
      free_type(tmp);
      break;
    }
    /* and_pike_types() doesn't handle and of functions
     * in the way we want here.
     */
    type_stack_mark();
    push_finished_type(tmp);
    push_finished_type(res);
    push_type(T_AND);
    free_type(tmp);
    free_type(res);
    res = pop_unfinished_type();
    break;

  case T_NOT:
    if (arg_type && (arg_type->type == T_NOT)) {
      /* Both sides are inverted. Pop both inversions. */
      arg_type = arg_type->car;
      fun_type = fun_type->car;
      flags ^= CALL_INVERTED_TYPES;
      goto loop;
    } else {
      res = lower_new_check_call(fun_type->car, arg_type,
				 flags ^ CALL_INVERTED_TYPES,
				 cs, sval CHECK_CALL_ARGS);
      if (res) {
	/* The argument matched the function type. */
	/* Move the inversion back to the function type. */
	type_stack_mark();
	push_finished_type(res);
	free_type(res);
	push_type(T_NOT);
	res = pop_unfinished_type();
      } else {
	/* The argument did not match the function type.
	 * ie the inverted type got a full match.
	 */
	add_ref(any_type_string);
	res = any_type_string;
      }
    }
    break;

  case PIKE_T_TYPE:
    /* FIXME: Check that the cast is valid. */
    type_stack_mark();
    push_finished_type(fun_type->car);
    push_type(T_VOID);
    push_type(T_MANY);
    res = pop_unfinished_type();
    break;

  case PIKE_T_PROGRAM:
    tmp = low_object_lfun_type(fun_type->car, LFUN_CREATE);
    if (!tmp) {
      /* No create() -- No arguments. */
      /* FIXME: Multiple cases:
       *          Untyped object.		function(mixed...:obj)
       *          Failed to lookup program id.	function(mixed...:obj)
       *          Program does not have a create().	function(:obj)
       *
       * We simply ignore the args.
       */

      type_stack_mark();
      push_finished_type(fun_type->car);
      push_type(T_MIXED);
      push_type(T_VOID);
      push_type(T_OR);
      push_type(T_MANY);
      fun_type = pop_unfinished_type();
    } else {
      fun_type = zzap_function_return(tmp, fun_type->car);
    }
    res = lower_new_check_call(fun_type, arg_type, flags,
			       cs, sval CHECK_CALL_ARGS);
    free_type(fun_type);
    break;

  case PIKE_T_OBJECT:
    fun_type = low_object_lfun_type(fun_type, LFUN_CALL);
    if (fun_type) goto loop;

    /* FIXME: Multiple cases:
     *          Untyped object.				mixed
     *          Failed to lookup program id.		mixed
     *          Program does not have the lfun `()().	NULL
     */

    /* FALLTHRU */
  case PIKE_T_MIXED:
    copy_pike_type(res, mixed_type_string);
    break;

  case PIKE_T_OPERATOR:
    tmp = apply_type_operator(fun_type->type, fun_type->car, fun_type->cdr);
    if (!tmp) {
      return NULL;
    }
    res = lower_new_check_call(tmp, arg_type, flags,
			       cs, sval CHECK_CALL_ARGS);
    free_type(tmp);
    break;

  case PIKE_T_TRANSITIVE:
#if 0
    /* NB: In theory we could use expand_transitive() here and recurse,
     *     but this leads to a combinatorial explosion.
     */
    tmp = expand_transitive(fun_type, a_markers, 0);
    res = lower_new_check_call(tmp, arg_type, flags,
			       cs, sval CHECK_CALL_ARGS);
    free_type(tmp);
#else
    /* There are two cases here; arg_type can belong to either
     * fun_type->car, or (if fun_type->car can return here) the
     * second argument to fun_type->cdr (or both).
     */
    if (fun_type->car) {
      tmp = new_get_return_type(fun_type->car, cs, 0);
    } else {
      tmp = new_get_return_type(fun_type->cdr, cs, 0);
    }
    if (tmp) {
      tmp2 = low_new_check_call(fun_type->cdr, tmp, 0, cs, NULL);
      free_type(tmp);
      tmp = NULL;
      if (tmp2) {
	/* tmp is a valid argument to fun_type->cdr,
	 * so check if arg_type is also valid. */
	tmp = lower_new_check_call(tmp2, arg_type, flags,
				   cs, sval CHECK_CALL_ARGS);
	free_type(tmp2);
      }
    }

    if (fun_type->car) {
      tmp2 = lower_new_check_call(fun_type->car, arg_type, flags,
				  cs, sval CHECK_CALL_ARGS);
    } else {
      tmp2 = lower_new_check_call(fun_type->cdr, arg_type, flags,
				  cs, sval CHECK_CALL_ARGS);
    }
    if (tmp2) {
      if (!tmp) {
	tmp = tmp2;
      } else {
	/* NB: Using arg_type as a temporary variable. */
	arg_type = or_pike_types(tmp, tmp2, 1);
	free_type(tmp);
	free_type(tmp2);
	tmp = arg_type;
      }
    }

    if (!tmp) return NULL;

    type_stack_mark();
    push_finished_type(fun_type->cdr);
    push_finished_type(tmp);
    push_type(PIKE_T_TRANSITIVE);
    free_type(tmp);
    res = pop_unfinished_type();
#endif
    break;

  case PIKE_T_FUNCTION:
  case T_MANY:
    /* Special case to detect workarounds for the old
     * function call checker.
     */
    tmp = NULL;
    if (arg_type &&
	((arg_type->type != T_NOT) ||
	 (arg_type->car->type != T_MIXED)) &&
	fun_type->car &&
	(fun_type->car->type == T_NOT) &&
	(fun_type->car->car->type == T_OR) &&
	((fun_type->car->car->car->type == T_MIXED) ||
	 (fun_type->car->car->cdr->type == T_MIXED))) {
      /* Rebuild the function type without the negated mixed
       * in the first argument.
       */
      type_stack_mark();
      push_finished_type(fun_type->cdr);
      if (fun_type->car->car->car->type == T_MIXED) {
	push_finished_type(fun_type->car->car->cdr);
      } else {
	push_finished_type(fun_type->car->car->car);
      }
      push_type(T_NOT);
      push_type(fun_type->type);
      tmp = fun_type = pop_unfinished_type();
    }

    {
      struct remap_state remap;
      struct pike_type *fun_cont;
      enum pt_remap_flags remap_flags = 0;
      struct pike_type *arg_match = NULL;

      INIT_REMAP_STATE(remap);

#ifdef PIKE_DEBUG
      if (l_flag>2) {
	fprintf(stderr, "%*sChecking argument type ", indent*2+2, "");
	simple_describe_type(arg_type);
	fprintf(stderr, " against function type ");
	simple_describe_type(fun_type);
	fprintf(stderr, ".\n");
	remap_flags |= PT_FLAG_REMAP_TRACE;
      }
#endif /* PIKE_DEBUG */

      if (!cs->m) {
	cs->m = allocate_mapping(4);
      }
      add_ref(remap.state = cs->m);

      push_int(cs->argno);
      push_constant_text("argno");
      mapping_insert(cs->m, Pike_sp-1, Pike_sp-2);
      pop_n_elems(2);

      /* No need to perform advanced checking in the trivial case... */
      if (arg_type != (tmp2 = fun_type->car)) {
	if (tmp2 == void_type_string) {
	  /* No more arguments accepted. */
	  goto no_match;
	}
	if (flags & CALL_ARG_LVALUE) {
	  /* For lvalues (ie sscanf) the direction is reversed. */
	  struct pike_type *tmp3 = tmp2;
	  tmp2 = arg_type;
	  arg_type = tmp3;

	  remap_flags ^= PT_FLAG_REMAP_SWAP_MARKERS;
	}
	if (!tmp2) {
	  if (flags & CALL_STRICT) goto no_match;
	} else {
	  struct pike_type *bin_t =
	    low_type_binop(PT_BINOP_MINUS,
			   arg_type, tmp2, &remap,
			   PT_FLAG_CMP_VOID_IS_ZERO|PT_FLAG_CMP_FUN_ARG,
			   PT_FLAG_CMP_VOID_IS_ZERO,
			   remap_flags|PT_FLAG_REMAP_EVAL_MARKERS);

	  if (bin_t) {
	    /* Partial or strict mismatch. */
	    free_type(bin_t);

	    if ((flags & (CALL_INVERTED_TYPES|CALL_STRICT)) ||
		(bin_t == arg_type)) {
	      goto no_match;
	    }

	    /* Partial matches allowed. */

	    arg_match = low_type_binop(PT_BINOP_AND,
				       arg_type, tmp2, &remap,
				       PT_FLAG_CMP_VOID_IS_ZERO|
				       PT_FLAG_CMP_FUN_ARG,
				       PT_FLAG_CMP_VOID_IS_ZERO,
				       remap_flags);

	    if (!arg_match) {
	    no_match:
	      /* No match. */
#ifdef PIKE_DEBUG
	      if (l_flag>2) {
		fprintf(stderr, "%*sNo match.\n", indent*2+2, "");
	      }
#endif /* PIKE_DEBUG */
	      res = NULL;
	      if (tmp) free_type(tmp);

	      EXIT_REMAP_STATE(remap);

	      break;
	    }
	  }
	}

	if (flags & CALL_ARG_LVALUE) {
	  /* Undo the lvalue swap from above. */
	  struct pike_type *tmp3 = tmp2;
	  tmp2 = arg_type;
	  arg_type = tmp3;

	  remap_flags ^= PT_FLAG_REMAP_SWAP_MARKERS;
	}
      }

      if (!arg_match) {
	arg_match = arg_type;
	if(arg_match) {
	  add_ref(arg_match);
	}
      }

      /* Match. */
      if (fun_type->type == PIKE_T_FUNCTION) {
	struct pike_type *t = NULL;
	/* Advance to the next argument. */
	fun_cont = fun_type->cdr;
      } else {
	fun_cont = fun_type;
      }

      if (tmp) free_type(tmp);

      /* NB: KEEP_MARKERS is needed if we are staying on
       *     the same function type, as it (by definition)
       *     then still holds the same assignments too.
       */
      res = remap_markers(fun_cont, &remap,
			  remap_flags|PT_FLAG_REMAP_SWAP_MARKERS|
			  ((fun_type == fun_cont)?
			   PT_FLAG_REMAP_KEEP_MARKERS:0));

      EXIT_REMAP_STATE(remap);

      if (Pike_compiler->compiler_pass == COMPILER_PASS_LAST) {
	while (tmp2 && (tmp2->type == PIKE_T_NAME)) {
	  tmp2 = tmp2->cdr;
	}

	if (tmp2 && (tmp2->type == PIKE_T_ATTRIBUTE)) {
	  struct compilation *c = MAYBE_THIS_COMPILATION;
	  if (c) {
	    /* Perform extra argument checking based on the attribute. */
	    if (!cs->m) {
	      cs->m = allocate_mapping(0);
	    }
	    ref_push_string((struct pike_string *)tmp2->car);
	    if (sval) {
	      push_svalue(sval);
	    } else {
	      push_undefined();
	    }
	    ref_push_type_value(arg_match);
	    ref_push_type_value(res);
	    ref_push_mapping(cs->m);
	    safe_apply_current(PC_APPLY_ATTRIBUTE_CONSTANT_FUN_NUM, 5);
	    if (TYPEOF(Pike_sp[-1]) == PIKE_T_TYPE) {
	      /* Got an alternative type for fun_type.
	       *
	       * Merge the two types.
	       */
	      type_stack_mark();
	      push_finished_type(Pike_sp[-1].u.type);
	      push_finished_type(res);
	      push_type(T_AND);
	      free_type(res);
	      res = pop_unfinished_type();
	    } else if ((TYPEOF(Pike_sp[-1]) == PIKE_T_INT) &&
		       !SUBTYPEOF(Pike_sp[-1])) {
	      /* Attribute handler says mismatch. */
	      free_type(res);
	      res = NULL;
	      tmp2 = NULL;
	    }
	    pop_stack();
	  }
	}
      }

      free_type(arg_match);
    }
#ifdef PIKE_DEBUG
    if (l_flag>2) {
      fprintf(stderr, "%*sSuccess.\n", indent*2+2, "");
    }
#endif /* PIKE_DEBUG */
    break;
  default:
    /* Not a callable. */
    break;
  }
  /* CAVEAT EMPTOR: When flags & CALL_ARG_LVALUE the
   *                PT_FLAG_REMAP_SWAP_MARKERS flag in remap_flags
   *                may be inverted here if the code above has exited
   *                via a jump to no_match.
   */
  if (!array_cnt || !res) {
#ifdef PIKE_DEBUG
    if (l_flag>2) {
      if (res) {
	fprintf(stderr, "%*s==> ", indent*2, "");
	simple_describe_type(res);
      } else {
	fprintf(stderr, "%*s==> NULL", indent*2, "");
      }
      fprintf(stderr, "\n");
    }
#endif /* PIKE_DEBUG */
    return res;
  }

  type_stack_mark();
  push_finished_type(res);
  free_type(res);
  while(array_cnt--) {
    push_unlimited_array_type(PIKE_T_ARRAY);
  }
  res = pop_unfinished_type();

#ifdef PIKE_DEBUG
  if (l_flag>2) {
    fprintf(stderr, "%*s==> ", indent*2, "");
    simple_describe_type(res);
    fprintf(stderr, "\n");
  }
#endif /* PIKE_DEBUG */

  return res;
}

/**
 * Check whether arg_type may be used as the type of the first argument
 * in a call to fun_type.
 *
 * If the argument is a constant, sval will contain a pointer to it.
 *
 * Returns NULL on failure.
 *
 * Returns continuation function type on success.
 */
struct pike_type *low_new_check_call(struct pike_type *fun_type,
				     struct pike_type *arg_type,
				     INT32 flags,
				     struct call_state *cs,
				     struct svalue *sval)
{
  struct pike_type *tmp;
  struct pike_type *tmp2;
  struct pike_type *res;

  /* FIXME: In strict mode we need to differentiate between
   *        two different kinds of OR:
   *          * Complex types, eg
   *              function(int:int)|function(float:float)
   *            or
   *              mapping(string:int)|mapping(int:string)
   *            where a value can have both types at the
   *            same time.
   *          * Alternate types, eg
   *              int|string
   *            where a value only can have one of the
   *            types at a time.
   *        In strict mode the former should be split here,
   *        and the latter kept.
   *        In non-strict mode both should be split here.
   * Suggestion:
   *   Introduce a new operator (UNION?) for the former case.
   */

  if (!(flags & CALL_ARG_LVALUE)) {
  loop:
    /* First split the argument type into basic types. */
    switch(arg_type?arg_type->type:PIKE_T_UNKNOWN) {
    case T_ASSIGN:
    case PIKE_T_NAME:
      arg_type = arg_type->cdr;
      goto loop;

      /* FIXME: PIKE_T_ATTRIBUTE's ought to propagate out to the basic types.
       */

    case PIKE_T_SCOPE:
      /* We're good if any part of the nested T_OR is good. */
      flags &= ~CALL_STRICT;
      /* Attempt using the arg_type as-is first. */
      if ((tmp = lower_new_check_call(fun_type, arg_type,
				      flags | CALL_WEAK_VOID, cs, sval
				      CHECK_CALL_ARGS))) {
	return tmp;
      }
      arg_type = arg_type->cdr;
      goto loop;

    case T_OR:
      if (arg_type->car == zero_type_string) {
	arg_type = arg_type->cdr;
	goto loop;
      }
      if (arg_type->cdr == zero_type_string) {
	arg_type = arg_type->car;
	goto loop;
      }
      if (!(tmp = low_new_check_call(fun_type, arg_type->car,
				     flags | CALL_WEAK_VOID, cs, sval))) {
	if (flags & CALL_STRICT) {
	  return NULL;
	}
	arg_type = arg_type->cdr;
	goto loop;
      }
      if (!(tmp2 = low_new_check_call(fun_type, arg_type->cdr,
				      flags | CALL_WEAK_VOID, cs, sval))) {
	if (flags & CALL_STRICT) {
	  free_type(tmp);
	  return NULL;
	}
	return tmp;
      }
      res = or_pike_types(tmp, tmp2, 1);
      free_type(tmp);
      free_type(tmp2);
      return res;

    case T_AND:
      if (!(tmp = low_new_check_call(fun_type, arg_type->car,
				     flags & ~CALL_WEAK_VOID, cs, sval))) {
	return NULL;
      }
      if (!(tmp2 = low_new_check_call(fun_type, arg_type->cdr,
				      flags & ~CALL_WEAK_VOID, cs, sval))) {
	free_type(tmp);
	return NULL;
      }
      if (tmp == tmp2) {
	free_type(tmp2);
	return tmp;
      }
      type_stack_mark();
      push_finished_type(tmp);
      push_finished_type(tmp2);
      push_type(T_AND);
      free_type(tmp);
      free_type(tmp2);
      return pop_unfinished_type();

    case T_VOID:
      if ((flags & (CALL_WEAK_VOID|CALL_STRICT)) == CALL_STRICT) {
	return NULL;
      }
      /* Promote void arguments to zero. */
      arg_type = zero_type_string;
      break;
    }
  }

  if (!(tmp = lower_new_check_call(fun_type, arg_type,
				   flags & ~CALL_WEAK_VOID, cs, sval
#ifdef PIKE_TYPE_DEBUG
				   , 0
#endif
				   ))) {
    struct pike_type *tmp2;
    if (!(flags & CALL_STRICT) || !arg_type || (arg_type->type != T_INT) ||
	(CAR_TO_INT(arg_type) >= 0) || (CDR_TO_INT(arg_type) <= 0)) {
      return NULL;
    }
    /* KLUDGE: Special case for integers spanning zero.
     *
     * Try splitting the argument at zero. The proper fix would be
     * to split at all the integer range limits for the first
     * declared argument to the function.
     *
     * Test the most likely problematic range first (ie negative).
     */
    type_stack_mark();
    push_int_type(CAR_TO_INT(arg_type), -1);
    tmp2 = pop_unfinished_type();
    if (!(tmp = lower_new_check_call(fun_type, tmp2,
				     flags & ~CALL_WEAK_VOID, cs, sval
#ifdef PIKE_TYPE_DEBUG
				     , 0
#endif
				     ))) {
      free_type(tmp2);
      return NULL;
    }
    free_type(tmp2);

    type_stack_mark();
    push_finished_type(tmp);
    free_type(tmp);

    /* Then the positive range. */
    type_stack_mark();
    push_int_type(1, CDR_TO_INT(arg_type));
    tmp2 = pop_unfinished_type();
    if (!(tmp = lower_new_check_call(fun_type, tmp2,
				     flags & ~CALL_WEAK_VOID, cs, sval
#ifdef PIKE_TYPE_DEBUG
				     , 0
#endif
				     ))) {
      free_type(tmp2);
      free_type(pop_unfinished_type());
      return NULL;
    }
    free_type(tmp2);

    push_finished_type(tmp);
    free_type(tmp);

    /* NB: Zero always succeeds. */
    push_type(T_OR);
    tmp = pop_unfinished_type();
  }
  return tmp;
}

/**
 * Return the return type for the function type fun_type, if
 * no further arguments are passed.
 *
 * Returns NULL if more arguments are required.
 *
 * Returns the type of the return value otherwise.
 */
struct pike_type *new_get_return_type(struct pike_type *fun_type,
				      struct call_state *cs,
				      INT32 flags)
{
  struct compilation *c = MAYBE_THIS_COMPILATION;
  struct pike_type *res = NULL;
  struct pike_type *tmp;
  struct pike_type *tmp2;
  INT32 array_cnt = 0;

#ifdef PIKE_DEBUG
  if (l_flag>2) {
    fprintf(stderr, "  Getting return type for ");
    simple_describe_type(fun_type);
    fprintf(stderr, "... ");
  }
#endif /* PIKE_DEBUG */

 loop:
  /* Count the number of array levels. */
  while(fun_type && (fun_type->type == PIKE_T_ARRAY)) {
    array_cnt++;
    if (!fun_type->cdr) break;
    fun_type = fun_type->cdr;
  }

  switch(fun_type?(fun_type->type & PIKE_T_MASK):PIKE_T_UNKNOWN) {
  case PIKE_T_SCOPE:
  case T_ASSIGN:
  case PIKE_T_NAME:
    fun_type = fun_type->cdr;
    goto loop;

  case PIKE_T_ATTRIBUTE:
    tmp = new_get_return_type(fun_type->cdr, cs, flags);
    if (!tmp) break;
    if (c) {
      if (!cs->m) {
	cs->m = allocate_mapping(0);
      }
      ref_push_string((struct pike_string *)fun_type->car);
      push_undefined();
      ref_push_mapping(cs->m);
      safe_apply_current2(PC_APPLY_TYPE_ATTRIBUTE_FUN_NUM, 3,
			  "apply_type_attribute");
      if ((TYPEOF(Pike_sp[-1]) == T_INT) &&
	  (SUBTYPEOF(Pike_sp[-1]) == NUMBER_NUMBER) &&
	  (!Pike_sp[-1].u.integer)) {
	free_type(tmp);
	pop_stack();
	break;
      }
      pop_stack();
    }
    type_stack_mark();
    push_finished_type(tmp);
    push_type_attribute((struct pike_string *)fun_type->car);
    res = pop_unfinished_type();
    free_type(tmp);
    break;

  case PIKE_T_RING:
    fun_type = fun_type->car;
    goto loop;

  case T_OR:
    if (!(res = new_get_return_type(fun_type->car, cs, flags))) {
      fun_type = fun_type->cdr;
      goto loop;
    }
    if (!(tmp = new_get_return_type(fun_type->cdr, cs, flags))) {
      break;
    }
    if ((res == void_type_string) || (tmp == void_type_string)) {
      /* Note: Promote void to zero in the return value
       *       when there's another non-void result.
       */
      if (tmp == void_type_string) {
	/* Keep res as is. */
	free_type(tmp);
      } else {
	free_type(res);
	res = tmp;
      }
      break;
    }
    res = or_pike_types(tmp2 = res, tmp, 1);
    free_type(tmp2);
    free_type(tmp);
    break;
  case T_AND:
    if (!(res = new_get_return_type(fun_type->car, cs, flags))) {
      break;
    }
    if (!(tmp = new_get_return_type(fun_type->cdr, cs, flags))) {
      free_type(res);
      res = NULL;
      break;
    }
    res = and_pike_types(tmp2 = res, tmp);
    free_type(tmp);
    free_type(tmp2);
    break;
  case T_NOT:
    if (!(res = new_get_return_type(fun_type->car, cs, flags))) {
      copy_pike_type(res, mixed_type_string);
    } else if (res->type == T_NOT) {
      tmp = res;
      copy_pike_type(res, tmp->car);
      free_type(tmp);
    } else if ((res == mixed_type_string) || (res == any_type_string)) {
      free_type(res);
      return NULL;
    } else {
      type_stack_mark();
      push_finished_type(res);
      push_type(T_NOT);
      free_type(res);
      res = pop_unfinished_type();
    }
    break;
  case PIKE_T_TYPE:
    /* Casting requires an argument, unless it is type(object)... */
    res = type_binop(PT_BINOP_AND, fun_type->car, object_type_string, 0, 0, 0);
    if (res) {
      /* Handle the program(object(Foo))(...) case.
       *
       * FIXME: Handle the type(object(Foo))(mixed val_to_cast) case.
       */
      tmp = find_lfun_type(res, LFUN_CREATE);
      if (!tmp) {
	/* No create() ==> No arguments required.
	 *
	 * res already contains the return type.
	 */
	break;
      }
      fun_type = zzap_function_return(tmp, res);
      free_type(tmp);
      free_type(res);
      res = new_get_return_type(fun_type, cs, flags);
      free_type(fun_type);
    }
    break;
  case PIKE_T_PROGRAM:
    tmp = low_object_lfun_type(fun_type->car, LFUN_CREATE);
    if (!tmp) {
      /* No create(). */
      add_ref(fun_type->car);
      res = fun_type->car;
      break;
    } else {
      fun_type = zzap_function_return(tmp, fun_type->car);
    }
    res = new_get_return_type(fun_type, cs, flags);
    free_type(fun_type);
    break;
  case PIKE_T_OBJECT:
    fun_type = low_object_lfun_type(fun_type, LFUN_CALL);
    if (fun_type) goto loop;
    /* FIXME: Multiple cases:
     *          Untyped object.
     *          Failed to lookup program id.
     *          Program does not have the lfun `()().
     */

    /* FALLTHRU */
  case PIKE_T_MIXED:
    copy_pike_type(res, mixed_type_string);
    break;

  case PIKE_T_FUNCTION:
    do {
      if (!match_types(fun_type->car, void_type_string)) {
	/* Too few arguments. */
#ifdef PIKE_DEBUG
	if (fun_type->car && (fun_type->car->flags & PT_FLAG_VOIDABLE)) {
	  fprintf(stderr, "voidable mismatch for ");
	  simple_describe_type(fun_type->car);
	  fprintf(stderr, " flags: 0x%08x\n", fun_type->car->flags);
	}
#endif
	break;
      }
#ifdef PIKE_DEBUG
      if (fun_type->car && !(fun_type->car->flags & PT_FLAG_VOIDABLE)) {
	fprintf(stderr, "voidable mismatch for ");
	simple_describe_type(fun_type->car);
	fprintf(stderr, " flags: 0x%08x\n", fun_type->car->flags);
      }
#endif
      fun_type = fun_type->cdr;
    } while(fun_type->type == PIKE_T_FUNCTION);
    if (fun_type->type != T_MANY) {
      /* Still too few arguments. */
      break;
    }
    /* FALLTHRU */
  case T_MANY:
    copy_pike_type(res, fun_type->cdr);
    if (!res) {
      /* Upgrade from __unknown__ to mixed
       * when there is an explicit __unknown__.
       * This applies to eg calling the default function type
       * (ie function(mixed...:__unknown__)).
       */
      copy_pike_type(res, mixed_type_string);
    }
    break;

  case PIKE_T_OPERATOR:
    tmp = apply_type_operator(fun_type->type, fun_type->car, fun_type->cdr);
    if (!tmp) {
      return NULL;
    }
    res = new_get_return_type(tmp, cs, flags);
    free_type(tmp);
    break;

  case PIKE_T_TRANSITIVE:
    /* NB: Not 100% correct, but good enough for most purposes. */
    if (fun_type->car) {
      fun_type = fun_type->car;
    } else {
      fun_type = fun_type->cdr;
    }
    goto loop;

  case PIKE_T_UNKNOWN:
  default:
    /* Not a callable. */
    break;
  }

  if (!res) {
#ifdef PIKE_DEBUG
    if (l_flag>2) {
      fprintf(stderr, "Failed.\n");
    }
#endif /* PIKE_DEBUG */
    return NULL;
  }

#ifdef PIKE_DEBUG
  if (l_flag>2) {
    fprintf(stderr, "  Got return type ");
    simple_describe_type(res);
    fprintf(stderr, "\n  Cleaning up markers...\n");
  }
#endif /* PIKE_DEBUG */

  type_stack_mark();

  /* Get rid of any remaining markers. */
  clear_markers();
  push_finished_type_with_markers(res, a_markers, 0);

  free_type(res);

  for (tmp = peek_type_stack();
       tmp && ((tmp->type == PIKE_T_NAME) || (tmp->type == PIKE_T_ATTRIBUTE));
       tmp = tmp->cdr) {
  redo:
    if (tmp->type == PIKE_T_ATTRIBUTE) {
      if (!cs->m) {
	cs->m = allocate_mapping(0);
      }
      ref_push_string((struct pike_string *)tmp->car);
      ref_push_type_value(tmp->cdr);
      ref_push_mapping(cs->m);
      safe_apply_current2(PC_EVAL_TYPE_ATTRIBUTE_FUN_NUM, 3,
			  "eval_type_attribute");
      if (TYPEOF(Pike_sp[-1]) == PIKE_T_TYPE) {
	compiler_discard_top_type();
	push_finished_type(Pike_sp[-1].u.type);
	pop_stack();

	tmp = peek_type_stack();
	goto redo;
      }
      pop_stack();
    }
  }

  while(array_cnt--) {
    push_unlimited_array_type(PIKE_T_ARRAY);
  }

#ifdef PIKE_DEBUG
  if (l_flag>2) {
    fprintf(stderr, "  Done. Return type is ");
    simple_describe_type(peek_type_stack());
    fprintf(stderr, "\n");
  }
#endif /* PIKE_DEBUG */

  return pop_unfinished_type();
}

/**
 * Adjust the argument type.
 *
 * Get rid of void and setvar.
 */
static struct pike_type *low_get_first_arg_type(struct pike_type *arg_type,
						INT32 flags)
{
  struct pike_type *tmp;
  struct pike_type *tmp2;
  struct pike_type *res;

  if (!arg_type) return NULL;

 loop:
  if (!(flags & FILTER_KEEP_VOID) ||
      (arg_type->flags & (PT_FLAG_MARKER|PT_FLAG_ASSIGN))) {
    /* There's markers, assigns or void's to to take care of. */
    switch(arg_type->type) {
    case T_OR:
      if ((tmp = low_get_first_arg_type(arg_type->cdr, flags))) {
	res =
	  or_pike_types(tmp,
			tmp2 = low_get_first_arg_type(arg_type->car, flags),
			1);
	if (tmp2) free_type(tmp2);
	free_type(tmp);
	return res;
      }
      arg_type = arg_type->car;
      goto loop;

    case T_ASSIGN:
      arg_type = arg_type->cdr;
      goto loop;

    case T_NOT:
      /* Recognize some common workarounds for the old function
       * call checker.
       */
      if ((arg_type->car->type == T_OR) &&
	  ((arg_type->car->car->type == T_MIXED) ||
	   (arg_type->car->cdr->type == T_MIXED))) {
	/* Workaround used for some operators; typically
	 *
	 * function(mixed...:mixed) & !function(!(object|mixed):mixed)
	 *
	 * In this case we only want the object, and not the mixed.
	 */
	if (arg_type->car->car->type == T_MIXED) {
	  tmp = low_get_first_arg_type(arg_type->car->cdr,
				       flags|FILTER_KEEP_VOID);
	} else {
	  tmp = low_get_first_arg_type(arg_type->car->car,
				       flags|FILTER_KEEP_VOID);
	}
	type_stack_mark();
	push_finished_type(tmp);
	free_type(tmp);
	push_type(arg_type->type);
	return pop_unfinished_type();
      }
      /* FALLTHRU */

    case T_MULTISET:
      /* Keep void! */
      tmp = low_get_first_arg_type(arg_type->car, flags|FILTER_KEEP_VOID);
      type_stack_mark();
      push_finished_type(tmp);
      free_type(tmp);
      push_type(arg_type->type);
      return pop_unfinished_type();

    case T_ARRAY:
      /* Keep void! */
      tmp = low_get_first_arg_type(arg_type->cdr, flags|FILTER_KEEP_VOID);
      type_stack_mark();
      push_finished_type(tmp);
      free_type(tmp);
      push_unlimited_array_type(arg_type->type);
      return pop_unfinished_type();

    case T_MAPPING:
    case T_TUPLE:
      /* Keep void! */
      type_stack_mark();
      tmp = low_get_first_arg_type(arg_type->cdr, flags|FILTER_KEEP_VOID);
      push_finished_type(tmp);
      free_type(tmp);
      tmp = low_get_first_arg_type(arg_type->car, flags|FILTER_KEEP_VOID);
      push_finished_type(tmp);
      free_type(tmp);
      push_type(arg_type->type);
      return pop_unfinished_type();

    case T_VOID:
      if (!(flags & FILTER_KEEP_VOID)) {
	return NULL;
      }
      /* FALLTHRU */
    default:
      break;
    }
  }
  add_ref(arg_type);
  return arg_type;
}

/**
 * Return the type of the first argument to a function of the type fun_type
 *
 * Returns NULL on failure. Eg not callable or no more args accepted.
 *
 * Returns the argument type on success.
 *
 * @note
 *   Returns void_type_string if no more args accepted in
 *   CALL_ARG_LVALUE mode.
 */
struct pike_type *get_first_arg_type(struct pike_type *fun_type,
				     INT32 flags)
{
  struct pike_type *res = NULL;
  struct pike_type *tmp;
  struct pike_type *tmp2;
 loop:
  /* Get rid of the array levels. */
  while(fun_type->type == PIKE_T_ARRAY) {
    fun_type = fun_type->cdr;
  }

#ifdef PIKE_DEBUG
  if (l_flag > 2) {
    fprintf(stderr, "get_first_arg_type(");
    simple_describe_type(fun_type);
    fprintf(stderr, ", 0x%04x)\n", flags);
  }
#endif

  switch(fun_type->type & PIKE_T_MASK) {
  case PIKE_T_SCOPE:
  case T_ASSIGN:
  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
  case PIKE_T_RING:
    fun_type = fun_type->cdr;
    goto loop;

  case PIKE_T_OPERATOR:
    tmp = apply_type_operator(fun_type->type, fun_type->car, fun_type->cdr);
    if (!tmp) {
      res = NULL;
      break;
    }
    res = get_first_arg_type(tmp, flags);
    free_type(tmp);
    break;

  case PIKE_T_TRANSITIVE:
    tmp = expand_transitive(fun_type, a_markers, 0);
    res = get_first_arg_type(tmp, flags);
    free_type(tmp);
    return res;

  case T_OR:
    if (!(res = get_first_arg_type(fun_type->car, flags))) {
      fun_type = fun_type->cdr;
      goto loop;
    }
    if (!(tmp = get_first_arg_type(fun_type->cdr, flags))) {
      break;
    }
    res = or_pike_types(tmp2 = res, tmp, 1);
    free_type(tmp);
    free_type(tmp2);
    break;
  case T_AND:
    if (!(res = get_first_arg_type(fun_type->car, flags)) &&
	!(flags & CALL_ARG_LVALUE)) {
      break;
    }
    if (!(tmp = get_first_arg_type(fun_type->cdr, flags))) {
      if (flags & CALL_ARG_LVALUE) {
	break;
      }
      free_type(res);
      res = NULL;
      break;
    }
    if (flags & CALL_ARG_LVALUE) {
      /* Handle end of arguments marker. */
      if (res == void_type_string) {
	free_type(tmp);
	break;
      }
      if (tmp == void_type_string) {
	free_type(res);
	res = tmp;
	break;
      }
    }
    /* NOTE: OR and not AND in some cases!
     *
     *   !function(!string:mixed)&function(string|int:string)
     *     ==>
     *   string | string|int
     *
     * This is however not true in the case where neither is inverted:
     *
     *   function(attribute(sprintf_args, mixed)...:string) &
     *   function(object|string:string)
     *     ==>
     *   attribute(sprintf_args, mixed) & object|string
     */
    if (!(flags & CALL_ARG_LVALUE) &&
	(!(flags & CALL_NOT_LAST_ARG) ||
	 ((fun_type->car->type == T_NOT) == (fun_type->cdr->type == T_NOT)))) {
      res = and_pike_types(tmp2 = res, tmp);
    } else {
      res = or_pike_types(tmp2 = res, tmp, 1);
    }
    free_type(tmp);
    free_type(tmp2);
    break;
  case T_NOT:
    if (!(res = get_first_arg_type(fun_type->car, flags))) {
      break;
    }
    if (res->type == T_NOT) {
      copy_pike_type(tmp, res->car);
      free_type(res);
      res = tmp;
    } else {
      type_stack_mark();
      push_finished_type(res);
      free_type(res);
      push_type(T_NOT);
      res = pop_unfinished_type();
    }
    break;
  case PIKE_T_TYPE:
    /* FIXME: Limit to valid cast operations. */
    copy_pike_type(res, mixed_type_string);
    break;
  case PIKE_T_PROGRAM:
    if ((fun_type = low_object_lfun_type(fun_type->car, LFUN_CREATE))) {
      /* No need to adjust the return type, since we're only
       * looking at the arguments.
       */
      goto loop;
    }
    /* FIXME: Multiple cases:
     *          Untyped object.			function(mixed...:object)
     *          Failed to lookup program id.	function(mixed...:object)
     *          Program does not have create().	function(:object)
     */
    /* No create() ==> no arguments. */
    copy_pike_type(res, mixed_type_string);
    break;
  case PIKE_T_OBJECT:
    fun_type = low_object_lfun_type(fun_type, LFUN_CALL);
    if (fun_type) {
      goto loop;
    }
    /* FIXME: Multiple cases:
     *          Untyped object.
     *          Failed to lookup program id.
     *          Program does not have the lfun `()().
     */

    /* FALLTHRU */
  case PIKE_T_MIXED:
    copy_pike_type(res, mixed_type_string);
    break;

  case PIKE_T_FUNCTION:
    if (!(flags & CALL_NOT_LAST_ARG) &&
	(fun_type->cdr->type == PIKE_T_FUNCTION) &&
	!match_types(fun_type->cdr->car, void_type_string)) {
      /* Last argument and more arguments required. */
      res = NULL;
      break;
    }
    /* FALLTHRU */
  case T_MANY:
    if (!(res = fun_type->car) || (res->type == T_VOID)) {
      if ((flags & CALL_ARG_LVALUE) && res) {
	add_ref(res);
	break;
      }
      res = NULL;
      break;
    }
    res = low_get_first_arg_type(res, 0);
    break;

  default:
    /* Not a callable. */
    break;
  }

#ifdef PIKE_DEBUG
  if (l_flag > 2) {
    fprintf(stderr, "get_first_arg_type(");
    simple_describe_type(fun_type);
    fprintf(stderr, ", 0x%04x) ==> ", flags);
    simple_describe_type(res);
    fprintf(stderr, "\n");
  }
#endif

  return res;
}

/* NOTE: fun_type loses a reference. */
struct pike_type *check_splice_call(struct pike_type *fun_type,
				    struct call_state *cs,
				    struct pike_type *args_type,
				    struct svalue *sval,
				    INT32 flags)
{
  struct compilation *c = THIS_COMPILATION;
  struct pike_type *res = NULL;
  struct pike_type *arg_type = index_type(args_type, int_type_string, NULL);
  struct pike_type *ind_type = key_type(args_type, NULL);
  INT_TYPE ind_range[2] = { 256, 0 };
  int min_cnt = 0;
  int max_cnt = 256;
  int cnt = 0;
  /* This argument can expand to anything between zero and MAX_ARGS args. */

  if (get_int_type_range(ind_type, ind_range)) {
    min_cnt = ind_range[0];
    max_cnt = ind_range[1];

    if (max_cnt < min_cnt) {
      /* Mixed or similar range. */
      min_cnt = 0;
      max_cnt = 256;
    }
    if (min_cnt < 0) min_cnt = 0;
    if (max_cnt > 256) max_cnt = 256;
  }

#ifdef PIKE_DEBUG
  if (l_flag>4) {
    fprintf(stderr, "check_splice_call(\"%s\", ", cs->fun_name->str);
    simple_describe_type(fun_type);
    fprintf(stderr, ",\n    %d, ", cs->argno);
    simple_describe_type(args_type);
    fprintf(stderr, ",\n    %p, 0x%04x)", sval, flags);
    fprintf(stderr, "\n    range: [%d..%d] ", min_cnt, max_cnt);
    simple_describe_type(ind_type);
  }
#endif /* PIKE_DEBUG */

  /* Loop until we get a stable fun_type, or it's an invalid argument. */
  for (cnt = 0;; cnt++) {
    struct pike_type *prev = NULL;

    if (cnt >= min_cnt) {
      res = or_pike_types(prev = res, fun_type, 1);
      free_type(prev);

#ifdef PIKE_DEBUG
      if (l_flag>4) {
	fprintf(stderr, "\n    joined_type: ");
	simple_describe_type(res);
      }
#endif /* PIKE_DEBUG */

      if ((res == prev) || (prev && (res == fun_type))) {
	/* Stable result. */
	break;
      }
    }

    if (cnt >= max_cnt) break;

    fun_type = low_new_check_call(prev = fun_type, arg_type,
				  flags | CALL_NOT_LAST_ARG, cs, sval);
    free_type(prev);

#ifdef PIKE_DEBUG
    if (l_flag>4) {
      fprintf(stderr, "\n    sub_result_type: ");
      simple_describe_type(fun_type);
    }
#endif /* PIKE_DEBUG */

    if (!fun_type || (fun_type == prev)) {
      /* Stable result. */
      break;
    }
  }

  if (fun_type || (cnt >= max_cnt)) {
    /* Max args reached or stable type. */
    free_type(fun_type);
  } else if (!(flags & CALL_INHIBIT_WARNINGS)) {
    /* The splice values are invalid for later arguments. */
    if (!cnt && max_cnt) {
      yywarning("In argument %d to %pS: The @-operator argument must be an empty array.",
		cs->argno, cs->fun_name);
    } else if (c->lex.pragmas & ID_STRICT_TYPES) {
      yywarning("In argument %d to %pS: The @-operator argument has a max length of %d.",
		cs->argno, cs->fun_name, cnt);
    }
  }

  free_type(ind_type);
  free_type(arg_type);

#ifdef PIKE_DEBUG
  if (l_flag>4) {
    fprintf(stderr, "\ncheck_splice_call(...) ==> ");
    simple_describe_type(res);
    fprintf(stderr, "\n");
  }
#endif /* PIKE_DEBUG */

  return res;
}

/* NOTE: fun_type loses a reference. */
static struct pike_type *new_check_call_arg(struct pike_type *fun_type,
					    node *args, struct call_state *cs,
					    INT32 flags)
{
  struct compilation *c = THIS_COMPILATION;
  struct pike_type *tmp = NULL;
  struct pike_type *res = NULL;
  struct svalue *sval = NULL;

  CHECK_COMPILER();

  debug_malloc_touch(fun_type);

  if (!args || !fun_type) {
    debug_malloc_touch(fun_type);
    return fun_type;
  }

  cs->argno++;

  if (args->token == F_CONSTANT) {
    sval = &args->u.sval;
  }

#ifdef PIKE_DEBUG
  if (l_flag>2) {
    fprintf(stderr, "  Checking argument #%d... ", cs->argno);
    simple_describe_type(args->type);
    if (sval) {
      fprintf(stderr, "\n  Constant of type %s",
	      get_name_of_type(TYPEOF(*sval)));
    }
    fprintf(stderr, "\n  fun_type: ");
    simple_describe_type(fun_type);
  }
#endif /* PIKE_DEBUG */

  if (args->token == F_PUSH_ARRAY) {
#ifdef PIKE_DEBUG
    if (l_flag>2) {
      fprintf(stderr, "\n  The argument is a splice operator.\n");
    }
#endif /* PIKE_DEBUG */

    res = check_splice_call(fun_type, cs, args->type, sval, flags);

#ifdef PIKE_DEBUG
    if (l_flag>2) {
      fprintf(stderr, "\n  result: ");
      simple_describe_type(res);
      fprintf(stderr, " OK.\n");
    }
#endif /* PIKE_DEBUG */

    return res;
  } else {
#ifdef PIKE_DEBUG
    if (l_flag>2) fputc ('\n', stderr);
#endif
    if ((res = low_new_check_call(fun_type, args->type, flags, cs, sval))) {
      /* OK. */
#ifdef PIKE_DEBUG
      if (l_flag>2) {
	fprintf(stderr, " OK.\n");
      }
#endif /* PIKE_DEBUG */

      if (c->lex.pragmas & ID_STRICT_TYPES) {
	if (!(tmp = low_new_check_call(fun_type, args->type,
				       flags|CALL_STRICT, cs, sval))) {
	  tmp = get_first_arg_type(fun_type, flags);

	  /* NB: Double-check. This is needed for some functions
	   *     which split types in obscure places.
	   * Eg object_program():
	   *      scope(0, function(object:program)|function(~object:zero))
	   *    In this above case tmp will be mixed, but low_new_check_call()
	   *    will still fail if args->type is mixed.
	   */
	  if (!pike_types_le(args->type, tmp,
			     PT_FLAG_CMP_VOID_IS_ZERO,
			     PT_FLAG_CMP_VOID_IS_ZERO)) {
	    yytype_report(REPORT_WARNING, NULL, 0, tmp,
			  NULL, 0, args->type,
                          0, "Type mismatch in argument %d to %pS.",
			  cs->argno, cs->fun_name);
	    yytype_report(REPORT_WARNING, NULL, 0, NULL,
			  NULL, 0, fun_type,
			  0, "Function.");
	  }
	  if (tmp) free_type(tmp);
	} else {
	  free_type(tmp);
	}
      }
      free_type(fun_type);

      return res;
    }
  }

  if ((tmp = get_first_arg_type(fun_type, flags|CALL_NOT_LAST_ARG)) &&
      (tmp != void_type_string)) {
    struct pike_type *tmp2;

#ifdef PIKE_DEBUG
    if (l_flag>2) {
      fprintf(stderr, " Bad argument.\n");
    }
#endif /* PIKE_DEBUG */
    yytype_report(REPORT_ERROR, NULL, 0, tmp, NULL, 0, args->type,
		  0, "Bad argument %d to %S.", cs->argno, cs->fun_name);

    /* Try advancing with the suggested type, so that we can check
     * the rest of the arguments.
     */
    if ((tmp2 = low_new_check_call(fun_type, tmp, flags, cs, NULL))) {
      /* Succeeded. */
      free_type(fun_type);
      free_type(tmp);
#ifdef PIKE_DEBUG
      if (l_flag>2) {
	fprintf(stderr, "  Created continuation type: ");
	simple_describe_type(tmp2);
	fprintf(stderr, " OK.\n");
      }
#endif /* PIKE_DEBUG */

      return tmp2;
    }
#ifdef PIKE_DEBUG
    if (l_flag>2) {
      fprintf(stderr, "\n  Failed to create continuation type.\n");
    }
#endif /* PIKE_DEBUG */
    free_type(tmp);
  } else {
    free_type(tmp);

#ifdef PIKE_DEBUG
    if (l_flag>2) {
      fprintf(stderr, " Too many arguments.\n");
    }
#endif /* PIKE_DEBUG */
    yytype_report(REPORT_ERROR, NULL, 0, NULL,
		  NULL, 0, args->type,
		  0, "Too many arguments to %S (expected %d arguments).",
		  cs->fun_name, cs->argno - 1);
  }
  free_type(fun_type);

  return NULL;
}

/* NOTE: fun_type loses a reference. */
struct pike_type *new_check_call(struct pike_type *fun_type,
				 node *args, struct call_state *cs,
				 INT32 flags)
{
  node *orig_args = args;
  node *orig_arg_parent = NULL;
  int num_cdr = 0;

  if (!args || !fun_type) {
    debug_malloc_touch(fun_type);
    return fun_type;
  }

  orig_arg_parent = args->parent;
  args->parent = NULL;	/* End marker. */

  if (flags & CALL_NOT_LAST_ARG) {
    /* Recursive call, where there's a CDR above. */
    num_cdr = 1;
  }

  debug_malloc_touch(fun_type);

  clear_markers();
  while (args && fun_type) {
    if ((args->token == F_ARG_LIST) || (args->token == F_LVALUE_LIST)) {
      if (CDR(args)) {
	num_cdr++;
	flags |= CALL_NOT_LAST_ARG;
      }
      if (args->token == F_LVALUE_LIST) {
	flags |= CALL_ARG_LVALUE;
      }
      if (CAR(args)) {
	CAR(args)->parent = args;
	args = CAR(args);
	continue;
      } else if (CDR(args)) {
	CDR(args)->parent = args;
	args = CDR(args);
	if (!--num_cdr) {
	  flags &= ~CALL_NOT_LAST_ARG;
	}
	continue;
      }
    } else {
      fun_type = new_check_call_arg(fun_type, args, cs, flags);
      debug_malloc_touch(fun_type);
    }

    while (args && fun_type) {
      node *prev = args;
      args = args->parent;
      if (!args) {
	break;
      }
      if ((CAR(args) == prev) && CDR(args)) {
	if (!--num_cdr) {
	  flags &= ~CALL_NOT_LAST_ARG;
	}
	if (CDR(args) != prev) {
	  CDR(args)->parent = args;
	  args = CDR(args);
	  break;
	}
	/* CAR(args) == CDR(args), so we need to recurse
	 * since we can't differentiate otherwise.
	 *
	 * This should be a quite rare case, and the tree is
	 * most likely very shallow, so this should be safe.
	 */
	fun_type = new_check_call(fun_type, prev, cs, flags);
	debug_malloc_touch(fun_type);
      }
    }
  }

  orig_args->parent = orig_arg_parent;

  return fun_type;
}

struct pike_type *zzap_function_return(struct pike_type *a,
				       struct pike_type *fun_ret)
{
  struct pike_type *ret = NULL;
  switch(a->type & PIKE_T_MASK)
  {
    case T_SCOPE:
      ret = zzap_function_return(a->cdr, fun_ret);
      if (!ret) return NULL;
      type_stack_mark();
      push_finished_type(ret);
      free_type(ret);
      push_scope_type(CAR_TO_INT(a));
      return pop_unfinished_type();

    case T_OR:
    {
      struct pike_type *ar, *br;
      ar = zzap_function_return(a->car, fun_ret);
      br = zzap_function_return(a->cdr, fun_ret);
      if(ar && br) ret = or_pike_types(ar, br, 0);
      if(ar) free_type(ar);
      if(br) free_type(br);
      return ret;
    }

    case T_FUNCTION:
    case T_MANY:
    {
      int nargs=0;
      type_stack_mark();

      while(a->type == T_FUNCTION)
      {
	push_finished_type(a->car);
	nargs++;
	a = a->cdr;
      }
      push_finished_type(a->car);
      push_finished_type(fun_ret);
      push_reverse_type(T_MANY);
      while(nargs-- > 0) {
	push_reverse_type(T_FUNCTION);
      }
      return pop_unfinished_type();
    }

    case T_ARRAY:
      return zzap_function_return(a->cdr, fun_ret);

    case PIKE_T_NAME:
      return zzap_function_return(a->cdr, fun_ret);

    case PIKE_T_ATTRIBUTE:
      {
	struct pike_type *res;
	if ((res = zzap_function_return(a->cdr, fun_ret))) {
	  type_stack_mark();
	  push_finished_type(res);
	  push_type_attribute((struct pike_string *)a->car);
	  free_type(res);
	  res = pop_unfinished_type();
	}
	return res;
      }

    case T_MIXED:
      /* I wonder when this occurrs, but apparently it does... */
      /* FIXME: */
      type_stack_mark();
      push_finished_type(fun_ret);
      push_type(T_VOID);
      push_type(T_MIXED);
      push_type(T_OR);
      push_type(T_MANY);
      return pop_unfinished_type();

    case PIKE_T_OPERATOR:
      {
	struct pike_type *tmp = apply_type_operator(a->type, a->car, a->cdr);
	if (!tmp) return NULL;
	ret = zzap_function_return(tmp, fun_ret);
	free_type(tmp);
	return ret;
      }

    case PIKE_T_TRANSITIVE:
      yytype_report(REPORT_WARNING, NULL, 0, NULL,
		    NULL, 0, a,
		    0, "Zapping the return value for a transitive "
		    "function is not supported.");
      break;
  }
/* This error is bogus /Hubbe
  Pike_fatal("zzap_function_return() called with unexpected value: %d\n",
	EXTRACT_UCHAR(a));
*/
  return NULL;
}

/* Implementation from https://mc.pp.se/binoprange.c
 *
 * Cf LysLysKOM 25306802
 */

static unsigned INT32 evaluate_binop_min(enum PIKE_TYPE op,
					 unsigned INT32 amin,
					 unsigned INT32 amax,
					 unsigned INT32 bmin,
					 unsigned INT32 bmax)
{
  /* The pivot is the most significant bit that changes in a range.
   * upper are the bits set above the pivot (these never change).
   */
  unsigned INT32 apivot, bpivot, aupper, bupper;
  if (amin == amax) {
    apivot = 0;
    aupper = amin;
  } else {
    apivot = 1 << (31 - clz32(amin ^ amax));
    aupper = amin & ~(apivot | (apivot-1));
  }
  if (bmin == bmax) {
    bpivot = 0;
    bupper = bmin;
  } else {
    bpivot = 1 << (31 - clz32(bmin ^ bmax));
    bupper = bmin & ~(bpivot | (bpivot-1));
  }
  if (!apivot && !bpivot)
    /* Both ranges are unit length - trivial case */
    switch (op) {
#if 0
    case PIKE_T_INT_OP_OR: return amin | bmin;
#endif
    case PIKE_T_INT_OP_AND: return amin & bmin;
    case PIKE_T_INT_OP_XOR: return amin ^ bmin;
    default:
      /* Keep C-compiler happy. */
      break;
    }

  /* Swap so that a has the larger pivot (apivot must then be != 0) */
  if (bpivot > apivot) {
    unsigned INT32 tmp;
    tmp = amin; amin = bmin; bmin = tmp;
    tmp = amax; amax = bmax; bmax = tmp;
    tmp = apivot; apivot = bpivot; bpivot = tmp;
    tmp = aupper; aupper = bupper; bupper = tmp;
  }

  /* Operation specific code */
  switch (op) {
#if 0
  case PIKE_T_INT_OP_OR:
    /* | min */
    if (amin > amax) {
      /* Special case for signed, apivot will be sign bit */
      if (bpivot == apivot)
	/* Either min can be achieved by setting the other term to 0 */
	return (amin < bmin? amin : bmin);
      else if ((bupper & apivot))
	/* b is always negative, set a to 0 for min */
	return bmin;
      else
	/* b is always positive, chose a negative */
	return apivot |
	  evaluate_binop_minmax(op, 1,
				amin & (apivot-1), apivot-1,
				bmin & (apivot-1), (bmax & (apivot-1)));
    } else if (!(amin & (apivot-1)) || (apivot & bupper)) {
      /* Either amin is zeroes below the pivot, or the pivot of a is
	 subsumed by the upper of b.  In this case, we can choose zeros
	 for a below (and at) the pivot. */
      return bmin | aupper;
    } else if (!((~amin) & (apivot-1))) {
      /* amin is all ones below the pivot, b will not matter below apivot */
      return amin | bupper;
    } else {
      /* a should be selected with zero pivot, but can't be all zeros
	 below it, pick a new pivot */
      return aupper | bupper |
	evaluate_binop_minmax(op, 1,
			      amin & (apivot-1), apivot-1, bmin & (apivot-1),
			      (bpivot == apivot? apivot-1 : (bmax & (apivot-1))));
    }
#endif
  case PIKE_T_INT_OP_AND:
    /* & min */
    if (amin > amax) {
      /* Special case for signed, apivot will be sign bit */
      if (bpivot == apivot || (bupper & apivot))
	/* Go for negative */
	return apivot |
	  evaluate_binop_min(op, amin & (apivot-1), apivot-1,
			     bmin & (apivot-1),
			     (bpivot == apivot? (apivot-1) : (bmax & (apivot-1))));
      else
	/* b is always positive, 0 (which is in a-range) is min result */
	return 0;
    } else if (!(amin & (apivot-1)) || !(apivot & bupper)) {
      /* Either amin is zeroes below the pivot, or the pivot of a is
	 subsumed by the upper of b.  In this case, we can choose zeros
	 for a below (and at) the pivot. */
      return aupper & bupper;
    } else {
      /* a should be selected with zero pivot, but can't be all zeros
	 below it, pick a new pivot */
      return (aupper & bupper) |
	evaluate_binop_min(op,
			   amin & (apivot-1), apivot-1,
			   bmin & (apivot-1), bmax & (apivot-1));
    }
  case PIKE_T_INT_OP_XOR:
    /* ^ min */
    if (amin > amax) {
      /* Special case for signed, apivot will be sign bit */
      if (bpivot == apivot) {
	/* Pivot bit must be chosen diffently to get negative result */
	unsigned INT32 xmin = /* a positive, b negative */
	  evaluate_binop_min(op,
			     0, amax & (apivot-1),
			     bmin & (apivot-1), apivot-1);
	unsigned INT32 ymin = /* a negative, b positive */
	  evaluate_binop_min(op,
			     amin & (apivot-1), apivot-1,
			     0, bmax & (apivot-1));
	return apivot | (xmin < ymin? xmin : ymin);
      } else if ((bupper & apivot)) {
	/* b is always negative, chose a positive for negative result */
	return apivot |
	  evaluate_binop_min(op,
			     0, amax & (apivot-1),
			     bmin & (apivot-1), bmax & (apivot-1));
      } else {
	/* b is always positive, chose a negative for negative result */
	return apivot |
	  evaluate_binop_min(op,
			     amin & (apivot-1), apivot-1,
			     bmin & (apivot-1), bmax & (apivot-1));
      }
    } else if (bpivot == apivot) {
      /* Choose the pivot point for both a and b to cancel them out */
      return ((aupper ^ bupper) & ~(apivot-1) & ~apivot);
      } else if ((bupper & apivot)) {
      /* Set pivot to 1 to cancel bit in b */
      return ((aupper ^ bupper) & ~(apivot-1) & ~apivot) |
	evaluate_binop_min(op,
			   0, amax & (apivot-1),
			   bmin & (apivot-1), bmax & (apivot-1));
    } else {
      /* Set pivot to 0 */
      return ((aupper ^ bupper) & ~(apivot-1) & ~apivot) |
	evaluate_binop_min(op,
			   amin & (apivot-1), apivot-1,
			   bmin & (apivot-1), bmax & (apivot-1));
    }
  default:
    Pike_fatal("Not implemented!\n");
  }
}

static unsigned INT32 evaluate_binop_max(enum PIKE_TYPE op,
					 unsigned INT32 amin,
					 unsigned INT32 amax,
					 unsigned INT32 bmin,
					 unsigned INT32 bmax)
{
  /* The pivot is the most significant bit that changes in a range.
   * upper are the bits set above the pivot (these never change).
   */
  unsigned INT32 apivot, bpivot, aupper, bupper;
  if (amin == amax) {
    apivot = 0;
    aupper = amin;
  } else {
    apivot = 1 << (31 - clz32(amin ^ amax));
    aupper = amin & ~(apivot | (apivot-1));
  }
  if (bmin == bmax) {
    bpivot = 0;
    bupper = bmin;
  } else {
    bpivot = 1 << (31 - clz32(bmin ^ bmax));
    bupper = bmin & ~(bpivot | (bpivot-1));
  }
  if (!apivot && !bpivot)
    /* Both ranges are unit length - trivial case */
    switch (op) {
#if 0
    case PIKE_T_INT_OP_OR: return amax | bmax;
#endif
    case PIKE_T_INT_OP_AND: return amax & bmax;
    case PIKE_T_INT_OP_XOR: return amax ^ bmax;
    default:
      /* Keep C-compiler happy. */
      break;
    }

  /* Swap so that a has the larger pivot (apivot must then be != 0) */
  if (bpivot > apivot) {
    unsigned INT32 tmp;
    tmp = amin; amin = bmin; bmin = tmp;
    tmp = amax; amax = bmax; bmax = tmp;
    tmp = apivot; apivot = bpivot; bpivot = tmp;
    tmp = aupper; aupper = bupper; bupper = tmp;
  }

  /* Operation specific code */
  switch (op) {
#if 0
  case PIKE_T_INT_OP_OR:
    /* | max */
    if (amin > amax) {
      /* Special case for signed, apivot will be sign bit */
      if ((bupper & apivot))
	/* b is always negative, so -1 (which is in a-range) is the max */
	return apivot | (apivot-1);
      else
	/* Go for positive result */
	return evaluate_binop_max(op, 0, amax,
				  (bpivot == apivot? 0 : bmin), bmax);
    } else if (!((~amax) & (apivot-1)) || (apivot & bupper)) {
      /* Either amax is ones below the pivot, or the pivot of a is
	 subsumed by the upper of b.  In this case, we can choose ones
	 for a below (and at) the pivot. */
      return bupper | aupper | apivot | (apivot-1);
    } else if (!((~amax) & (apivot-1))) {
      /* amax is all zeros below the pivot */
      return bmax | aupper | apivot;
    } else if (bpivot == apivot) {
      /* a and b have the same pivot; pick one at the pivot point and the
	 other just below to get the max (all ones at and below pivot) */
      return bupper | aupper | apivot | (apivot-1);
    } else {
      /* a should be selected with one pivot, but can't be all ones
	 below it, pick a new pivot */
      return aupper | bupper | apivot |
	evaluate_binop_max(op,
			   0, amax & (apivot-1),
			   bmin & (apivot-1), bmax & (apivot-1));
    }
#endif
  case PIKE_T_INT_OP_AND:
    /* & max */
    if (amin > amax) {
      /* Special case for signed, apivot will be sign bit */
      if (bpivot == apivot)
	/* Either max can be achieved by setting the other term to -1 */
	return (amax > bmax? amax : bmax);
      else if ((bupper & apivot))
	/* b is always negative, must choose a positive */
	return
	  evaluate_binop_max(op,
			     0, amax & (apivot-1),
			     bmin & (apivot-1), bmax & (apivot-1));
      else
	/* b is always positive, and it with -1 (which is in a-range)
	   to get its max */
	return bmax;
    } else if (bpivot == apivot || (bupper & apivot)) {
      /* Need to pick 1 for the a pivot */
      return (aupper & bupper) | apivot |
	evaluate_binop_max(op, 0, amax & (apivot-1),
			   (bpivot == apivot? 0 : (bmin & (apivot-1))),
			   bmax & (apivot-1));
    } else {
      /* b has 0 in the pivot position, so we can simply pick the pivot
	 point minus 1 for a to get 1:s in all the lower bits */
      return (aupper & bupper) | (bmax & (apivot-1));
    }
  case PIKE_T_INT_OP_XOR:
    /* ^ max */
    if (amin > amax) {
      /* Special case for signed, apivot will be sign bit */
      if (bpivot == apivot) {
	/* Pivot bit must be chosen the same to get positive result */
	unsigned INT32 xmax = /* a positive, b positive */
	  evaluate_binop_max(op,
			     0, amax & (apivot-1),
			     0, bmax & (apivot-1));
	unsigned INT32 ymax = /* a negative, b negative */
	  evaluate_binop_max(op,
			     amin & (apivot-1), apivot-1,
			     bmin & (apivot-1), apivot-1);
	return (xmax > ymax? xmax : ymax);
      } else if ((bupper & apivot)) {
	/* b is always negative, chose a negative for positive result */
	return
	  evaluate_binop_max(op,
			     amin & (apivot-1), apivot-1,
			     bmin & (apivot-1), bmax & (apivot-1));
      } else {
	/* b is always positive, chose a positive for positive result */
	return
	  evaluate_binop_max(op,
			     0, amax & (apivot-1),
			     bmin & (apivot-1), bmax & (apivot-1));
      }
    } else if (bpivot == apivot) {
      /* Chose a at the pivot point and b one below to get the max */
      return (aupper ^ bupper) | apivot | (apivot-1);
    } else if ((bupper & apivot)) {
      /* Set pivot to 0 to not cancel bit in b */
      return ((aupper ^ bupper) & ~(apivot-1)) | apivot |
	evaluate_binop_max(op,
			   amin & (apivot-1), apivot-1,
			   bmin & (apivot-1), bmax & (apivot-1));
    } else {
      /* Set pivot to 1 */
      return ((aupper ^ bupper) & ~(apivot-1)) | apivot |
	evaluate_binop_max(op,
			   0, amax & (apivot-1),
			   bmin & (apivot-1), bmax & (apivot-1));
    }
  default:
    Pike_fatal("Not implemented!\n");
  }
}

struct pike_type *low_type_int_op(enum PIKE_TYPE op,
				  struct pike_type *arg1,
				  struct pike_type *arg2)
{
  INT64 min1 = CAR_TO_INT(arg1), min2 = CAR_TO_INT(arg2);
  INT64 max1 = CDR_TO_INT(arg1), max2 = CDR_TO_INT(arg2);
  INT64 minres = MIN_INT32, maxres = MAX_INT32, tmp;

  switch(op) {
  case PIKE_T_INT_OP_SUB:
    if ((min1 == MIN_INT32) || (max2 == MAX_INT32)) {
      minres = MIN_INT32;
    } else {
      minres = min1 - max2;
    }
    if ((max1 == MAX_INT32) || (min2 == MIN_INT32)) {
      maxres = MAX_INT32;
    } else {
      maxres = max1 - min2;
    }
    break;

  case PIKE_T_INT_OP_MUL:
    maxres = minres = min1 * min2;
    tmp = min1 * max2;
    if (tmp > maxres) {
      maxres = tmp;
    } else {
      minres = tmp;
    }
    tmp = max1 * min2;
    if (tmp > maxres) {
      maxres = tmp;
    } else if (tmp < minres) {
      minres = tmp;
    }
    tmp = max1 * max2;
    if (tmp > maxres) {
      maxres = tmp;
    } else if (tmp < minres) {
      minres = tmp;
    }
    break;

  case PIKE_T_INT_OP_AND:
  case PIKE_T_INT_OP_XOR:
    minres = (INT32)evaluate_binop_min(op,
				       (unsigned INT32)min1,
				       (unsigned INT32)max1,
				       (unsigned INT32)min2,
				       (unsigned INT32)max2);
    maxres = (INT32)evaluate_binop_max(op,
				       (unsigned INT32)min1,
				       (unsigned INT32)max1,
				       (unsigned INT32)min2,
				       (unsigned INT32)max2);
    break;
  case PIKE_T_INT_OP_RANGE:
    minres = min1;
    maxres = max2;
    break;
  case PIKE_T_INT_OP_MIN:
    if (min1 <= min2) {
      minres = min1;
    } else {
      minres = min2;
    }
    if (max1 <= max2) {
      maxres = max1;
    } else {
      maxres = max2;
    }
    break;
  case PIKE_T_INT_OP_MAX:
    if (min1 <= min2) {
      minres = min2;
    } else {
      minres = min1;
    }
    if (max1 <= max2) {
      maxres = max2;
    } else {
      maxres = max1;
    }
    break;
  default:
    Pike_fatal("low_type_int_op(): Unknown operator: 0x%04x\n", op);
    break;
  }

  if (minres < MIN_INT32) minres = MIN_INT32;
  else if (minres > MAX_INT32) minres = MAX_INT32;

  if (maxres < MIN_INT32) maxres = MIN_INT32;
  else if (maxres > MAX_INT32) maxres = MAX_INT32;

  if (minres > maxres) {
    return NULL;
  }

  type_stack_mark();
  push_int_type(minres, maxres);
  return pop_unfinished_type();
}

struct pike_type *type_int_op(enum PIKE_TYPE op,
			      struct pike_type *arg1,
			      struct pike_type *arg2)
{
  while (1) {
    if (!arg1 || !arg2) {
      return NULL;
    }
    switch(arg1->type) {
    case PIKE_T_ZERO:
    case PIKE_T_VOID:
      arg1 = int0_type_string;
      break;
    case T_MIXED:
      arg1 = int_type_string;
      break;
    case PIKE_T_ATTRIBUTE:
    case PIKE_T_NAME:
      arg1 = arg1->cdr;
      continue;
    }
    switch(arg2->type) {
    case PIKE_T_ZERO:
    case PIKE_T_VOID:
      arg2 = int0_type_string;
      break;
    case T_MIXED:
      arg2 = int_type_string;
      break;
    case PIKE_T_ATTRIBUTE:
    case PIKE_T_NAME:
      arg2 = arg2->cdr;
      continue;
    }
    break;
  }
  if (arg1->type == PIKE_T_OBJECT) {
    /* FIXME: Check type for LFUN corresponding to op. */
    add_ref(mixed_type_string);
    return mixed_type_string;
  }
  if (arg2->type == PIKE_T_OBJECT) {
    /* FIXME: Check type for LFUN corresponding to op. */
    add_ref(mixed_type_string);
    return mixed_type_string;
  }
  if (arg1->type != arg2->type) return NULL;
  switch(arg1->type) {
  case PIKE_T_INT:
    return low_type_int_op(op, arg1, arg2);
  default:
    return type_binop(PT_BINOP_OR, arg1, arg2, 0, 0, 0);
  }

  /* FIXME */
  return NULL;
}

struct pike_type *apply_type_operator(enum PIKE_TYPE op,
				      struct pike_type *arg1,
				      struct pike_type *arg2)
{
  struct pike_type *res = NULL;
  switch(op) {
  case PIKE_T_GET_RETURN:
    {
      struct call_state cs;
      INIT_CALL_STATE(cs, NULL);
      res = new_get_return_type(arg1, &cs, 0);
      FREE_CALL_STATE(cs);
    }
    break;
  case PIKE_T_THRESHOLD:
    if (!arg1) break;
    copy_pike_type(res, any_type_string);
    break;
  case PIKE_T_APPLY:
    {
      struct call_state cs;
      INIT_CALL_STATE(cs, NULL);
      res = low_new_check_call(arg1, arg2, 0, &cs, NULL);
      FREE_CALL_STATE(cs);
    }
    break;
  case PIKE_T_FIND_LFUN:
    res = find_lfun_type(arg1, (ptrdiff_t)(void*)arg2);
    break;
  case PIKE_T_INT_OP_SUB:
  case PIKE_T_INT_OP_MUL:
  case PIKE_T_INT_OP_AND:
  case PIKE_T_INT_OP_XOR:
  case PIKE_T_INT_OP_RANGE:
  case PIKE_T_INT_OP_MIN:
  case PIKE_T_INT_OP_MAX:
    res = type_int_op(op, arg1, arg2);
    break;
  case PIKE_T_SET_CAR:
    if (!arg1) return NULL;
    switch(arg1->type) {
    case PIKE_T_FUNCTION:
    case PIKE_T_MANY:
    case PIKE_T_RING:
    case PIKE_T_TUPLE:
    case PIKE_T_MAPPING:
    case PIKE_T_ARRAY:
    case PIKE_T_STRING:
    case PIKE_T_MULTISET:
      type_stack_mark();
      push_finished_type(arg2);
      push_finished_type(arg1->cdr);
      push_reverse_type(arg1->type);
      return pop_unfinished_type();
    }
    break;
  case PIKE_T_SET_CDR:
    if (!arg1) return NULL;
    switch(arg1->type) {
    case PIKE_T_FUNCTION:
    case PIKE_T_MANY:
    case PIKE_T_RING:
    case PIKE_T_TUPLE:
    case PIKE_T_MAPPING:
    case PIKE_T_ARRAY:
    case PIKE_T_STRING:
      type_stack_mark();
      push_finished_type(arg2);
      push_finished_type(arg1->car);
      push_type(arg1->type);
      return pop_unfinished_type();
    }
    break;
  default:
    Pike_fatal("apply_type_operator(): Unknown operator: 0x%04x\n", op);
    break;
  }
  return res;
}

struct pike_type *get_lax_type_of_svalue( const struct svalue *c )
{
  struct pike_type *res;
  if (TYPEOF(*c) == T_INT)
  {
    if (c->u.integer)
      copy_pike_type(res, int_type_string);
    else
      copy_pike_type(res, zero_type_string);
  }
  else if (TYPEOF(*c) == T_STRING )
    copy_pike_type(res, string_type_string);
  else
    return get_type_of_svalue(c);

  return res;
}

struct pike_type *get_type_of_svalue(const struct svalue *s)
{
  struct pike_type *ret;
  switch(TYPEOF(*s))
  {
  case T_FUNCTION:
    if(SUBTYPEOF(*s) == FUNCTION_BUILTIN)
    {
      copy_pike_type(ret, s->u.efun->type);
    }else{
      struct program *p;

      p=s->u.object->prog;
      if(!p)
      {
	copy_pike_type(ret, zero_type_string);
      } else if (p == pike_trampoline_program) {
	struct pike_trampoline *t =
	  (struct pike_trampoline *) s->u.object->storage;
	if ((p = t->frame->current_object->prog)) {
	  copy_pike_type(ret, ID_FROM_INT(p, t->func)->type);
	} else {
	  copy_pike_type(ret, zero_type_string);
	}
      } else {
	copy_pike_type(ret, ID_FROM_INT(p,SUBTYPEOF(*s))->type);
      }
    }
    return ret;

  case T_ARRAY:
    {
      struct array *a = s->u.array;

      type_stack_mark();
#if 0
      {
	struct pike_type *arg_type;
	int i;

	/* FIXME: Circular structures? */
	copy_pike_type(arg_type, zero_type_string);
	for (i = 0; i < a->size; i++) {
	  struct pike_type *tmp1 = get_type_of_svalue(a->item+i);
	  struct pike_type *tmp2 = or_pike_types(arg_type, tmp1, 1);
	  free_type(arg_type);
	  free_type(tmp1);
	  arg_type = tmp2;
	}
	push_finished_type(arg_type);
	free_type(arg_type);
      }
#else /* !0 */
      push_type_field(a->size ? a->type_field : 0);
#endif /* 0 */
      push_int_type(a->size, a->size);
      push_type(T_ARRAY);
      return pop_unfinished_type();
    }

  case T_MULTISET:
    type_stack_mark();
    if (multiset_sizeof(s->u.multiset)) {
      push_type(T_MIXED);
    }
    else {
      push_type(PIKE_T_UNKNOWN);
    }
    push_type(T_MULTISET);
    return pop_unfinished_type();

  case T_MAPPING:
    type_stack_mark();
    if (m_sizeof(s->u.mapping)) {
      push_type_field(s->u.mapping->data->val_types);
      push_type_field(s->u.mapping->data->ind_types);
    }
    else {
      push_type(PIKE_T_UNKNOWN);
      push_type(PIKE_T_UNKNOWN);
    }
    push_type(T_MAPPING);
    return pop_unfinished_type();

  case T_OBJECT:
    type_stack_mark();
    if(s->u.object->prog)
    {
      if(is_bignum_object(s->u.object))
      {
	push_int_type(MIN_INT32, MAX_INT32);
	push_object_type(1, s->u.object->prog->id);
	push_type(T_OR);
	push_scope_type(0);
      }
      else
      {
	push_object_type(1, s->u.object->prog->id);
      }
    }else{
      /* Destructed object */
      push_type(T_ZERO);
    }
    return pop_unfinished_type();

  case T_INT:
    if(s->u.integer) {
      type_stack_mark();
      /* Check that the integer is in range of MIN_INT32 .. MAX_INT32. */
      if (((s->u.integer & 0x7fffffff) == s->u.integer) ||
	  ((~s->u.integer & 0x7fffffff) == ~s->u.integer)) {
	push_int_type(s->u.integer, s->u.integer);
      } else {
	/* Out of range. Depending on where the integer ends up it may
	 * get truncated in various ways. Avoid confusion by reducing
	 * the specificity of the type.
	 */
	push_int_type(MIN_INT32, MAX_INT32);
      }
      return pop_unfinished_type();
    }else{
      copy_pike_type(ret, zero_type_string);
      return ret;
    }

  case T_PROGRAM:
  {
    /* FIXME: An alternative would be to push program(object(1,p->id)). */
    struct pike_type *a;
    struct pike_type *ret_type;
    int id;

    type_stack_mark();
    push_object_type(1, s->u.program->id);
    ret_type = pop_unfinished_type();

    if(s->u.program->identifiers)
    {
      id=FIND_LFUN(s->u.program,LFUN_CREATE);
      if(id>=0)
      {
	a = ID_FROM_INT(s->u.program, id)->type;
	if((a = zzap_function_return(a, ret_type))) {
	  free_type(ret_type);
	  return a;
	}
#if 0
	{
	  struct pike_string *tmp =
	    describe_type(ID_FROM_INT(s->u.program, id)->type);
	  yywarning("Failed to zzap function return for type: %s.", tmp->str);
	  free_string(tmp);
	}
#endif /* 0 */
      }
      if (!(s->u.program->flags & PROGRAM_PASS_1_DONE)) {
	/* We haven't added all identifiers in s->u.program yet,
	 * so we might find a create() later.
	 */
	if((a = zzap_function_return(function_type_string, ret_type))) {
	  free_type(ret_type);
	  return a;
	}
      }
    } else {
      if((a = zzap_function_return(function_type_string, ret_type))) {
	free_type(ret_type);
	return a;
      }
    }

    type_stack_mark();
    push_finished_type(ret_type);
    push_type(T_VOID);
    push_type(T_MANY);
    free_type(ret_type);
    return pop_unfinished_type();
  }

  case T_TYPE:
    type_stack_mark();
    push_finished_type(s->u.type);
    push_type(T_TYPE);
    return pop_unfinished_type();

  case T_STRING:
    type_stack_mark();
    if (s->u.string->len) {
      INT32 min, max;
      check_string_range( s->u.string, 0, &min, &max );
      push_int_type(min, max);
    } else {
      push_type(PIKE_T_UNKNOWN);
    }
    push_int_type(s->u.string->len, s->u.string->len);
    push_type(T_STRING);
    return pop_unfinished_type();

  default:
    type_stack_mark();
    push_type(TYPEOF(*s));
    return pop_unfinished_type();
  }
}


static struct pike_type *low_object_type_to_program_type(struct pike_type *obj_t)
{
  struct pike_type *res = NULL;
  struct pike_type *sub;
  struct svalue sval;
  int id;

  while(obj_t->type == T_OR) {
    sub = low_object_type_to_program_type(obj_t->car);
    if (!sub) {
      if (res) {
	free_type(res);
      }
      return NULL;
    }
    if (res) {
      struct pike_type *tmp = or_pike_types(res, sub, 1);
      free_type(res);
      free_type(sub);
      res = tmp;
    } else {
      res = sub;
    }
    obj_t = obj_t->cdr;
  }
  SET_SVAL_TYPE(sval, T_PROGRAM);
  if ((obj_t->type != T_OBJECT) ||
      (!(id = CDR_TO_INT(obj_t))) ||
      (!(sval.u.program = id_to_program(id))) ||
      (!(sub = get_type_of_svalue(&sval)))) {
    if (res) {
      free_type(res);
    }
    return NULL;
  }
  /* FIXME: obj_t->car should propagate to the return-type in sub. */
  if (res) {
    struct pike_type *tmp = or_pike_types(res, sub, 1);
    free_type(res);
    free_type(sub);
    return tmp;
  }
  return sub;
}

/* Used by fix_object_program_type() */
struct pike_type *object_type_to_program_type(struct pike_type *obj_t)
{
  return low_object_type_to_program_type(obj_t);
}



int type_may_overload(struct pike_type *type, int lfun)
{
  switch(type->type)
  {
    case T_ASSIGN:
      return type_may_overload(type->cdr, lfun);

    case T_FUNCTION:
    case T_MANY:
    case T_ARRAY:
      /* might want to check for `() */

    default:
      return 0;

    case PIKE_T_NAME:
    case PIKE_T_ATTRIBUTE:
      return type_may_overload(type->cdr, lfun);

    case PIKE_T_RING:
      return type_may_overload(type->car, lfun);

    case T_OR:
      return type_may_overload(type->car, lfun) ||
	type_may_overload(type->cdr, lfun);

    case T_AND:
      return type_may_overload(type->car, lfun) &&
	type_may_overload(type->cdr, lfun);

    case T_NOT:
      return !type_may_overload(type->car, lfun);

    case T_MIXED:
      return 1;

    case T_OBJECT:
    {
      struct program *p = id_to_program(CDR_TO_INT(type));
      if(!p) return 1;
      return FIND_LFUN(p, lfun)!=-1;
    }
  }
}


void yyexplain_nonmatching_types(int severity_level,
				 struct pike_string *a_file,
				 INT32 a_line,
				 struct pike_type *type_a,
				 struct pike_string *b_file,
				 INT32 b_line,
				 struct pike_type *type_b)
{
  DECLARE_CYCLIC();

  implements_a=0;
  implements_b=0;
  implements_mode=0;

  /* Note the argument order. */
  pike_types_le(type_b, type_a, 0, 0);

#if 0
  if(!(implements_a && implements_b &&
       type_a->str[0]==T_OBJECT &&
       type_b->str[0]==T_OBJECT))
#endif /* 0 */
  {
    ref_push_type_value(type_a);
    yytype_report(severity_level, NULL, 0, NULL, a_file, a_line, NULL,
                  1, "Expected: %O.");
    ref_push_type_value(type_b);
    yytype_report(severity_level, NULL, 0, NULL, b_file, b_line, NULL,
                  1, "Got     : %O.");
  }

  /* Protect against circularities. */
  if (BEGIN_CYCLIC(type_a, type_b)) {
    END_CYCLIC();
    return;
  }
  SET_CYCLIC_RET(1);

  if(implements_a && implements_b) {
    if (implements_mode) {
      yyexplain_not_implements(severity_level, implements_a, implements_b);
    } else {
      yyexplain_not_compatible(severity_level, implements_a, implements_b);
    }
  }
  END_CYCLIC();
}

/* FIXME: Code duplication! */
void string_builder_explain_nonmatching_types(struct string_builder *s,
					      struct pike_type *type_a,
					      struct pike_type *type_b)
{
  DECLARE_CYCLIC();

  implements_a=0;
  implements_b=0;
  implements_mode=0;

  /* Note the argument order. */
  pike_types_le(type_b, type_a, 0, 0);

#if 0
  if(!(implements_a && implements_b &&
       type_a->str[0]==T_OBJECT &&
       type_b->str[0]==T_OBJECT))
#endif /* 0 */
  {
    ref_push_type_value(type_a);
    ref_push_type_value(type_b);
    string_builder_sprintf(s,
                           "Expected: %pO.\n"
                           "Got     : %pO.\n",
			   Pike_sp-2, Pike_sp-1);
  }

  /* Protect against circularities. */
  if (BEGIN_CYCLIC(type_a, type_b)) {
    END_CYCLIC();
    return;
  }
  SET_CYCLIC_RET(1);

  if(implements_a && implements_b) {
    if (implements_mode) {
      string_builder_explain_not_implements(s, implements_a, implements_b);
    } else {
      string_builder_explain_not_compatible(s, implements_a, implements_b);
    }
  }
  END_CYCLIC();
}

/******/

static void low_make_pike_type(unsigned char *type_string,
			       unsigned char **cont);

static void low_make_function_type(unsigned char *type_string,
				   unsigned char **cont)
{
  if (*type_string == T_MANY) {
    low_make_pike_type(type_string+1, cont);
    low_make_pike_type(*cont, cont);
    push_reverse_type(T_MANY);
    return;
  }
  low_make_pike_type(type_string, cont);
  low_make_function_type(*cont, cont);
  push_reverse_type(T_FUNCTION);
}

static void low_make_pike_type(unsigned char *type_string,
			       unsigned char **cont)
{
  unsigned INT32 type = *type_string;

  if (type <= MAX_TYPE) {
    /* Remap from old type enumeration to
     * keep compat with output from __parse_pike_type().
     */
    type ^= MIN_REF_TYPE;
  }

  switch(type) {
#ifdef PIKE_DEBUG
  case T_SCOPE:
    Pike_fatal("Not supported yet.\n");
#endif
  case T_ASSIGN:
    if ((type_string[1] < '0') || (type_string[1] > '9')) {
      Pike_fatal("low_make_pike_type(): Bad marker: $%d\n", type_string[1]);
    }
    low_make_pike_type(type_string+2, cont);
    push_assign_type(type_string[1]);
    break;
  case T_OR:
  case T_AND:
    /* Order independant */
    /* FALLTHRU */

  case T_MANY:
  case T_TUPLE:
  case T_MAPPING:
  case PIKE_T_RING:
  case PIKE_T_TRANSITIVE:
    /* Order dependant */
    low_make_pike_type(type_string+1, cont);
    low_make_pike_type(*cont, cont);
    push_reverse_type(type);
    break;
  case PIKE_T_FUNCTION_ARG:
    low_make_pike_type(type_string+1, cont);
    low_make_pike_type(*cont, cont);
    push_reverse_type(T_FUNCTION);
    break;
  case T_FUNCTION:
    low_make_function_type(type_string+1, cont);
    break;
  case T_MULTISET:
  case T_TYPE:
  case T_NOT:
  case T_PROGRAM:
    low_make_pike_type(type_string+1, cont);
    push_reverse_type(type);
    break;
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
    /* Marker type */
    /* FALLTHRU */
  case T_FLOAT:
  case T_MIXED:
  case T_VOID:
  case T_ZERO:
  case PIKE_T_UNKNOWN:
    /* Leaf type */
    *cont = type_string+1;
    push_type(type);
    break;

  case T_STRING:
    *cont = type_string + 1;
    push_finished_type(int_type_string);
    push_unlimited_array_type(T_STRING);
    break;

  case PIKE_T_NSTRING:
    type = T_STRING;
    /* FALLTHRU */
  case T_ARRAY:
    low_make_pike_type(type_string + 1, cont);
    /* FIXME: Add check for valid subtype in the string case. */
    push_unlimited_array_type(type);
    break;

  case PIKE_T_LSTRING:
    type = T_STRING;
    /* Order dependant */
    low_make_pike_type(type_string+1, cont);
    low_make_pike_type(*cont, cont);
    push_reverse_type(type);
    break;

  case PIKE_T_LARRAY:
    type = T_ARRAY;
    /* Order dependant */
    low_make_pike_type(type_string+1, cont);
    low_make_pike_type(*cont, cont);
    push_reverse_type(type);
    break;

  case T_INT:
    {
      INT32 min = extract_type_int((char *)type_string+1);
      INT32 max = extract_type_int((char *)type_string+5);

      *cont = type_string + 9;	/* 2*sizeof(INT32) + 1 */
      push_int_type(min, max);
      break;
    }

  case PIKE_T_INT_UNTYPED:
    *cont = type_string + 1;
    push_int_type(MIN_INT32, MAX_INT32);
    break;

  case T_OBJECT:
    *cont = type_string + 6;	/* 1 + sizeof(INT32) + 1 */
    push_object_type(type_string[1], extract_type_int((char *)type_string+2));
    break;

  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
    {
      int size_shift = type_string[1] & 0x3;
      struct pike_string *str;
      INT32 bytes;
      /* bit 0 & 1: size_shift
       * bit 2 ==> little endian.
       *
       * The loops check the lsb first, since it's most likely to
       * be non-zero.
       */
      switch(type_string[1]) {
      default: /* will not happen? */
#ifdef PIKE_DEBUG
	 Pike_fatal("unexpected case in make_pike_type (%d)\n",
		    type_string[1]);
#endif
      case 0: case 4:
	bytes = strlen((char *)type_string+2);
	break;
      case 1:
	for(bytes=0; ; bytes+=2)
	  if(!type_string[bytes+3] && !type_string[bytes+2])
	    break;
	break;
      case 5:
	for(bytes=0; ; bytes+=2)
	  if(!type_string[bytes+2] && !type_string[bytes+3])
	    break;
	break;
      case 2:
	for(bytes=0; ; bytes+=4)
	  if(!type_string[bytes+5] && !type_string[bytes+4] &&
	     !type_string[bytes+3] && !type_string[bytes+2])
	    break;
	break;
      case 6:
	for(bytes=0; ; bytes+=4)
	  if(!type_string[bytes+2] && !type_string[bytes+3] &&
	     !type_string[bytes+4] && !type_string[bytes+5])
	    break;
	break;
      }
      str = begin_wide_shared_string(bytes>>size_shift, size_shift);
      memcpy(str->str, type_string+2, bytes);
      if (size_shift &&
#if (PIKE_BYTEORDER == 1234)
	  /* Little endian */
	  !(type_string[1] & 0x04)
#else /* PIKE_BYTEORDER != 1234 */
	  /* Big endian */
	  (type_string[1] & 0x04)
#endif /* PIKE_BYTEORDER == 1234 */
	  ) {
	int len;
	char tmp;
	if (size_shift == 1) {
	  for (len = 0; len < bytes; len += 2) {
	    tmp = str->str[len];
	    str->str[len] = str->str[len+1];
	    str->str[len+1] = tmp;
	  }
	} else {
	  for (len = 0; len < bytes; len += 4) {
	    tmp = str->str[len];
	    str->str[len] = str->str[len+3];
	    str->str[len+3] = tmp;
	    tmp = str->str[len+1];
	    str->str[len+1] = str->str[len+2];
	    str->str[len+2] = tmp;
	  }
	}
      }
      low_make_pike_type(type_string + 2 + bytes + (1<<size_shift), cont);
      if (type_string[0] == PIKE_T_NAME) {
	push_type_name(str = end_shared_string(str));
      } else {
	push_type_attribute(str = end_shared_string(str));
      }
      free_string(str);
      break;
    }

  case PIKE_T_OPERATOR:
    {
      type |= type_string[1]<<8;
      if (type & 0x8000) {
	low_make_pike_type(type_string + 2, cont);
	low_make_pike_type(*cont, cont);
	push_reverse_type(type);
      } else {
	switch(type) {
	case PIKE_T_FIND_LFUN:
	  {
	    struct pike_string *str;
	    int lfun = -1;
	    int i;
	    low_make_pike_type(type_string + 2, cont);
	    str = findstring((const char *)*cont);
	    if (!str) {
	      Pike_fatal("compile_type_string(): Invalid lfun name: \"%s\"\n", *cont);
	    }
	    for (i = 0; i < 256; i++) {
	      if (lfun_strings[i] == str) {
		lfun = i;
		break;
	      }
	    }
	    if (lfun == -1) {
	      Pike_fatal("compile_type_string(): Unknown lfun: \"%s\"\n", *cont);
	    }
	    *cont += str->len + 1;

	    push_type_operator(PIKE_T_FIND_LFUN,
			       (struct pike_type *)(ptrdiff_t)lfun);
	    break;
	  }

	case PIKE_T_GET_RETURN:
	case PIKE_T_THRESHOLD:
	  low_make_pike_type(type_string + 2, cont);
	  push_type_operator(type, NULL);
	  break;

	default:
	  Pike_fatal("compile_type_string(): Unknown operator: 0x%04x\n", type);
	  break;
	}
      }
      break;
    }
#ifdef PIKE_DEBUG
  default:
    Pike_fatal("compile_type_string(): Error in type string %d.\n", type);
    UNREACHABLE(break);
#endif
  }
}

void type_stack_mark(void)
{
  if(UNLIKELY(Pike_compiler->pike_type_mark_stackp >= pike_type_mark_stack + (PIKE_TYPE_STACK_SIZE>>4)))
    Pike_fatal("Type mark stack overflow.\n");
  *Pike_compiler->pike_type_mark_stackp=Pike_compiler->type_stackp;
  Pike_compiler->pike_type_mark_stackp++;
  TYPE_STACK_DEBUG("type_stack_mark");
}

/* Make a pike-type from a serialized (old-style) type. */
struct pike_type *debug_make_pike_type(const char *serialized_type)
{
  unsigned char *dummy;
  type_stack_mark();
  low_make_pike_type((unsigned char *)serialized_type, &dummy);
#if 1
  if ((Pike_compiler->type_stackp[0]->flags &
       (PT_FLAG_MARKER|PT_FLAG_ASSIGN)) ||
      (((Pike_compiler->type_stackp[0]->type == T_OR) ||
	(Pike_compiler->type_stackp[0]->type == T_AND)) &&
       (Pike_compiler->type_stackp[0]->car->type == PIKE_T_FUNCTION))) {
    push_scope_type(0);
  }
#endif /* 1 */
  return pop_unfinished_type();
}

int pike_type_allow_premature_toss(struct pike_type *type)
{
 again:
  if (!type) return 1;
#if 0
  fprintf(stderr, "pike_type_allow_premature_toss(): Type: %d\n",
	  type->type);
#endif /* 0 */
  switch(type->type & PIKE_T_MASK)
  {
    default:
#ifdef PIKE_DEBUG
      Pike_fatal("pike_type_allow_premature_toss: Unknown type (code: %d)\n",
		 type->type);
      UNREACHABLE(return 0);
#endif
    case T_NOT:
      return !pike_type_allow_premature_toss(type->car);

    case T_OBJECT:
    case T_MIXED:
    case T_FUNCTION:
    case T_MANY:
    case PIKE_T_OPERATOR:
    case PIKE_T_TRANSITIVE:
      return 0;

    case PIKE_T_NAME:
    case PIKE_T_ATTRIBUTE:
    case T_SCOPE:
    case T_ASSIGN:
    case T_ARRAY:
      type = type->cdr;
      goto again;

    case PIKE_T_RING:
      type = type->car;
      goto again;

    case T_OR:
    case T_MAPPING:
      if(!pike_type_allow_premature_toss(type->car)) return 0;
      type = type->cdr;
      goto again;

    case T_AND:
      /* FIXME: Should probably look at both branches. */
      type = type->cdr;
      goto again;

    case T_MULTISET:
      type = type->car;
      goto again;

    case T_PROGRAM:
    case T_TYPE:
    case T_INT:
    case T_FLOAT:
    case T_STRING:
    case PIKE_T_ZERO:
    case T_VOID:
      return 1;
  }
}

static void low_type_to_string(struct byte_buffer *buf, struct pike_type *t)
{
  /* FIXME: PIKE_T_OPERATOR */

 recurse:
  switch(t->type) {
  case T_MULTISET:
  case T_TYPE:
  case T_PROGRAM:
    buffer_add_u8(buf, t->type ^ MIN_REF_TYPE);
    t = t->car;
    goto recurse;

  case T_ARRAY:
    buffer_add_u8(buf, t->type ^ MIN_REF_TYPE);
    t = t->cdr;
    goto recurse;

  case T_NOT:
    buffer_add_u8(buf, t->type);
    t = t->car;
    goto recurse;

  case T_MAPPING:
    buffer_add_u8(buf, t->type ^ MIN_REF_TYPE);
    low_type_to_string(buf, t->car);
    t = t->cdr;
    goto recurse;

  case PIKE_T_RING:
  case T_TUPLE:
  case T_OR:
  case T_AND:
  case PIKE_T_TRANSITIVE:
    buffer_add_u8(buf, t->type);
    low_type_to_string(buf, t->car);
    t = t->cdr;
    goto recurse;

  case T_FLOAT:
  case T_ZERO:
    buffer_add_u8(buf, t->type ^ MIN_REF_TYPE);
    break;

  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
  case T_VOID:
  case T_MIXED:
    buffer_add_u8(buf, t->type);
    break;

  case T_OBJECT:
    {
      INT32 i;
      buffer_add_u8(buf, T_OBJECT ^ MIN_REF_TYPE);
      i = (INT32)CAR_TO_INT(t);
      buffer_add_u8(buf, i);
      i = (INT32)CDR_TO_INT(t);

      if( i > 65535 )  i = 0; /* Not constant between recompilations */

      buffer_add_be32(buf, i);
    }
    break;

  case T_STRING:
    {
      if (t->cdr == int_type_string) {
	buffer_add_u8(buf, T_STRING ^ MIN_REF_TYPE);
      } else {
	buffer_add_u8(buf, PIKE_T_NSTRING);
	low_type_to_string(buf, t->cdr);
      }
    }
    break;

  case T_INT:
    {
      INT32 i;
      buffer_add_u8(buf, T_INT ^ MIN_REF_TYPE);
      i = (INT32)CAR_TO_INT(t);
      buffer_add_be32(buf, i);
      i = (INT32)CDR_TO_INT(t);
      buffer_add_be32(buf, i);
    }
    break;

  case T_FUNCTION:
  case T_MANY:
    buffer_add_u8(buf, T_FUNCTION ^ MIN_REF_TYPE);
    while(t->type == T_FUNCTION) {
      low_type_to_string(buf, t->car);
      t = t->cdr;
    }
    buffer_add_u8(buf, T_MANY);
    low_type_to_string(buf, t->car);
    t = t->cdr;
    goto recurse;

  case T_SCOPE:
  case T_ASSIGN:
    buffer_add_u8(buf, t->type);
    buffer_add_u8(buf, '0' + CAR_TO_INT(t));
    t = t->cdr;
    goto recurse;

  case PIKE_T_NAME:
  case PIKE_T_ATTRIBUTE:
    buffer_add_u8(buf, t->type);
    buffer_add_u8(buf, 0);
    buffer_add_str(buf, ((struct pike_string *)t->car)->str);
    buffer_add_u8(buf, 0);
    t = t->cdr;
    goto recurse;

  default:
    Pike_error("low_type_to_string(): Unsupported node: %d\n", t->type);
    break;
  }
}

struct pike_string *type_to_string(struct pike_type *t)
{
  ONERROR err;
  struct byte_buffer buf = BUFFER_INIT();
  SET_ONERROR(err, buffer_free, &buf);
  low_type_to_string(&buf, t);
  UNSET_ONERROR(err);
  return buffer_finish_pike_string(&buf);
}

#ifdef PIKE_DEBUG
static void gc_mark_external_types(struct callback *cb, void *a, void *b);
static struct callback *pike_type_gc_callback = NULL;
#endif /* PIKE_DEBUG */

#ifdef HAVE_SYS_MMAN_H
#include <sys/mman.h>
#endif

#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS	MAP_ANON
#endif /* !MAP_ANONYMOUS && MAP_ANON */

#ifdef MAP_ANONYMOUS
static int type_stack_mmap, pike_type_mark_stack_mmap;
#endif

void init_types(void)
{
  /* Initialize hashtable here. */
  pike_type_hash = xcalloc(sizeof(struct pike_type *),
                           (PIKE_TYPE_HASH_SIZE+1));
  pike_type_hash_size = PIKE_TYPE_HASH_SIZE;

  /* if possible, use mmap with on-demand allocation */
#ifdef MAP_ANONYMOUS
#ifndef MAP_NORESERVE
#define MAP_NORESERVE 0
#endif /* MAP_NORESERVE */
  type_stack = mmap( NULL, sizeof(struct pike_type *)*PIKE_TYPE_STACK_SIZE,
		     PROT_READ|PROT_WRITE, MAP_NORESERVE|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
  if( type_stack != MAP_FAILED ) {
    type_stack_mmap = 1;
  } else {
    type_stack = NULL;
  }
  pike_type_mark_stack =
    mmap( NULL, sizeof(struct pike_type **)*PIKE_TYPE_STACK_SIZE>>2,
	  PROT_READ|PROT_WRITE, MAP_NORESERVE|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
  if( pike_type_mark_stack != MAP_FAILED ) {
    pike_type_mark_stack_mmap = 1;
  } else {
    pike_type_mark_stack = NULL;
  }
#endif /* MAP_ANONYMOUS */
  if( !type_stack )
    type_stack = xalloc(sizeof(struct pike_type *)*PIKE_TYPE_STACK_SIZE);
  if( !pike_type_mark_stack )
    pike_type_mark_stack = xalloc(sizeof(struct pike_type *)*PIKE_TYPE_STACK_SIZE / 4);

  Pike_compiler->type_stackp = type_stack;
  Pike_compiler->pike_type_mark_stackp = pike_type_mark_stack;

  type_stack_mark();	/* Type stack marker sentinel. */

  bool_type_string = CONSTTYPE(tInt01);
  int_type_string = CONSTTYPE(tInt);	/* MUST come before string and array! */
  int_pos_type_string = CONSTTYPE(tIntPos);
  string0_type_string = CONSTTYPE(tStr0);
  string_type_string = CONSTTYPE(tStr32);
  object_type_string = CONSTTYPE(tObj);
  program_type_string = CONSTTYPE(tPrg(tObj));
  float_type_string = CONSTTYPE(tFloat);
  mixed_type_string = CONSTTYPE(tMix);
  array_type_string = CONSTTYPE(tArray);
  multiset_type_string = CONSTTYPE(tMultiset);
  mapping_type_string = CONSTTYPE(tMapping);
  function_type_string = CONSTTYPE(tFunction);
  void_function_type_string = CONSTTYPE(tFunc(tNone,tVoid));
  type_type_string = CONSTTYPE(tType(tMix));
  void_type_string = CONSTTYPE(tVoid);
  zero_type_string = CONSTTYPE(tZero);
  inheritable_type_string = CONSTTYPE(tOr3(tPrg(tObj), tObj,
					   tFuncV(tNone, tOr(tVoid, tMix),
						  tObj)));
  typeable_type_string = CONSTTYPE(tOr4(tPrg(tObj), tObj,
					tFuncV(tNone, tOr(tVoid, tMix),
					       tObj),
					tType(tMix)));
  enumerable_type_string = CONSTTYPE(tOr3(tString,tInt,tFloat));
  any_type_string = CONSTTYPE(tOr(tVoid,tMix));
  weak_type_string = CONSTTYPE(tOr4(tArray,tMultiset,tMapping,
				    tFuncV(tNone,tZero,tOr(tMix,tVoid))));
  sscanf_type_string = CONSTTYPE(tFuncV(tAttr("sscanf_input", tStr)
					tAttr("sscanf_format", tStr),
					tAttr("sscanf_args", tUnknown), tIntPos));
  sscanf_80_type_string = CONSTTYPE(tFuncV(tAttr("sscanf_input", tStr)
					   tAttr("sscanf_80_format", tStr),
					   tAttr("sscanf_args", tUnknown), tIntPos));
  utf8_type_string = CONSTTYPE(tUtf8Str);

  /* add_ref(weak_type_string);	*//* LEAK */

  literal_string_string = make_shared_string("string");
  literal_int_string = make_shared_string("int");
  literal_float_string = make_shared_string("float");
  literal_function_string = make_shared_string("function");
  literal_object_string = make_shared_string("object");
  literal_program_string = make_shared_string("program");
  literal_array_string = make_shared_string("array");
  literal_multiset_string = make_shared_string("multiset");
  literal_mapping_string = make_shared_string("mapping");
  literal_type_string = make_shared_string("type");
  literal_mixed_string = make_shared_string("mixed");

  unknown_function_string = make_shared_string("unknown function");

#ifdef PIKE_DEBUG
  pike_type_gc_callback = add_gc_callback(gc_mark_external_types, NULL, NULL);
#endif

  INIT;
}

void cleanup_pike_types(void)
{
  EXIT;

#ifdef DO_PIKE_CLEANUP
  while (all_pike_type_locations) {
    free_type(all_pike_type_locations->t);
    all_pike_type_locations = all_pike_type_locations->next;
  }
#ifdef MAP_ANONYMOUS
  if( type_stack_mmap )
  {
    munmap( type_stack, sizeof(struct pike_type *)*PIKE_TYPE_STACK_SIZE);
    type_stack = NULL;
  }
  if( pike_type_mark_stack_mmap )
  {
    munmap( pike_type_mark_stack, sizeof(struct pike_type *)*PIKE_TYPE_STACK_SIZE>>2);
    pike_type_mark_stack = NULL;
  }
#endif
  free( type_stack );
  free( pike_type_mark_stack );
#endif /* DO_PIKE_CLEANUP */

  clear_markers();

  free_type(string0_type_string);
  string0_type_string = NULL;
  free_type(string_type_string);
  string_type_string = NULL;
  free_type(bool_type_string);
  bool_type_string = NULL;
  free_type(int_type_string);
  int_type_string = NULL;
  free_type(int_pos_type_string);
  int_pos_type_string = NULL;
  free_type(float_type_string);
  float_type_string = NULL;
  free_type(void_function_type_string);
  void_function_type_string = NULL;
  free_type(function_type_string);
  function_type_string = NULL;
  free_type(object_type_string);
  object_type_string = NULL;
  free_type(program_type_string);
  program_type_string = NULL;
  free_type(array_type_string);
  array_type_string = NULL;
  free_type(multiset_type_string);
  multiset_type_string = NULL;
  free_type(mapping_type_string);
  mapping_type_string = NULL;
  free_type(type_type_string);
  type_type_string = NULL;
  free_type(mixed_type_string);
  mixed_type_string = NULL;
  free_type(void_type_string);
  void_type_string = NULL;
  free_type(zero_type_string);
  zero_type_string = NULL;
  free_type(inheritable_type_string);
  inheritable_type_string = NULL;
  free_type(typeable_type_string);
  typeable_type_string = NULL;
  free_type(enumerable_type_string);
  enumerable_type_string = NULL;
  free_type(any_type_string);
  any_type_string = NULL;
  free_type(weak_type_string);
  weak_type_string = NULL;
  free_type(sscanf_type_string);
  sscanf_type_string = NULL;
  free_type(sscanf_80_type_string);
  sscanf_80_type_string = NULL;
  free_type(utf8_type_string);
  utf8_type_string = NULL;

  free_string(literal_string_string); literal_string_string = NULL;
  free_string(literal_int_string); literal_int_string = NULL;
  free_string(literal_float_string); literal_float_string = NULL;
  free_string(literal_function_string); literal_function_string = NULL;
  free_string(literal_object_string); literal_object_string = NULL;
  free_string(literal_program_string); literal_program_string = NULL;
  free_string(literal_array_string); literal_array_string = NULL;
  free_string(literal_multiset_string); literal_multiset_string = NULL;
  free_string(literal_mapping_string); literal_mapping_string = NULL;
  free_string(literal_type_string); literal_type_string = NULL;
  free_string(literal_mixed_string); literal_mixed_string = NULL;

  free_string(unknown_function_string); unknown_function_string = NULL;

#ifdef PIKE_DEBUG
  remove_callback(pike_type_gc_callback);
#endif
}

void cleanup_pike_type_table(void)
{
  /* Free the hashtable here. */
  if (pike_type_hash) {
    free(pike_type_hash);
    /* Don't do this, it messes up stuff...
     *
     * It's needed for dmalloc to survive.
     */
    pike_type_hash = NULL;
  }
  /* Don't do this, it messes up stuff...
   *
   * It's needed for dmalloc to survive.
   */
  pike_type_hash_size = 0;

#ifdef DO_PIKE_CLEANUP
  ba_destroy(&type_allocator);
#endif /* DO_PIKE_CLEANUP */
}

PMOD_EXPORT void *find_type(struct pike_type *t,
			    void *(*cb)(struct pike_type *))
{
  void *res;
  if (!t) return NULL;

  res = cb(t);
  if (res) return res;

  switch(t->type & PIKE_T_MASK) {
    case T_FUNCTION:
    case T_MANY:
    case T_TUPLE:
    case T_MAPPING:
    case T_OR:
    case T_AND:
    case PIKE_T_RING:
    case PIKE_T_TRANSITIVE:
      res = find_type(t->car, cb);
      if (res) return res;
      /* FALLTHRU */
    case T_SCOPE:
    case T_ASSIGN:
    case PIKE_T_ATTRIBUTE:
    case PIKE_T_NAME:
    case T_ARRAY:
    case T_STRING:
      return find_type(t->cdr, cb);

    case T_MULTISET:
    case T_NOT:
    case T_TYPE:
    case T_PROGRAM:
      return find_type(t->car, cb);

    case PIKE_T_OPERATOR:
      if (t->type & 0x8000) {
	res = find_type(t->cdr, cb);
	if (res) return res;
      }
      return find_type(t->car, cb);

#ifdef PIKE_DEBUG
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case T_FLOAT:
    case T_MIXED:
    case T_VOID:
    case T_ZERO:
    case PIKE_T_UNKNOWN:
    case T_INT:
    case T_OBJECT:
      break;
    default:
      Pike_fatal("find_type: Unhandled type-node: %d\n", t->type);
      break;
#endif /* PIKE_DEBUG */
  }
  return NULL;
}

PMOD_EXPORT void visit_type (struct pike_type *t, int action, void *extra)
{
  if (!t) return;
  visit_enter(t, PIKE_T_TYPE, extra);
  switch (action & VISIT_MODE_MASK) {
#ifdef PIKE_DEBUG
    default:
      Pike_fatal ("Unknown visit action %d.\n", action);
    case VISIT_NORMAL:
      break;
#endif
    case VISIT_COMPLEX_ONLY:
      visit_leave(t, PIKE_T_TYPE, extra);
      return;
    case VISIT_COUNT_BYTES:
      mc_counted_bytes += sizeof (struct pike_type);
      break;
  }

  switch (t->type & PIKE_T_MASK) {
    case T_FUNCTION:
    case T_MANY:
    case T_TUPLE:
    case T_MAPPING:
    case T_OR:
    case T_AND:
    case PIKE_T_RING:
    case T_ARRAY:
    case T_STRING:
    case PIKE_T_TRANSITIVE:
      if (t->car) {
	visit_type_ref (t->car, REF_TYPE_INTERNAL, extra);
      }
      /* FALLTHRU */
    case T_SCOPE:
    case T_ASSIGN:
      visit_type_ref (t->cdr, REF_TYPE_INTERNAL, extra);
      break;
    case T_MULTISET:
    case T_NOT:
    case T_TYPE:
    case T_PROGRAM:
      visit_type_ref (t->car, REF_TYPE_INTERNAL, extra);
      break;
    case PIKE_T_ATTRIBUTE:
    case PIKE_T_NAME:
      visit_string_ref ((struct pike_string *) t->car, REF_TYPE_INTERNAL,
			extra);
      visit_type_ref (t->cdr, REF_TYPE_INTERNAL, extra);
      break;

    case PIKE_T_OPERATOR:
      if (t->type & 0x8000) {
	visit_type_ref(t->cdr, REF_TYPE_INTERNAL, extra);
      }
      visit_type_ref(t->car, REF_TYPE_INTERNAL, extra);
      break;

#ifdef PIKE_DEBUG
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case T_FLOAT:
    case T_MIXED:
    case T_VOID:
    case T_ZERO:
    case PIKE_T_UNKNOWN:
    case T_INT:
    case T_OBJECT:
      break;
    default:
      Pike_fatal("visit_type: Unhandled type-node: %d\n", t->type);
      break;
#endif /* PIKE_DEBUG */
  }
  visit_leave(t, PIKE_T_TYPE, extra);
}

#if defined (PIKE_DEBUG) || defined (DO_PIKE_CLEANUP)

/* This is only enough gc stuff to detect leaking pike_type structs
 * and to locate references to them. More is needed if types are
 * extended to contain pointers to other memory objects or if they
 * might contain cycles. */

void gc_mark_type_as_referenced(struct pike_type *t)
{
  if (gc_mark(t, PIKE_T_TYPE)) {
    GC_ENTER(t, PIKE_T_TYPE) {
      switch(t->type & PIKE_T_MASK) {
      case PIKE_T_SCOPE:
      case T_ASSIGN:
      case PIKE_T_NAME:
      case PIKE_T_ATTRIBUTE:
	if (t->cdr) gc_mark_type_as_referenced(t->cdr);
	break;
      case PIKE_T_FUNCTION:
      case T_MANY:
      case PIKE_T_RING:
      case PIKE_T_TUPLE:
      case PIKE_T_MAPPING:
      case T_OR:
      case T_AND:
      case PIKE_T_ARRAY:
      case PIKE_T_STRING:
      case PIKE_T_TRANSITIVE:
	if (t->cdr) gc_mark_type_as_referenced(t->cdr);
      /* FALLTHROUGH */
      case PIKE_T_MULTISET:
      case T_NOT:
      case PIKE_T_TYPE:
      case PIKE_T_PROGRAM:
	if (t->car) gc_mark_type_as_referenced(t->car);
	break;
      case PIKE_T_OPERATOR:
	if ((t->type & 0x8000) && t->cdr) {
	  gc_mark_type_as_referenced(t->cdr);
	}
	gc_mark_type_as_referenced(t->car);
	break;
      }
    } GC_LEAVE;
  }
}

#ifdef PIKE_DEBUG
static void gc_mark_external_types(struct callback *UNUSED(cb),
                                   void *UNUSED(a), void *UNUSED(b))
{
  unsigned int e;
  for (e = 0; e < NELEM (a_markers); e++) {
    if (a_markers[e])
      gc_mark_external (a_markers[e], " in a_markers");
    if (b_markers[e])
      gc_mark_external (b_markers[e], " in b_markers");
  }

  if (string0_type_string)
    gc_mark_external(string0_type_string, " as string0_type_string");
  if (string_type_string)
    gc_mark_external(string_type_string, " as string_type_string");
  if (int_type_string)
    gc_mark_external(int_type_string, " as int_type_string");
  gc_mark_external(int0_type_string, " as int0_type_string");
  if (int_pos_type_string)
    gc_mark_external(int_pos_type_string, " as int_pos_type_string");
  if (object_type_string)
    gc_mark_external(object_type_string, " as object_type_string");
  if (program_type_string)
    gc_mark_external(program_type_string, " as program_type_string");
  if (float_type_string)
    gc_mark_external(float_type_string, " as float_type_string");
  if (mixed_type_string)
    gc_mark_external(mixed_type_string, " as mixed_type_string");
  if (array_type_string)
    gc_mark_external(array_type_string, " as array_type_string");
  if (multiset_type_string)
    gc_mark_external(multiset_type_string, " as multiset_type_string");
  if (mapping_type_string)
    gc_mark_external(mapping_type_string, " as mapping_type_string");
  if (function_type_string)
    gc_mark_external(function_type_string, " as function_type_string");
  if (type_type_string)
    gc_mark_external(type_type_string, " as type_type_string");
  if (void_type_string)
    gc_mark_external(void_type_string, " as void_type_string");
  if (zero_type_string)
    gc_mark_external(zero_type_string, " as zero_type_string");
  if (enumerable_type_string)
    gc_mark_external(enumerable_type_string, " as enumerable_type_string");
  if (any_type_string)
    gc_mark_external(any_type_string, " as any_type_string");
  if (weak_type_string)
    gc_mark_external(weak_type_string, " as weak_type_string");

#ifdef DO_PIKE_CLEANUP
  {
    struct pike_type_location *t = all_pike_type_locations;
    while(t) {
      gc_mark_external (t->t, " as constant type");
      t = t->next;
    }
  }
#endif
}
#endif

void gc_check_type (struct pike_type *t)
{
  debug_malloc_touch (t);

  GC_ENTER (t, T_TYPE) {
    switch (t->type & PIKE_T_MASK) {
      case T_FUNCTION:
      case T_MANY:
      case T_TUPLE:
      case T_MAPPING:
      case T_OR:
      case T_AND:
      case PIKE_T_RING:
      case T_ARRAY:
      case T_STRING:
      case PIKE_T_TRANSITIVE:
	if (t->car) {
	  debug_gc_check (t->car, " as car in a type");
	}
	if (t->cdr) {
	  debug_gc_check (t->cdr, " as cdr in a type");
	}
	break;
      case PIKE_T_ATTRIBUTE:
      case PIKE_T_NAME:
#ifdef PIKE_DEBUG
        /* this is a string and without PIKE_DEBUG
         * they are not touched by the GC */
	debug_gc_check (t->car, " as car in a type");
#endif
	if (t->cdr) {
	  debug_gc_check (t->cdr, " as cdr in a type");
	}
	break;
      case T_MULTISET:
      case T_NOT:
      case T_TYPE:
      case T_PROGRAM:
      case PIKE_T_AUTO:
	if (t->car) {
	  debug_gc_check (t->car, " as car in a type");
	}
	break;
      case T_SCOPE:
      case T_ASSIGN:
	if (t->cdr) {
	  debug_gc_check (t->cdr, " as cdr in a type");
	}
	break;
      case PIKE_T_OPERATOR:
	if ((t->type & 0x8000) && t->cdr) {
	  debug_gc_check (t->cdr, " as cdr in a type");
	}
	if (t->car) {
	  debug_gc_check (t->car, " as car in a type");
	}
	break;
#ifdef PIKE_DEBUG
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case T_FLOAT:
      case T_MIXED:
      case T_VOID:
      case T_ZERO:
      case PIKE_T_UNKNOWN:
      case T_INT:
      case T_OBJECT:
	break;
      default:
	Pike_fatal("gc_check_type: "
		   "Unhandled type-node: %d\n", t->type);
	break;
#endif /* PIKE_DEBUG */
    }
  } GC_LEAVE;
}

void gc_check_all_types (void)
{
  size_t e;
  for(e=0;e<=pike_type_hash_size;e++)
  {
    struct pike_type *t;
    for(t = pike_type_hash[e]; t; t=t->next) {
      if (gc_keep_markers) {
	/* Make sure that leaked types also have markers at cleanup... */
	(void)get_marker(t);
      }
      gc_check_type(t);
    }
  }
}

#endif /* PIKE_DEBUG || DO_PIKE_CLEANUP */

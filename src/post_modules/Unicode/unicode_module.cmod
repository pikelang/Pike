/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
|| $Id$
*/

#include "global.h"
#include "stralloc.h"
#include "global.h"
RCSID("$Id$");
#include "pike_macros.h"
#include "interpret.h"
#include "program.h"
#include "program_id.h"
#include "object.h"
#include "operators.h"
#include "module_support.h"
#include "array.h"

#include "config.h"
#include "normalize.h"
#include "split.h"
#include "buffer.h"

/*! @module Unicode
 */

static void push_words( int *d, struct words *w )
{
  struct array *r = allocate_array( w->size );
  unsigned int i;
  
  for( i=0; i<w->size; i++ )
  {
    r->item[i].type = PIKE_T_STRING;
    r->item[i].u.string =
      make_shared_binary_string2( d+w->words[i].start,
				  w->words[i].size );
  }
  push_array( r );
  uc_words_free( w );
}

/*! @decl array(string) split_words(string intput)
 *!
 *! @fixme
 *!   Document this function.
 */
PIKEFUN array(string) split_words( string input )
{
  struct words *res;
  struct buffer * data;
  data = uc_buffer_from_pikestring( input );
  res = unicode_split_words_buffer( data );
  pop_n_elems( args );
  push_words( data->data, res );
  uc_buffer_free( data );
}

/*! @decl array(string) split_words_and_normalize(string input)
 *!
 *! @fixme
 *!   Document this function.
 */
PIKEFUN array(string) split_words_and_normalize( string input )
{
  struct words *res;
  struct buffer *data;
  data = unicode_decompose_buffer(uc_buffer_from_pikestring(input), COMPAT_BIT);
  res = unicode_split_words_buffer( data );
  pop_n_elems( args );
  push_words( data->data, res );
  uc_buffer_free( data );
}

/*! @decl string normalize( string data, string method );
 *!
 *! Normalize the given unicode string according to the specified method.
 *! 
 *! The methods are:
 *!
 *!  NFC, NFD, NFKC and NFKD.
 *!  
 *! The methods are described in detail in the UAX #15 document, which
 *! can currently be found at
 *! http://www.unicode.org/unicode/reports/tr15/tr15-21.html
 *!
 *! A short description:
 *! 
 *! C and D specifies whether to decompose (D) complex characters to
 *! their parts, or compose (C) single characters to complex ones.
 *!
 *! K specifies whether or not do a canonical or compatibility
 *! conversion. When K is present, compatibility transformations are
 *! performed as well as the canonical transformations.
 *!
 *! @i{In the following text, 'X' denotes the single character 'X', even
 *!  if there is more than one character inside the quotation marks. 
 *!  The reson is that it's somewhat hard to describe unicode in
 *!  iso-8859-1.@}
 *!
 *! The Unicode Standard defines two equivalences between characters:
 *! canonical equivalence and compatibility equivalence. Canonical
 *! equivalence is a basic equivalency between characters or
 *! sequences of characters. 
 *!
 *! 'Å'  and  'A' '° (combining ring above)' are canonically equivalent.
 *!
 *! For round-trip compatibility with existing standards, Unicode has
 *! encoded many entities that are really variants of existing nominal
 *! characters. The visual representations of these character are
 *! typically a subset of the possible visual representations of the
 *! nominal character. These are given compatibility decompositions in
 *! the standard. Because the characters are visually distinguished,
 *! replacing a character by a compatibility equivalent may lose
 *! formatting information unless supplemented by markup or styling.
 *!
 *! Examples of compatibility equivalences:
 *! @ul
 *!   @item
 *!     Font variants (thin, italic, extra wide characters etc)
 *!   @item
 *!     Circled and squared characters
 *!   @item
 *!     super/subscript ('²' -> '2')
 *!   @item
 *!     Fractions       ('½' -> '1/2')
 *!   @item
 *!     Other composed characters ('fi' -> 'f' 'i',  'kg' -> 'k' 'g')
 *! @endul
 *!
 */
PIKEFUN string normalize( string s, string flags )
{
  int _flags=0, i;

  for( i = 0; i<flags->len; i++ )
    switch( flags->str[ i ] )
    {
      case 'K': _flags|=1; break;
      case 'C': _flags|=2; break;
    }

  RETURN unicode_normalize( s, _flags );
}

/*! @decl int is_wordchar(int c)
 *!
 *! @fixme
 *!   Document this function.
 */
PIKEFUN int is_wordchar( int c )
{
  RETURN unicode_is_wordchar( c );
}

/*! @endmodule
 */

PIKE_MODULE_INIT
{
  INIT
  unicode_normalize_init();
}

PIKE_MODULE_EXIT
{
  EXIT
}

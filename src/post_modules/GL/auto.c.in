/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
|| $Id: auto.c.in,v 1.28 2004/09/06 11:47:49 grubba Exp $
*/

#include "global.h"

#include "config.h"

RCSID("$Id: auto.c.in,v 1.28 2004/09/06 11:47:49 grubba Exp $");
#include "stralloc.h"
#include "pike_macros.h"
#include "object.h"
#include "program.h"
#include "interpret.h"
#include "builtin_functions.h"
#include "pike_error.h"
#include "module_support.h"
#include "operators.h"
#include "mapping.h"

#ifdef HAVE_WINDEF_H
#include <windef.h>
#endif /* HAVE_WINDEF_H */
#ifdef HAVE_WINGDI_H
#include <wingdi.h>
#endif /* HAVE_WINGDI_H */
#ifdef HAVE_GL_GL_H
#include <GL/gl.h>
#endif /* HAVE_GL_GL_H */
#ifdef HAVE_OPENGL_GL_H
#include <OpenGL/gl.h>
#endif /* HAVE_OPENGL_GL_H */


#define sp Pike_sp

#define ZT_INT    1
#define ZT_FLOAT  2
#define ZT_DOUBLE 4
#define ZT_ARRAY  8

struct zvalue4 {
  union {
    GLint i[4];
    GLfloat f[4];
    GLdouble d[4];
  } v;
  int ty;
};

union zvalue16 {
  GLint i[16];
  GLfloat f[16];
  GLdouble d[16];
};

struct zimage {
  GLsizei width, height;
  GLenum format, type;
  GLvoid *pixels;
  int alloc;
};

static int check_234_args(char *func, INT32 args, int mn, int mx, int ty,
			  int rty, struct zvalue4 *ret)
{
  struct svalue *s;
  int i, tt, tr=0;

  if(args==1 && sp[-1].type==T_ARRAY) {
    struct array *a = sp[-1].u.array;
    args = a->size;
    if(args<mn || args>mx)
      Pike_error("%s: expected array of size %d-%d.\n", func, mn, mx);
    s = ITEM(a);
  } else {
    if(args<mn || args>mx)
      Pike_error("%s: too %s arguments.\n", func, (args<mn? "few":"many"));
    s = sp-args;
  }
  for(i=0; i<args; i++)
    if(!((tt=1<<s[i].type)&ty)) {
      char buf[32];
      int n=0;
      buf[0]='\0';
      for(tt=0; ty; tt++)
	if(ty&(1<<tt)) {
	  ty&=~(1<<tt);
	  if(n++)
	    strcat(buf, " or ");
	  strcat(buf, get_name_of_type(tt));
	}
      Pike_error("%s: got %s, expected %s.\n", func,
	    get_name_of_type(s[i].type), buf);
    } else
      tr|=tt;
  if(tr==(BIT_INT|BIT_FLOAT))
    tt=((rty&ZT_DOUBLE)? ZT_DOUBLE:ZT_FLOAT);
  else if(tr==BIT_FLOAT)
    tt=((rty&ZT_FLOAT)? ZT_FLOAT:ZT_DOUBLE);
  else if(tr!=BIT_INT)
    Pike_error("Internal error in check_234_args for %s!\n", func);
  else if(rty&ZT_INT)
    tt=ZT_INT;
  else 
    tt=((rty&ZT_DOUBLE)? ZT_DOUBLE:ZT_FLOAT);
  ret->ty=tt;
  for(i=0; i<args; i++) 
    switch(tt)
    {
    case ZT_INT:
      ret->v.i[i]=s[i].u.integer;
      break;
    case ZT_FLOAT:
      ret->v.f[i]=(s[i].type==T_INT?(float)s[i].u.integer:s[i].u.float_number);
      break;      
    case ZT_DOUBLE:
      ret->v.d[i]=(s[i].type==T_INT?(double)s[i].u.integer:
		   s[i].u.float_number);
      break;      
    }
  return args;
}

static int img_inited=0;

static void img_init()
{
  glPixelStorei(GL_PACK_SWAP_BYTES, 0);
  glPixelStorei(GL_PACK_LSB_FIRST, 0);
  glPixelStorei(GL_PACK_ROW_LENGTH, 0);
  glPixelStorei(GL_PACK_SKIP_ROWS, 0);
  glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
  glPixelStorei(GL_PACK_ALIGNMENT, 1);
  glPixelStorei(GL_UNPACK_SWAP_BYTES, 0);
  glPixelStorei(GL_UNPACK_LSB_FIRST, 0);
  glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
  glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
  glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
  img_inited=1;
}

static void check_img_arg(struct svalue *a, struct zimage *img,
			  int arg, const char *func)
{
  struct {
    void *img;
    INT_TYPE w, h;
  } *rgbstor = NULL, *lumstor = NULL, *astor = NULL;
  struct {
    unsigned char *p;
    size_t size;
  } *stor_mem;
  unsigned char *pp;
  struct { unsigned char r, g, b; } *p1, *p2;
  INT32 cnt;

  static struct program *image_program=NULL;
  static struct program *shm_program=NULL;

  if(image_program == NULL) {
    push_string(make_shared_string("Image")); push_int(0);
    SAFE_APPLY_MASTER("resolv",2);
    if (sp[-1].type==T_OBJECT) 
    {
      push_string(make_shared_string("image"));
      f_index(2);
      image_program=program_from_svalue(sp-1);
      pop_stack();
    }
    if(image_program == NULL)
      Pike_error("%s: Can't resolve Image.image!\n", func);
  }

  if(shm_program == NULL) {
    push_string(make_shared_string("System.Memory")); push_int(0);
    SAFE_APPLY_MASTER("resolv",2);
    shm_program=program_from_svalue(sp-1);
    pop_stack();
    if(shm_program == NULL)
      Pike_error("%s: Can't resolve System.Memory!\n", func);
  }

  img->alloc = 0;
  if(a->type == T_MAPPING) {
    struct svalue *v;
    if((v=simple_mapping_string_lookup(a->u.mapping, "rgb"))) {
      if(v->type == T_OBJECT &&
	 (rgbstor = (void *)get_storage(v->u.object, image_program)) != NULL &&
	 rgbstor->img != NULL)
	;
      else
	Pike_error("Bad argument %d to %s.\n", arg, func);
    }
    if((v=simple_mapping_string_lookup(a->u.mapping, "luminance"))) {
      if(v->type == T_OBJECT &&
	 (lumstor = (void *)get_storage(v->u.object, image_program)) != NULL &&
	 lumstor->img != NULL)
	;
      else
	Pike_error("Bad argument %d to %s.\n", arg, func);
    }
    if((v=simple_mapping_string_lookup(a->u.mapping, "alpha"))) {
      if(v->type == T_OBJECT &&
	 (astor = (void *)get_storage(v->u.object, image_program)) != NULL &&
	 astor->img != NULL)
	;
      else
	Pike_error("Bad argument %d to %s.\n", arg, func);
    }
    if( (v=simple_mapping_string_lookup(a->u.mapping, "mem" )) ) {
      if( v->type == T_OBJECT &&
	  (stor_mem = (void *)get_storage( v->u.object, shm_program ) ) )
      {
	if( (v=simple_mapping_string_lookup(a->u.mapping, "mem_w" )) )
	  img->width = v->u.integer;
	else
	  Pike_error("Need mem_w for memory texture\n");
	if( (v=simple_mapping_string_lookup(a->u.mapping, "mem_h" )) )
	  img->height = v->u.integer;
	else
	  Pike_error("Need mem_h for memory texture\n");
	if( (v=simple_mapping_string_lookup(a->u.mapping, "mem_format" )) )
	  img->format = v->u.integer;
	else
	  Pike_error("Need mem_format for memory texture\n");
	if( (v=simple_mapping_string_lookup(a->u.mapping, "mem_type" )) )
	  img->type = v->u.integer;
	else
	  Pike_error("Need mem_type for memory texture\n");
	img->pixels = stor_mem->p;
	if( (v=simple_mapping_string_lookup(a->u.mapping, "mem_offset" )) )
	  img->pixels = (char *)img->pixels + v->u.integer;
	if(!img_inited)
	  img_init();
	return;
      }
    }
  } else if(a->type == T_OBJECT &&
	    (rgbstor = (void *)get_storage(a->u.object, image_program)) !=
	    NULL && rgbstor->img != NULL)
    ;
  else
    Pike_error("Bad argument %d to %s.\n", arg, func);

  if(rgbstor==NULL && lumstor==NULL && astor==NULL)
    Pike_error("Too few images specified.\n");

  if(rgbstor!=NULL && lumstor!=NULL)
    Pike_error("Can't have both rgb and luminance data.\n");

  if((rgbstor != NULL && astor != NULL &&
      (rgbstor->w != astor->w || rgbstor->h != astor->h)) ||
     (lumstor != NULL && astor != NULL &&
      (lumstor->w != astor->w || lumstor->h != astor->h)))
    Pike_error("Alpha channel must have same size as image!\n");

  if(lumstor==NULL && astor==NULL) {
    /* RGB */
    img->width = rgbstor->w;
    img->height = rgbstor->h;
    img->pixels = rgbstor->img;
    img->format = GL_RGB;
    img->type = GL_UNSIGNED_BYTE;
  } else if(rgbstor != NULL) {
    /* RGBA */
    img->width = rgbstor->w;
    img->height = rgbstor->h;
    img->pixels = pp = xalloc(img->width*img->height*4);
    img->format = GL_RGBA;
    img->type = GL_UNSIGNED_BYTE;
    cnt = img->width * img->height;
    p1 = rgbstor->img;
    p2 = astor->img;
    while(cnt--) {
      *pp++ = p1->r;
      *pp++ = p1->g;
      *pp++ = p1++->b;
      *pp++ = p2++->r;
    }
  } else if(astor == NULL) {
    /* Y */
    img->width = lumstor->w;
    img->height = lumstor->h;
    img->pixels = pp = xalloc(img->width*img->height);
    img->format = GL_LUMINANCE;
    img->type = GL_UNSIGNED_BYTE;
    cnt = img->width * img->height;
    p1 = lumstor->img;
    while(cnt--)
      *pp++ = p1++->r;
  } else if(lumstor == NULL) {
    /* A */
    img->width = astor->w;
    img->height = astor->h;
    img->pixels = pp = xalloc(img->width*img->height);
    img->format = GL_ALPHA;
    img->type = GL_UNSIGNED_BYTE;
    cnt = img->width * img->height;
    p1 = astor->img;
    while(cnt--)
      *pp++ = p1++->r;
  } else {
    /* YA */
    img->width = lumstor->w;
    img->height = lumstor->h;
    img->pixels = pp = xalloc(img->width*img->height*2);
    img->format = GL_LUMINANCE_ALPHA;
    img->type = GL_UNSIGNED_BYTE;
    cnt = img->width * img->height;
    p1 = lumstor->img;
    p2 = astor->img;
    while(cnt--) {
      *pp++ = p1++->r;
      *pp++ = p2++->r;
    }
  }
  if(!img_inited)
    img_init();
}

static void release_img(struct zimage *img)
{
  if(img->alloc)
    free(img->pixels);
}

static int check_1n_args(char *func, INT32 args, int ty, int rty,
			 union zvalue16 *ret)
{
  int i, tt, tr=0, arr=0;
  struct svalue *s;

  if(args!=1)
    Pike_error("%s: too %s arguments.\n", func, (args<1? "few":"many"));
  
  if(sp[-1].type==T_ARRAY) {
    struct array *a = sp[-1].u.array;
    args = a->size;
    if(args>16)
      Pike_error("%s: array too large.\n", func);
    arr++;
    s = ITEM(a);
  } else
    s = sp-args;

  for(i=0; i<args; i++)
    if(!((tt=1<<s[i].type)&ty)) {
      char buf[32];
      int n=0;
      buf[0]='\0';
      for(tt=0; ty; tt++)
	if(ty&(1<<tt)) {
	  ty&=~(1<<tt);
	  if(n++)
	    strcat(buf, " or ");
	  strcat(buf, get_name_of_type(tt));
	}
      Pike_error("%s: got %s, expected %s.\n", func,
	    get_name_of_type(s[i].type), buf);
    } else
      tr|=tt;
  if(tr==(BIT_INT|BIT_FLOAT))
    tt=((rty&ZT_DOUBLE)? ZT_DOUBLE:ZT_FLOAT);
  else if(tr==BIT_FLOAT)
    tt=((rty&ZT_FLOAT)? ZT_FLOAT:ZT_DOUBLE);
  else if(tr!=BIT_INT)
    Pike_error("Internal error in check_1n_args for %s!\n", func);
  else if(rty&ZT_INT)
    tt=ZT_INT;
  else 
    tt=((rty&ZT_DOUBLE)? ZT_DOUBLE:ZT_FLOAT);

  for(i=0; i<args; i++) 
    switch(tt)
    {
    case ZT_INT:
      ret->i[i]=s[i].u.integer;
      break;
    case ZT_FLOAT:
      ret->f[i]=(s[i].type==T_INT?(float)s[i].u.integer:s[i].u.float_number);
      break;      
    case ZT_DOUBLE:
      ret->d[i]=(s[i].type==T_INT?(double)s[i].u.integer:s[i].u.float_number);
      break;      
    }  

  return tt|(arr?ZT_ARRAY:0);
}

inline static void my_push_text(char * str) {
  if(!str)
    push_int(0);
  else
    push_text(str);
}

#define glClearColor3v(f) glClearColor((f)[0], (f)[1], (f)[2], 0.0)
#define glClearColor4v(f) glClearColor((f)[0], (f)[1], (f)[2], (f)[3])
#define glClearAccum3v(f) glClearAccum((f)[0], (f)[1], (f)[2], 0.0)
#define glClearAccum4v(f) glClearAccum((f)[0], (f)[1], (f)[2], (f)[3])
#define glEvalPoint1v(i) glEvalPoint1((i)[0]);
#define glEvalPoint2v(i) glEvalPoint2((i)[0], (i)[1]);

static void pre_init()
{
}

static void post_init()
{
}

@@

PROGRAM(color_selection);
// The color selection widget is, not surprisingly, a widget for
// interactive selection of colors.  This composite widget lets the
// user select a color by manipulating RGB (Red, Green, Blue) and HSV
// (Hue, Saturation, Value) triples. This is done either by adjusting
// single values with sliders or entries, or by picking the desired
// color from a hue-saturation wheel/value bar.  Optionally, the
// opacity of the color can also be set.

// <p>


// The color selection widget currently emits only one signal,
// "color_changed", which is emitted whenever the current color in the
// widget changes, either when the user changes it or if it's set
// explicitly through set_color().

// <p>

// IMG: GTK.ColorSelection()
INHERIT(vbox);
COMPLEX_FUNCTION(create);
// Create a new color selection.
COMPLEX_FUNCTION(set_update_policy,int);
NAME_ARGS(policy);
// one of CONST(GTK_UPDATE).
// <p>
// The default policy is GTK.UpdateContinuous which means that the
// current color is updated continuously when the user drags the
// sliders or presses the mouse and drags in the hue-saturation wheel
// or value bar. If you experience performance problems, you may want
// to set the policy to GTK.UpdateDiscontinuous or GTK.UpdateDelayed.

COMPLEX_FUNCTION(set_opacity,int);
NAME_ARGS(opacity);
// The color selection widget supports adjusting the opacity of a
// color (also known as the alpha channel). This is disabled by
// default. Calling this function with use_opacity set to 1 enables
// opacity. Likewise, use_opacity set to 0 will disable opacity.

FUNCTION(get_color, "function(void:array(float))")
//  When you need to query the current color, typically when you've
//  received a "color_changed" signal, you use this function. The
//  return value is an array of floats, See the set_color() function
//  for the description of this array.
{
  double vals[4];
  int i;
  gtk_color_selection_get_color( GTK_COLOR_SELECTION( THIS->obj ), vals );
  for(i=0; i<4; i++)
    push_float(vals[i]);
  f_aggregate( 4 );
}

FUNCTION(set_color, "function(array(float):object)")
NAME_ARGS(rgba);
RETURNS(GTK.ColorDialog);
// You can set the current color explicitly by calling this function
// with an array of colors (floats). The length of the array depends
// on whether opacity is enabled or not. Position 0 contains the red
// component, 1 is green, 2 is blue and opacity is at position 3 (only
// if opacity is enabled, see set_opacity()) All values are between
// 0.0 and 1.0
{
  gdouble vals[4];
  int i;
  struct array *a;
  get_all_args( "set_color", args, "%a", &a );
  for(i=0; i<a->size; i++)
    if(i>3) 
      break;
    else
      vals[i] = a->item[i].u.float_number;
  gtk_color_selection_set_color( GTK_COLOR_SELECTION( THIS->obj ), vals );
  
  RETURN_THIS();
}
/*
 * SUBWIDGET( wheel_area, container );
 * SUBWIDGET( value_area, container );
 * SUBWIDGET( sample_area, container );
 * SUBWIDGET( sample_area_eb, container );
 */

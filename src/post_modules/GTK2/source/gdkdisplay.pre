/* -*- C -*- */
require gtk22;

class GDK2.Display;
inherit G.Object;

//! GdkDisplay object.

%{
#define GTK_GDKDISPLAY(X) GDK_DISPLAY_OBJECT(X)
%}

signal closed;

void create()
//! Get the default display.
{
  pgtk2_verify_not_inited();
  pgtk2_verify_setup();
  THIS->obj=G_OBJECT(gdk_display_get_default());
  pgtk2_pop_n_elems(args);
  pgtk2__init_this_object();
}

void open(string name)
//! Opens a display.
{
  pgtk2_verify_inited();
  {
    const gchar *name;
    get_all_args("open",args,"%s",&name);
    THIS->obj=G_OBJECT(gdk_display_open(name));
  }
  RETURN_THIS();
}

string get_name();
//! Gets the name of the display.

/*
int get_n_screens();
//! Gets the number of screens managed by the display.
*/

void pointer_ungrab()
//! Release any pointer grab.
{
  pgtk2_verify_inited();
  gdk_display_pointer_ungrab(GDK_DISPLAY_OBJECT(THIS->obj),GDK_CURRENT_TIME);
  RETURN_THIS();
}

void keyboard_ungrab()
//! Release any keyboard grab.
{
  pgtk2_verify_inited();
  gdk_display_keyboard_ungrab(GDK_DISPLAY_OBJECT(THIS->obj),GDK_CURRENT_TIME);
  RETURN_THIS();
}

int pointer_is_grabbed();
//! Test if the pointer is grabbed.

void beep();
//! Emits a short beep on display

void sync();
//! Flushes any requests queued for the windowing system and waits until all
//! requests have been handled.  This is often used for making sure that the
//! display is synchronized with the current state of the program.  Calling
//! sync() before (gdk_error_trap_pop()) makes sure that any errors
//! generated from earlier requests are handled before the error trap is
//! removed.
//! <p>
//! This is most useful for X11.  On windowing systems where requests are
//! handled synchronously, this function will do nothing.

require gtk24;
void flush();
//! Flushes any requests queued for the windowing system; this happens
//! automatically when the main loop blocks waiting for new events, but if
//! your application is drawing without returning control to the main loop,
//! you may need to call this function explicitly.  A common case where this
//! function needs to be called is when an application is executing drawing
//! commands from a thread other than the thread where the main loop is
//! running.
endrequire;

void close();
//! Closes the connection to the window system for the given display, and
//! cleans up associated resources.

GDK2.Event get_event();
//! Gets the next GDK2.Event to be processed, fetching events from the
//! windowing system if necessary.

GDK2.Event peek_event();
//! Gets a copy of the first GDK2.Event in the event queue, without removing
//! the event from the queue.  (Note that this function will not get more
//! events from the windowing system.  It only checks the events that have
//! already been moved to the GDK event queue.)

void put_event(GDK2.Event event);
//! Appends a copy of the given event onto the front of the event queue.

void set_double_click_time(int msec);
//! Sets the double click time (two clicks within this time interval counts
//! as a double click and result in a GDK_2BUTTON_PRESS event).  Applications
//! should not set this, it is a global user-configured setting.

require gtk24;
void set_double_click_distance(int distance);
//! Sets the double click distance (two clicks within this distance count as
//! a double click and result in a GDK_2BUTTON_PRESS event).  See also
//! set_double_click_time().
endrequire;

mapping get_pointer()
//! Gets the current location of the pointer and the current modifier mask.
{
  pgtk2_verify_inited();
  {
    gint x,y;
    GdkModifierType mask;
    gdk_display_get_pointer(GDK_DISPLAY_OBJECT(THIS->obj),NULL,&x,&y,&mask);
    pgtk2_pop_n_elems(args);
    ref_push_string(_STR("x")); push_int(x);
    ref_push_string(_STR("y")); push_int(y);
    ref_push_string(_STR("mask")); push_int(mask);
    f_aggregate_mapping(6);
  }
}

mapping get_window_at_pointer()
//! Obtains the window underneath the mouse pointer, and the x,y location.
//! Returns 0 if the window is not known to GDK (for example, belongs to
//! another application).
{
  pgtk2_verify_inited();
  pgtk2_pop_n_elems(args);
  {
    gint x,y;
    GdkWindow *gw;
    gw=gdk_display_get_window_at_pointer(GDK_DISPLAY_OBJECT(THIS->obj),&x,&y);
/*    push_text("window"); push_gdkobject(gw,window); */
    ref_push_string(_STR("window")); push_gobject(gw);
    ref_push_string(_STR("x")); push_int(x);
    ref_push_string(_STR("y")); push_int(y);
    f_aggregate_mapping(6);
  }
}

require gtk24;
int supports_cursor_color();
//! Returns true if multicolored cursors are supported.  Otherwise, cursors
//! have only a foreground and a background color.

int supports_cursor_alpha();
//! Returns true if cursors can use an 8bit alpha channel.  Otherwise, cursors
//! are restricted to bilevel alpha (i.e. a mask).

int get_default_cursor_size();
//! Returns the default size to use for cursors.

mapping get_maximal_cursor_size()
//! Returns the maximal size to use for cursors.
{
  pgtk2_verify_inited();
  {
    guint width,height;
    gdk_display_get_maximal_cursor_size(GDK_DISPLAY_OBJECT(THIS->obj),
			&width,&height);
    pgtk2_pop_n_elems(args);
    ref_push_string(_STR("width")); push_int(width);
    ref_push_string(_STR("height")); push_int(height);
    f_aggregate_mapping(4);
  }
}

GDK2.Window get_default_group();
//! Returns the default group leader window for all toplevel windows.  This
//! window is implicitly create by GDK.
endrequire;

require gtk26;
int supports_selection_notification();
//! Returns whether GdkEventOwnerChange events will be sent when the owner
//! of a selection changes.

int request_selection_notification(GDK2.Atom selection)
//! Request GdkEventOwnerChange events for ownership changes of the selection
//! named by the given atom.
{
  pgtk2_verify_inited();
  {
    struct object *o1;
    int res;
    get_all_args("request_selection_notification",args,"%o",&o1);
    res=gdk_display_request_selection_notification(
		GDK_DISPLAY_OBJECT(THIS->obj),
		get_gdkatom(o1));
    pgtk2_pop_n_elems(args);
    push_int(res);
  }
}

int supports_clipboard_persistence();
//! Returns whether the specified display supports clipboard persistence, i.e.
//! if it's possible to store the clipboard data after an application has quit.
//! On X11 this checks if a clipboard daemon is running.
endrequire;

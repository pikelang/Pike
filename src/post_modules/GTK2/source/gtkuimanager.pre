/* -*- C -*- */
require gtk24;

class GTK2.UiManager;
inherit G.Object;

//! Constructing menus and toolbars from an XML description.

//! Properties:
//! int add-tearoffs
//! string ui

signal actions_changed;
//! Emitted whenever the actions changes.
signal add_widget;
//! Emitted for each generated menubar and toolbar, but not for generated
//! popup menus.
signal connect_proxy;
//! Emitted after connecting a proxy to an action.
signal disconnect_proxy;
//! Emitted after disconnecting a proxy from an action.
signal post_activate;
//! Emitted just after the action is activated.
signal pre_activate;
//! Emitted just before the action is activated.

//! A UI definition:
//! &lt;ui&gt;
//!   &lt;menubar&gt;
//!     &lt;menu name="FileMenu" action="FileMenuAction"&gt;
//!       &lt;menuitem name="New" action="New2Action" /&gt;
//!       &lt;placeholder name="FileMenuAdditions" /&gt;
//!     &lt;/menu>
//!     &lt;menu name="JustifyMenu" action="JustifyMenuAction"&gt;
//!       &lt;menuitem name="Left" action="justify-left"/&gt;
//!       &lt;menuitem name="Centre" action="justify-center"/&gt;
//!       &lt;menuitem name="Right" action="justify-right"/&gt;
//!       &lt;menuitem name="Fill" action="justify-fill"/&gt;
//!     &lt;/menu&gt;
//!   &lt;/menubar&gt;
//!   &lt;toolbar action="toolbar1"&gt;
//!     &lt;placeholder name="JustifyToolItems"&gt;
//!       &lt;separator/&gt;
//!       &lt;toolitem name="Left" action="justify-left"/&gt;
//!       &lt;toolitem name="Centre" action="justify-center"/&gt;
//!       &lt;toolitem name="Right" action="justify-right"/&gt;
//!       &lt;toolitem name="Fill" action="justify-fill"/&gt;
//!       &lt;separator/&gt;
//!     &lt;/placeholder&gt;
//!   &lt;/toolbar&gt;
//! &lt;/ui&gt;

void create(?mapping(string:mixed) props)
//! Creates a new ui manager object.
{
  pgtk2_verify_not_inited();
  pgtk2_verify_setup();
  if (args) {
    INIT_WITH_PROPS(GTK_TYPE_UI_MANAGER);
    pgtk2_pop_n_elems(args);
  } else {
    GtkUIManager *gu;
    gu=gtk_ui_manager_new();
    THIS->obj=G_OBJECT(gu);
  }
  pgtk2__init_this_object();
}

void set_add_tearoffs(int setting);
//! Sets the "add-tearoffs" property, which controls whether menus generated
//! by this manager will have tearoff menu items.
//! <p>
//! Note that this only affects regular menus.  Generated popup menus never
//! have tearoff menu items.

int get_add_tearoffs();
//! Returns whether menus generated by this manager will have tearoff menu
//! items.

void insert_action_group(GTK2.ActionGroup group, int pos);
//! Inserts an action group into the list of action groups.  Actions in
//! earlier groups hide actions with the same name in later groups.

void remove_action_group(GTK2.ActionGroup group);
//! Removes an action group from the list of action groups.

array(GTK2.ActionGroup) get_action_groups()
//! Returns the list of action groups.
{
  pgtk2_verify_inited();
  pgtk2_pop_n_elems(args);
  {
    GList *gl;
    int i=0;
    gl=gtk_ui_manager_get_action_groups(GTK_UI_MANAGER(THIS->obj));
    while (gl) {
      push_gobject(GTK_ACTION_GROUP(gl->data));
      g_object_ref(GTK_ACTION_GROUP(gl->data));
      i++;
      gl=g_list_next(gl);
    }
    f_aggregate(i);
  }
}

+GTK2.AccelGroup get_accel_group();
//! Returns the GTK2.AccelGroup associated with this.

+GTK2.Widget get_widget(string path)
//! Looks up a widget by following a path.  The path consists of the names
//! specified in the xml description of the ui, separated by '/'.  Elements
//! which don't have a name or action attribute in the xml (e.g. &gt;popup&lt;)
//! can be addressed by their xml element name (e.g. "popup").  The root element
//! ("/ui") can be omitted in the path.
//! <p>
//! Note that the widget found be following a path that ends in a &gt;menu&lt;
//! element is the menuitem to which the menu is attached, not the menu itself.
{
  pgtk2_verify_inited();
  {
    char *path;
    GtkWidget *w;
    get_all_args(NULL,args,"%c",&path);
    w=gtk_ui_manager_get_widget(GTK_UI_MANAGER(THIS->obj),path);
    pgtk2_pop_n_elems(args);
    push_gobject(w);
  }
}

array(GTK2.Widget) get_toplevels(int types)
//! Obtains a list of all toplevel widgets of the requested types.  Bitwise or
//! of CONST(GTK_UI_MANAGER_).
{
  pgtk2_verify_inited();
  {
    GSList *gl,*g2;
    int i=0;
    INT_TYPE type;
    get_all_args(NULL,args,"%i",&type);
    pgtk2_pop_n_elems(args);
    gl=g2=gtk_ui_manager_get_toplevels(GTK_UI_MANAGER(THIS->obj),type);
    while (g2) {
      push_gobject(GTK_WIDGET(g2->data));
      g_object_ref(GTK_WIDGET(g2->data));
      i++;
      g2=g_slist_next(g2);
    }
    f_aggregate(i);
    g_slist_free(gl);
  }
}

+GTK2.Action get_action(string path);
//! Looks up an action by following a path.

int add_ui_from_string(string buffer)
//! Parses a string containing a ui definition and merges it with the current
//! contents.  An enclosing &gt;ui&lt; element is added if it is missing.
{
  pgtk2_verify_inited();
  {
    const gchar *buff;
    int res;
    get_all_args(NULL,args,"%c",&buff);
    res=gtk_ui_manager_add_ui_from_string(GTK_UI_MANAGER(THIS->obj),
			buff,-1,NULL);
    pgtk2_pop_n_elems(args);
    PGTK_PUSH_INT(res);
  }
}

int add_ui_from_file(string filename, null);
//! Parses a file containing a ui definition.

int new_merge_id();
//! Returns an unused merge id, suitable for use with add_ui().

void add_ui(int merge_id, string path, string name, string action,
	    int type, int top);
//! Adds a ui element to the current contents.
//! <p>
//! If type is GTK2.UI_MANAGER_AUTO, GTK2+ inserts a menuitem, toolitem or
//! separator if such an element can be inserted at the place determined by
//! path.  Otherwise type must indicate an element that can be inserted at the
//! place determined by path.

void remove_ui(int merge_id);
//! Unmerges the part of the content identified by merge_id.

string get_ui();
//! Creates a ui definition of the merged ui.

void ensure_update();
//! Makes sure that all pending updates to the ui have been completed.
endrequire;

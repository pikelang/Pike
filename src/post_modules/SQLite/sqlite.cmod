/* sqlite.cmod -*- c -*- */

#include "global.h"
#include "interpret.h"
#include "module_support.h"
#include "config.h"
#include "object.h"
#include "builtin_functions.h"
#include "mapping.h"

#ifdef HAVE_SQLITE3_H

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <sqlite3.h>
#include <time.h>

DECLARATIONS

static int step(sqlite3_stmt *stmt) {
  int ret;
  while( (ret=sqlite3_step(stmt))==SQLITE_BUSY ) {
#ifdef HAVE_USLEEP
    usleep(100);
#else
    sleep(1);
#endif
  }
  return ret;
}

PIKECLASS ResObj
{
  CVAR sqlite3 *db;
  CVAR sqlite3_stmt *stmt;
  CVAR int eof;
  CVAR int columns;

  static void ResObj_handle_error(void) {
    Pike_error("Sql.SQLite: %s\n", sqlite3_errmsg(THIS->db));
  }

  PIKEFUN void create() {
    THIS->columns = sqlite3_column_count(THIS->stmt);
  }

  PIKEFUN int num_rows() {
    Pike_error("Sql.SQLite: Number of rows not known in advance.\n");
  }

  PIKEFUN int num_fields() {
    RETURN THIS->columns;
  }

  PIKEFUN int eof() {
    RETURN THIS->eof;
  }

  PIKEFUN array(mapping(string:mixed)) fetch_fields() {
    int i;
    for(i=0; i<THIS->columns; i++) {
      push_constant_text("name");
      push_text(sqlite3_column_name(THIS->stmt, i));
      f_utf8_to_string(1);
      f_aggregate_mapping(2);
    }
    f_aggregate(THIS->columns);
  }

  PIKEFUN void seek(int skip) {
    int i;
    for(i=0; i<skip; i++)
      if( step(THIS->stmt)==SQLITE_DONE ) {
	THIS->eof = 1;
	return;
      }
  }

  PIKEFUN array fetch_row() {
    int i;
    sqlite3_stmt *stmt = THIS->stmt;

    if(THIS->eof) {
      push_int(0);
      return;
    }

    switch( step(stmt) ) {
    case SQLITE_DONE:
      THIS->eof = 1;
      sqlite3_finalize(stmt);
      THIS->stmt = 0;
      push_int(0);
      return;
    case SQLITE_ROW:
      break;
    default:
      ResObj_handle_error();
    }

    for(i=0; i<THIS->columns; i++) {
      push_string( make_shared_binary_string
		   ( sqlite3_column_blob(stmt, i),
		     sqlite3_column_bytes(stmt, i) ) );
      if( sqlite3_column_type(stmt, i) )
	f_utf8_to_string(1);
    }
    f_aggregate(THIS->columns);
  }

  INIT {
    THIS->eof = 0;
    THIS->columns = -1;
  }
  EXIT {
    if(THIS->stmt)
      sqlite3_finalize(THIS->stmt);
  }
}

PIKECLASS SQLite
{
  CVAR sqlite3 *db;

  static void SQLite_handle_error(void) {
    Pike_error("Sql.SQLite: %s\n", sqlite3_errmsg(THIS->db));
  }
#define ERR(X) if(X!=SQLITE_OK) SQLite_handle_error()

  /* @decl void create(string path)
   */
  PIKEFUN void create(string path, mixed|void a, mixed|void b, mixed|void c) {
    pop_n_elems(args-1);
    f_string_to_utf8(1);
    ERR( sqlite3_open(path->str, &THIS->db) );
    pop_stack();
  }

  PIKEFUN object big_query(string query) {
    struct object *res;
    sqlite3_stmt *stmt;
    const char *tail;
    struct ResObj_struct *store;
    struct pike_string *q;

    f_string_to_utf8(1);
    q = Pike_sp[-1].u.string;

    ERR( sqlite3_prepare(THIS->db, q->str, q->len, &stmt, &tail) );
    if( tail[0] )
      Pike_error("Sql.SQLite->big_query: Trailing query data (\"%s\")\n",
		 tail);

    res=fast_clone_object(ResObj_program);
    store = OBJ2_RESOBJ(res);
    store->db = THIS->db;
    store->stmt = stmt;
    apply_low(res, f_ResObj_create_fun_num, 0);
    push_object(res);
  }

  PIKEFUN int changes() {
    RETURN sqlite3_changes(THIS->db);
  }

  PIKEFUN int total_changes() {
    RETURN sqlite3_total_changes(THIS->db);
  }

  PIKEFUN void interrupt() {
    sqlite3_interrupt(THIS->db);
  }

  PIKEFUN string server_info() {
    push_constant_text(sqlite3_libversion());
  }

  PIKEFUN int last_insert_rowid() {
    RETURN sqlite3_last_insert_rowid(THIS->db);
  }

  PIKEFUN string error() {
    push_text(sqlite3_errmsg(THIS->db));
    f_utf8_to_string(1);
  }

  PIKEFUN void select_db(string db) {
    Pike_error("This operation is not possible with SQLite.\n");
  }

  PIKEFUN void create_db(string db) {
    Pike_error("This operation is not possible with SQLite.\n");
  }

  PIKEFUN void drop_db(string db) {
    Pike_error("This operation is not possible with SQLite.\n");
  }

  PIKEFUN array(string) list_dbs() {
    Pike_error("This operation is not possible with SQLite.\n");
  }

  PIKEFUN array(string) list_tables() {
    int err, tbls;
    sqlite3_stmt *stmt;
    ERR( sqlite3_prepare(THIS->db,
			 "SELECT name FROM sqlite_master WHERE type='table'",
			 -1, &stmt, NULL) );
    tbls=0;
    while( (err=step(stmt))==SQLITE_ROW ) {
      push_text( sqlite3_column_text(stmt, 0) );
      f_utf8_to_string(1);
      tbls++;
    }
    sqlite3_finalize(stmt);
    if(err!=SQLITE_DONE) SQLite_handle_error();
    f_aggregate(tbls);
  }

  PIKEFUN array(mapping(string:mixed)) list_fields(string table) {
    int fields, i;
    sqlite3_stmt *stmt;
    char q[2048];
    struct pike_string *tbl;

    f_string_to_utf8(1);
    tbl = Pike_sp[-1].u.string;
    if(tbl->len > 2047) Pike_error("Table name to long.\n");
    snprintf(q, 2048, "SELECT * FROM %s LIMIT 1", tbl->str);

    ERR( sqlite3_prepare(THIS->db, q, -1, &stmt, NULL) );
    pop_n_elems(args);

    fields = sqlite3_column_count(stmt);

    for(i=0; i<fields; i++) {
      push_constant_text("name");
      push_text(sqlite3_column_name(stmt, i));
      f_utf8_to_string(1);
      f_aggregate_mapping(2);
    }
    f_aggregate(fields);
    sqlite3_finalize(stmt);
  }

  /* compile_query */

  INIT {
  }
  EXIT {
    /* FIXME: This call can fail. What do we do then? */
    sqlite3_close(THIS->db);
  }

}


#endif /* HAVE_SQLITE3_H */

PIKE_MODULE_INIT {
  INIT;
}

PIKE_MODULE_EXIT {
  EXIT;
}

/* sqlite.cmod -*- c -*- */

#include "global.h"
#include "interpret.h"
#include "module_support.h"
#include "config.h"
#include "object.h"
#include "builtin_functions.h"
#include "mapping.h"

#ifdef HAVE_SQLITE3_H

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <sqlite3.h>
#include <time.h>

#ifdef HAVE_USLEEP
#define SLEEP() usleep(100)
#else
#define SLEEP() sleep(1)
#endif


DECLARATIONS

static int step(sqlite3_stmt *stmt) {
  int ret;
  while( (ret=sqlite3_step(stmt))==SQLITE_BUSY )
    SLEEP();
  return ret;
}

PIKECLASS ResObj
  flags ID_PRIVATE | ID_STATIC;
{
  CVAR struct object *dbobj;
  CVAR struct mapping *bindings;
  CVAR sqlite3 *db;
  CVAR sqlite3_stmt *stmt;
  CVAR int eof;
  CVAR int columns;

  static void ResObj_handle_error(void) {
    /* FIXME: We could use dbobj and remove the db variable. */
    Pike_error("Sql.SQLite: %s\n", sqlite3_errmsg(THIS->db));
  }

  PIKEFUN void create()
    flags ID_STATIC;
  {
    THIS->columns = sqlite3_column_count(THIS->stmt);
  }

  PIKEFUN int num_rows() {
    Pike_error("Sql.SQLite: Number of rows not known in advance.\n");
  }

  PIKEFUN int num_fields() {
    RETURN THIS->columns;
  }

  PIKEFUN int eof() {
    RETURN THIS->eof;
  }

  PIKEFUN array(mapping(string:mixed)) fetch_fields() {
    int i;
    for(i=0; i<THIS->columns; i++) {
      push_constant_text("name");
      push_text(sqlite3_column_name(THIS->stmt, i));
      f_utf8_to_string(1);
      f_aggregate_mapping(2);
    }
    f_aggregate(THIS->columns);
  }

  PIKEFUN void seek(int skip) {
    int i;
    for(i=0; i<skip; i++)
      if( step(THIS->stmt)==SQLITE_DONE ) {
	THIS->eof = 1;
	return;
      }
  }

  PIKEFUN array fetch_row() {
    int i;
    sqlite3_stmt *stmt = THIS->stmt;

    if(THIS->eof) {
      push_int(0);
      return;
    }

    switch( step(stmt) ) {
    case SQLITE_DONE:
      THIS->eof = 1;
      sqlite3_finalize(stmt);
      THIS->stmt = 0;
      push_int(0);
      return;
    case SQLITE_ROW:
      break;
    default:
      ResObj_handle_error();
    }

    for(i=0; i<THIS->columns; i++) {
      push_string( make_shared_binary_string
		   ( sqlite3_column_blob(stmt, i),
		     sqlite3_column_bytes(stmt, i) ) );
      if( sqlite3_column_type(stmt, i)==SQLITE_TEXT )
	f_utf8_to_string(1);
    }
    f_aggregate(THIS->columns);
  }

  INIT {
    THIS->eof = 0;
    THIS->columns = -1;
    THIS->dbobj = NULL;
    THIS->stmt = NULL;
    THIS->bindings = NULL;
  }
  EXIT {
    if(THIS->stmt)
      sqlite3_finalize(THIS->stmt);
    if(THIS->dbobj)
      free_object(THIS->dbobj);
    if(THIS->bindings)
      free_mapping(THIS->bindings);
  }
}

PIKECLASS SQLite
{
  CVAR sqlite3 *db;

  static void SQLite_handle_error(void) {
    Pike_error("Sql.SQLite: %s\n", sqlite3_errmsg(THIS->db));
  }
#define ERR(X) if(X!=SQLITE_OK) SQLite_handle_error()

  /* @decl void create(string path)
   */
  PIKEFUN void create(string path, mixed|void a, mixed|void b, mixed|void c)
    flags ID_STATIC;
  {
    pop_n_elems(args-1);
    f_string_to_utf8(1);
    ERR( sqlite3_open(path->str, &THIS->db) );
    pop_stack();
  }

  PIKEFUN object big_query(string query,
			   mapping(string|int:mixed)|void bindings) {

    struct object *res;
    sqlite3_stmt *stmt;
    const char *tail;
    struct ResObj_struct *store;
    struct pike_string *q;

    if(args==2) stack_swap();
    f_string_to_utf8(1);
    q = Pike_sp[-1].u.string;

    ERR( sqlite3_prepare(THIS->db, q->str, q->len, &stmt, &tail) );
    if( tail[0] )
      Pike_error("Sql.SQLite->big_query: Trailing query data (\"%s\")\n",
		 tail);
    pop_stack();

    res=fast_clone_object(ResObj_program);
    store = OBJ2_RESOBJ(res);
    store->db = THIS->db;
    store->stmt = stmt;

    /* Add a reference to the database to prevent it from being
       destroyed before the query object. */
    store->dbobj = this_object();

    if(bindings) {
      struct mapping_data *md = bindings->data;
      INT32 e;
      struct keypair *k;
      NEW_MAPPING_LOOP(md) {
	int idx;
	switch(k->ind.type) {
	case T_INT:
	  idx = k->ind.u.integer;
	  break;
	case T_STRING:
	  ref_push_string(k->ind.u.string);
	  f_string_to_utf8(1);
	  idx = sqlite3_bind_parameter_index(stmt, Pike_sp[-1].u.string->str);
	  pop_stack();
	  if(!idx)
	    Pike_error("Unknown bind index \"%s\".\n", k->ind.u.string->str);
	  break;
	default:
	  Pike_error("Bind index is not int|string.\n");
	}
	switch(k->val.type) {
	case T_INT:
	  ERR( sqlite3_bind_int64(stmt, idx, k->val.u.integer) );
	  break;
	case T_STRING:
	  {
	    struct pike_string *s = k->val.u.string;
	    switch(s->size_shift) {
	    case 0:
	      ERR( sqlite3_bind_blob(stmt, idx, s->str, s->len,
				     SQLITE_STATIC) );
	      break;
	    case 1:
	    case 2:
	      ref_push_string(s);
	      f_string_to_unicode(1);
	      s = Pike_sp[-1].u.string;
	      ERR( sqlite3_bind_text16(stmt, idx, s->str, s->len,
				       SQLITE_TRANSIENT) );
	      pop_stack();
	      break;
#ifdef PIKE_DEBUG
	    default:
	      Pike_error("Unknown size_shift.\n");
#endif
	    }
	  }
	  break;
	case T_FLOAT:
	  ERR( sqlite3_bind_double(stmt, idx, (double)k->val.u.float_number) );
	  break;
	default:
	  Pike_error("Can only bind string|int|float.\n");
	}
      }

      /* Add a reference so that the bound strings are kept, which in
	 turn allows us to use SQLITE_STATIC. */
      add_ref(bindings);
      store->bindings = bindings;
    }

    apply_low(res, f_ResObj_create_fun_num, 0);
    push_object(res);
  }

  PIKEFUN int changes()
    optflags OPT_EXTERNAL_DEPEND;
  {
    RETURN sqlite3_changes(THIS->db);
  }

  PIKEFUN int total_changes()
    optflags OPT_EXTERNAL_DEPEND;
  {
    RETURN sqlite3_total_changes(THIS->db);
  }

  PIKEFUN void interrupt()
    optflags OPT_SIDE_EFFECT;
  {
    sqlite3_interrupt(THIS->db);
  }

  PIKEFUN string server_info()
    optflags OPT_TRY_OPTIMIZE;
  {
    push_constant_text(sqlite3_libversion());
  }

  PIKEFUN int last_insert_rowid()
    optflags OPT_EXTERNAL_DEPEND;
  {
    RETURN sqlite3_last_insert_rowid(THIS->db);
  }

  PIKEFUN string error()
    optflags OPT_EXTERNAL_DEPEND;
  {
    push_text(sqlite3_errmsg(THIS->db));
    f_utf8_to_string(1);
  }

  PIKEFUN void select_db(string db) {
    Pike_error("This operation is not possible with SQLite.\n");
  }

  PIKEFUN void create_db(string db) {
    Pike_error("This operation is not possible with SQLite.\n");
  }

  PIKEFUN void drop_db(string db) {
    Pike_error("This operation is not possible with SQLite.\n");
  }

  PIKEFUN array(string) list_dbs() {
    Pike_error("This operation is not possible with SQLite.\n");
  }

  PIKEFUN array(string) list_tables()
    optflags OPT_EXTERNAL_DEPEND;
  {
    int err, tbls;
    sqlite3_stmt *stmt;
    ERR( sqlite3_prepare(THIS->db,
			 "SELECT name FROM sqlite_master WHERE type='table'",
			 -1, &stmt, NULL) );
    tbls=0;
    while( (err=step(stmt))==SQLITE_ROW ) {
      push_text( sqlite3_column_text(stmt, 0) );
      f_utf8_to_string(1);
      tbls++;
    }
    sqlite3_finalize(stmt);
    if(err!=SQLITE_DONE) SQLite_handle_error();
    f_aggregate(tbls);
  }

  PIKEFUN array(mapping(string:mixed)) list_fields(string table)
    optflags OPT_EXTERNAL_DEPEND;
  {
    int fields, i;
    sqlite3_stmt *stmt;
    char q[2048];
    struct pike_string *tbl;

    f_string_to_utf8(1);
    tbl = Pike_sp[-1].u.string;
    if(tbl->len > 2047) Pike_error("Table name too long.\n");
    snprintf(q, 2048, "SELECT * FROM %s LIMIT 1", tbl->str);

    ERR( sqlite3_prepare(THIS->db, q, -1, &stmt, NULL) );
    pop_n_elems(args);

    fields = sqlite3_column_count(stmt);

    for(i=0; i<fields; i++) {
      push_constant_text("name");
      push_text(sqlite3_column_name(stmt, i));
      f_utf8_to_string(1);
      push_constant_text("type");
      push_text(sqlite3_column_decltype(stmt, i));
      f_aggregate_mapping(4);
    }
    f_aggregate(fields);
    sqlite3_finalize(stmt);
  }

  /* compile_query */

  INIT {
    THIS->db = NULL;
  }
  EXIT {
    if(THIS->db) {
      int i;
      /* FIXME: sqlite3_close can fail. What do we do then? */
      for(i=0; i<5; i++) {
	if( sqlite3_close(THIS->db)!=SQLITE_OK )
	  SLEEP();
	else
	  break;
      }
    }
  }

}


#endif /* HAVE_SQLITE3_H */

PIKE_MODULE_INIT {
  INIT;
}

PIKE_MODULE_EXIT {
  EXIT;
}

/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/

#include "module.h"
#include "interpret.h"
#include "operators.h"
#include "threads.h"
#include "pike_compiler.h"
#include "module_support.h"

#include "nettle_config.h"

#ifdef HAVE_LIBNETTLE

DECLARATIONS

#include "nettle.h"

#include <nettle/memxor.h>
#include <nettle/aes.h>
#include <nettle/arctwo.h>
#include <nettle/arcfour.h>
#ifdef HAVE_NETTLE_BLOWFISH_DECRYPT
#include <nettle/blowfish.h>
#endif
#ifdef HAVE_NETTLE_CAMELLIA_H
#include <nettle/camellia.h>
#endif
#include <nettle/cast128.h>
#ifdef HAVE_NETTLE_CHACHA_H
#include <nettle/chacha.h>
#endif
#include <nettle/des.h>
#ifdef HAVE_NETTLE_SALSA20_CRYPT
#include <nettle/salsa20.h>
#endif
#ifdef HAVE_NETTLE_SERPENT_DECRYPT
#include <nettle/serpent.h>
#endif
#include <nettle/twofish.h>
#include "idea.h"

#include <nettle/cbc.h>
#include <nettle/ctr.h>

/*! @module Nettle
 */

static struct pike_string *nul13_string = NULL;
static struct pike_string *nul16_string = NULL;

/* Generic callback function for Nettle in case the crypt()
 * function in the object isn't a Nettle function.
 */
static void pike_crypt_func(void *object, pike_nettle_size_t length,
			    uint8_t *dst, const uint8_t *src)
{
  struct pike_string *str;
  push_string(make_shared_binary_string((const char *)src, length));
  apply((struct object *)object, "crypt", 1);
  get_all_args(NULL, 1, "%n", &str);
  if (str->len != (ptrdiff_t)length) {
    Pike_error("Bad string length %ld returned from crypt()\n",
               (long)str->len);
  }
  memcpy(dst, str->str, length);
  pop_stack();
}

#if !defined(HAVE_MEMXOR3) && !defined(memxor3)
/* Really old versions of nettle don't have memxor3().
 *
 * Note that prior to Nettle 3.1 memxor3() didn't have a namespace prefix.
 */
static unsigned char *pike_memxor3(unsigned char *dst, const unsigned char *a,
				   const unsigned char *b, size_t n)
{
  size_t i;
  for(i = 0; i < n; i++) {
    dst[i] = a[i]^b[i];
  }
  return dst;
}

#define memxor3(D, A, B, N)	pike_memxor3((D), (A), (B), (N))
#endif

/* Rotate src left and xor to destination. */
static unsigned char *pike_memrolx(unsigned char *dst, const unsigned char *src,
				   size_t shift, size_t n)
{
  /* FIXME: Could be possibly optimized by reading larger quantities on
   *        big-endian architectures.
   */
  size_t k;

  if (!n) return dst;

  /* Calculate the number of full bytes to rotate. */
  k = (shift >> 3);
  if (k > n) {
    k %= n;
  }
  k = n - k;

  shift = shift & 0x07;
  if (!shift) {
    size_t i = n;
    if (!k || (k == n)) {
      /* Noop rotation. */
      return memxor(dst, src, n);
    }
    while (i--) {
      if (!(k--)) k = n - 1;
      dst[k] ^= src[i];
    }
  } else {
    unsigned char prev_overflow = src[0]>>(8 - shift);
    size_t i = n;
    while (i--) {
      unsigned char next_overflow = src[i]>>(8 - shift);
      if (!(k--)) k = n - 1;
      dst[k] ^= (src[i]<<shift) | prev_overflow;
      prev_overflow = next_overflow;
    }
  }
  return dst;
}

#define memrolx(D, S, L, N)	pike_memrolx((D), (S), (L), (N))

/* Calls Pike_error on errors */
typedef void (*pike_nettle_set_key_func)(void *ctx,
					 ptrdiff_t length, const char *key,
					 /* Force means to use key even if it is weak */
					 int force);

struct pike_cipher
{
  const char *name;

  unsigned context_size;

  unsigned block_size;

  /* Suggested key size; other sizes are sometimes possible. */
  unsigned key_size;

  pike_nettle_set_key_func set_encrypt_key;
  pike_nettle_set_key_func set_decrypt_key;

  pike_nettle_crypt_func encrypt;
  pike_nettle_crypt_func decrypt;
};

#define _PIKE_CIPHER(name, NAME) {		\
  #name,					\
  sizeof(struct name##_ctx),			\
  NAME##_BLOCK_SIZE,				\
  NAME##_KEY_SIZE,				\
  pike_##name##_set_encrypt_key,		\
  pike_##name##_set_decrypt_key,		\
  (pike_nettle_crypt_func) name##_encrypt,	\
  (pike_nettle_crypt_func) name##_decrypt,	\
}

#cmod_define STREAM_MODE	"stream"
#cmod_define BLOCK_MODE		"block"
#cmod_define BLOCK16_MODE	"block16"

/*! @class Cipher
 *!
 *! Represents information about a cipher algorithm, such as
 *! name, key size, and block size.
 */
PIKECLASS Cipher
{
  /*! @decl inherit __builtin.Nettle.Cipher
   */
  INHERIT "__builtin.Nettle.Cipher";

  CVAR const struct pike_cipher *meta;

  DECLARE_STORAGE;

#ifdef PIKE_NULL_IS_SPECIAL
  INIT
  {
    THIS->meta = NULL;
  }
#endif

  /*! @decl string(0..255) name()
   *!
   *! @returns
   *!   A human readable name for the algorithm.
   */
  PIKEFUN string(0..255) name()
    optflags OPT_TRY_OPTIMIZE;
  {
    if (!THIS->meta)
      Pike_error("Cipher not properly initialized.\n");

    push_text(THIS->meta->name);
  }

  /*! @decl int(1..) key_size()
   *!
   *! @returns
   *!   The recommended key size for the cipher.
   */
  PIKEFUN int(1..) key_size()
    optflags OPT_TRY_OPTIMIZE;
  {
    if (!THIS->meta)
      Pike_error("Cipher not properly initialized.\n");

    push_int(THIS->meta->key_size);
  }

  /*! @decl int(1..) block_size()
   *!
   *! @returns
   *!   The block size of the cipher (1 for stream ciphers).
   */
  PIKEFUN int(1..) block_size()
    optflags OPT_TRY_OPTIMIZE;
  {
    if (!THIS->meta)
      Pike_error("Cipher not properly initialized.\n");

    push_int(THIS->meta->block_size);
  }

  /*! @class State
   *!
   *! Base class for cipher contexts.
   */
  PIKECLASS State
    program_flags PROGRAM_USES_PARENT|PROGRAM_NEEDS_PARENT|PROGRAM_CLEAR_STORAGE;
  {
    DOCSTART() @decl inherit Cipher::State
    DOCEND()

    EXTRA
    {
      /* Perform an inherit of the State class (if any) that our parent
       * may contain via its inherit of __builtin.Nettle.Hash.
       */
      lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
    }

    CVAR pike_nettle_crypt_func crypt;
    CVAR void *ctx;
    CVAR int key_size;

    /* FIXME: Create should copy state from the other object, if
     * provided. */

#define GET_INFO()	((struct Nettle_Cipher_struct *)parent_storage(1, Nettle_Cipher_program))

    /*! @decl State set_encrypt_key(string(0..255) key, void|int flags)
     *!
     *! Initializes the object for encryption. The @[key] memory will be
     *! cleared before released.
     *!
     *! @seealso
     *!   @[set_decrypt_key], @[crypt]
     */
    PIKEFUN object set_encrypt_key(string(0..255) key, void|int flags)
      optflags OPT_SIDE_EFFECT;
      rawtype tFunc(tStr8 tOr(tInt, tVoid), tObjImpl_NETTLE_CIPHER_STATE);
    {
      struct Nettle_Cipher_struct *info = GET_INFO();
      assert(info);

      if (!THIS->ctx || !info->meta)
	Pike_error("CipherState not properly initialized.\n");

      NO_WIDE_STRING(key);
      key->flags |= STRING_CLEAR_ON_EXIT;
      info->meta->set_encrypt_key(THIS->ctx, key->len, key->str,
				  flags ? flags->u.integer : 0);

      THIS->crypt = info->meta->encrypt;
      THIS->key_size = key->len;

      RETURN this_object();
    }

    /*! @decl State set_decrypt_key(string(0..255) key, void|int flags)
     *!
     *! Initializes the object for decryption. The @[key] memory will be
     *! cleared before released.
     *!
     *! @seealso
     *!   @[set_encrypt_key], @[crypt]
     */
    PIKEFUN object set_decrypt_key(string(0..255) key, void|int flags)
      optflags OPT_SIDE_EFFECT;
      rawtype tFunc(tStr8 tOr(tInt, tVoid), tObjImpl_NETTLE_CIPHER_STATE);
    {
      struct Nettle_Cipher_struct *info = GET_INFO();
      assert(info);

      if (!THIS->ctx || !info->meta)
	Pike_error("CipherState not properly initialized.\n");

      NO_WIDE_STRING(key);
      key->flags |= STRING_CLEAR_ON_EXIT;
      info->meta->set_decrypt_key(THIS->ctx, key->len, key->str,
				  flags ? flags->u.integer : 0);
      THIS->crypt = info->meta->decrypt;
      THIS->key_size = key->len;

      RETURN this_object();
    }

    /*! @decl string(0..255) make_key()
     *!
     *! Generate a key by calling @[random_string] and initialize this
     *! object for encryption with that key.
     *!
     *! @returns
     *!   The generated key. The key memory will be cleared before
     *!   being released.
     *!
     *! @seealso
     *!   @[set_encrypt_key]
     */
    PIKEFUN string(0..255) make_key()
      optflags OPT_EXTERNAL_DEPEND;
    {
      struct Nettle_Cipher_struct *info = GET_INFO();
      assert(info);

      if (!THIS->ctx || !info->meta)
	Pike_error("CipherState not properly initialized.\n");

      /* NB: Some ciphers (eg Blowfish) have weak keys, for which
       *     set_encrypt_key() will throw an error. We thus need
       *     to retry with a new key on error.
       */
      while(1) {
	JMP_BUF recover;
	if (!SETJMP(recover)) {
	  push_random_string(info->meta->key_size);

	  stack_dup();
	  Pike_sp[-1].u.string->flags |= STRING_CLEAR_ON_EXIT;
	  apply_current(f_Nettle_Cipher_State_set_encrypt_key_fun_num, 1);
	  pop_stack();

	  UNSETJMP(recover);
	  return;
	}
	UNSETJMP(recover);
      }
    }

    /*! @decl string(0..255) crypt(string(0..255) data)
     *!
     *! Encrypts or decrypts data, using the current key. Neither the
     *! input nor output data is automatically memory scrubbed,
     *! unless @[String.secure] has been called on them.
     *!
     *! @param data
     *!   For block ciphers, data must be an integral number of blocks.
     *!
     *! @returns
     *!   The encrypted or decrypted data.
     */
    PIKEFUN string(0..255) crypt (string(0..255) data)
      optflags OPT_EXTERNAL_DEPEND | OPT_SIDE_EFFECT;
    {
      struct Nettle_Cipher_struct *info = GET_INFO();
      struct pike_string *s;
      pike_nettle_crypt_func crypt;
      void *ctx;
      assert(info);

      if (!(ctx = THIS->ctx) || !(crypt = THIS->crypt) || !info->meta)
	Pike_error("CipherState not properly initialized.\n");

      NO_WIDE_STRING(data);

      if (data->len % info->meta->block_size)
	Pike_error("Data must be an integral number of blocks.\n");

      s = begin_shared_string(data->len);
      if (data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) {
	THREADS_ALLOW();
	crypt(ctx, data->len, STR0(s), STR0(data));
	THREADS_DISALLOW();
      } else {
	crypt(ctx, data->len, STR0(s), STR0(data));
      }
      s = end_shared_string(s);
      push_string(s);
    }

    /*! @decl string(0..255) name(void)
     *!
     *! @returns
     *!   A human readable name for the algorithm.
     *!
     *! @note
     *!   The default implementation just calls @[Cipher::name()]
     *!   in the parent.
     */
    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, f_Nettle_Cipher_name_fun_num, args);
    }

    /*! @decl int(1..) key_size(void)
     *!
     *! @returns
     *!   The actual key size for this cipher.
     */
    PIKEFUN int(1..) key_size()
      optflags OPT_TRY_OPTIMIZE;
    {
      RETURN THIS->key_size;
    }

    /*! @decl int(1..) block_size(void)
     *!
     *! @returns
     *!   The block size for this cipher.
     *!
     *! @note
     *!   The default implementation just calls @[Cipher::block_size()]
     *!   in the parent.
     */
    PIKEFUN int(1..) block_size()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, f_Nettle_Cipher_block_size_fun_num, args);
    }

#ifdef PIKE_NULL_IS_SPECIAL
    INIT
    {
      THIS->ctx = NULL;
      THIS->crypt = NULL;
      THIS->key_size = 0;
    }
#endif

    EXIT
    {
      if (THIS->ctx && Pike_fp->current_object->prog)
      {
	struct Nettle_Cipher_struct *info = GET_INFO();
	if (info && info->meta) {
	  memset(THIS->ctx, 0, info->meta->context_size);
	}
      }
    }
  }
  /*! @endclass State
   */
}

/*! @endclass Cipher
 */

/*! @class BufferedCipher
 *!
 *! Extends the @[Cipher] class with the @[Buffer]
 *! meta cipher. This is in turn inherited by the
 *! @[BlockCipher] class, which is the base class
 *! for all block ciphers.
 */
PIKECLASS BufferedCipher
{
  /* NOTE: MUST be first in the class to simplify access to symbols
   *       in Cipher!
   */
  /*! @decl inherit Cipher
   */
  INHERIT Cipher;

#define PAD_SSL        0
#define PAD_ISO_10126  1
#define PAD_ANSI_X923  2
#define PAD_PKCS7      3
#define PAD_ZERO       4
#define PAD_TLS        5

  /*! @module Buffer
   *! Acts as a buffer so that data can be fed to the cipher in blocks
   *! that don't correspond to cipher block sizes.
   *!
   *! @example
   *!   class Encrypter
   *!   {
   *!     protected Crypto.Cipher buffer;
   *!
   *!     void create(string key)
   *!     {
   *!       buffer = Crypto.AES.CBC.Buffer();
   *!       buffer->set_encrypt_key(key);
   *!     }
   *!
   *!     string feed(string data)
   *!     {
   *!       return buffer->crypt(data);
   *!     }
   *!
   *!     string drain()
   *!     {
   *!       return buffer->pad(Crypto.PAD_PKCS7);
   *!     }
   *!   }
   *!
   *! @seealso
   *!   @[BlockCipher.CBC], @[BlockCipher16.GCM]
   */
  PIKEVAR object(Nettle_BufferedCipher_cq__Buffer) Buffer;

  PIKECLASS _Buffer
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit __builtin.Nettle.Cipher
     */
    INHERIT "__builtin.Nettle.Cipher";

    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, f_Nettle_Cipher_name_fun_num, args);
      push_constant_text(".Buffer");
      f_add(2);
    }

    PIKEFUN int(1..) block_size()
    {
      apply_external(1, f_Nettle_Cipher_block_size_fun_num, args);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1, f_Nettle_Cipher_key_size_fun_num, args);
    }

    PIKEFUN int(0..) iv_size()
    {
      apply_external(1, f_Nettle_Cipher_block_size_fun_num, args);
    }

    /*! @class State
     *! Acts as a buffer so that data can be fed to the cipher in blocks
     *! that don't correspond to cipher block sizes.
     *!
     *! @example
     *!   class Encrypter
     *!   {
     *!     protected Crypto.Cipher buffer;
     *!
     *!     void create(string key)
     *!     {
     *!       buffer = Crypto.AES.CBC.Buffer();
     *!       buffer->set_encrypt_key(key);
     *!     }
     *!
     *!     string feed(string data)
     *!     {
     *!       return buffer->crypt(data);
     *!     }
     *!
     *!     string drain()
     *!     {
     *!       return buffer->pad(Crypto.PAD_PKCS7);
     *!     }
     *!   }
     *!
     *! @seealso
     *!   @[BlockCipher.CBC], @[BlockCipher16.GCM]
     */
    PIKECLASS State
      program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT|PROGRAM_CLEAR_STORAGE;
    {
      CVAR struct object *object;
      CVAR int block_size;
      CVAR unsigned char *backlog;
      CVAR int backlog_len;

#ifdef PIKE_NULL_IS_SPECIAL
      INIT {
	THIS->object = NULL;
	THIS->block_size = 0;
	THIS->backlog = NULL;
	THIS->backlog_len = 0;
      }
#endif

      EXIT
	gc_trivial;
      {
	if(THIS->backlog) {
          secure_zero(THIS->backlog, THIS->block_size);
	  free(THIS->backlog);
        }
        if(THIS->object)
        {
          free_object(THIS->object);
          THIS->object = NULL;
        }
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
	flags ID_PROTECTED;
      {
	apply_external(2, Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       *!
       *! Initialize the buffer with the @[Cipher::State] object
       *! returned by @[substate_factory()]. This is usually
       *! the State for the cipher implemented in the parent module.
       */
      PIKEFUN void create()
	flags ID_PROTECTED;
      {
	struct object *o;
	int block_size;
	int f;

	exit_Nettle_BufferedCipher_cq__Buffer_State_struct();

	apply_current(f_Nettle_BufferedCipher_cq__Buffer_State_substate_factory_fun_num,
		      0);

	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  Pike_error("Unsupported return value from Cipher::State().\n");
	}
	o = Pike_sp[-1].u.object;
	if (!o->prog) {
	  Pike_error("Cipher::State() returned destructed object.\n");
	}

	f = find_identifier("crypt", o->prog);
	if (f < 0) {
	  Pike_error("State object has no crypt() function.\n");
	}

	apply(o, "block_size", 0);

	if(TYPEOF(Pike_sp[-1]) != T_INT)
	  Pike_error("block_size() didn't return an int.\n");

	block_size = Pike_sp[-1].u.integer;

	if ((!block_size) || (block_size > 4096))
	  Pike_error("Bad block size %d.\n", block_size);

	THIS->block_size = block_size;
	THIS->backlog = xcalloc(1, block_size);
	THIS->backlog_len = 0;

        add_ref(THIS->object = o);
        pop_n_elems(2);
      }

      /*! @decl string(0..255) name()
       *! Returns the name of the wrapped cipher with @expr{".Buffer"@}
       *! appended.
       */
      PIKEFUN string(0..255) name()
	optflags OPT_TRY_OPTIMIZE;
      {
	apply(THIS->object, "name", 0);
	push_constant_text(".Buffer");
	f_add(2);
      }

      /*! @decl int(1..) block_size()
       *!
       *! Get the block size of the contained block crypto.
       */
      PIKEFUN int(1..) block_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl int(1..) key_size()
       *!
       *! Get the key size of the contained block crypto.
       */
      PIKEFUN int(1..) key_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
	apply(THIS->object, "key_size", args);
      }

      /*! @decl int(0..) iv_size()
       *!
       *! Get the iv size of the contained block crypto.
       */
      PIKEFUN int(0..) iv_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
	apply(THIS->object, "iv_size", args);
      }

      /*! @decl this_program set_encrypt_key(string(0..255) key, @
       *!                                    void|int flags)
       *!
       *! Set the encryption key. The @[key] memory will be cleared before
       *! released.
       *!
       *! @note
       *!   As a side-effect any buffered data will be cleared.
       */
      PIKEFUN object set_encrypt_key(string(0..255) key, void|int flags)
	optflags OPT_SIDE_EFFECT;
      {
	THIS->backlog_len = 0;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();
	push_object(this_object());
      }

      /*! @decl this_program set_decrypt_key(string(0..255) key, @
       *!                                    void|int flags)
       *!
       *! Set the decryption key. The @[key] memory will be cleared before
       *! released.
       *!
       *! @note
       *!   As a side-effect any buffered data will be cleared.
       */
      PIKEFUN object set_decrypt_key(string(0..255) key, void|int flags)
	optflags OPT_SIDE_EFFECT;
      {
	THIS->backlog_len = 0;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_decrypt_key", args);
	pop_stack();
	push_object(this_object());
      }

      /*! @decl string(0..255) crypt(string(0..255) data)
       *!
       *! Encrypt or decrypt some data.
       *!
       *! Adds data to be en/decrypted to the buffer. If there's enough
       *! data to en/decrypt a block, that will be done, and the result
       *! returned. Any unprocessed data will be left in the buffer.
       *!
       *! Neither the input or output data is not automatically memory
       *! scrubbed, unless @[String.secure] has been called on the data.
       */
      PIKEFUN string(0..255) crypt(string(0..255) data) {
	ptrdiff_t strings = 0;
	ptrdiff_t soffset = 0;
	ptrdiff_t len;

	if (THIS->backlog_len) {
	  if (data->len >= (THIS->block_size - THIS->backlog_len)) {
	    memcpy(THIS->backlog + THIS->backlog_len, data->str,
		   (THIS->block_size - THIS->backlog_len));
	    soffset += (THIS->block_size - THIS->backlog_len);
	    THIS->backlog_len = 0;
	    push_string(make_shared_binary_string((char *)THIS->backlog,
						  THIS->block_size));
	    apply(THIS->object, "crypt", 1);
	    if (TYPEOF(Pike_sp[-1]) != T_STRING)
	      Pike_error("crypt() did not return string\n");
	    if (Pike_sp[-1].u.string->len != THIS->block_size)
	      Pike_error("Unexpected string length %ld\n",
                         (long)Pike_sp[-1].u.string->len);
	    strings++;
	  } else {
	    memcpy(THIS->backlog + THIS->backlog_len,
		   data->str, data->len);
	    THIS->backlog_len += data->len;
	    pop_n_elems(args);
	    push_empty_string();
	    return;
	  }
	}

	len = (data->len - soffset);
	len -= len % THIS->block_size;

	if (len) {
	  push_string( string_slice( data, soffset, len ) );
	  soffset += len;

	  apply(THIS->object, "crypt", 1);

	  if (TYPEOF(Pike_sp[-1]) != T_STRING)
	    Pike_error("crypt() did not return string.\n");
	  if (Pike_sp[-1].u.string->len != len)
	    Pike_error("crypt() Unexpected string length %ld.\n",
                       (long)Pike_sp[-1].u.string->len);

	  strings++;
	}

	if (soffset < data->len) {
	  memcpy(THIS->backlog, data->str + soffset, data->len - soffset);
	  THIS->backlog_len = data->len - soffset;
	}

	if( !strings )
	  push_empty_string();
	else if( strings > 1 )
	  f_add( strings );

	stack_pop_n_elems_keep_top(args);
      }

      /*! @decl string(0..255) pad(void|int method)
       *!
       *! Pad and encrypt any data left in the buffer. The output data is
       *! not automatically memory scrubbed, unless @[String.secure] is
       *! called on the data.
       *!
       *! @param method
       *! The type of padding to apply to the buffer.
       *! @int
       *!   @value Crypto.PAD_ISO_10126
       *!     Pads according to ISO 10126, which means filling all extra
       *!     space with random data and putting the size of the
       *!     non-payload data last.
       *!   @value Crypto.PAD_TLS
       *!   @value Crypto.PAD_SSL
       *!     Pads according to @rfc{5246:6.2.3.2@}, meaning that all
       *!     extra space is filled with the size of the padding. Note
       *!     that this size has an off by one difference to the other
       *!     schemas, so 0 means 1 byte of padding.
       *!   @value Crypto.PAD_ANSI_X923
       *!     Pads according to ANSI X.923, which means filling all extra
       *!     space with zero and putting the size of the non-payload data
       *!     last.
       *!   @value Crypto.PAD_PKCS7
       *!     Pads according to PKCS7 / @rfc{3852@}, which means
       *!     filling all extra space with the size of the extra
       *!     space.
       *!   @value Crypto.PAD_ZERO
       *!     Fills the extra space with null bytes. To correctly remove
       *!     the padding the clear text data must not end with a null
       *!     byte. In that case the data would have to be manually
       *!     padded/unpadded before/after calling @[crypt()].
       *! @endint
       *! Defaults to Crypto.PAD_SSL for compatibility reasons.
       *!
       *! @seealso
       *!   @[unpad()]
       */
      PIKEFUN string(0..255) pad(void|int method) {
	ptrdiff_t i;
        int m = PAD_SSL;
	int size = THIS->block_size - THIS->backlog_len;

	if(method)
	{
	  if(TYPEOF(*method) != PIKE_T_INT)
	    Pike_error("Bad argument type.\n");
	  m = method->u.integer;
        }

	switch(m)
	{
	case PAD_SSL:
	case PAD_TLS:
	  size--;
	  break;
	case PAD_ZERO:
	  if( THIS->backlog_len>0 &&
	      THIS->backlog[THIS->backlog_len-1] == 0 )
	    Pike_error("Using zero padding on a zero terminated string.\n");
	  size = 0;
	  break;
	}

        if( m == PAD_ISO_10126 )
        {
          push_random_string(THIS->block_size-THIS->backlog_len);
        }

	for (i = THIS->backlog_len; i < THIS->block_size - 1; i++)
	  switch(m)
	  {
	  default:
	    Pike_error("Unknown method.\n");
	  case PAD_SSL:
	  case PAD_TLS:
	    /* TLS 1.1 and forward */
	    THIS->backlog[i] = size;
	    break;
	  case PAD_ISO_10126:
	    /* ISO 10126 */
            THIS->backlog[i] = (unsigned char)Pike_sp[-1].u.string->str[i-THIS->backlog_len];
	    break;
	  case PAD_ANSI_X923:
	    /* ANSI X.923 */
	    THIS->backlog[i] = 0;
	    break;
	  case PAD_PKCS7:
	    /* PKCS7 / RFC 3852 */
            THIS->backlog[i] = (unsigned char)size;
	    break;
	  case PAD_ZERO:
	    /* Null only */
	    THIS->backlog[i] = 0;
	    break;
	  }

        THIS->backlog[THIS->block_size - 1] = (unsigned char)size;
	push_string(make_shared_binary_string((const char *)THIS->backlog, THIS->block_size));

	THIS->backlog_len = 0;

	apply(THIS->object, "crypt", 1);
      }

      /*! @decl string(0..255) unpad(string(0..255) data, void|int method)
       *!
       *! Decrypt and unpad a block of data. Neither the input or output
       *! data is not automatically memory scrubbed, unless
       *! @[String.secure] has been called on the data.
       *!
       *! This performs the reverse operation of @[pad()]. The padding
       *! will be verified to be correct, if possible. If not, zero is
       *! returned.
       *!
       *! @param method
       *! The type of padding that was applied to the original buffer.
       *! @int
       *!   @value Crypto.PAD_SSL
       *!   @value Crypto.PAD_TLS
       *!   @value Crypto.PAD_ISO_10126
       *!   @value Crypto.PAD_ANSI_X923
       *!   @value Crypto.PAD_PKCS7
       *!   @value Crypto.PAD_ZERO
       *! @endint
       *! Defaults to Crypto.PAD_SSL for compatibility reasons.
       *!
       *! @seealso
       *!   @[pad()]
       */
      PIKEFUN string(0..255) unpad(string(0..255) str, void|int method) {
	ptrdiff_t len, bytes;
	int m = 0, i, invalid = 0, padding=0;

	len = str->len + THIS->backlog_len;
	if( len % THIS->block_size)
	  Pike_error("Total data size must be integral numbers of blocks.\n");

	if( method!=NULL )
	{
	  m = method->u.integer;
	  pop_stack();
	  args--;
	}

	f_Nettle_BufferedCipher_cq__Buffer_State_crypt(1);
	if (TYPEOF(Pike_sp[-1]) != T_STRING)
	  Pike_error("crypt() did not return string.\n");
	if (Pike_sp[-1].u.string->len != len)
	  Pike_error("crypt() Unexpected string length %ld.\n",
                     (long)Pike_sp[-1].u.string->len);
	str = Pike_sp[-1].u.string;

	bytes = STR0(str)[len - 1];
	if( m==PAD_SSL || m==PAD_TLS ) bytes++;

	/* FIXME: Shouldn't this be supported? */
	if (bytes > str->len)
          Pike_error("Invalid padding (%ld > %ld)\n",
                     (long)bytes, (long)str->len);

	switch( m )
	{
	default:
	  Pike_error("Unknown method.\n");
	case PAD_ISO_10126:
	case PAD_ZERO:
	case PAD_SSL:
	  break;
	case PAD_ANSI_X923:
	  padding = 0;
	  goto do_check;
	case PAD_TLS:
	  padding = bytes-1;
	  goto do_check;
	case PAD_PKCS7:
	  padding = bytes;
	do_check:
	  /* Try to be constant time here. */
	  invalid = 1;
	  for(i=len-256; i<len-1; i++) {
	    if (i < 0) i = 0;
	    if (i == len-bytes) invalid = 0;
	    invalid |= (STR0(str)[i] ^ padding);
	  }
	  /* NB: If bytes <= 1 the loop will terminate before the
	   *     case where invalid is reset to zero is reached.
	   */
	  if (bytes <= 1) invalid = 0;
	  break;
	}

	if( m == PAD_ZERO )
	{
	  int c=THIS->block_size;
	  while( str->str[len-1]==0 && c>0 )
	  {
	    c--;
	    len--;
	  }
	}
	else
	  len -= bytes;

	if (len < 0)
	  Pike_error("String too short to unpad\n");

	add_ref(str);
	pop_stack();
	push_string(make_shared_binary_string(str->str, len));
	free_string(str);
	if( invalid )
	{
	  pop_stack();
	  push_int(0);
	}
      }

      /*! @decl this_program set_iv(string(0..255) iv)
       *! Set the initialization vector to @[iv].
       */
      PIKEFUN object set_iv(string(0..255) iv)
	optflags OPT_SIDE_EFFECT;
      {
	apply(THIS->object, "set_iv", args);
	args = 1;
	RETURN this_object();
      }
    }
    /*! @endclass State
     */

    /*! @decl State `()()
     *!
     *! @returns
     *!   Returns a new @[State] object.
     */
    PIKEFUN Nettle_BufferedCipher_cq__Buffer_State `()()
    {
      apply_current(Nettle_BufferedCipher_cq__Buffer_State_program_fun_num,
		    args);
    }

  }
  /*! @endmodule Buffer
   */

  INIT
  {
    apply_current(Nettle_BufferedCipher_cq__Buffer_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BUFFEREDCIPHER->Buffer = Pike_sp[-1].u.object);
    }
    pop_stack();
  }
}
/*! @endclass BufferedCipher */

#define BUFFEREDCIPHER_CIPHER_INHERIT	1

/*! @class BlockCipher
 *!
 *! Base class for all block ciphers.
 *!
 *! Extends the @[BufferedCipher] class with various operating modes.
 */
PIKECLASS BlockCipher
{
  /*! @decl inherit __builtin.Nettle.BlockCipher
   */
  INHERIT "__builtin.Nettle.BlockCipher";

  /*! @decl inherit BufferedCipher
   */
  INHERIT BufferedCipher;

  /*! @module CBC
   *! Implementation of the Cipher Block Chaining mode (CBC).
   *!
   *! Works as a wrapper for the cipher implemented by overloading
   *! the parent class (@[Cipher]).
   *!
   *! @seealso
   *!   @[Crypto.CBC], @[GCM]
   */
  PIKEVAR object(Nettle_BlockCipher_cq__CBC) CBC;

  PIKECLASS _CBC
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit BufferedCipher
     */
    INHERIT BufferedCipher;

    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_name_fun_num, args);
      push_constant_text(".CBC");
      f_add(2);
    }

    PIKEFUN int(1..) block_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_key_size_fun_num, args);
    }

    PIKEFUN int(0..) iv_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
    }

    /*! @class State
     */
    PIKECLASS State
      program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
    {
      DOCSTART() @decl inherit Cipher::State
	DOCEND()

      EXTRA
      {
	/* Perform an inherit of the State class that our parent
	 * contains via its inherit of Cipher via BufferedCipher.
	 */
        lexical_inherit(1, MK_STRING("State"), 0, REPORT_ERROR, NULL);
      }

      PIKEVAR object object
	flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *crypt_state;
      CVAR struct pike_string *iv;	/* NB: Not finished. */
      CVAR INT32 block_size;
      CVAR INT32 mode;

      EXIT
	gc_trivial;
      {
        if(THIS->iv)
	  free_string(THIS->iv);
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
	flags ID_PROTECTED;
      {
	apply_external(2,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		       Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       *!
       *! Initialize the CBC state with the @[Cipher::State] object
       *! returned by @[substate_factory()]. This is usually
       *! the State for the cipher implemented in the parent module.
       */
      PIKEFUN void create()
	flags ID_PROTECTED;
      {
	struct object *o;
	struct inherit *inh;
	unsigned old_block_size = THIS->block_size;
	unsigned block_size;
	int f;

	apply_current(f_Nettle_BlockCipher_cq__CBC_State_substate_factory_fun_num,
		      0);

	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  Pike_error("Unsupported return value from Cipher::State().\n");
	}
	o = Pike_sp[-1].u.object;
	if (!o->prog) {
	  Pike_error("Cipher::State() returned destructed object.\n");
	}

	f = find_identifier("crypt", o->prog);
	if (f < 0) {
	  Pike_error("State object has no crypt() function.\n");
	}

	apply(o, "block_size", 0);

	if(TYPEOF(Pike_sp[-1]) != T_INT)
	  Pike_error("block_size() didn't return an int.\n");

	block_size = Pike_sp[-1].u.integer;

	if ((!block_size) || (block_size > 4096))
	  Pike_error("Bad block size %d.\n", block_size);

	if(THIS->iv) {
	  free_string(THIS->iv);
	  THIS->iv = NULL;
	}

	THIS->block_size = block_size;

	THIS->iv = begin_shared_string(block_size);
	memset(STR0(THIS->iv), 0, block_size);
	THIS->iv->flags |= STRING_CLEAR_ON_EXIT;

	if (THIS->object) free_object(THIS->object);
	add_ref(THIS->object = o);

	inh = INHERIT_FROM_INT(o->prog, f);
	if (inh->prog == Nettle_Cipher_State_program) {
	  /* crypt() is from Nettle.Cipher.State.
	   * Check if the context and crypt function are valid.
	   */
	  THIS->crypt_state = (struct Nettle_Cipher_State_struct *)
	    get_inherit_storage(o, inh - o->prog->inherits);
	} else {
	  THIS->crypt_state = NULL;
        }
        pop_n_elems(2);
      }

      /*! @decl string(0..255) name()
       *! Returns the string @expr{"CBC(x)"@} where x is the
       *! encapsulated algorithm.
       */
      PIKEFUN string(0..255) name()
	optflags OPT_TRY_OPTIMIZE;
      {
	push_static_text("CBC(");
	apply(THIS->object, "name", 0);
	push_static_text(")");
	f_add(3);
      }

      /*! @decl int(1..) block_size()
       *! Returns the block size of the encapsulated cipher.
       */
      PIKEFUN int(1..) block_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl int(1..) key_size()
       *! Returns the key size of the encapsulated cipher.
       */
      PIKEFUN int(1..) key_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
	apply(THIS->object, "key_size", args);
      }

      /*! @decl int(1..) iv_size()
       *! Returns the size for the initialization vector
       */
      PIKEFUN int(1..) iv_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl this_program set_encrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for encrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       */
      PIKEFUN object set_encrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	assert(THIS->block_size);
	THIS->mode = 0;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();
	push_object(this_object());
      }

      /*! @decl this_program set_decrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for decrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       */
      PIKEFUN object set_decrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	assert(THIS->block_size);
	THIS->mode = 1;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_decrypt_key", args);
	pop_stack();
	push_object(this_object());
      }

      /*! @decl this_program set_iv(string(0..255) iv)
       *!
       *! Set the initialization vector to @[iv]. The @[iv] memory will be
       *! cleared before released.
       */
      PIKEFUN object set_iv(string(0..255) iv)
	optflags OPT_SIDE_EFFECT;
      {
	assert(THIS->iv);
	iv->flags |= STRING_CLEAR_ON_EXIT;
	NO_WIDE_STRING(iv);
	if(iv->len != THIS->block_size)
	  Pike_error("Argument incompatible with cipher block size.\n");
	memcpy(STR0(THIS->iv), STR0(iv), THIS->block_size);
	RETURN this_object();
      }

      /*! @decl string(0..255) crypt(string(0..255) data)
       *!
       *! Encrypt/decrypt @[data] and return the result. @[data] must
       *! be an integral number of blocks.
       *!
       *! Neither the input or output data is not automatically memory
       *! scrubbed, unless @[String.secure] has been called on the data.
       */
      PIKEFUN string(0..255) crypt(string(0..255) data)
      {
	struct pike_string *result;
	ONERROR uwp;
        pike_nettle_crypt_func func = (pike_nettle_crypt_func)pike_crypt_func;
	void *ctx = THIS->object;
	struct pike_string *iv = THIS->iv;
	int block_size = THIS->block_size;

	NO_WIDE_STRING(data);

	if(data->len % block_size)
	  Pike_error("Data length not multiple of block size.\n");

	if (!THIS->object || !THIS->object->prog) {
	  Pike_error("Lookup in destructed object.\n");
	}

	result = begin_shared_string(data->len);
	SET_ONERROR (uwp, do_free_string, result);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	if(THIS->mode == 0) {
	  if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	      (func != pike_crypt_func)) {
	    /* Protect the iv from being freed by a different thread. */
	    add_ref(iv);
	    THREADS_ALLOW();
            cbc_encrypt(ctx, (pike_nettle_cipher_func)func,
                        block_size, STR0(iv),
			data->len, STR0(result), STR0(data));
	    THREADS_DISALLOW();
	    free_string(iv);
	  } else {
            cbc_encrypt(ctx, (pike_nettle_cipher_func)func,
                        block_size, STR0(iv),
			data->len, STR0(result), STR0(data));
	  }
	}
	else {
	  if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	      (func != pike_crypt_func)) {
	    /* Protect the iv from being freed by a different thread. */
	    add_ref(iv);
	    THREADS_ALLOW();
            cbc_decrypt(ctx, (pike_nettle_cipher_func)func,
                        block_size, STR0(iv),
			data->len, STR0(result), STR0(data));
	    THREADS_DISALLOW();
	    free_string(iv);
	  } else {
            cbc_decrypt(ctx, (pike_nettle_cipher_func)func,
                        block_size, STR0(iv),
			data->len, STR0(result), STR0(data));
	  }
	}

	pop_n_elems(args);
	push_string(end_shared_string(result));
	UNSET_ONERROR(uwp);
      }
    }
    /*! @endclass State
     */
  }
  /*! @endmodule CBC
   */

  /*! @module PCBC
   *! Implementation of the Propagating Cipher Block Chaining mode (PCBC).
   *!
   *! This mode is also known as plaintext cipher block chaining (from
   *! Kerberos v4).
   *!
   *! Works as a wrapper for the cipher implemented by overloading
   *! the parent class (@[Cipher]).
   *!
   *! @seealso
   *!   @[CBC], @[GCM]
   */
  PIKEVAR object(Nettle_BlockCipher_cq__PCBC) PCBC;

  PIKECLASS _PCBC
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit CBC
     */
    static int f_pcbc_inh_cbc_state_program_fun_num = -1;

    EXTRA
    {
      low_inherit(Nettle_BlockCipher_cq__CBC_program, 0,
		  Nettle_BlockCipher_cq__CBC_program_fun_num,
		  42 + 1,
                  0, NULL, NULL);
      f_pcbc_inh_cbc_state_program_fun_num =
	really_low_reference_inherited_identifier(NULL, 1,
		    Nettle_BlockCipher_cq__CBC_State_program_fun_num);
    }

    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_name_fun_num, args);
      push_constant_text(".PCBC");
      f_add(2);
    }

    /*! @class State
     */
    PIKECLASS State
      program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
    {
      DOCSTART() @decl inherit CBC::State
	DOCEND()

      static int f_pcbc_state_inh_cbc_state_crypt_fun_num = -1;

      EXTRA
      {
	low_inherit(Nettle_BlockCipher_cq__CBC_State_program, 0,
		    f_pcbc_inh_cbc_state_program_fun_num,
		    42 + 1,
                    0, NULL, NULL);

	/* We want to call some of our inherited functions recursively... */
	f_pcbc_state_inh_cbc_state_crypt_fun_num =
	  really_low_reference_inherited_identifier(NULL, 1,
		    f_Nettle_BlockCipher_cq__CBC_State_crypt_fun_num);
      }

      /*! @decl string(0..255) name()
       *! Returns the string @expr{"PCBC(x)"@} where x is the
       *! encapsulated algorithm.
       */
      PIKEFUN string(0..255) name()
	optflags OPT_TRY_OPTIMIZE;
      {
	struct Nettle_BlockCipher_cq__CBC_State_struct *cbc_state =
	  get_inherited_storage(1, Nettle_BlockCipher_cq__CBC_State_program);

	push_constant_text("PCBC(");
	apply(cbc_state->object, "name", 0);
	push_constant_text(")");
	f_add(3);
      }

      /*! @decl string(0..255) crypt(string(0..255) data)
       *!
       *! Encrypt/decrypt @[data] and return the result. @[data] must
       *! be an integral number of blocks.
       *!
       *! Neither the input nor the output data is automatically memory
       *! scrubbed, unless @[String.secure] has been called on the data.
       */
      PIKEFUN string(0..255) crypt(string(0..255) data)
      {
	struct Nettle_BlockCipher_cq__CBC_State_struct *cbc_state =
	  get_inherited_storage(1, Nettle_BlockCipher_cq__CBC_State_program);

	struct pike_string *propagated;
	int block_size = cbc_state->block_size;

	NO_WIDE_STRING(data);

	if(data->len % block_size) {
	  Pike_error("Data length not multiple of block size.\n");
	}

	if (!cbc_state->object || !cbc_state->object->prog) {
	  Pike_error("Lookup in destructed object.\n");
	}

	if (!data->len) {
	  return;
	}

	if (cbc_state->mode == 0) {
	  propagated = begin_shared_string(data->len);
	  memcpy(STR0(propagated), STR0(data), block_size);
	  if (data->len > block_size) {
	    memxor3(STR0(propagated) + block_size, STR0(data) + block_size,
		    STR0(data), data->len - block_size);
	  }

	  pop_stack();
	  push_string(propagated);	/* NB: Not shared! */

	  apply_current(f_pcbc_state_inh_cbc_state_crypt_fun_num, 1);

	  /* Update the iv with the last block of the plaintext. */
	  memxor(STR0(cbc_state->iv), STR0(data) + data->len - block_size,
		 block_size);
	} else {
	  ptrdiff_t offset;

	  apply_current(f_pcbc_state_inh_cbc_state_crypt_fun_num, 1);

	  data = Pike_sp[-1].u.string;

	  if (data->len == block_size) {
	    memxor(STR0(cbc_state->iv), STR0(data), block_size);
	    return;
	  }

	  propagated = begin_shared_string(data->len);
	  memcpy(STR0(propagated), STR0(data), block_size);

	  for(offset = block_size; offset < data->len; offset += block_size) {
	    memxor3(STR0(propagated) + offset, STR0(data) + offset,
		    STR0(propagated) + offset - block_size, block_size);
	  }
	  memxor(STR0(cbc_state->iv),
		 STR0(propagated) + offset - block_size, block_size);

	  pop_stack();
	  push_string(end_shared_string(propagated));
	}
      }
    }
    /*! @endclass State
     */
  }
  /*! @endmodule PCBC
   */

  /*! @module IGE
   *! Implementation of the Infinite Garble Extension mode (IGE).
   *!
   *! This is a mode of operation suggested in 1977 by C. Cambell.
   *!
   *! @seealso
   *!   @[CBC], @[GCM], @[CFB]
   */
  PIKEVAR object(Nettle_Cipher) IGE;

  PIKECLASS _IGE
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit BufferedCipher
     */
    INHERIT BufferedCipher;

    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_name_fun_num, args);
      push_constant_text(".IGE");
      f_add(2);
    }

    PIKEFUN int(1..) block_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_key_size_fun_num, args);
    }

    PIKEFUN int(0..) iv_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
      push_int(2);
      f_multiply(2);
    }

    /*! @class State
     */
    PIKECLASS State
      program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
    {
      DOCSTART() @decl inherit Cipher::State
	DOCEND()

      EXTRA
      {
	/* Perform an inherit of the State class that our parent
	 * contains via its inherit of Cipher via BufferedCipher.
	 */
        lexical_inherit(1, MK_STRING("State"), 0, REPORT_ERROR, NULL);
      }

      PIKEVAR object object
	flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *crypt_state;
      CVAR struct pike_string *iv;	/* NB: Not finished. */
      CVAR INT32 block_size;		/* NB: iv size is twice this. */
      CVAR INT32 mode;

      EXIT
	gc_trivial;
      {
        if(THIS->iv)
	  free_string(THIS->iv);
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
	flags ID_PROTECTED;
      {
	apply_external(2,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		       Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       *!
       *! Initialize the IGE state with the @[Cipher::State] object
       *! returned by @[substate_factory()]. This is usually
       *! the State for the cipher implemented in the parent module.
       */
      PIKEFUN void create()
	flags ID_PROTECTED;
      {
	struct object *o;
	struct inherit *inh;
	unsigned old_block_size = THIS->block_size;
	unsigned block_size;
	int f;

	apply_current(f_Nettle_BlockCipher_cq__IGE_State_substate_factory_fun_num,
		      0);

	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  Pike_error("Unsupported return value from Cipher::State().\n");
	}
	o = Pike_sp[-1].u.object;
	if (!o->prog) {
	  Pike_error("Cipher::State() returned destructed object.\n");
	}

	f = find_identifier("crypt", o->prog);
	if (f < 0) {
	  Pike_error("State object has no crypt() function.\n");
	}

	apply(o, "block_size", 0);

	if(TYPEOF(Pike_sp[-1]) != T_INT)
	  Pike_error("block_size() didn't return an int.\n");

	block_size = Pike_sp[-1].u.integer;

	if ((!block_size) || (block_size > 4096))
	  Pike_error("Bad block size %d.\n", block_size);

	if(THIS->iv) {
	  free_string(THIS->iv);
	  THIS->iv = NULL;
	}

	THIS->block_size = block_size;

	THIS->iv = begin_shared_string(block_size * 2);
	memset(STR0(THIS->iv), 0, block_size * 2);
	THIS->iv->flags |= STRING_CLEAR_ON_EXIT;

	if (THIS->object) free_object(THIS->object);
	add_ref(THIS->object = o);

	inh = INHERIT_FROM_INT(o->prog, f);
	if (inh->prog == Nettle_Cipher_State_program) {
	  /* crypt() is from Nettle.Cipher.State.
	   * Check if the context and crypt function are valid.
	   */
	  THIS->crypt_state = (struct Nettle_Cipher_State_struct *)
	    get_inherit_storage(o, inh - o->prog->inherits);
	} else {
	  THIS->crypt_state = NULL;
        }
        pop_n_elems(2);
      }

      /*! @decl string(0..255) name()
       *! Returns the string @expr{"IGE(x)"@} where x is the
       *! encapsulated algorithm.
       */
      PIKEFUN string(0..255) name()
	optflags OPT_TRY_OPTIMIZE;
      {
	push_static_text("IGE(");
	apply(THIS->object, "name", 0);
	push_static_text(")");
	f_add(3);
      }

      /*! @decl int(1..) block_size()
       *! Returns the block size of the encapsulated cipher.
       */
      PIKEFUN int(1..) block_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl int(1..) key_size()
       *! Returns the key size of the encapsulated cipher.
       */
      PIKEFUN int(1..) key_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
	apply(THIS->object, "key_size", args);
      }

      /*! @decl int(1..) iv_size()
       *! Returns the size for the initialization vector
       */
      PIKEFUN int(1..) iv_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size * 2;
      }

      /*! @decl this_program set_encrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for encrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       */
      PIKEFUN object set_encrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	assert(THIS->block_size);
	THIS->mode = 0;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();
	push_object(this_object());
      }

      /*! @decl this_program set_decrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for decrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       */
      PIKEFUN object set_decrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	assert(THIS->block_size);
	THIS->mode = 1;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_decrypt_key", args);
	pop_stack();
	push_object(this_object());
      }

      /*! @decl this_program set_iv(string(0..255) iv)
       *!
       *! Set the initialization vector to @[iv]. The @[iv] memory will be
       *! cleared before released.
       *!
       *! @note
       *!   IGE semantically has two initialization vectors of size
       *!   @[block_size()]; @tt{x0@} (previous plaintext) and @tt{y0@}
       *!   (previous ciphertext). They are here concatenated to a single
       *!   initialization vector of double the block size.
       */
      PIKEFUN object set_iv(string(0..255) iv)
	optflags OPT_SIDE_EFFECT;
      {
	assert(THIS->iv);
	iv->flags |= STRING_CLEAR_ON_EXIT;
	NO_WIDE_STRING(iv);
	if(iv->len != (THIS->block_size * 2))
	  Pike_error("Argument incompatible with cipher block size.\n");
	memcpy(STR0(THIS->iv), STR0(iv), THIS->block_size);
	RETURN this_object();
      }

      /*! @decl string(0..255) crypt(string(0..255) data)
       *!
       *! Encrypt/decrypt @[data] and return the result. @[data] must
       *! be an integral number of blocks.
       *!
       *! Neither the input or output data is not automatically memory
       *! scrubbed, unless @[String.secure] has been called on the data.
       */
      PIKEFUN string(0..255) crypt(string(0..255) data)
      {
	struct pike_string *result;
	ONERROR uwp;
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	struct pike_string *iv = THIS->iv;
	int block_size = THIS->block_size;

        if (!data->len) return;

	NO_WIDE_STRING(data);

	if(data->len % block_size)
	  Pike_error("Data length not multiple of block size.\n");

	if (!THIS->object || !THIS->object->prog) {
	  Pike_error("Lookup in destructed object.\n");
	}

	result = begin_shared_string(data->len);
	SET_ONERROR (uwp, do_free_string, result);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	if(THIS->mode == 0) {
	  ptrdiff_t offset = 0;
	  uint8_t *prev_dec = STR0(iv);
	  uint8_t *prev_enc = prev_dec + block_size;
	  uint8_t *res = STR0(result);
	  uint8_t *src = STR0(data);
	  if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	      (func != pike_crypt_func)) {
	    /* Protect the iv from being freed by a different thread. */
	    add_ref(iv);
	    THREADS_ALLOW();

	    while (offset < data->len) {
	      memxor3(res + offset, src + offset, prev_enc, block_size);
	      func(ctx, block_size, res + offset, res + offset);
	      memxor(res + offset, prev_dec, block_size);
	      prev_dec = src + offset;
	      prev_enc = res + offset;
	      offset += block_size;
	    }
	    memcpy(STR0(iv), prev_dec, block_size);
	    memcpy(STR0(iv) + block_size, prev_enc, block_size);

	    THREADS_DISALLOW();
	    free_string(iv);
	  } else {
	    while (offset < data->len) {
	      memxor3(res + offset, src + offset, prev_enc, block_size);
	      func(ctx, block_size, res + offset, res + offset);
	      memxor(res + offset, prev_dec, block_size);
	      prev_dec = src + offset;
	      prev_enc = res + offset;
	      offset += block_size;
	    }
	    memcpy(STR0(iv), prev_dec, block_size);
	    memcpy(STR0(iv) + block_size, prev_enc, block_size);
	  }
	}
	else {
	  ptrdiff_t offset = 0;
	  uint8_t *prev_dec = STR0(iv);
	  uint8_t *prev_enc = prev_dec + block_size;
	  uint8_t *res = STR0(result);
	  uint8_t *src = STR0(data);
	  if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	      (func != pike_crypt_func)) {
	    /* Protect the iv from being freed by a different thread. */
	    add_ref(iv);
	    THREADS_ALLOW();

	    while (offset < data->len) {
	      memxor3(res + offset, src + offset, prev_dec, block_size);
	      func(ctx, block_size, res + offset, res + offset);
	      memxor(res + offset, prev_enc, block_size);
	      prev_dec = res + offset;
	      prev_enc = src + offset;
	      offset += block_size;
	    }
	    memcpy(STR0(iv), prev_dec, block_size);
	    memcpy(STR0(iv) + block_size, prev_enc, block_size);

	    THREADS_DISALLOW();
	    free_string(iv);
	  } else {
	    while (offset < data->len) {
	      memxor3(res + offset, src + offset, prev_dec, block_size);
	      func(ctx, block_size, res + offset, res + offset);
	      memxor(res + offset, prev_enc, block_size);
	      prev_dec = res + offset;
	      prev_enc = src + offset;
	      offset += block_size;
	    }
	    memcpy(STR0(iv), prev_dec, block_size);
	    memcpy(STR0(iv) + block_size, prev_enc, block_size);
	  }
	}

	pop_n_elems(args);
	push_string(end_shared_string(result));
	UNSET_ONERROR(uwp);
      }
    }
    /*! @endclass State
     */
  }
  /*! @endmodule IGE
   */

  /*! @module ABC
   *! Implementation of the Accumulated Block Chaining mode (ABC).
   *!
   *! This is a mode of operation similar to @[IGE], but
   *! where the plaintext is mixed with both initialization
   *! vectors. It was suggested as a mode of operation for
   *! @[AES] by Lars R. Knudsen.
   *!
   *! @seealso
   *!   @[CBC], @[GCM], @[CFB], @[IGE]
   */
  PIKEVAR object(Nettle_Cipher) ABC;

  PIKECLASS _ABC
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit BufferedCipher
     */
    INHERIT BufferedCipher;

    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_name_fun_num, args);
      push_constant_text(".ABC");
      f_add(2);
    }

    PIKEFUN int(1..) block_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_key_size_fun_num, args);
    }

    PIKEFUN int(0..) iv_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
      push_int(2);
      f_multiply(2);
    }

    /*! @class State
     */
    PIKECLASS State
      program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
    {
      DOCSTART() @decl inherit Cipher::State
	DOCEND()

      EXTRA
      {
	/* Perform an inherit of the State class that our parent
	 * contains via its inherit of Cipher via BufferedCipher.
	 */
        lexical_inherit(1, MK_STRING("State"), 0, REPORT_ERROR, NULL);
      }

      PIKEVAR object object
	flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *crypt_state;
      CVAR struct pike_string *iv;	/* NB: Not finished. */
      CVAR INT32 block_size;		/* NB: iv size is twice this. */
      CVAR INT32 mode;

      EXIT
	gc_trivial;
      {
        if(THIS->iv)
	  free_string(THIS->iv);
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
	flags ID_PROTECTED;
      {
	apply_external(2,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		       Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       *!
       *! Initialize the ABC state with the @[Cipher::State] object
       *! returned by @[substate_factory()]. This is usually
       *! the State for the cipher implemented in the parent module.
       */
      PIKEFUN void create()
	flags ID_PROTECTED;
      {
	struct object *o;
	struct inherit *inh;
	unsigned old_block_size = THIS->block_size;
	unsigned block_size;
	int f;

	apply_current(f_Nettle_BlockCipher_cq__ABC_State_substate_factory_fun_num,
		      0);

	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  Pike_error("Unsupported return value from Cipher::State().\n");
	}
	o = Pike_sp[-1].u.object;
	if (!o->prog) {
	  Pike_error("Cipher::State() returned destructed object.\n");
	}

	f = find_identifier("crypt", o->prog);
	if (f < 0) {
	  Pike_error("State object has no crypt() function.\n");
	}

	apply(o, "block_size", 0);

	if(TYPEOF(Pike_sp[-1]) != T_INT)
	  Pike_error("block_size() didn't return an int.\n");

	block_size = Pike_sp[-1].u.integer;

	if ((!block_size) || (block_size > 4096))
	  Pike_error("Bad block size %d.\n", block_size);

	if(THIS->iv) {
	  free_string(THIS->iv);
	  THIS->iv = NULL;
	}

	THIS->block_size = block_size;

	THIS->iv = begin_shared_string(block_size * 2);
	memset(STR0(THIS->iv), 0, block_size * 2);
	THIS->iv->flags |= STRING_CLEAR_ON_EXIT;

	if (THIS->object) free_object(THIS->object);
	add_ref(THIS->object = o);

	inh = INHERIT_FROM_INT(o->prog, f);
	if (inh->prog == Nettle_Cipher_State_program) {
	  /* crypt() is from Nettle.Cipher.State.
	   * Check if the context and crypt function are valid.
	   */
	  THIS->crypt_state = (struct Nettle_Cipher_State_struct *)
	    get_inherit_storage(o, inh - o->prog->inherits);
	} else {
	  THIS->crypt_state = NULL;
        }
        pop_n_elems(2);
      }

      /*! @decl string(0..255) name()
       *! Returns the string @expr{"ABC(x)"@} where x is the
       *! encapsulated algorithm.
       */
      PIKEFUN string(0..255) name()
	optflags OPT_TRY_OPTIMIZE;
      {
	push_static_text("ABC(");
	apply(THIS->object, "name", 0);
	push_static_text(")");
	f_add(3);
      }

      /*! @decl int(1..) block_size()
       *! Returns the block size of the encapsulated cipher.
       */
      PIKEFUN int(1..) block_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl int(1..) key_size()
       *! Returns the key size of the encapsulated cipher.
       */
      PIKEFUN int(1..) key_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
	apply(THIS->object, "key_size", args);
      }

      /*! @decl int(1..) iv_size()
       *! Returns the size for the initialization vector
       */
      PIKEFUN int(1..) iv_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size * 2;
      }

      /*! @decl this_program set_encrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for encrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       */
      PIKEFUN object set_encrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	assert(THIS->block_size);
	THIS->mode = 0;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();
	push_object(this_object());
      }

      /*! @decl this_program set_decrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for decrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       */
      PIKEFUN object set_decrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	assert(THIS->block_size);
	THIS->mode = 1;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_decrypt_key", args);
	pop_stack();
	push_object(this_object());
      }

      /*! @decl this_program set_iv(string(0..255) iv)
       *!
       *! Set the initialization vector to @[iv]. The @[iv] memory will be
       *! cleared before released.
       *!
       *! @note
       *!   ABC semantically has two initialization vectors of size
       *!   @[block_size()]; @tt{x0@} (previous plaintext) and @tt{y0@}
       *!   (previous ciphertext). They are here concatenated to a single
       *!   initialization vector of double the block size.
       */
      PIKEFUN object set_iv(string(0..255) iv)
	optflags OPT_SIDE_EFFECT;
      {
	assert(THIS->iv);
	iv->flags |= STRING_CLEAR_ON_EXIT;
	NO_WIDE_STRING(iv);
	if(iv->len != (THIS->block_size * 2))
	  Pike_error("Argument incompatible with cipher block size.\n");
	memcpy(STR0(THIS->iv), STR0(iv), THIS->block_size);
	RETURN this_object();
      }

      /*! @decl string(0..255) crypt(string(0..255) data)
       *!
       *! Encrypt/decrypt @[data] and return the result. @[data] must
       *! be an integral number of blocks.
       *!
       *! Neither the input or output data is not automatically memory
       *! scrubbed, unless @[String.secure] has been called on the data.
       */
      PIKEFUN string(0..255) crypt(string(0..255) data)
      {
	struct pike_string *result;
	ONERROR uwp;
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	struct pike_string *iv = THIS->iv;
	int block_size = THIS->block_size;

	NO_WIDE_STRING(data);

	if (!data->len) return;

	if(data->len % block_size)
	  Pike_error("Data length not multiple of block size.\n");

	if (!THIS->object || !THIS->object->prog) {
	  Pike_error("Lookup in destructed object.\n");
	}

	result = begin_shared_string(data->len);
	SET_ONERROR (uwp, do_free_string, result);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	if(THIS->mode == 0) {
	  ptrdiff_t offset = 0;
	  uint8_t *prev_dec = STR0(iv);
	  uint8_t *prev_enc = prev_dec + block_size;
	  uint8_t *res = STR0(result);
	  uint8_t *src = STR0(data);
	  if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	      (func != pike_crypt_func)) {
	    /* Protect the iv from being freed by a different thread. */
	    add_ref(iv);
	    THREADS_ALLOW();

	    while (offset < data->len) {
	      memxor3(res + offset, src + offset, prev_enc, block_size);
	      memrolx(res + offset, prev_dec, 1, block_size);
	      func(ctx, block_size, res + offset, res + offset);
	      memxor(res + offset, prev_dec, block_size);
	      prev_dec = src + offset;
	      prev_enc = res + offset;
	      offset += block_size;
	    }
	    memcpy(STR0(iv), prev_dec, block_size);
	    memcpy(STR0(iv) + block_size, prev_enc, block_size);

	    THREADS_DISALLOW();
	    free_string(iv);
	  } else {
	    while (offset < data->len) {
	      memxor3(res + offset, src + offset, prev_enc, block_size);
	      memrolx(res + offset, prev_dec, 1, block_size);
	      func(ctx, block_size, res + offset, res + offset);
	      memxor(res + offset, prev_dec, block_size);
	      prev_dec = src + offset;
	      prev_enc = res + offset;
	      offset += block_size;
	    }
	    memcpy(STR0(iv), prev_dec, block_size);
	    memcpy(STR0(iv) + block_size, prev_enc, block_size);
	  }
	}
	else {
	  ptrdiff_t offset = 0;
	  uint8_t *prev_dec = STR0(iv);
	  uint8_t *prev_enc = prev_dec + block_size;
	  uint8_t *res = STR0(result);
	  uint8_t *src = STR0(data);
	  if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	      (func != pike_crypt_func)) {
	    /* Protect the iv from being freed by a different thread. */
	    add_ref(iv);
	    THREADS_ALLOW();

	    while (offset < data->len) {
	      memxor3(res + offset, src + offset, prev_dec, block_size);
	      func(ctx, block_size, res + offset, res + offset);
	      memxor(res + offset, prev_enc, block_size);
	      memrolx(res + offset, prev_dec, 1, block_size);
	      prev_dec = res + offset;
	      prev_enc = src + offset;
	      offset += block_size;
	    }
	    memcpy(STR0(iv), prev_dec, block_size);
	    memcpy(STR0(iv) + block_size, prev_enc, block_size);

	    THREADS_DISALLOW();
	    free_string(iv);
	  } else {
	    while (offset < data->len) {
	      memxor3(res + offset, src + offset, prev_dec, block_size);
	      func(ctx, block_size, res + offset, res + offset);
	      memxor(res + offset, prev_enc, block_size);
	      memrolx(res + offset, prev_dec, 1, block_size);
	      prev_dec = res + offset;
	      prev_enc = src + offset;
	      offset += block_size;
	    }
	    memcpy(STR0(iv), prev_dec, block_size);
	    memcpy(STR0(iv) + block_size, prev_enc, block_size);
	  }
	}

	pop_n_elems(args);
	push_string(end_shared_string(result));
	UNSET_ONERROR(uwp);
      }
    }
    /*! @endclass State
     */
  }
  /*! @endmodule ABC
   */

  /*! @module CFB
   *! Implementation of the Cipher Feed-Back mode (CFB).
   *!
   *! @note
   *!   Requires Nettle 3.4 or later.
   *!
   *! @seealso
   *!   @[CBC], @[GCM]
   */
  PIKEVAR object(Nettle_Cipher) CFB;

  PIKECLASS _CFB
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit BufferedCipher
     */
    INHERIT BufferedCipher;

    /*! @decl string(0..255) name()
     *! Returns the base cipher name appended with the string @expr{".CFB"@}.
     */
    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_name_fun_num, args);
      push_static_text(".CFB");
      f_add(2);
    }

    PIKEFUN int(1..) block_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_key_size_fun_num, args);
    }

    PIKEFUN int(0..) iv_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
    }

    /*! @class State
     *!
     *! The state for a CFB instance.
     */
    PIKECLASS State
      program_flags PROGRAM_USES_PARENT|PROGRAM_NEEDS_PARENT;
    {
      DOCSTART() @decl inherit BufferedCipher::State
	DOCEND()

      EXTRA
      {
	/* Perform an inherit of the State class that our parent
	 * contains via its inherit of Cipher via BufferedCipher.
	 */
        lexical_inherit(1, MK_STRING("State"), 0, REPORT_ERROR, NULL);
      }

      PIKEVAR object object
	flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *crypt_state;
      CVAR struct pike_string *iv;	/* NB: Not finished. */
      CVAR INT32 block_size;
      CVAR INT32 mode;

      EXIT
	gc_trivial;
      {
        if (THIS->iv)
	  free_string(THIS->iv);
      }

      /*! @decl object `obj()
       *!
       *! Getter for the wrapped cipher algorithm.
       */
      PIKEFUN object `obj()
      {
	if (THIS->object) {
	  ref_push_object(THIS->object);
	} else {
	  push_int(0);
	}
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
	flags ID_PROTECTED;
      {
	apply_external(2,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		       Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       *!
       *! Initialize the CFB state with the @[Cipher::State] object
       *! returned by @[substate_factory()]. This is usually
       *! the State for the cipher implemented in the parent module.
       */
      PIKEFUN void create()
	flags ID_PROTECTED;
      {
	struct object *o;
	struct inherit *inh;
	int old_block_size = THIS->block_size;
	int block_size;
	int f;

	if (THIS->object) free_object(THIS->object);
	THIS->object = NULL;
	THIS->crypt_state = NULL;

	apply_current(f_Nettle_BlockCipher_cq__CFB_State_substate_factory_fun_num,
		      0);

	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  Pike_error("Unsupported return value from Cipher::State().\n");
	}
	o = Pike_sp[-1].u.object;
	if (!o->prog) {
	  Pike_error("Cipher::State() returned destructed object.\n");
	}

	f = find_identifier("crypt", o->prog);
	if (f < 0) {
	  Pike_error("State object has no crypt() function.\n");
	}

	apply(o, "block_size", 0);

	if(TYPEOF(Pike_sp[-1]) != T_INT)
	  Pike_error("block_size() didn't return an int.\n");

	block_size = Pike_sp[-1].u.integer;

	if ((block_size <= 0) || (block_size > 4096))
	  Pike_error("Bad block size %d.\n", block_size);

	inh = INHERIT_FROM_INT(o->prog, f);
	if (inh->prog == Nettle_Cipher_State_program) {
	  /* crypt() is from Nettle.Cipher.State.
	   * Check if the context and crypt function are valid.
	   */
	  THIS->crypt_state = (struct Nettle_Cipher_State_struct *)
	    get_inherit_storage(o, inh - o->prog->inherits);
	}

	if(THIS->iv) {
	  free_string(THIS->iv);
	  THIS->iv = NULL;
	}

	THIS->iv = begin_shared_string(block_size);
	memset(STR0(THIS->iv), 0, block_size);
	THIS->iv->flags |= STRING_CLEAR_ON_EXIT;

	THIS->block_size = block_size;
	THIS->mode = 0;

        add_ref(THIS->object = o);
        pop_n_elems(2);
      }

      /*! @decl string(0..255) name()
       *! Returns the string @expr{"CFB(x)"@} where x is the
       *! encapsulated algorithm.
       */
      PIKEFUN string(0..255) name()
	optflags OPT_TRY_OPTIMIZE;
      {
	push_static_text("CFB(");
	apply(THIS->object, "name", 0);
	push_static_text(")");
	f_add(3);
      }

      /*! @decl int(1..) block_size()
       *! Returns the block size of the encapsulated cipher.
       */
      PIKEFUN int(1..) block_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl int(1..) iv_size()
       *! Returns the size for the initialization vector
       */
      PIKEFUN int(1..) iv_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl int(1..) key_size()
       *! Returns the key size of the encapsulated cipher.
       */
      PIKEFUN int(1..) key_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
	apply(THIS->object, "key_size", args);
      }

      /*! @decl this_program set_encrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for encrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_decrypt_key()], @[set_iv()]
       */
      PIKEFUN object set_encrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();
	THIS->mode = 0;

	push_object(this_object());
      }

      /*! @decl this_program set_decrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for decrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_encrypt_key()], @[set_iv()]
       */
      PIKEFUN object set_decrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	key->flags |= STRING_CLEAR_ON_EXIT;
	/* NOTE: CFB always uses the encryption function
	 *       of the underlying cipher!
	 */
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();
	THIS->mode = 1;

	push_object(this_object());
      }

      /*! @decl this_program set_iv(string(0..255) iv)
       *!
       *! Set the initialization vector to @[iv]. The @[iv] memory will be
       *! cleared before released.
       *!
       *! @note
       *!   @[iv] must have the length reported by @[iv_size()].
       *!
       *! @seealso
       *!   @[set_encrypt_key()], @[set_decrypt_key()].
       */
      PIKEFUN object set_iv(string(0..255) iv)
	optflags OPT_SIDE_EFFECT;
      {
	iv->flags |= STRING_CLEAR_ON_EXIT;
	NO_WIDE_STRING(iv);
	if(iv->len != THIS->block_size)
	  Pike_error("Argument incompatible with cipher block size.\n");
	memcpy(STR0(THIS->iv), STR0(iv), THIS->block_size);
	RETURN this_object();
      }

      /*! @decl string(0..255) crypt(string(0..255) data)
       *!
       *! Encrypt/decrypt @[data] and return the result. @[data] must
       *! be an integral number of blocks.
       *!
       *! The length of @[data] MUST be a multiple of the block size
       *! for all calls except the last.
       *!
       *! Neither the input or output data is not automatically memory
       *! scrubbed, unless @[String.secure] has been called on the data.
       *!
       *! @seealso
       *!   @[update()], @[digest()]
       */
      PIKEFUN string(0..255) crypt(string(0..255) data)
      {
	struct pike_string *result;
	ONERROR uwp;
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	struct pike_string *iv = THIS->iv;
	unsigned block_size = (unsigned)THIS->block_size;

	NO_WIDE_STRING(data);

	if (!THIS->object || !THIS->object->prog) {
	  Pike_error("Lookup in destructed object.\n");
	}

	if (!data->len) return;

	result = begin_shared_string(data->len);
	SET_ONERROR (uwp, do_free_string, result);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	if (!THIS->mode) {
	  /* Encryption. */
	  const uint8_t *prev = STR0(iv);
	  uint8_t *src = STR0(data);
	  uint8_t *dst = STR0(result);
	  pike_nettle_size_t bytes = data->len;

	  if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	      (func != pike_crypt_func)) {
	    /* Protect the iv from being freed by a different thread. */
	    add_ref(iv);
	    THREADS_ALLOW();
	    while (bytes >= block_size) {
	      func(ctx, block_size, STR0(iv), prev);
	      memxor3(dst, STR0(iv), src, block_size);
	      prev = dst;
	      dst += block_size;
	      src += block_size;
	      bytes -= block_size;
	    }
	    if (!bytes) {
	      memcpy(STR0(iv), dst - block_size, block_size);
	    } else {
	      /* Trailer partial block. */
	      func(ctx, block_size, STR0(iv), prev);
	      memxor3(dst, STR0(iv), src, bytes);
	      memcpy(STR0(iv), dst, bytes);
	    }
	    THREADS_DISALLOW();
	    free_string(iv);
	  } else {
	    while (bytes >= block_size) {
	      func(ctx, block_size, STR0(iv), prev);
	      memxor3(dst, STR0(iv), src, block_size);
	      prev = dst;
	      dst += block_size;
	      src += block_size;
	      bytes -= block_size;
	    }
	    if (!bytes) {
	      memcpy(STR0(iv), dst - block_size, block_size);
	    } else {
	      /* Trailer partial block. */
	      func(ctx, block_size, STR0(iv), prev);
	      memxor3(dst, STR0(iv), src, bytes);
	      memcpy(STR0(iv), dst, bytes);
	    }
	  }
	} else {
	  /* Decryption. */
	  unsigned trailer_len = data->len % block_size;
	  unsigned blocked_len = data->len - trailer_len;
	  if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	      (func != pike_crypt_func)) {
	    /* Protect the iv from being freed by a different thread. */
	    add_ref(iv);
	    THREADS_ALLOW();
	    if (blocked_len) {
	      memcpy(STR0(result), STR0(iv), block_size);
	      if (blocked_len > block_size) {
		memcpy(STR0(result) + block_size, STR0(data),
		       blocked_len - block_size);
	      }
	      func(ctx, blocked_len, STR0(result), STR0(result));
	      memxor(STR0(result), STR0(data), blocked_len);
	      memcpy(STR0(iv), STR0(data) + blocked_len - block_size,
		     block_size);
	    }
	    if (trailer_len) {
	      func(ctx, block_size, STR0(iv), STR0(iv));
	      memxor3(STR0(result) + blocked_len, STR0(data) + blocked_len,
		      STR0(iv), trailer_len);
	      memcpy(STR0(iv), STR0(data) + blocked_len, trailer_len);
	    }
	    THREADS_DISALLOW();
	    free_string(iv);
	  } else {
	    if (blocked_len) {
	      memcpy(STR0(result), STR0(iv), block_size);
	      if (blocked_len > block_size) {
		memcpy(STR0(result) + block_size, STR0(data),
		       blocked_len - block_size);
	      }
	      func(ctx, blocked_len, STR0(result), STR0(result));
	      memxor(STR0(result), STR0(data), blocked_len);
	      memcpy(STR0(iv), STR0(data) + blocked_len - block_size,
		     block_size);
	    }
	    if (trailer_len) {
	      func(ctx, block_size, STR0(iv), STR0(iv));
	      memxor3(STR0(result) + blocked_len, STR0(data) + blocked_len,
		      STR0(iv), trailer_len);
	      memcpy(STR0(iv), STR0(data) + blocked_len, trailer_len);
	    }
	  }
	}

	pop_n_elems(args);
	push_string(end_shared_string(result));
	UNSET_ONERROR(uwp);
      }
    }
    /*! @endclass
     */

    /*! @decl State `()()
     *!
     *! @returns
     *!   Returns a new @[State] object.
     */
    PIKEFUN Nettle_Cipher_State `()()
    {
      apply_current(Nettle_BlockCipher_cq__CFB_State_program_fun_num, args);
    }
  }

  /*! @endmodule CFB
   */

  /* FIXME: Support CFB8 (Nettle 3.5 and later). */

  /*! @module CTR
   *! Implementation of the Counter mode (CTR).
   *!
   *! This cipher mode works like a stream cipher with
   *! a block size >= 1. This means that the same key
   *! and initialization vector (aka counter) should
   *! never be reused, since a simple xor would reveal
   *! information about the plain text. It also means
   *! that it should never be used without a suiteable
   *! Message Authentication Code (MAC).
   *!
   *! @seealso
   *!   @[CBC], @[GCM], @[Buffer]
   */
  PIKEVAR object(Nettle_Cipher) CTR;

  PIKECLASS _CTR
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit __builtin.Nettle.Cipher
     */
    INHERIT "__builtin.Nettle.Cipher";

    /*! @decl string(0..255) name()
     *! Returns the base cipher name appended with the string @expr{".CTR"@}.
     */
    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_name_fun_num, args);
      push_static_text(".CTR");
      f_add(2);
    }

    PIKEFUN int(1..) block_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_key_size_fun_num, args);
    }

    PIKEFUN int(0..) iv_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
    }

    /*! @class State
     *!
     *! The state for a CTR instance.
     */
    PIKECLASS State
      program_flags PROGRAM_USES_PARENT|PROGRAM_NEEDS_PARENT|PROGRAM_CLEAR_STORAGE;
    {
      DOCSTART() @decl inherit Cipher::State
	DOCEND()

      EXTRA
      {
	/* Perform an inherit of the State class (if any) that our parent
	 * may contain via its inherit of __builtin.Nettle.Cipher.
	 */
        lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
      }

      PIKEVAR object object
	flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *crypt_state;
      CVAR struct pike_string *iv;	/* NB: Not finished. */
      CVAR INT32 block_size;

      EXIT
	gc_trivial;
      {
        if (THIS->iv)
	  free_string(THIS->iv);
      }

      /*! @decl object `obj()
       *!
       *! Getter for the wrapped cipher algorithm.
       */
      PIKEFUN object `obj()
      {
	if (THIS->object) {
	  ref_push_object(THIS->object);
	} else {
	  push_int(0);
	}
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
	flags ID_PROTECTED;
      {
	apply_external(2,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       *!
       *! Initialize the CTR state with the @[Cipher::State] object
       *! returned by @[substate_factory()]. This is usually
       *! the State for the cipher implemented in the parent module.
       */
      PIKEFUN void create()
	flags ID_PROTECTED;
      {
	struct object *o;
	struct inherit *inh;
	int old_block_size = THIS->block_size;
	int block_size;
	int f;

	if (THIS->object) free_object(THIS->object);
	THIS->object = NULL;
	THIS->crypt_state = NULL;

	apply_current(f_Nettle_BlockCipher_cq__CTR_State_substate_factory_fun_num,
		      0);

	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  Pike_error("Unsupported return value from Cipher::State().\n");
	}
	o = Pike_sp[-1].u.object;
	if (!o->prog) {
	  Pike_error("Cipher::State() returned destructed object.\n");
	}

	f = find_identifier("crypt", o->prog);
	if (f < 0) {
	  Pike_error("State object has no crypt() function.\n");
	}

	apply(o, "block_size", 0);

	if(TYPEOF(Pike_sp[-1]) != T_INT)
	  Pike_error("block_size() didn't return an int.\n");

	block_size = Pike_sp[-1].u.integer;

	if ((!block_size) || (block_size > 4096))
	  Pike_error("Bad block size %d.\n", block_size);

	inh = INHERIT_FROM_INT(o->prog, f);
	if (inh->prog == Nettle_Cipher_State_program) {
	  /* crypt() is from Nettle.Cipher.State.
	   * Check if the context and crypt function are valid.
	   */
	  THIS->crypt_state = (struct Nettle_Cipher_State_struct *)
	    get_inherit_storage(o, inh - o->prog->inherits);
	}

	if(THIS->iv) {
	  free_string(THIS->iv);
	  THIS->iv = NULL;
	}

	THIS->iv = begin_shared_string(block_size);
	memset(STR0(THIS->iv), 0, block_size);
	THIS->iv->flags |= STRING_CLEAR_ON_EXIT;

	THIS->block_size = block_size;

        add_ref(THIS->object = o);
        pop_n_elems(2);
      }

      /*! @decl string(0..255) name()
       *! Returns the string @expr{"CTR(x)"@} where x is the
       *! encapsulated algorithm.
       */
      PIKEFUN string(0..255) name()
	optflags OPT_TRY_OPTIMIZE;
      {
	push_static_text("CTR(");
	apply(THIS->object, "name", 0);
	push_static_text(")");
	f_add(3);
      }

      /*! @decl int(1..) block_size()
       *! Returns the block size of the encapsulated cipher.
       */
      PIKEFUN int(1..) block_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl int(1..) iv_size()
       *! Returns the size for the initialization vector
       */
      PIKEFUN int(1..) iv_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl int(1..) key_size()
       *! Returns the key size of the encapsulated cipher.
       */
      PIKEFUN int(1..) key_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
	apply(THIS->object, "key_size", args);
      }

      /*! @decl this_program set_encrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for encrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_decrypt_key()], @[set_iv()]
       */
      PIKEFUN object set_encrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();

	push_object(this_object());
      }

      /*! @decl this_program set_decrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for decrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_encrypt_key()], @[set_iv()]
       */
      PIKEFUN object set_decrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	key->flags |= STRING_CLEAR_ON_EXIT;
	/* NOTE: CTR always uses the encryption function
	 *       of the underlying cipher!
	 */
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();

	push_object(this_object());
      }

      /*! @decl this_program set_iv(string(0..255) iv)
       *!
       *! Set the initialization vector to @[iv]. The @[iv] memory will be
       *! cleared before released.
       *!
       *! @note
       *!   @[iv] must have the length reported by @[iv_size()].
       *!
       *! @seealso
       *!   @[set_encrypt_key()], @[set_decrypt_key()].
       */
      PIKEFUN object set_iv(string(0..255) iv)
	optflags OPT_SIDE_EFFECT;
      {
	iv->flags |= STRING_CLEAR_ON_EXIT;
	NO_WIDE_STRING(iv);
	if(iv->len != THIS->block_size)
	  Pike_error("Argument incompatible with cipher block size.\n");
	memcpy(STR0(THIS->iv), STR0(iv), THIS->block_size);
	RETURN this_object();
      }

      /*! @decl string(0..255) crypt(string(0..255) data)
       *!
       *! Encrypt/decrypt @[data] and return the result. @[data] must
       *! be an integral number of blocks.
       *!
       *! The length of @[data] MUST be a multiple of the block size
       *! for all calls except the last.
       *!
       *! Neither the input or output data is not automatically memory
       *! scrubbed, unless @[String.secure] has been called on the data.
       *!
       *! @seealso
       *!   @[update()], @[digest()]
       */
      PIKEFUN string(0..255) crypt(string(0..255) data)
      {
	struct pike_string *result;
	ONERROR uwp;
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	struct pike_string *iv = THIS->iv;
	int block_size = THIS->block_size;

	NO_WIDE_STRING(data);

	if (!THIS->object || !THIS->object->prog) {
	  Pike_error("Lookup in destructed object.\n");
	}

	result = begin_shared_string(data->len);
	SET_ONERROR (uwp, do_free_string, result);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	    (func != pike_crypt_func)) {
	  /* Protect the iv from being freed by a different thread. */
	  add_ref(iv);
	  THREADS_ALLOW();
          ctr_crypt(ctx, (pike_nettle_cipher_func)func, block_size, STR0(iv),
		    data->len, STR0(result), STR0(data));
	  THREADS_DISALLOW();
	  free_string(iv);
	} else {
          ctr_crypt(ctx, (pike_nettle_cipher_func)func, block_size, STR0(iv),
		    data->len, STR0(result), STR0(data));
	}

	pop_n_elems(args);
	push_string(end_shared_string(result));
	UNSET_ONERROR(uwp);
      }

    }
    /*! @endclass
     */

    /*! @decl State `()()
     *!
     *! @returns
     *!   Returns a new @[State] object.
     */
    PIKEFUN Nettle_Cipher_State `()()
    {
      apply_current(Nettle_BlockCipher_cq__CTR_State_program_fun_num, args);
    }

  }

  /*! @endmodule CTR
   */

  /*! @module OFB
   *! Implementation of the Output Feed-Back mode (OFB).
   *!
   *! This cipher mode works like a stream cipher with
   *! a block size >= 1. This means that the same key
   *! and initialization vector (aka counter) should
   *! never be reused, since a simple xor would reveal
   *! information about the plain text. It also means
   *! that it should never be used without a suiteable
   *! Message Authentication Code (MAC).
   *!
   *! @seealso
   *!   @[CFB], @[CBC], @[CTR], @[GCM]
   */
  PIKEVAR object(Nettle_Cipher) OFB;

  PIKECLASS _OFB
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit BufferedCipher
     */
    INHERIT BufferedCipher;

    /*! @decl string(0..255) name()
     *! Returns the base cipher name appended with the string @expr{".OFB"@}.
     */
    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_name_fun_num, args);
      push_static_text(".OFB");
      f_add(2);
    }

    PIKEFUN int(1..) block_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_key_size_fun_num, args);
    }

    PIKEFUN int(0..) iv_size()
    {
      apply_external(1,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		     f_Nettle_Cipher_block_size_fun_num, args);
    }

    /*! @class State
     *!
     *! The state for a OFB instance.
     */
    PIKECLASS State
      program_flags PROGRAM_USES_PARENT|PROGRAM_NEEDS_PARENT;
    {
      DOCSTART() @decl inherit BufferedCipher::State
	DOCEND()

      EXTRA
      {
	/* Perform an inherit of the State class that our parent
	 * contains via its inherit of Cipher via BufferedCipher.
	 */
        lexical_inherit(1, MK_STRING("State"), 0, REPORT_ERROR, NULL);
      }

      PIKEVAR object object
	flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *crypt_state;
      CVAR struct pike_string *iv;	/* NB: Not finished. */
      CVAR INT32 block_size;

      EXIT
	gc_trivial;
      {
        if (THIS->iv)
	  free_string(THIS->iv);
      }

      /*! @decl object `obj()
       *!
       *! Getter for the wrapped cipher algorithm.
       */
      PIKEFUN object `obj()
      {
	if (THIS->object) {
	  ref_push_object(THIS->object);
	} else {
	  push_int(0);
	}
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
	flags ID_PROTECTED;
      {
	apply_external(2,  Nettle_BlockCipher_BufferedCipher_inh_offset +
		       Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       *!
       *! Initialize the OFB state with the @[Cipher::State] object
       *! returned by @[substate_factory()]. This is usually
       *! the State for the cipher implemented in the parent module.
       */
      PIKEFUN void create()
	flags ID_PROTECTED;
      {
	struct object *o;
	struct inherit *inh;
	int old_block_size = THIS->block_size;
	int block_size;
	int f;

	if (THIS->object) free_object(THIS->object);
	THIS->object = NULL;
	THIS->crypt_state = NULL;

	apply_current(f_Nettle_BlockCipher_cq__OFB_State_substate_factory_fun_num,
		      0);

	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  Pike_error("Unsupported return value from Cipher::State().\n");
	}
	o = Pike_sp[-1].u.object;
	if (!o->prog) {
	  Pike_error("Cipher::State() returned destructed object.\n");
	}

	f = find_identifier("crypt", o->prog);
	if (f < 0) {
	  Pike_error("State object has no crypt() function.\n");
	}

	apply(o, "block_size", 0);

	if(TYPEOF(Pike_sp[-1]) != T_INT)
	  Pike_error("block_size() didn't return an int.\n");

	block_size = Pike_sp[-1].u.integer;

	if ((!block_size) || (block_size > 4096))
	  Pike_error("Bad block size %d.\n", block_size);

	inh = INHERIT_FROM_INT(o->prog, f);
	if (inh->prog == Nettle_Cipher_State_program) {
	  /* crypt() is from Nettle.Cipher.State.
	   * Check if the context and crypt function are valid.
	   */
	  THIS->crypt_state = (struct Nettle_Cipher_State_struct *)
	    get_inherit_storage(o, inh - o->prog->inherits);
	}

	if(THIS->iv) {
	  free_string(THIS->iv);
	  THIS->iv = NULL;
	}

	THIS->iv = begin_shared_string(block_size);
	memset(STR0(THIS->iv), 0, block_size);
	THIS->iv->flags |= STRING_CLEAR_ON_EXIT;

	THIS->block_size = block_size;

        add_ref(THIS->object = o);
        pop_n_elems(2);
      }

      /*! @decl string(0..255) name()
       *! Returns the string @expr{"OFB(x)"@} where x is the
       *! encapsulated algorithm.
       */
      PIKEFUN string(0..255) name()
	optflags OPT_TRY_OPTIMIZE;
      {
	push_static_text("OFB(");
	apply(THIS->object, "name", 0);
	push_static_text(")");
	f_add(3);
      }

      /*! @decl int(1..) block_size()
       *! Returns the block size of the encapsulated cipher.
       */
      PIKEFUN int(1..) block_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl int(1..) iv_size()
       *! Returns the size for the initialization vector
       */
      PIKEFUN int(1..) iv_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN THIS->block_size;
      }

      /*! @decl int(1..) key_size()
       *! Returns the key size of the encapsulated cipher.
       */
      PIKEFUN int(1..) key_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
	apply(THIS->object, "key_size", args);
      }

      /*! @decl this_program set_encrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for encrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_decrypt_key()], @[set_iv()]
       */
      PIKEFUN object set_encrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();
	push_object(this_object());
      }

      /*! @decl this_program set_decrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for decrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_encrypt_key()], @[set_iv()]
       */
      PIKEFUN object set_decrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	key->flags |= STRING_CLEAR_ON_EXIT;
	/* NOTE: OFB always uses the encryption function
	 *       of the underlying cipher!
	 */
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();
	push_object(this_object());
      }

      /*! @decl this_program set_iv(string(0..255) iv)
       *!
       *! Set the initialization vector to @[iv]. The @[iv] memory will be
       *! cleared before released.
       *!
       *! @note
       *!   @[iv] must have the length reported by @[iv_size()].
       *!
       *! @seealso
       *!   @[set_encrypt_key()], @[set_decrypt_key()].
       */
      PIKEFUN object set_iv(string(0..255) iv)
	optflags OPT_SIDE_EFFECT;
      {
	iv->flags |= STRING_CLEAR_ON_EXIT;
	NO_WIDE_STRING(iv);
	if(iv->len != THIS->block_size)
	  Pike_error("Argument incompatible with cipher block size.\n");
	memcpy(STR0(THIS->iv), STR0(iv), THIS->block_size);
	RETURN this_object();
      }

      /*! @decl string(0..255) crypt(string(0..255) data)
       *!
       *! Encrypt/decrypt @[data] and return the result. @[data] must
       *! be an integral number of blocks.
       *!
       *! The length of @[data] MUST be a multiple of the block size
       *! for all calls except the last.
       *!
       *! Neither the input or output data is not automatically memory
       *! scrubbed, unless @[String.secure] has been called on the data.
       *!
       *! @seealso
       *!   @[update()], @[digest()]
       */
      PIKEFUN string(0..255) crypt(string(0..255) data)
      {
	struct pike_string *result;
	ONERROR uwp;
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	struct pike_string *iv = THIS->iv;
	unsigned block_size = (unsigned)THIS->block_size;
	uint8_t *src;
	uint8_t *dst;
	pike_nettle_size_t bytes;

	NO_WIDE_STRING(data);

	if (!THIS->object || !THIS->object->prog) {
	  Pike_error("Lookup in destructed object.\n");
	}

	if (!(bytes = data->len)) return;

	result = begin_shared_string(data->len);
	SET_ONERROR (uwp, do_free_string, result);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	src = STR0(data);
	dst = STR0(result);

	if ((bytes >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	    (func != pike_crypt_func)) {
	  /* Protect the iv from being freed by a different thread. */
	  add_ref(iv);
	  THREADS_ALLOW();
	  while (bytes >= block_size) {
	    func(ctx, block_size, STR0(iv), STR0(iv));
	    memxor3(dst, STR0(iv), src, block_size);
	    dst += block_size;
	    src += block_size;
	    bytes -= block_size;
	  }
	  if (bytes) {
	    func(ctx, block_size, STR0(iv), STR0(iv));
	    memxor3(dst, STR0(iv), src, bytes);
	  }
	  THREADS_DISALLOW();
	  free_string(iv);
	} else {
	  while (bytes >= block_size) {
	    func(ctx, block_size, STR0(iv), STR0(iv));
	    memxor3(dst, STR0(iv), src, block_size);
	    dst += block_size;
	    src += block_size;
	    bytes -= block_size;
	  }
	  if (bytes) {
	    func(ctx, block_size, STR0(iv), STR0(iv));
	    memxor3(dst, STR0(iv), src, bytes);
	  }
	}

	pop_n_elems(args);
	push_string(end_shared_string(result));
	UNSET_ONERROR(uwp);
      }
    }
    /*! @endclass
     */

    /*! @decl State `()()
     *!
     *! @returns
     *!   Returns a new @[State] object.
     */
    PIKEFUN Nettle_Cipher_State `()()
    {
      apply_current(Nettle_BlockCipher_cq__OFB_State_program_fun_num, args);
    }
  }

  /*! @endmodule OFB
   */

  /* NB: Declare the storage explicitly to avoid having it declared
   *     inside the #ifdef above.
   */
  DECLARE_STORAGE;

  INIT
  {
    apply_current(Nettle_BlockCipher_cq__CBC_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER->CBC = Pike_sp[-1].u.object);
    }
    pop_stack();
    apply_current(Nettle_BlockCipher_cq__PCBC_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER->PCBC = Pike_sp[-1].u.object);
    }
    pop_stack();
    apply_current(Nettle_BlockCipher_cq__IGE_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER->IGE = Pike_sp[-1].u.object);
    }
    pop_stack();
    apply_current(Nettle_BlockCipher_cq__ABC_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER->ABC = Pike_sp[-1].u.object);
    }
    pop_stack();
    apply_current(Nettle_BlockCipher_cq__CFB_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER->CFB = Pike_sp[-1].u.object);
    }
    pop_stack();
    apply_current(Nettle_BlockCipher_cq__CTR_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER->CTR = Pike_sp[-1].u.object);
    }
    pop_stack();
    apply_current(Nettle_BlockCipher_cq__OFB_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER->OFB = Pike_sp[-1].u.object);
    }
    pop_stack();
  }
}
/*! @endclass BlockCipher
 */

#define BLOCKCIPHER_CIPHER_INHERIT	(BUFFEREDCIPHER_CIPHER_INHERIT + \
					 Nettle_BlockCipher_BufferedCipher_inh_num)

/*! @class BlockCipher16
 *!
 *! This is the @[BlockCipher] class extended with algorithms
 *! that require a block size of @expr{16@} bytes.
 *!
 *! @seealso
 *!   @[Cipher], @[BlockCipher], @[BufferedCipher], @[GCM]
 */
PIKECLASS BlockCipher16
{
  /* NOTE: MUST be first in the class to simplify access to symbols
   *       in Cipher!
   */
  /*! @decl inherit BlockCipher
   */
  INHERIT BlockCipher;

  /*! @decl inherit __builtin.Nettle.BlockCipher16Mixin
   */
  INHERIT "__builtin.Nettle.BlockCipher16Mixin";

  /*! @class State
   *!
   *! Base class for cipher contexts for ciphers that have
   *! a block size of 16 bytes.
   */
  PIKECLASS State
    program_flags PROGRAM_USES_PARENT|PROGRAM_NEEDS_PARENT|PROGRAM_CLEAR_STORAGE;
  {
    DOCSTART() @decl inherit BlockCipher::State
    DOCEND()

    EXTRA
    {
      /* Perform an inherit of the State class (if any) that our parent
       * may contain via its inherit of BlockCipher.
       */
      lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
    }

    /*! @decl string(8bit) wrap_key(string(8bit) key, int(0..1)|void method)
     *!
     *! The AES Key Wrapping algorithms from @rfc{3394@} and @rfc{5649@}.
     *!
     *! @param key
     *!   Key to wrap.
     *!
     *! @param method
     *!   Method to use to wrap the key. One of:
     *!   @int
     *!     @value 0
     *!       @rfc{3394@} This algorithm is intended to be used to encode
     *!       encryption keys which are a multiple of 8 bytes and at least
     *!       16 bytes long. This is the default method.
     *!     @value 1
     *!       @rfc{5649@} This algorithm is similar to the above, but
     *!       supports keys of any length and has an intentionally
     *!       not compatible result.
     *!   @endint
     *!
     *! @returns
     *!   Returns the wrapped key.
     *!
     *! @note
     *!   Assumes that the @[State] object has been initialized to
     *!   encryption mode (ie that @[set_encrypt_key()] has been called).
     *!
     *! @note
     *!   @rfc{6931:2.6.3@} indicates that the @rfc{3394@} algorithm
     *!   is also appropriate for @[Camellia].
     *!
     *! @seealso
     *!   @[unwrap_key()]
     */
    PIKEFUN string(8bit) wrap_key(string(8bit) key, int(0..1)|void _method)
    {
      int f, i, j, k;
      union {
        INT64 i64;
        p_wchar0 bin[8];
      } t;
      struct inherit *inh;
      p_wchar0 buf[AES_BLOCK_SIZE];
      struct pike_string *res;
      pike_nettle_crypt_func func = pike_crypt_func;
      void *ctx = Pike_fp->current_object;
      unsigned int method = _method?_method->u.integer:0;

      if (!method) {
        if ((key->len & 0x07) || (key->len < 16)) {
          Pike_error("Unsupported key length.\n");
        }
      } else if (method > 1) {
        Pike_error("Unsupported key wrapping method.\n");
      }

      f = find_identifier("crypt", Pike_fp->current_program);
      if (f < 0) {
        Pike_error("State object has no crypt() function.\n");
      }

      inh = INHERIT_FROM_INT(Pike_fp->current_program, f);
      if (inh->prog == Nettle_Cipher_State_program) {
        struct Nettle_Cipher_State_struct *crypt_state;
        /* crypt() is from Nettle.Cipher.State.
         * Check if the context and crypt function are valid.
         */
        crypt_state = (struct Nettle_Cipher_State_struct *)
          get_inherit_storage(Pike_fp->current_object,
                              (inh - Pike_fp->current_program->inherits));
        func = crypt_state->crypt;
        ctx = crypt_state->ctx;

        if (!func || !ctx) {
          Pike_error("State object is not initialized properly.\n");
        }
      }

      res = begin_shared_string((key->len + 15) & ~7);
      push_string(res);		/* Paranoia in case func() throws an error. */
      res->flags |= STRING_CLEAR_ON_EXIT;
      memcpy(res->str + 8, key->str, key->len);

      /* Initialize the iv. */
      switch(method) {
      case 0:
        memset(buf, 0xa6, 8);
        break;
      case 1:
        if (key->len + 8 < res->len) {
          memset(res->str + 8 + key->len, 0, res->len - (key->len + 8));
        }
        memcpy(buf, "\246YY\246\0\0\0\0", 8);
        {
          union {
            unsigned INT32 i32;
            p_wchar0 bin[4];
          } mli;
          mli.i32 = (unsigned INT32)key->len;
          for (k = 0; k < 4; k++) {
#if PIKE_BYTEORDER == 4321
            buf[k + 4] ^= mli.bin[k];
#else
            buf[k + 4] ^= mli.bin[3-k];
#endif
          }
        }
        break;
      }

      if (method && (res->len == 16)) {
        /* Short key. */
        memcpy(res->str, buf, 8);
        func(ctx, 16, STR0(res), STR0(res));
      } else {
        t.i64 = 0;
        for (j = 0; j < 6; j++) {
          for (i = 8; i < res->len; i += 8) {
            memcpy(buf + 8, res->str + i, 8);
            func(ctx, 16, buf, buf);
            memcpy(res->str + i, buf + 8, 8);
            t.i64++;
            for (k = 0; k < 8; k++) {
#if PIKE_BYTEORDER == 4321
              buf[k] ^= t.bin[k];
#else
              buf[k] ^= t.bin[7-k];
#endif
            }
          }
        }
        memcpy(res->str, buf, 8);
      }

      secure_zero(buf, sizeof(buf));

      add_ref(res);
      pop_stack();
      push_string(end_shared_string(res));
    }

    /*! @decl string(8bit) unwrap_key(string(8bit) wrap, int(0..1)|void method)
     *!
     *! The AES Key Unwrapping algorithms from @rfc{3394@} and @rfc{5649@}.
     *!
     *! @param wrap
     *!   Wrapped key to unwrap.
     *!
     *! @param method
     *!   Method that was used to wrap @[wrap]. See @[wrap_key()] for details.
     *!   @int
     *!     @value 0
     *!       @rfc{3394@}
     *!     @value 1
     *!       @rfc{5649@}
     *!   @endint
     *!
     *! This function is intended to be used to decode encryption keys
     *! that have been wrapped by @[wrap_key()].
     *!
     *! @returns
     *!   Returns the unwrapped key.
     *!
     *! @throws
     *!   Throws an error on failure to unwrap the key.
     *!
     *! @note
     *!   Assumes that the @[State] object has been initialized to
     *!   decryption mode (ie that @[set_decrypt_key()] has been called).
     *!
     *! @note
     *!   @rfc{6931:2.6.3@} indicates that the @rfc{3394@} algorithm
     *!   is also appropriate for @[Camellia].
     *!
     *! @seealso
     *!   @[wrap_key()]
     */
    PIKEFUN string(8bit) unwrap_key(string(8bit) wrap, int(0..1)|void _method)
    {
      int f, i, j, k;
      union {
        INT64 i64;
        p_wchar0 bin[8];
      } t;
      struct inherit *inh;
      p_wchar0 buf[AES_BLOCK_SIZE];
      struct pike_string *res;
      pike_nettle_crypt_func func = pike_crypt_func;
      void *ctx = Pike_fp->current_object;
      unsigned int method = _method?_method->u.integer:0;
      ptrdiff_t len = 24;

      switch(method) {
      case 0: break;
      case 1:
        len = 16;
        break;
      default:
        Pike_error("Unsupported key wrapping method.\n");
        break;
      }

      if ((wrap->len & 0x07) || (wrap->len < len)) {
        Pike_error("Unsupported wrapped key length.\n");
      }

      f = find_identifier("crypt", Pike_fp->current_program);
      if (f < 0) {
        Pike_error("State object has no crypt() function.\n");
      }

      inh = INHERIT_FROM_INT(Pike_fp->current_program, f);
      if (inh->prog == Nettle_Cipher_State_program) {
        struct Nettle_Cipher_State_struct *crypt_state;
        /* crypt() is from Nettle.Cipher.State.
         * Check if the context and crypt function are valid.
         */
        crypt_state = (struct Nettle_Cipher_State_struct *)
          get_inherit_storage(Pike_fp->current_object,
                              (inh - Pike_fp->current_program->inherits));
        func = crypt_state->crypt;
        ctx = crypt_state->ctx;

        if (!func || !ctx) {
          Pike_error("State object is not initialized properly.\n");
        }
      }

      res = begin_shared_string(wrap->len - 8);
      push_string(res);		/* Paranoia in case func() throws an error. */
      res->flags |= STRING_CLEAR_ON_EXIT;
      memcpy(buf, wrap->str, 8);
      memcpy(res->str, wrap->str + 8, wrap->len - 8);

      if (method && (wrap->len == 16)) {
        /* Short key. */
        memcpy(buf + 8, wrap->str + 8, 8);
        func(ctx, 16, buf, buf);
        memcpy(res->str, buf + 8, 8);
      } else {
        t.i64 = 6 * (res->len >> 3);
        for (j = 0; j < 6; j++) {
          for (i = res->len; i;) {
            i -= 8;
            for (k = 0; k < 8; k++) {
#if PIKE_BYTEORDER == 4321
              buf[k] ^= t.bin[k];
#else
              buf[k] ^= t.bin[7-k];
#endif
            }
            t.i64--;
            memcpy(buf + 8, res->str + i, 8);

            func(ctx, 16, buf, buf);
            memcpy(res->str + i, buf + 8, 8);
          }
        }
      }

      /* Validate the iv against the expected iv. */
      if (!method) {
        memset(buf + 8, 0xa6, 8);
        k = memcmp(buf, buf + 8, 8);
        len = res->len;
      } else {
        union {
          unsigned INT32 i32;
          p_wchar0 bin[4];
        } mli;
        k = memcmp(buf, "\246YY\246", 4);
        if (!k) {
          for (k = 0; k < 4; k++) {
#if PIKE_BYTEORDER == 4321
            mli.bin[k] = buf[k + 4];
#else
            mli.bin[3-k] = buf[k + 4];
#endif
          }
          len = (ptrdiff_t)mli.i32;
          if ((res->len >= len) && (res->len < len + 8)) {
            k = 0;
            while (res->len > len) {
              res->len--;
              k |= res->str[res->len];
            }
          }
        }
      }

      secure_zero(buf, sizeof(buf));

      if (k) {
        /* Bad IV! */
        pop_stack();
        Pike_error("Decoding failed.\n");
      }

      add_ref(res);
      pop_stack();

      push_string(end_and_resize_shared_string(res, len));
    }
  }
  /*! @endclass
   */

  /*! @module CCM
   *!
   *! Implementation of the Counter with Cipher Block Chaining
   *! Message Authentication Code mode (CCM).
   *!
   *! Works as a wrapper for the cipher implemented by overloading
   *! the parent class (@[BlockCipher16]).
   *!
   *! This is a so-called authenticated encryption with associated data
   *! (AEAD) algorithm, and in addition to encryption also provides
   *! message digests.
   *!
   *! The operation of CCM is specified in
   *! NIST Special Publication 800-38C.
   *!
   *! @note
   *!   This mode of operation is not suited for streaming operation,
   *!   as the sizes of the associated data and payload data need to
   *!   be known for the CBC-MAC operation to start. Currently this
   *!   means that the associated data and payload data are buffered
   *!   until @[State()->digest()] is called.
   *!
   *! @seealso
   *!   @[CCM8], @[CBC], @[GCM], @[CTR]
   */
  PIKEVAR object(Nettle_AEAD) CCM;

  PIKECLASS _CCM
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit __builtin.Nettle.AEAD
     */
    INHERIT "__builtin.Nettle.AEAD";

    /*! @decl inherit BlockCipher::CTR
     */
    EXTRA
    {
      /* Perform an inherit if the _CTR class that our parent contains
       * via its inherit of BlockCipher.
       */
      lexical_inherit(1, MK_STRING("_CTR"), 0, REPORT_ERROR, NULL);
    }

    /*! @decl string(8bit) name()
     *! Returns the name of the base cipher with @expr{".CCM"@} appended.
     */
    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, f_Nettle_Cipher_name_fun_num, args);
      push_static_text(".CCM");
      f_add(2);
    }

    /*! @decl int(4..16) digest_size()
     *! Default digest size.
     *!
     *! @returns
     *!   Returns @expr{16@}, but overloading via inherit is supported,
     *!   and may return any even number in the range @expr{[4..16]@}.
     *!
     *! @note
     *!   Note that the digest length is folded into the digest, so
     *!   it doesn't simply imply a truncation.
     */
    PIKEFUN int(4..16) digest_size()
    {
      push_int(16);
    }

    PIKEFUN int(1..) block_size()
    {
      apply_external(1, f_Nettle_Cipher_block_size_fun_num, args);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1, f_Nettle_Cipher_key_size_fun_num, args);
    }

    PIKEFUN int(1..) iv_size()
    {
      push_int(13);
    }

    /*! @class State
     */
    PIKECLASS State
      program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
    {
      /*! @decl inherit CTR::State
       */

      static int ccm_state_inh_ctr_state_create_fun_num = -1;
      static int ccm_state_inh_ctr_state_crypt_fun_num = -1;
      static int ccm_state_inh_ctr_state_set_encrypt_key_fun_num = -1;
      static int ccm_state_inh_ctr_state_set_decrypt_key_fun_num = -1;

      EXTRA
      {
	/* Perform an inherit of the _CTR.State class that our parent
	 * contains via its inherit of _CTR.
	 */
        if (lexical_inherit(1, MK_STRING("State"), 0, REPORT_ERROR, NULL)) {
	  /* We want to call some of our inherited functions recursively... */
	  ccm_state_inh_ctr_state_create_fun_num =
	    really_low_reference_inherited_identifier(NULL, 1,
		    f_Nettle_BlockCipher_cq__CTR_State_create_fun_num);
	  ccm_state_inh_ctr_state_crypt_fun_num =
	    really_low_reference_inherited_identifier(NULL, 1,
		    f_Nettle_BlockCipher_cq__CTR_State_crypt_fun_num);
	  ccm_state_inh_ctr_state_set_encrypt_key_fun_num =
	    really_low_reference_inherited_identifier(NULL, 1,
		    f_Nettle_BlockCipher_cq__CTR_State_set_encrypt_key_fun_num);
	  ccm_state_inh_ctr_state_set_decrypt_key_fun_num =
	    really_low_reference_inherited_identifier(NULL, 1,
		    f_Nettle_BlockCipher_cq__CTR_State_set_decrypt_key_fun_num);
	}
      }

      CVAR int decrypt_mode;

      PIKEVAR string(8bit) mac_mask flags ID_PRIVATE;

      PIKEVAR string(8bit) nonce flags ID_PROTECTED;

      CVAR struct string_builder abuf;
      CVAR struct string_builder pbuf;

      CVAR struct Nettle_BlockCipher_cq__CTR_State_struct *ctr;

      INIT
      {
	init_string_builder(&THIS->abuf, 0);
	init_string_builder(&THIS->pbuf, 0);

	ASSIGN_CURRENT_STORAGE(THIS->ctr,
			       struct Nettle_BlockCipher_cq__CTR_State_struct,
			       1, Nettle_BlockCipher_cq__CTR_State_program);
      }

      EXIT
      {
        free_string_builder(&THIS->abuf);
	free_string_builder(&THIS->pbuf);
      }

      /*! @decl void create()
       */
      PIKEFUN void create()
	flags ID_PROTECTED;
      {
	apply_current(ccm_state_inh_ctr_state_create_fun_num, args);
	pop_stack();
	if (THIS->ctr->block_size != 16) {
	  Pike_error("Invalid block cipher for CCM: %d.\n",
		     THIS->ctr->block_size);
	}
	reset_string_builder(&THIS->abuf);
	reset_string_builder(&THIS->pbuf);

	if (THIS->nonce) free_string(THIS->nonce);
	THIS->nonce = NULL;
      }

      PIKEFUN string(8bit) name()
      {
	apply(THIS->ctr->object, "name", args);
	push_static_text(".CCM");
	f_add(2);
      }

      PIKEFUN object(Nettle_AEAD_State) set_encrypt_key(string(8bit) key,
							int|void flags)
      {
	reset_string_builder(&THIS->abuf);
	reset_string_builder(&THIS->pbuf);
	THIS->decrypt_mode = 0;
	apply_current(ccm_state_inh_ctr_state_set_encrypt_key_fun_num, args);
      }

      PIKEFUN object(Nettle_AEAD_State) set_decrypt_key(string(8bit) key,
							int|void flags)
      {
	reset_string_builder(&THIS->abuf);
	reset_string_builder(&THIS->pbuf);
	THIS->decrypt_mode = 1;
	apply_current(ccm_state_inh_ctr_state_set_decrypt_key_fun_num, args);
      }

      PIKEFUN object(Nettle_AEAD_State) set_iv(string(8bit) iv)
      {
	int iv_len = iv->len;
	uint8_t *ctr_iv;

	iv->flags |= STRING_CLEAR_ON_EXIT;
	NO_WIDE_STRING(iv);
        if (iv_len < 7 || iv_len > 13) {
          Pike_error("Nonce length must be between 7 and 13 bytes.\n");
	}

	reset_string_builder(&THIS->abuf);
	reset_string_builder(&THIS->pbuf);
        if (THIS->nonce) {
	  free_string(THIS->nonce);
	  THIS->nonce = NULL;
	}
        add_ref(THIS->nonce = iv);

	ctr_iv = STR0(THIS->ctr->iv);

	*(ctr_iv++) = 14 - iv_len;

	memcpy(ctr_iv, STR0(iv), iv_len);
	memset(ctr_iv + iv_len, 0, 15 - iv_len);

	RETURN this_object();
      }

      PIKEFUN int(0..) iv_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
        if( THIS->nonce )
          push_int(THIS->nonce->len);
        else
          push_int(13);
      }


      PIKEFUN object(Nettle_AEAD_State) update(string(8bit) public_data)
      {
	if (!public_data->len) return;

	NO_WIDE_STRING(public_data);

	string_builder_shared_strcat(&THIS->abuf, public_data);

	RETURN this_object();
      }

      static void blockcipher16_ccm_init_mac_mask()
      {
	struct pike_string *mac_mask;

	if (!THIS->nonce) {
	  /* NB: Default to nonce of 13 NULs. */
	  add_ref(THIS->nonce = nul13_string);
          memcpy(STR0(THIS->ctr->iv), "\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16);
	}

	/* Save the first block from the CTR to encrypt the MAC. */
	ref_push_string(nul16_string);

	apply_current(ccm_state_inh_ctr_state_crypt_fun_num, 1);

        get_all_args(NULL, 1, "%n", &mac_mask);
	NO_WIDE_STRING(mac_mask);
	if (mac_mask->len != 16) {
	  Pike_error("Bad string length %ld returned from crypt()\n",
                     (long)mac_mask->len);
	}
	if (THIS->mac_mask) free_string(THIS->mac_mask);
	add_ref(THIS->mac_mask = mac_mask);
	pop_stack();
      }

      PIKEFUN string(8bit) crypt(string(8bit) data)
      {
	if (!data->len) {
	  return;
	}

	NO_WIDE_STRING(data);

	if (!THIS->pbuf.s->len) {
          blockcipher16_ccm_init_mac_mask();
	}

	if (!THIS->decrypt_mode) {
	  string_builder_shared_strcat(&THIS->pbuf, data);
	}

	apply_current(ccm_state_inh_ctr_state_crypt_fun_num, args);

	if (THIS->decrypt_mode) {
          get_all_args(NULL, 1, "%n", &data);

	  NO_WIDE_STRING(data);

	  string_builder_shared_strcat(&THIS->pbuf, data);
	}
      }

      /*! @decl int(4..16) digest_size()
       *!
       *! Default digest size.
       *!
       *! This function is used by @[digest()] to determine the digest
       *! size if no argument was given.
       *!
       *! @returns
       *!   The default implementation returns the result from calling
       *!   @[global::digest_size()], but overloading via inherit is supported,
       *!   and may return any even number in the range @expr{[4..16]@}.
       *!
       *! @note
       *!   Note that the digest length is folded into the digest, so
       *!   it doesn't simply imply a truncation.
       *!
       *! @seealso
       *!   @[digest()], @[CCM::digest_size()]
       */
      PIKEFUN int(4..16) digest_size()
      {
	apply_external(1, f_Nettle_BlockCipher16_cq__CCM_digest_size_fun_num,
		       args);
      }

      static void pike_low_ccm_digest(struct pike_string *res,
				      struct pike_string *nonce,
				      struct pike_string *mac_mask,
				      struct pike_string *astr,
				      struct pike_string *pstr,
				      pike_nettle_crypt_func func,
				      void *ctx)
      {
	uint8_t buf[2][16];
	size_t bytes = res->len;
	size_t psize = pstr->len;
	int i;
	int flags;
	int bufno = 0;
	uint8_t *ptr;

	flags = ((bytes-2)<<2) | (14 - nonce->len);
	if (astr->len) {
	  // Set the a-bit.
	  flags |= 0x40;
	}

	psize = pstr->len;

	/* NB: The nonce has a minimum size of 7 bytes.
	 *     Thus we need at most 8 bytes for the psize.
	 */
	/* |flags|nonce|psize| */
	ptr = buf[0] + 8;
	for (i = 8; i--; psize >>= 8) {
	  ptr[i] = psize & 0xff;
	}
	buf[0][0] = flags;
	memcpy(buf[0]+1, STR0(nonce), nonce->len);

	func(ctx, 16, buf[1], buf[0]);
	bufno = 1;

	if (astr->len) {
	  size_t asize = astr->len;
	  ptr = STR0(astr);
	  if (asize < 0xff00) {
	    buf[1][0] ^= (asize >> 8) & 0xff;
	    buf[1][1] ^= asize & 0xff;
	    if (asize < 14) {
	      memxor(buf[1]+2, ptr, asize);
	      asize = 0;
	    } else {
	      memxor(buf[1]+2, ptr, 14);
	      ptr += 14;
	      asize -= 14;
	    }
#if (SIZEOF_CHARP > 4)
	  } else if (asize > 0xffffffffUL) {
	    buf[1][0] ^= 0xff;
	    buf[1][1] ^= 0xff;
	    buf[1][2] ^= (asize >> 56) & 0xff;
	    buf[1][3] ^= (asize >> 48) & 0xff;
	    buf[1][4] ^= (asize >> 40) & 0xff;
	    buf[1][5] ^= (asize >> 32) & 0xff;
	    buf[1][6] ^= (asize >> 24) & 0xff;
	    buf[1][7] ^= (asize >> 16) & 0xff;
	    buf[1][8] ^= (asize >> 8) & 0xff;
	    buf[1][9] ^= asize & 0xff;
	    memxor(buf[1]+10, ptr, 6);
	    ptr += 6;
	    asize -= 6;
#endif
	  } else {
	    buf[1][0] ^= 0xff;
	    buf[1][1] ^= 0xfe;
	    buf[1][2] ^= (asize >> 24) & 0xff;
	    buf[1][3] ^= (asize >> 16) & 0xff;
	    buf[1][4] ^= (asize >> 8) & 0xff;
	    buf[1][5] ^= asize & 0xff;
	    memxor(buf[1]+6, ptr, 10);
	    ptr += 10;
	    asize -= 10;
	  }

	  func(ctx, 16, buf[0], buf[1]);
	  bufno = 0;

	  for (;asize >= 16; asize -= 16, ptr += 16) {
	    memxor(buf[bufno], ptr, 16);
	    func(ctx, 16, buf[!bufno], buf[bufno]);
	    bufno = !bufno;
	  }
	  if (asize) {
	    memxor(buf[bufno], ptr, asize);
	    func(ctx, 16, buf[!bufno], buf[bufno]);
	    bufno = !bufno;
	  }
	}

	ptr = STR0(pstr);
	psize = pstr->len;

	for (; psize >= 16; psize -= 16, ptr += 16) {
	  memxor(buf[bufno], ptr, 16);
	  func(ctx, 16, buf[!bufno], buf[bufno]);
	  bufno = !bufno;
	}
	if (psize) {
	  memxor(buf[bufno], ptr, psize);
	  func(ctx, 16, buf[!bufno], buf[bufno]);
	  bufno = !bufno;
	}

	memxor3(STR0(res), buf[bufno], STR0(mac_mask), bytes);
      }

      /*! @decl string(8bit) digest(int(4..16)|void bytes)
       *!
       *! Returns the CBC-MAC digest of the specified size.
       *!
       *! @param bytes
       *!   Size in bytes for the desired digest. Any even number in
       *!   the range @expr{[4..16]@}. If not specified the value from
       *!   calling @[digest_size()] will be used.
       *!
       *! @note
       *!   Note that the digest length is folded into the digest, so
       *!   it doesn't simply imply a truncation.
       *!
       *! @seealso
       *!   @[digest_size()], @[global::digest_size()]
       */
      PIKEFUN string(8bit) digest(int(4..16)|void bytes_p)
      {
	int bytes = 0;
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->ctr->object;
	struct pike_string *res;
	struct pike_string *nonce = THIS->nonce;
	struct pike_string *mac_mask = THIS->mac_mask;
	struct pike_string *astr = THIS->abuf.s;
	struct pike_string *pstr = THIS->pbuf.s;

	if (bytes_p) {
	  bytes = bytes_p->u.integer;
	  if (bytes & 1) {
	    bytes++;
	  }
	}
	if (!bytes) {
	  apply_current(f_Nettle_BlockCipher16_cq__CCM_State_digest_size_fun_num,
			0);
          get_all_args(NULL, 1, "%d", &bytes);
	}
	if (bytes < 4) {
	  bytes = 4;
	} else if (bytes > 16) {
	  bytes = 16;
	}

	res = begin_shared_string(bytes);

	if (!pstr->len) {
	  // Unlikely, but make sure that it is initialized.
          blockcipher16_ccm_init_mac_mask();
	  mac_mask = THIS->mac_mask;
	}

	if (THIS->ctr->crypt_state && THIS->ctr->crypt_state->crypt) {
	  func = THIS->ctr->crypt_state->crypt;
	  ctx = THIS->ctr->crypt_state->ctx;
	}

	if (((THIS->abuf.s->len + THIS->pbuf.s->len) >=
	     CIPHER_THREADS_ALLOW_THRESHOLD) &&
	    (func != pike_crypt_func)) {
	  /* NB: This is a rather expensive MAC, as it is based
	   *     on encrypting with CBC. */
	  /* Protect stuff in the object from being freed
	   * by a different thread while we use them.
	   */
	  add_ref(nonce);
	  add_ref(mac_mask);
	  add_ref(astr);
	  add_ref(pstr);

	  THREADS_ALLOW();
	  pike_low_ccm_digest(res, nonce, mac_mask, astr, pstr, func, ctx);
	  THREADS_DISALLOW();

	  free_string(pstr);
	  free_string(astr);
	  free_string(mac_mask);
	  free_string(nonce);
	} else {
	  pike_low_ccm_digest(res, nonce, mac_mask, astr, pstr, func, ctx);
	}

	reset_string_builder(&THIS->pbuf);
	reset_string_builder(&THIS->abuf);

	push_string(end_shared_string(res));
      }
    }
    /*! @endclass State
     */
  }
  /*! @endmodule CCM
   */

  /*! @module CCM8
   *!
   *! Special case of @[CCM] where the default digest size
   *! has been truncated to @expr{8@} bytes.
   *!
   *! @seealso
   *!   @[CCM], @[CBC], @[GCM], @[CTR]
   */
  PIKEVAR object(Nettle_AEAD) CCM8;

  PIKECLASS _CCM8
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit CCM
     */
    EXTRA
    {
      /* Perform an inherit of the _CCM class that our parent contains.
       */
      /* FIXME: */
      if (Nettle_BlockCipher16_cq__CCM_program) {
	low_inherit(Nettle_BlockCipher16_cq__CCM_program, 0,
		    Nettle_BlockCipher16_cq__CCM_program_fun_num,
                    1 + 42, 0, NULL, NULL);
      } else {
	yyerror("Symbol to inherit (_CCM) not found in parent scope #1.");
      }
    }

    /*! @decl string(8bit) name()
     *! Returns the name of the base cipher with @expr{".CCM8"@} appended.
     */
    PIKEFUN string(7bit) name()
    {
      apply_external(1, f_Nettle_Cipher_name_fun_num, args);
      push_static_text(".CCM8");
      f_add(2);
    }

    /*! @decl int(4..16) digest_size()
     *! Default digest size.
     *!
     *! @returns
     *!   Returns @expr{8@}, but overloading via inherit is supported,
     *!   and may return any even number in the range @expr{[4..16]@}.
     */
    PIKEFUN int(4..16) digest_size()
    {
      push_int(8);
    }
  }
  /*! @endmodule CCM8
   */

#ifdef HAVE_NETTLE_EAX_H

#include <nettle/eax.h>

  /*! @module EAX
   *!
   *! Implementation of the EAX mode.
   *!
   *! Works as a wrapper for the cipher implemented by overloading
   *! the parent class (@[BlockCipher16]).
   *!
   *! This is a so-called authenticated encryption with associated data
   *! (AEAD) algorithm, and in addition to encryption also provides
   *! message digests.
   *!
   *! @note
   *!   This mode of operation was specified as a reaction to the
   *!   limitiations of the @[BlockCipher16.CCM] mode.
   *!
   *! @note
   *!   Requires Nettle 3.0 or later.
   *!
   *! @seealso
   *!   @[CBC], @[CTR], @[BlockCipher16.CCM], @[BlockCipher16.GCM]
   */
  PIKEVAR object(Nettle_AEAD) EAX
    /* NB: Solaris 11/x86 has a conflicting #define of EAX in <sys/regset.h>,
     *     which gets included when __EXTENSIONS__ is defined.
     */
    c_name EAX_object;

  PIKECLASS _EAX
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit __builtin.Nettle.AEAD
     */
    INHERIT "__builtin.Nettle.AEAD";

    /*! @decl string(8bit) name()
     *! Returns the name of the base cipher with @expr{".EAX"@} appended.
     */
    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, f_Nettle_Cipher_name_fun_num, args);
      push_static_text(".EAX");
      f_add(2);
    }

    /*! @decl int(1..) digest_size()
     *! Default digest size.
     *!
     *! @returns
     *!   Returns @[BlockCipher::block_size()], but overloading via
     *!   inherit is supported, and may return any positive number
     *!   @expr{<= BlockCipher::block_size()@}.
     */
    PIKEFUN int(1..) digest_size()
    {
      apply_external(1, f_Nettle_Cipher_block_size_fun_num, args);
    }

    PIKEFUN int(1..) block_size()
    {
      apply_external(1, f_Nettle_Cipher_block_size_fun_num, args);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1, f_Nettle_Cipher_key_size_fun_num, args);
    }

    PIKEFUN int(1..) iv_size()
    {
      apply_external(1, f_Nettle_Cipher_block_size_fun_num, args);
    }

    /*! @class State
     */
    PIKECLASS State
      program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT|PROGRAM_CLEAR_STORAGE;
    {
      PIKEVAR object object
	flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *crypt_state;
      CVAR int block_size;
      CVAR int mode;
      CVAR struct eax_key eax_key;
      CVAR struct eax_ctx eax_ctx;

      /*! @decl inherit AEAD::State
       */

      EXTRA
      {
	/* Perform an inherit of the State class (if any) that our parent
	 * may contain via its inherit of __builtin.Nettle.AEAD.
	 */
        lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
	flags ID_PROTECTED;
      {
	apply_external(2, Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       */
      PIKEFUN void create()
	flags ID_PROTECTED;
      {
	struct object *o;
	struct inherit *inh;
	int block_size;
	int f;

	apply_current(f_Nettle_BlockCipher16_cq__EAX_State_substate_factory_fun_num,
		      args);
	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  Pike_error("Unsupported return value from Cipher::State().\n");
	}
	o = Pike_sp[-1].u.object;
	if (!o->prog) {
	  Pike_error("Cipher::State() returned destructed object.\n");
	}

	f = find_identifier("crypt", o->prog);
	if (f < 0) {
	  Pike_error("State object has no crypt() function.\n");
	}

	apply(o, "block_size", 0);

	if(TYPEOF(Pike_sp[-1]) != T_INT)
	  Pike_error("block_size() didn't return an int.\n");

	block_size = Pike_sp[-1].u.integer;

	if (block_size != EAX_BLOCK_SIZE)
	  Pike_error("Bad block size for EAX: %d.\n", block_size);

	THIS->block_size = block_size;

	if (THIS->object) free_object(THIS->object);
	add_ref(THIS->object = o);

	inh = INHERIT_FROM_INT(o->prog, f);
	if (inh->prog == Nettle_Cipher_State_program) {
	  /* crypt() is from Nettle.Cipher.State.
	   */
	  THIS->crypt_state = (struct Nettle_Cipher_State_struct *)
	    get_inherit_storage(o, inh - o->prog->inherits);
	} else {
	  THIS->crypt_state = NULL;
	}

        THIS->mode = 0;
        pop_n_elems(2);
      }

      /*! @decl string(0..255) name()
       *! Returns the string @expr{"x.EAX"@} where x is the
       *! encapsulated algorithm.
       */
      PIKEFUN string(8bit) name()
      {
	apply(THIS->object, "name", args);
	push_static_text(".EAX");
	f_add(2);
      }

      /*! @decl int(16..16) block_size()
       *! Returns the block size of the encapsulated cipher,
       *! which is always @expr{16@} for EAX.
       */
      PIKEFUN int(16..16) block_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN EAX_BLOCK_SIZE;
      }

      /*! @decl int(1..16) digest_size()
       *!
       *! Default digest size.
       *!
       *! This function is used by @[digest()] to determine the digest
       *! size if no argument was given.
       *!
       *! @returns
       *!   The default implementation returns the result from calling
       *!   @[EAX::digest_size()], but overloading via inherit is supported,
       *!   and may return any even number in the range @expr{[1..16]@}.
       *!
       *! @seealso
       *!   @[digest()], @[EAX::digest_size()]
       */
      PIKEFUN int(1..16) digest_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	apply_external(1, f_Nettle_BlockCipher16_cq__EAX_digest_size_fun_num, args);
      }

      /*! @decl int(16..16) iv_size()
       *! Returns the recommended size for the initialization vector
       *! (ie @expr{16@}).
       *!
       *! Other sizes are allowed, but will be compressed or expanded
       *! to this size using the encapsulated cipher.
       */
      PIKEFUN int(16..16) iv_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN EAX_IV_SIZE;
      }

      /*! @decl int(1..) key_size()
       *! Returns the key size of the encapsulated cipher.
       */
      PIKEFUN int(1..) key_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
	apply(THIS->object, "key_size", args);
      }

      /*! @decl this_program set_encrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for encrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_decrypt_key()], @[set_iv()]
       */
      PIKEFUN object(Nettle_AEAD_State) set_encrypt_key(string(8bit) key,
							int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}
        eax_set_key(&THIS->eax_key, ctx, (pike_nettle_cipher_func)func);
	THIS->mode = 0;

	push_object(this_object());
      }

      /*! @decl this_program set_decrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for decrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_encrypt_key()], @[set_iv()]
       */
      PIKEFUN object(Nettle_AEAD_State) set_decrypt_key(string(8bit) key,
							int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	key->flags |= STRING_CLEAR_ON_EXIT;
	/* NOTE: EAX always uses the encryption function
	 *       of the underlying cipher!
	 */
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}
        eax_set_key(&THIS->eax_key, ctx, (pike_nettle_cipher_func)func);
	THIS->mode = 1;

	push_object(this_object());
      }

      PIKEFUN object(Nettle_AEAD_State) set_iv(string(8bit) iv)
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	int iv_len = iv->len;

	iv->flags |= STRING_CLEAR_ON_EXIT;
	NO_WIDE_STRING(iv);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	eax_set_nonce(&THIS->eax_ctx, &THIS->eax_key,
                      ctx, (pike_nettle_cipher_func)func,
                      iv->len, STR0(iv));

	RETURN this_object();
      }

      PIKEFUN object(Nettle_AEAD_State) update(string(8bit) public_data)
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;

	if (!public_data->len) return;

	NO_WIDE_STRING(public_data);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	eax_update(&THIS->eax_ctx, &THIS->eax_key,
                   ctx, (pike_nettle_cipher_func)func,
                   public_data->len, STR0(public_data));

	RETURN this_object();
      }

      PIKEFUN string(8bit) crypt(string(8bit) data)
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	struct pike_string *res;

	if (!data->len) {
	  return;
	}

	NO_WIDE_STRING(data);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	res = begin_shared_string(data->len);

	if (!THIS->mode) {
	  eax_encrypt(&THIS->eax_ctx, &THIS->eax_key,
                      ctx, (pike_nettle_cipher_func)func,
                      data->len, STR0(res), STR0(data));
	} else {
	  eax_decrypt(&THIS->eax_ctx, &THIS->eax_key,
                      ctx, (pike_nettle_cipher_func)func,
                      data->len, STR0(res), STR0(data));
	}

	push_string(end_shared_string(res));
      }

      /*! @decl string(8bit) digest(int(1..16)|void bytes)
       *!
       *! Returns the OMAC digest of the specified size.
       *!
       *! @param bytes
       *!   Size in bytes for the desired digest. Any number in the
       *!   range @expr{[1..16]@}. If not specified the value from
       *!   calling @[digest_size()] will be used.
       *!
       *! @seealso
       *!   @[digest_size()], @[global::digest_size()]
       */
      PIKEFUN string(8bit) digest(int(1..16)|void bytes_p)
      {
	int bytes = 0;
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	struct pike_string *res;

	if (bytes_p) {
	  bytes = bytes_p->u.integer;
	  if (bytes & 1) {
	    bytes++;
	  }
	}
	if (!bytes) {
	  apply_current(f_Nettle_BlockCipher16_cq__EAX_State_digest_size_fun_num,
			0);
          get_all_args(NULL, 1, "%d", &bytes);
	}
	if (bytes < 1) {
	  bytes = 1;
	} else if (bytes > EAX_DIGEST_SIZE) {
	  bytes = EAX_DIGEST_SIZE;
	}

	res = begin_shared_string(bytes);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	eax_digest(&THIS->eax_ctx, &THIS->eax_key,
                   ctx, (pike_nettle_cipher_func)func,
                   bytes, STR0(res));

	push_string(end_shared_string(res));
      }
    }
    /*! @endclass State
     */
  }
  /*! @endmodule EAX
   */
#endif /* HAVE_NETTLE_EAX_H */

#ifdef HAVE_NETTLE_GCM_H

#include <nettle/gcm.h>

  /*! @module GCM
   *! Implementation of the Galois Counter Mode (GCM).
   *!
   *! Works as a wrapper for the cipher implemented by overloading
   *! the parent class (@[BlockCipher16]).
   *!
   *! This is a so-called authenticated encryption with associated data
   *! (AEAD) algorithm, which in addition to encryption also provides
   *! message digests.
   *!
   *! The operation of GCM is specified in
   *! NIST Special Publication 800-38D.
   *!
   *! Typically accessed as @expr{Crypto.AES.GCM@} or
   *! @expr{Crypto.Camellia.GCM@}
   *!
   *! @note
   *!   Requires Nettle 2.2 or later.
   *!
   *! @seealso
   *!   @[CBC]
   */
  PIKEVAR object(Nettle_AEAD) GCM;

  PIKECLASS _GCM
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit __builtin.Nettle.AEAD
     */
    INHERIT "__builtin.Nettle.AEAD";

    /*! @decl string(0..255) name()
     *! Returns the name of the base cipher with @expr{".GCM"@} appended.
     */
    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, f_Nettle_Cipher_name_fun_num, args);
      push_static_text(".GCM");
      f_add(2);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1, f_Nettle_Cipher_key_size_fun_num, args);
    }

    /*! @decl int(16..16) block_size()
     *! Returns the block size of the encapsulated cipher,
     *! which is always @expr{16@} for GCM.
     */
    PIKEFUN int(16..16) block_size()
      optflags OPT_TRY_OPTIMIZE;
    {
      RETURN GCM_BLOCK_SIZE;
    }

    /*! @decl int(16..16) digest_size()
     *! Returns the size of the generated digest,
     *! which is always @expr{16@} for GCM.
     */
    PIKEFUN int(16..16) digest_size()
      optflags OPT_TRY_OPTIMIZE;
    {
      RETURN GCM_BLOCK_SIZE;
    }

    /*! @decl int(12..12) iv_size()
     *! Returns the recommended size for the initialization vector
     *! (ie @expr{12@}).
     *!
     *! Other sizes are allowed, but will be compressed or expanded
     *! to this size using the encapsulated cipher.
     */
    PIKEFUN int(12..12) iv_size()
      optflags OPT_TRY_OPTIMIZE;
    {
      RETURN GCM_IV_SIZE;
    }

    /*! @class State
     *!
     *! The state for a GCM instance.
     */
   PIKECLASS State
      program_flags PROGRAM_USES_PARENT|PROGRAM_NEEDS_PARENT|PROGRAM_CLEAR_STORAGE;
    {
      DOCSTART() @decl inherit AEAD::State
	DOCEND()

      EXTRA
      {
	/* Perform an inherit of the State class (if any) that our parent
	 * may contain via its inherit of __builtin.Nettle.AEAD.
	 */
        lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
      }

      PIKEVAR object object
	flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *crypt_state;
      CVAR INT32 mode;
      CVAR INT32 dmode;
      CVAR struct gcm_key gcm_key;
      CVAR struct gcm_ctx gcm_ctx;

      /* dmode flags */
#define NO_ADATA	1	/* Disallow associated data. */
#define NO_CDATA	2	/* Disallow crypted data. */

      INIT
      {
	THIS->mode = -1;
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
	flags ID_PROTECTED;
      {
	apply_external(2, Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       *!
       *! Initialize the GCM state with the @[Cipher::State] object
       *! returned by @[substate_factory()]. This is usually
       *! the State for the cipher implemented in the parent module.
       */
      PIKEFUN void create()
	flags ID_PROTECTED;
      {
	struct object *o;
	struct inherit *inh;
	int f;

	apply_current(f_Nettle_BlockCipher16_cq__GCM_State_substate_factory_fun_num,
		      0);
	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  Pike_error("Unsupported return value from Cipher::State().\n");
	}
	o = Pike_sp[-1].u.object;
	if (!o->prog) {
	  Pike_error("Cipher::State() returned destructed object.\n");
	}

	f = find_identifier("crypt", o->prog);
	if (f < 0) {
	  Pike_error("State object has no crypt() function.\n");
	}

	apply(o, "block_size", 0);

	if (TYPEOF(Pike_sp[-1]) != T_INT)
	  Pike_error("block_size() didn't return an int.\n");

	if (Pike_sp[-1].u.integer != GCM_BLOCK_SIZE)
	  Pike_error("cipher has an invalid block size for GCM.\n");

	if (THIS->object) free_object(THIS->object);
	add_ref(THIS->object = o);
        pop_stack();

	inh = INHERIT_FROM_INT(o->prog, f);
	if (inh->prog == Nettle_Cipher_State_program) {
	  /* crypt() is from Nettle.Cipher.State.
	   */
	  THIS->crypt_state = (struct Nettle_Cipher_State_struct *)
	    get_inherit_storage(o, inh - o->prog->inherits);
	} else {
	  THIS->crypt_state = NULL;
	}

        THIS->mode = -1;
      }

      /*! @decl string(0..255) name()
       *! Returns the string @expr{"x.GCM"@} where x is the
       *! encapsulated algorithm.
       */
      PIKEFUN string(0..255) name()
	optflags OPT_TRY_OPTIMIZE;
      {
	apply(THIS->object, "name", 0);
	push_static_text(".GCM");
	f_add(2);
      }

      /*! @decl int(16..16) block_size()
       *! Returns the block size of the encapsulated cipher,
       *! which is always @expr{16@} for GCM.
       */
      PIKEFUN int(16..16) block_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN GCM_BLOCK_SIZE;
      }

      /*! @decl int(16..16) digest_size()
       *! Returns the size of the generated digest,
       *! which is always @expr{16@} for GCM.
       */
      PIKEFUN int(16..16) digest_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN GCM_BLOCK_SIZE;
      }

      /*! @decl int(12..12) iv_size()
       *! Returns the recommended size for the initialization vector
       *! (ie @expr{12@}).
       *!
       *! Other sizes are allowed, but will be compressed or expanded
       *! to this size using the encapsulated cipher.
       */
      PIKEFUN int(12..12) iv_size()
	optflags OPT_TRY_OPTIMIZE;
      {
	RETURN GCM_IV_SIZE;
      }

      /*! @decl int(1..) key_size()
       *! Returns the key size of the encapsulated cipher.
       */
      PIKEFUN int(1..) key_size()
	optflags OPT_EXTERNAL_DEPEND;
      {
	apply(THIS->object, "key_size", args);
      }

      /*! @decl this_program set_encrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for encrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_decrypt_key()], @[set_iv()]
       */
      PIKEFUN object set_encrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	key->flags |= STRING_CLEAR_ON_EXIT;
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}
        gcm_set_key(&THIS->gcm_key, ctx, (pike_nettle_cipher_func)func);
	THIS->mode = 0;

	push_object(this_object());
      }

      /*! @decl this_program set_decrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for decrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_encrypt_key()], @[set_iv()]
       */
      PIKEFUN object set_decrypt_key(string(0..255) key, int|void flags)
	optflags OPT_SIDE_EFFECT;
      {
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	key->flags |= STRING_CLEAR_ON_EXIT;
	/* NOTE: GCM always uses the encryption function
	 *       of the underlying cipher!
	 */
	apply(THIS->object, "set_encrypt_key", args);
	pop_stack();

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}
        gcm_set_key(&THIS->gcm_key, ctx, (pike_nettle_cipher_func)func);
	THIS->mode = 1;

	push_object(this_object());
      }

      /*! @decl this_program set_iv(string(0..255) iv)
       *!
       *! Set the initialization vector to @[iv]. The @[iv] memory will be
       *! cleared before released.
       *!
       *! Also resets all state needed to start a new message.
       *!
       *! @note
       *!   For @[iv]s of length other than @expr{12@}, an encryption or
       *!   decryption key must have been set first.
       *!
       *! @seealso
       *!   @[set_encrypt_key()], @[set_decrypt_key()].
       */
      PIKEFUN object set_iv(string(0..255) iv)
	optflags OPT_SIDE_EFFECT;
      {
	iv->flags |= STRING_CLEAR_ON_EXIT;
	NO_WIDE_STRING(iv);
	if ((THIS->mode < 0) && (iv->len != GCM_IV_SIZE))
	  Pike_error("The key must be set to use an iv of length other than %d.\n",
		     GCM_IV_SIZE);
	gcm_set_iv(&THIS->gcm_ctx, &THIS->gcm_key, iv->len, STR0(iv));
	THIS->dmode = 0;
	RETURN this_object();
      }

      /*! @decl void update(string(0..255) public_data)
       *!
       *! Add @[public_data] to be authenticated.
       *!
       *! The length of @[public_data] MUST be a multiple of the
       *! block size (ie @expr{16@}) for all calls except the last.
       *!
       *! All calls of @[update()] need to be performed before
       *! any calls of @[crypt()].
       */
      PIKEFUN void update(string(0..255) data)
      {
	struct gcm_ctx *gcm_ctx = &THIS->gcm_ctx;
	struct gcm_key *gcm_key = &THIS->gcm_key;

	NO_WIDE_STRING(data);

	if (!THIS->object || !THIS->object->prog) {
	  Pike_error("Lookup in destructed object.\n");
	}

	if (THIS->mode < 0)
	  Pike_error("Key schedule not initialized.\n");

	if (THIS->dmode & NO_ADATA)
	  Pike_error("Public data not allowed now.\n");

	if (data->len >= HASH_THREADS_ALLOW_THRESHOLD) {
	  THREADS_ALLOW();
	  gcm_update(gcm_ctx, gcm_key, data->len, STR0(data));
	  THREADS_DISALLOW();
	} else {
	  gcm_update(gcm_ctx, gcm_key, data->len, STR0(data));
	}

	if (data->len & (GCM_BLOCK_SIZE - 1))
	  THIS->dmode |= NO_ADATA;
      }

      /*! @decl string(0..255) crypt(string(0..255) data)
       *!
       *! Encrypt/decrypt @[data] and return the result. @[data] must
       *! be an integral number of blocks.
       *!
       *! The length of @[data] MUST be a multiple of the block size
       *! (ie @expr{16@}) for all calls except the last.
       *!
       *! Neither the input or output data is not automatically memory
       *! scrubbed, unless @[String.secure] has been called on the data.
       *!
       *! @seealso
       *!   @[update()], @[digest()]
       */
      PIKEFUN string(0..255) crypt(string(0..255) data)
      {
	struct pike_string *result;
	ONERROR uwp;
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;
	struct gcm_ctx *gcm_ctx = &THIS->gcm_ctx;
	struct gcm_key *gcm_key = &THIS->gcm_key;

	NO_WIDE_STRING(data);

	if (!THIS->object || !THIS->object->prog) {
	  Pike_error("Lookup in destructed object.\n");
	}

	if (THIS->mode < 0)
	  Pike_error("Key schedule not initialized.\n");

	if (THIS->dmode & NO_CDATA)
	  Pike_error("More data not allowed before the iv is reset.\n");

	result = begin_shared_string(data->len);
	SET_ONERROR (uwp, do_free_string, result);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

	if (!THIS->mode) {
	  if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	      (func != pike_crypt_func)) {
	    THREADS_ALLOW();
            gcm_encrypt(gcm_ctx, gcm_key, ctx, (pike_nettle_cipher_func)func,
			data->len, STR0(result), STR0(data));
	    THREADS_DISALLOW();
	  } else {
            gcm_encrypt(gcm_ctx, gcm_key, ctx, (pike_nettle_cipher_func)func,
			data->len, STR0(result), STR0(data));
	  }
	} else {
	  if ((data->len >= CIPHER_THREADS_ALLOW_THRESHOLD) &&
	      (func != pike_crypt_func)) {
	    THREADS_ALLOW();
            gcm_decrypt(gcm_ctx, gcm_key, ctx, (pike_nettle_cipher_func)func,
			data->len, STR0(result), STR0(data));
	    THREADS_DISALLOW();
	  } else {
            gcm_decrypt(gcm_ctx, gcm_key, ctx, (pike_nettle_cipher_func)func,
			data->len, STR0(result), STR0(data));
	  }
	}

	THIS->dmode |= NO_ADATA;

	if (data->len & (GCM_BLOCK_SIZE - 1))
	  THIS->dmode |= NO_CDATA;

	pop_n_elems(args);
	push_string(end_shared_string(result));
	UNSET_ONERROR(uwp);
      }

      /*! @decl string(0..255) digest()
       *!
       *! Generate a message digest for the data accumulated so far.
       *!
       *! @note
       *!   @[set_iv()] needs to be called to start the next message.
       *!
       *! @seealso
       *!   @[update()], @[digest()]
       */
      PIKEFUN string(0..255) digest()
      {
	struct pike_string *result;
	ONERROR uwp;
	pike_nettle_crypt_func func = pike_crypt_func;
	void *ctx = THIS->object;

	if (!THIS->object || !THIS->object->prog) {
	  Pike_error("Lookup in destructed object.\n");
	}

	if (THIS->mode < 0)
	  Pike_error("Key schedule not initialized.\n");

	result = begin_shared_string(GCM_BLOCK_SIZE);
	SET_ONERROR (uwp, do_free_string, result);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  func = THIS->crypt_state->crypt;
	  ctx = THIS->crypt_state->ctx;
	}

        gcm_digest(&THIS->gcm_ctx, &THIS->gcm_key,
                   ctx, (pike_nettle_cipher_func)func,
		   GCM_BLOCK_SIZE, STR0(result));

	THIS->dmode |= NO_ADATA | NO_CDATA;

	pop_n_elems(args);
	push_string(end_shared_string(result));
	UNSET_ONERROR(uwp);
      }
    }
    /*! @endclass State
     */
  }

  /*! @endmodule GCM
   */

#endif /* HAVE_NETTLE_GCM_H */

#ifdef HAVE_NETTLE_CMAC_H

#include <nettle/cmac.h>

  /*!@module CMAC
   *!
   *! CMAC - Cipher-based Message Authentication Code
   *!
   *! This module implements the CMAC algorithm from @rfc{4493@}.
   *!
   *! @note
   *!   Requires Nettle 3.5 or later.
   */
  PIKEVAR object(Nettle_MAC) CMAC;

  PIKECLASS _CMAC
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit __builtin.Nettle.MAC
     */
    INHERIT "__builtin.Nettle.MAC";

    /*! @decl string(8bit) name()
     *! Returns the name of the base cipher with @expr{".CMAC"@} appended.
     */
    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, f_Nettle_Cipher_name_fun_num, args);
      push_static_text(".CMAC");
      f_add(2);
    }

    PIKEFUN int(16..16) digest_size()
    {
      push_int(16);
    }

    PIKEFUN int(16..16) block_size()
    {
      push_int(16);
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1, f_Nettle_Cipher_key_size_fun_num, args);
    }

    /* NB: No IV for CMAC. Use the default implementation of iv_size(). */

    /*! @class State
     */
    PIKECLASS State
      program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
    {
      DOCSTART() @decl inherit Cipher::State
	DOCEND()

      EXTRA
      {
	/* Perform an inherit of the State class (if any) that our parent
	 * may contain via its inherit of __builtin.Nettle.MAC.
	 */
        lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
      }

      CVAR struct cmac128_ctx cmac_ctx;
      CVAR struct cmac128_key cmac_key;
      PIKEVAR object object
	flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *crypt_state;

      PIKEFUN object(Nettle_MAC_State) init(string(8bit)|void data)
      {
	pike_nettle_crypt_func crypt_func = pike_crypt_func;
	void *crypt_ctx = THIS->object;

	cmac128_init(&THIS->cmac_ctx);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  crypt_func = THIS->crypt_state->crypt;
	  crypt_ctx = THIS->crypt_state->ctx;
	}

        cmac128_set_key(&THIS->cmac_key, crypt_ctx,
                        (pike_nettle_cipher_func)crypt_func);

	if (data) {
          cmac128_update(&THIS->cmac_ctx, crypt_ctx,
                         (pike_nettle_cipher_func)crypt_func,
			 data->len, STR0(data));
	}

	push_object(this_object());
      }

      PIKEFUN object(Nettle_MAC_State) update(string(8bit) data)
      {
	pike_nettle_crypt_func crypt_func = pike_crypt_func;
	void *crypt_ctx = THIS->object;

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  crypt_func = THIS->crypt_state->crypt;
	  crypt_ctx = THIS->crypt_state->ctx;
	}

        cmac128_update(&THIS->cmac_ctx, crypt_ctx,
                       (pike_nettle_cipher_func)crypt_func,
		       data->len, STR0(data));
      }

      PIKEFUN string(8bit) digest(int(1..16)|void length)
      {
	pike_nettle_crypt_func crypt_func = pike_crypt_func;
	void *crypt_ctx = THIS->object;
	struct pike_string *digest;
	unsigned len = CMAC128_DIGEST_SIZE;

	if (length) {
	  len = length->u.integer;
	  if ((len <= 0) || (len > CMAC128_DIGEST_SIZE)) {
	    Pike_error("Invalid digest length for CMAC.\n");
	  }
	}

	digest = begin_shared_string(len);

	if (THIS->crypt_state && THIS->crypt_state->crypt) {
	  crypt_func = THIS->crypt_state->crypt;
	  crypt_ctx = THIS->crypt_state->ctx;
	}

        cmac128_digest(&THIS->cmac_ctx, &THIS->cmac_key,
                       crypt_ctx, (pike_nettle_cipher_func)crypt_func,
		       len, STR0(digest));

	push_string(end_shared_string(digest));
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
	flags ID_PROTECTED;
      {
	apply_external(2, Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       */
      PIKEFUN void create(string key)
	flags ID_PROTECTED;
      {
	struct object *o;
	struct inherit *inh;
	int block_size;
	int f;

	apply_current(f_Nettle_BlockCipher16_cq__CMAC_State_substate_factory_fun_num,
		      args);
	if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
	  Pike_error("Unsupported return value from Cipher::State().\n");
	}
	o = Pike_sp[-1].u.object;
	if (!o->prog) {
	  Pike_error("Cipher::State() returned destructed object.\n");
	}

	f = find_identifier("crypt", o->prog);
	if (f < 0) {
	  Pike_error("State object has no crypt() function.\n");
	}

	apply(o, "block_size", 0);

	if(TYPEOF(Pike_sp[-1]) != T_INT)
	  Pike_error("block_size() didn't return an int.\n");

	block_size = Pike_sp[-1].u.integer;

	if (block_size != CMAC128_DIGEST_SIZE)
	  Pike_error("Bad block size for CMAC: %d.\n", block_size);

	if (THIS->object) free_object(THIS->object);
	add_ref(THIS->object = o);

	apply(o, "set_encrypt_key", args);
	pop_stack();

	inh = INHERIT_FROM_INT(o->prog, f);
	if (inh->prog == Nettle_Cipher_State_program) {
	  /* crypt() is from Nettle.Cipher.State.
	   */
	  THIS->crypt_state = (struct Nettle_Cipher_State_struct *)
	    get_inherit_storage(o, inh - o->prog->inherits);
	} else {
	  THIS->crypt_state = NULL;
	}

	apply_current(f_Nettle_BlockCipher16_cq__CMAC_State_init_fun_num, 0);
      }
    }
    /*! @endclass State
     */
  }
  /*! @endmodule CMAC
   */
#endif

  /* FIXME: Add support for CMAC64 (Nettle 3.6 and later). */

#if defined(HAVE_NETTLE_OCB_H) && defined(HAVE_NETTLE_OCB_ENCRYPT)

#include <nettle/ocb.h>

  /*! @module OCB
   *!
   *! Implementation of the OCB mode (@rfc{7253@}).
   *!
   *! Works as a wrapper for the cipher implemented by overloading
   *! the parent class (@[BlockCipher16]).
   *!
   *! OCB was initially an acronym for Offset CodeBook.
   *!
   *! This is a so-called authenticated encryption with associated data
   *! (AEAD) algorithm, and in addition to encryption also provides
   *! message digests.
   *!
   *! @note
   *!   This module requires Nettle 3.9 or later.
   *!
   *! @seealso
   *!   @[CBC], @[CTR], @[BlockCipher16.CCM], @[BlockCipher16.GCM]
   */
  PIKEVAR object(Nettle_AEAD) OCB;

  PIKECLASS _OCB
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit __builtin.Nettle.AEAD
     */
    INHERIT "__builtin.Nettle.AEAD";

    /*! @decl string(8bit) name()
     *! Returns the name of the base cipher with @expr{".OCB"@} appended.
     */
    PIKEFUN string(0..255) name()
      optflags OPT_TRY_OPTIMIZE;
    {
      apply_external(1, f_Nettle_Cipher_name_fun_num, args);
      push_static_text(".OCB");
      f_add(2);
    }

    /*! @decl int(16..16) digest_size()
     *!   Default digest size (16).
     */
    PIKEFUN int(16..16) digest_size()
    {
      RETURN OCB_DIGEST_SIZE;
    }

    PIKEFUN int(16..16) block_size()
    {
      RETURN OCB_BLOCK_SIZE;
    }

    PIKEFUN int(1..) key_size()
    {
      apply_external(1, f_Nettle_Cipher_key_size_fun_num, args);
    }

    PIKEFUN int(15..15) iv_size()
    {
      RETURN OCB_MAX_NONCE_SIZE;
    }

    /*! @class State
     */
    PIKECLASS State
      program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT|PROGRAM_CLEAR_STORAGE;
    {
      PIKEVAR object encrypt_object
        flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *encrypt_state;
      PIKEVAR object decrypt_object
        flags ID_PRIVATE|ID_PROTECTED|ID_HIDDEN;
      CVAR struct Nettle_Cipher_State_struct *decrypt_state;
      CVAR size_t tag_length;
      CVAR int mode;
      CVAR struct ocb_key ocb_key;
      CVAR struct ocb_ctx ocb_ctx;

      /*! @decl inherit AEAD::State
       */

      EXTRA
      {
        /* Perform an inherit of the State class (if any) that our parent
         * may contain via its inherit of __builtin.Nettle.AEAD.
         */
        lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
      }

      /*! @decl Cipher::State substate_factory()
       *!
       *! Returns the @[Cipher::State] object that this object
       *! is to operate on.
       *!
       *! Defaults to creating the State for the cipher implemented
       *! in the parent module.
       */
      PIKEFUN object(Nettle_Cipher_State) substate_factory()
        flags ID_PROTECTED;
      {
        apply_external(2, Nettle_Cipher_State_program_fun_num, 0);
      }

      /*! @decl void create()
       */
      PIKEFUN void create()
        flags ID_PROTECTED;
      {
        struct object *o;
        struct inherit *inh;
        int block_size;
        int f;

        apply_current(f_Nettle_BlockCipher16_cq__OCB_State_substate_factory_fun_num,
                      args);
        if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
          Pike_error("Unsupported return value from Cipher::State().\n");
        }
        o = Pike_sp[-1].u.object;
        if (!o->prog) {
          Pike_error("Cipher::State() returned destructed object.\n");
        }

        f = find_identifier("crypt", o->prog);
        if (f < 0) {
          Pike_error("State object has no crypt() function.\n");
        }

        apply(o, "block_size", 0);

        if(TYPEOF(Pike_sp[-1]) != T_INT)
          Pike_error("block_size() didn't return an int.\n");

        block_size = Pike_sp[-1].u.integer;

        if (block_size != OCB_BLOCK_SIZE)
          Pike_error("Bad block size for OCB: %d.\n", block_size);

        if (THIS->encrypt_object) free_object(THIS->encrypt_object);
        add_ref(THIS->encrypt_object = o);

        inh = INHERIT_FROM_INT(o->prog, f);
        if (inh->prog == Nettle_Cipher_State_program) {
          /* crypt() is from Nettle.Cipher.State.
           */
          THIS->encrypt_state = (struct Nettle_Cipher_State_struct *)
            get_inherit_storage(o, inh - o->prog->inherits);
        } else {
          THIS->encrypt_state = NULL;
        }

        THIS->mode = 0;
        pop_n_elems(2);

        apply_current(f_Nettle_BlockCipher16_cq__OCB_State_substate_factory_fun_num,
                      args);
        if (TYPEOF(Pike_sp[-1]) != T_OBJECT) {
          Pike_error("Unsupported return value from Cipher::State().\n");
        }
        o = Pike_sp[-1].u.object;
        if (!o->prog) {
          Pike_error("Cipher::State() returned destructed object.\n");
        }

        f = find_identifier("crypt", o->prog);
        if (f < 0) {
          Pike_error("State object has no crypt() function.\n");
        }

        apply(o, "block_size", 0);

        if(TYPEOF(Pike_sp[-1]) != T_INT)
          Pike_error("block_size() didn't return an int.\n");

        block_size = Pike_sp[-1].u.integer;

        if (block_size != OCB_BLOCK_SIZE)
          Pike_error("Bad block size for OCB: %d.\n", block_size);

        if (THIS->decrypt_object) free_object(THIS->decrypt_object);
        add_ref(THIS->decrypt_object = o);

        inh = INHERIT_FROM_INT(o->prog, f);
        if (inh->prog == Nettle_Cipher_State_program) {
          /* crypt() is from Nettle.Cipher.State.
           */
          THIS->decrypt_state = (struct Nettle_Cipher_State_struct *)
            get_inherit_storage(o, inh - o->prog->inherits);
        } else {
          THIS->decrypt_state = NULL;
        }

        THIS->mode = 0;
        pop_n_elems(2);
      }

      /*! @decl string(0..255) name()
       *! Returns the string @expr{"x.OCB"@} where x is the
       *! encapsulated algorithm.
       */
      PIKEFUN string(8bit) name()
      {
        apply(THIS->encrypt_object, "name", args);
        push_static_text(".OCB");
        f_add(2);
      }

      /*! @decl int(16..16) block_size()
       *! Returns the block size of the encapsulated cipher,
       *! which is always @expr{16@} for OCB.
       */
      PIKEFUN int(16..16) block_size()
        optflags OPT_TRY_OPTIMIZE;
      {
        RETURN OCB_BLOCK_SIZE;
      }

      /*! @decl int(1..16) digest_size()
       *!
       *! Digest size as set by @[set_iv()].
       *!
       *! @seealso
       *!   @[digest()], @[OCB::digest_size()]
       */
      PIKEFUN int(1..16) digest_size()
        optflags OPT_TRY_OPTIMIZE;
      {
        if (!THIS->tag_length) {
          THIS->tag_length = OCB_DIGEST_SIZE;
        }
        push_int(THIS->tag_length);
      }

      /*! @decl int(15..15) iv_size()
       *! Returns the recommended size for the initialization vector
       *! (ie @expr{15@}).
       *!
       *! Other sizes are allowed, but will be compressed or expanded
       *! to this size using the encapsulated cipher.
       */
      PIKEFUN int(15..15) iv_size()
        optflags OPT_TRY_OPTIMIZE;
      {
        RETURN OCB_MAX_NONCE_SIZE;
      }

      /*! @decl int(1..) key_size()
       *! Returns the key size of the encapsulated cipher.
       */
      PIKEFUN int(1..) key_size()
        optflags OPT_EXTERNAL_DEPEND;
      {
        apply(THIS->encrypt_object, "key_size", args);
      }

      /*! @decl this_program set_encrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for encrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_decrypt_key()], @[set_iv()]
       */
      PIKEFUN object(Nettle_AEAD_State) set_encrypt_key(string(8bit) key,
                                                        int|void flags)
        optflags OPT_SIDE_EFFECT;
      {
        pike_nettle_crypt_func func = pike_crypt_func;
        void *ctx = THIS->encrypt_object;
        key->flags |= STRING_CLEAR_ON_EXIT;

        if (args > 2) {
          /* Paranoia */
          pop_n_elems(args - 2);
        }
        if ((args > 1) && !flags) pop_stack();

        args = 1;
        ref_push_string(key);
        if (flags) {
          push_svalue(flags);
          args = 2;
        }
        apply(THIS->encrypt_object, "set_encrypt_key", args);
        pop_stack();

        apply(THIS->decrypt_object, "set_decrypt_key", args);
        pop_stack();

        if (THIS->encrypt_state && THIS->encrypt_state->crypt) {
          func = THIS->encrypt_state->crypt;
          ctx = THIS->encrypt_state->ctx;
        }
        ocb_set_key(&THIS->ocb_key, ctx, (pike_nettle_cipher_func)func);
        THIS->mode = 0;

        push_object(this_object());
      }

      /*! @decl this_program set_decrypt_key(string(0..255) key, int|void flags)
       *!
       *! Prepare the cipher and the wrapper for decrypting with the given
       *! @[key]. The @[key] memory will be cleared before released.
       *!
       *! @note
       *!   Note that this operation does not by itself reset the
       *!   context sufficiently to start a new message; @[set_iv()]
       *!   needs to be called too.
       *!
       *! @seealso
       *!   @[set_encrypt_key()], @[set_iv()]
       */
      PIKEFUN object(Nettle_AEAD_State) set_decrypt_key(string(8bit) key,
                                                        int|void flags)
        optflags OPT_SIDE_EFFECT;
      {
        pike_nettle_crypt_func func = pike_crypt_func;
        void *ctx = THIS->encrypt_object;
        key->flags |= STRING_CLEAR_ON_EXIT;

        if (args > 2) {
          /* Paranoia */
          pop_n_elems(args - 2);
        }
        if ((args > 1) && !flags) pop_stack();

        args = 1;
        ref_push_string(key);
        if (flags) {
          push_svalue(flags);
          args = 2;
        }
        /* NOTE: OCB always uses the encryption function
         *       of the underlying cipher!
         */
        apply(THIS->encrypt_object, "set_encrypt_key", args);
        pop_stack();

        apply(THIS->decrypt_object, "set_decrypt_key", args);
        pop_stack();

        if (THIS->encrypt_state && THIS->encrypt_state->crypt) {
          func = THIS->encrypt_state->crypt;
          ctx = THIS->encrypt_state->ctx;
        }
        ocb_set_key(&THIS->ocb_key, ctx, (pike_nettle_cipher_func)func);
        THIS->mode = 1;

        push_object(this_object());
      }

      PIKEFUN object(Nettle_AEAD_State) set_iv(string(8bit) iv,
                                               int(1..16)|void tag_length)
      {
        pike_nettle_crypt_func func = pike_crypt_func;
        void *ctx = THIS->encrypt_object;
        int iv_len = iv->len;
        uint8_t *ctr_iv;
        THIS->tag_length = tag_length?tag_length->u.integer:OCB_DIGEST_SIZE;

        iv->flags |= STRING_CLEAR_ON_EXIT;
        NO_WIDE_STRING(iv);

        if (THIS->encrypt_state && THIS->encrypt_state->crypt) {
          func = THIS->encrypt_state->crypt;
          ctx = THIS->encrypt_state->ctx;
        }

        ocb_set_nonce(&THIS->ocb_ctx, ctx, (pike_nettle_cipher_func)func,
                      THIS->tag_length, iv->len, STR0(iv));

        RETURN this_object();
      }

      PIKEFUN object(Nettle_AEAD_State) update(string(8bit) public_data)
      {
        pike_nettle_crypt_func func = pike_crypt_func;
        void *ctx = THIS->encrypt_object;

        if (!public_data->len) return;

        NO_WIDE_STRING(public_data);

        if (THIS->encrypt_state && THIS->encrypt_state->crypt) {
          func = THIS->encrypt_state->crypt;
          ctx = THIS->encrypt_state->ctx;
        }

        ocb_update(&THIS->ocb_ctx, &THIS->ocb_key,
                   ctx, (pike_nettle_cipher_func)func,
                   public_data->len, STR0(public_data));

        RETURN this_object();
      }

      PIKEFUN string(8bit) crypt(string(8bit) data)
      {
        pike_nettle_crypt_func func = pike_crypt_func;
        void *ctx = THIS->encrypt_object;
        struct pike_string *res;

        if (!data->len) {
          return;
        }

        NO_WIDE_STRING(data);

        if (THIS->encrypt_state && THIS->encrypt_state->crypt) {
          func = THIS->encrypt_state->crypt;
          ctx = THIS->encrypt_state->ctx;
        }

        res = begin_shared_string(data->len);

        if (!THIS->mode) {
          ocb_encrypt(&THIS->ocb_ctx, &THIS->ocb_key,
                      ctx, (pike_nettle_cipher_func)func,
                      data->len, STR0(res), STR0(data));
        } else {
          pike_nettle_crypt_func dfunc = pike_crypt_func;
          void *dctx = THIS->decrypt_object;

          if (THIS->decrypt_state && THIS->decrypt_state->crypt) {
            dfunc = THIS->decrypt_state->crypt;
            dctx = THIS->decrypt_state->ctx;
          }

          ocb_decrypt(&THIS->ocb_ctx, &THIS->ocb_key,
                      ctx, (pike_nettle_cipher_func)func,
                      dctx, (pike_nettle_cipher_func)dfunc,
                      data->len, STR0(res), STR0(data));
        }

        push_string(end_shared_string(res));
      }

      /*! @decl string(8bit) digest()
       *!
       *! Returns the OCB authentication tag.
       *!
       *! @note
       *!   The size of the digest is specified in the call to
       *!   @[set_iv()].
       *!
       *! @seealso
       *!   @[set_iv()], @[digest_size()], @[global::digest_size()]
       */
      PIKEFUN string(8bit) digest()
      {
        int bytes = 0;
        pike_nettle_crypt_func func = pike_crypt_func;
        void *ctx = THIS->encrypt_object;
        struct pike_string *res;

        if (!THIS->tag_length) {
          THIS->tag_length = OCB_DIGEST_SIZE;
        }

        res = begin_shared_string(THIS->tag_length);

        if (THIS->encrypt_state && THIS->encrypt_state->crypt) {
          func = THIS->encrypt_state->crypt;
          ctx = THIS->encrypt_state->ctx;
        }

        ocb_digest(&THIS->ocb_ctx, &THIS->ocb_key,
                   ctx, (pike_nettle_cipher_func)func,
                   THIS->tag_length, STR0(res));

        push_string(end_shared_string(res));
      }
    }
    /*! @endclass State
     */
  }
  /*! @endmodule OCB
   */
#endif /* HAVE_NETTLE_OCB_H && HAVE_NETTLE_OCB_ENCRYPT */

  /* NB: Declare the storage explicitly to avoid having it declared
   *     inside the #ifdef above.
   */
  DECLARE_STORAGE;

  INIT
  {
    apply_current(Nettle_BlockCipher16_cq__CCM_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER16->CCM = Pike_sp[-1].u.object);
    }
    pop_stack();
    apply_current(Nettle_BlockCipher16_cq__CCM8_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER16->CCM8 = Pike_sp[-1].u.object);
    }
    pop_stack();
#ifdef HAVE_NETTLE_EAX_H
    apply_current(Nettle_BlockCipher16_cq__EAX_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER16->EAX_object = Pike_sp[-1].u.object);
    }
    pop_stack();
#endif
#ifdef HAVE_NETTLE_GCM_H
    apply_current(Nettle_BlockCipher16_cq__GCM_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER16->GCM = Pike_sp[-1].u.object);
    }
    pop_stack();
#endif
#ifdef HAVE_NETTLE_CMAC_H
    apply_current(Nettle_BlockCipher16_cq__CMAC_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER16->CMAC = Pike_sp[-1].u.object);
    }
    pop_stack();
#endif
#if defined(HAVE_NETTLE_OCB_H) && defined(HAVE_NETTLE_OCB_ENCRYPT)
    apply_current(Nettle_BlockCipher16_cq__OCB_program_fun_num, 0);
    if (TYPEOF(Pike_sp[-1]) == T_OBJECT) {
      add_ref(THIS_NETTLE_BLOCKCIPHER16->OCB = Pike_sp[-1].u.object);
    }
    pop_stack();
#endif
  }
}
/*! @endclass BlockCipher16
 */

#define BLOCKCIPHER16_CIPHER_INHERIT	(BLOCKCIPHER_CIPHER_INHERIT + 1)

#ifndef HAVE_NETTLE_AES128_ENCRYPT
#define aes128_ctx	aes_ctx
#define aes192_ctx	aes_ctx
#define aes256_ctx	aes_ctx
#define aes128_encrypt	aes_encrypt
#define aes128_decrypt	aes_decrypt
#define aes192_encrypt	aes_encrypt
#define aes192_decrypt	aes_decrypt
#define aes256_encrypt	aes_encrypt
#define aes256_decrypt	aes_decrypt
#endif

/* Some old versions of Nettle do not have these. */
#ifndef AES128_KEY_SIZE
#define AES128_KEY_SIZE	16
#endif
#ifndef AES192_KEY_SIZE
#define AES192_KEY_SIZE	24
#endif
#ifndef AES256_KEY_SIZE
#define AES256_KEY_SIZE	32
#endif

static void
pike_aes_set_encrypt_key(void *ctx,
			 ptrdiff_t length, const char *key,
			 int UNUSED(force))
{
  if (length == AES128_KEY_SIZE) {
#ifdef HAVE_NETTLE_STRUCT_AES_CTX_FIELD_KEY_SIZE
    aes128_set_encrypt_key(&((struct aes_ctx*)ctx)->u.ctx128,
			   (const uint8_t *)key);
#else
    aes_set_encrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else if (length == AES192_KEY_SIZE) {
#ifdef HAVE_NETTLE_STRUCT_AES_CTX_FIELD_KEY_SIZE
    aes192_set_encrypt_key(&((struct aes_ctx*)ctx)->u.ctx192,
			   (const uint8_t *)key);
#else
    aes_set_encrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else if (length == AES256_KEY_SIZE) {
#ifdef HAVE_NETTLE_STRUCT_AES_CTX_FIELD_KEY_SIZE
    aes256_set_encrypt_key(&((struct aes_ctx*)ctx)->u.ctx256,
			   (const uint8_t *)key);
#else
    aes_set_encrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else
    Pike_error("AES: Bad keysize for AES.\n");
#ifdef HAVE_NETTLE_STRUCT_AES_CTX_FIELD_KEY_SIZE
  ((struct aes_ctx*)ctx)->key_size = length;
#endif
}

static void
pike_aes_set_decrypt_key(void *ctx,
			 ptrdiff_t length, const char *key,
			 int UNUSED(force))
{
  if (length == AES128_KEY_SIZE) {
#ifdef HAVE_NETTLE_STRUCT_AES_CTX_FIELD_KEY_SIZE
    aes128_set_decrypt_key(&((struct aes_ctx*)ctx)->u.ctx128,
			   (const uint8_t *)key);
#else
    aes_set_decrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else if (length == AES192_KEY_SIZE) {
#ifdef HAVE_NETTLE_STRUCT_AES_CTX_FIELD_KEY_SIZE
    aes192_set_decrypt_key(&((struct aes_ctx*)ctx)->u.ctx192,
			   (const uint8_t *)key);
#else
    aes_set_decrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else if (length == AES256_KEY_SIZE) {
#ifdef HAVE_NETTLE_STRUCT_AES_CTX_FIELD_KEY_SIZE
    aes256_set_decrypt_key(&((struct aes_ctx*)ctx)->u.ctx256,
			   (const uint8_t *)key);
#else
    aes_set_decrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else
    Pike_error("AES: Bad keysize for AES.\n");
#ifdef HAVE_NETTLE_STRUCT_AES_CTX_FIELD_KEY_SIZE
  ((struct aes_ctx*)ctx)->key_size = length;
#endif
}

#ifdef HAVE_NETTLE_STRUCT_AES_CTX_FIELD_KEY_SIZE
/* Reimplementation of the deprecated API to avoid warnings. */
static void pike_aes_encrypt(const struct aes_ctx *ctx, size_t length,
			     uint8_t *dst, const uint8_t *src)
{
  switch(ctx->key_size) {
  case AES128_KEY_SIZE:
    aes128_encrypt(&ctx->u.ctx128, length, dst, src);
    break;
  case AES192_KEY_SIZE:
    aes192_encrypt(&ctx->u.ctx192, length, dst, src);
    break;
  case AES256_KEY_SIZE:
    aes256_encrypt(&ctx->u.ctx256, length, dst, src);
    break;
  }
}
static void pike_aes_decrypt(const struct aes_ctx *ctx, size_t length,
			     uint8_t *dst, const uint8_t *src)
{
  switch(ctx->key_size) {
  case AES128_KEY_SIZE:
    aes128_decrypt(&ctx->u.ctx128, length, dst, src);
    break;
  case AES192_KEY_SIZE:
    aes192_decrypt(&ctx->u.ctx192, length, dst, src);
    break;
  case AES256_KEY_SIZE:
    aes256_decrypt(&ctx->u.ctx256, length, dst, src);
    break;
  }
}
#define nettle_aes_encrypt	pike_aes_encrypt
#define nettle_aes_decrypt	pike_aes_decrypt
#endif

static void
pike_aes128_set_encrypt_key(void *ctx,
			    ptrdiff_t length, const char *key,
			    int UNUSED(force))
{
  if (length == AES128_KEY_SIZE) {
#ifdef HAVE_NETTLE_AES128_ENCRYPT
    aes128_set_encrypt_key(ctx, (const uint8_t *)key);
#else
    aes_set_encrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else
    Pike_error("AES128: Bad keysize for AES128.\n");
}

static void
pike_aes128_set_decrypt_key(void *ctx,
			    ptrdiff_t length, const char *key,
			    int UNUSED(force))
{
  if (length == AES128_KEY_SIZE) {
#ifdef HAVE_NETTLE_AES128_ENCRYPT
    aes128_set_decrypt_key(ctx, (const uint8_t *)key);
#else
    aes_set_decrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else
    Pike_error("AES128: Bad keysize for AES128.\n");
}

static void
pike_aes192_set_encrypt_key(void *ctx,
			    ptrdiff_t length, const char *key,
			    int UNUSED(force))
{
  if (length == AES192_KEY_SIZE) {
#ifdef HAVE_NETTLE_AES128_ENCRYPT
    aes192_set_encrypt_key(ctx, (const uint8_t *)key);
#else
    aes_set_encrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else
    Pike_error("AES192: Bad keysize for AES192.\n");
}

static void
pike_aes192_set_decrypt_key(void *ctx,
			    ptrdiff_t length, const char *key,
			    int UNUSED(force))
{
  if (length == AES192_KEY_SIZE) {
#ifdef HAVE_NETTLE_AES128_ENCRYPT
    aes192_set_decrypt_key(ctx, (const uint8_t *)key);
#else
    aes_set_decrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else
    Pike_error("AES192: Bad keysize for AES192.\n");
}

static void
pike_aes256_set_encrypt_key(void *ctx,
			    ptrdiff_t length, const char *key,
			    int UNUSED(force))
{
  if (length == AES256_KEY_SIZE) {
#ifdef HAVE_NETTLE_AES128_ENCRYPT
    aes256_set_encrypt_key(ctx, (const uint8_t *)key);
#else
    aes_set_encrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else
    Pike_error("AES256: Bad keysize for AES256.\n");
}

static void
pike_aes256_set_decrypt_key(void *ctx,
			    ptrdiff_t length, const char *key,
			    int UNUSED(force))
{
  if (length == AES256_KEY_SIZE) {
#ifdef HAVE_NETTLE_AES128_ENCRYPT
    aes256_set_decrypt_key(ctx, (const uint8_t *)key);
#else
    aes_set_decrypt_key(ctx, length, (const uint8_t *)key);
#endif
  } else
    Pike_error("AES256: Bad keysize for AES256.\n");
}

#ifndef HAVE_NETTLE_AES128_ENCRYPT
#define aes128_ctx	aes_ctx
#define aes192_ctx	aes_ctx
#define aes256_ctx	aes_ctx
#endif

#cmod_define CIPHER_MODE	BLOCK16_MODE
#cmod_define PIKE_NAME AES
#cmod_define NETTLE_NAME aes
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#define AES128_BLOCK_SIZE	AES_BLOCK_SIZE
#cmod_define CIPHER_MODE	BLOCK16_MODE
#cmod_define PIKE_NAME AES128
#cmod_define NETTLE_NAME aes128
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#define AES192_BLOCK_SIZE	AES_BLOCK_SIZE
#cmod_define CIPHER_MODE	BLOCK16_MODE
#cmod_define PIKE_NAME AES192
#cmod_define NETTLE_NAME aes192
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#define AES256_BLOCK_SIZE	AES_BLOCK_SIZE
#cmod_define CIPHER_MODE	BLOCK16_MODE
#cmod_define PIKE_NAME AES256
#cmod_define NETTLE_NAME aes256
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

static void pike_arctwo_set_key(void *ctx,
				ptrdiff_t length, const char *key,
				int ekb)
{
  if (!ekb) ekb = 128;

  if (length < ARCTWO_MIN_KEY_SIZE || length > ARCTWO_MAX_KEY_SIZE)
    Pike_error("ARCTWO: Bad keysize for ARCTWO.\n");

  arctwo_set_key_ekb(ctx, length, (const uint8_t *)key, ekb);
}

#define pike_arctwo_set_encrypt_key pike_arctwo_set_key
#define pike_arctwo_set_decrypt_key pike_arctwo_set_key

/*! @class ARCTWO
 *!
 *! Implementation of the ARCTWO cipher.
 *!
 */
PIKECLASS ARCTWO
{
  /*! @decl inherit BlockCipher
   */
  INHERIT BlockCipher;

  static const struct pike_cipher pike_arctwo =
    _PIKE_CIPHER(arctwo, ARCTWO);

  INIT
    {
      struct Nettle_Cipher_struct *cipher;
      ASSIGN_CURRENT_STORAGE(cipher, struct Nettle_Cipher_struct,
			     BLOCKCIPHER_CIPHER_INHERIT + 1,
			     Nettle_Cipher_program);
      cipher->meta = &pike_arctwo;
    }

  /*! @class State
   *!
   *! State for PIKE_NAME encyption.
   *!
   */
  PIKECLASS State
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit Cipher::State
     */

    static int f_ARCTWO_State_inherited_set_encrypt_key_fun_num = -1;
    static int f_ARCTWO_State_inherited_set_decrypt_key_fun_num = -1;

    EXTRA
    {
      /* Perform an inherit of the Cipher.State class (if any) that our parent
       * may contain via its inherit of Cipher via BlockCipher.
       */
      if( lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL) )
      {
        f_ARCTWO_State_inherited_set_encrypt_key_fun_num =
          really_low_reference_inherited_identifier(NULL, 1,
                                                    f_Nettle_Cipher_State_set_encrypt_key_fun_num);
        f_ARCTWO_State_inherited_set_decrypt_key_fun_num =
          really_low_reference_inherited_identifier(NULL, 1,
                                                    f_Nettle_Cipher_State_set_decrypt_key_fun_num);
      }
    }

    CVAR struct arctwo_ctx arctwo;

    INIT
    {
      struct Nettle_Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Nettle_Cipher_State_struct, 1,
			     Nettle_Cipher_State_program);
      state->ctx = &THIS->arctwo;
    }

    /*! @decl State set_encrypt_key(string(0..255) key, int|void ekb)
     *!
     *! Initializes the object for encryption. The @[key] memory will be
     *! cleared before released.
     *!
     *! @param ekb
     *!   The effective number of bits in the key.
     *!   @int
     *!     @value UNDEFINED
     *!       Derive from the key size (ie @expr{8 * sizeof(key)@}).
     *!     @value 0
     *!       Convenience alias for max (ie @expr{1024@}).
     *!     @value 1..1024
     *!       Reduce the effective key size to the specified number of bits.
     *!   @endint
     *!
     *! @seealso
     *!   @[set_decrypt_key], @[crypt]
     */
    PIKEFUN object set_encrypt_key(string(0..255) key, void|int(0..1024) ekb)
      optflags OPT_SIDE_EFFECT;
      rawtype tFunc(tStr8 tOr(tInt, tVoid), tObjImpl_NETTLE_CIPHER_STATE);
    {
      NO_WIDE_STRING(key);
      if (!ekb) {
	if (args > 1) pop_n_elems(args - 1);
	push_int(key->len * 8);
	args = 2;
      }
      apply_current(f_ARCTWO_State_inherited_set_encrypt_key_fun_num, args);
    }

    /*! @decl State set_decrypt_key(string(0..255) key, void|int ekb)
     *!
     *! Initializes the object for decryption. The @[key] memory will be
     *! cleared before released.
     *!
     *! @param ekb
     *!   The effective number of bits in the key.
     *!   @int
     *!     @value UNDEFINED
     *!       Derive from the key size (ie @expr{8 * sizeof(key)@}).
     *!     @value 0
     *!       Convenience alias for max (ie @expr{1024@}).
     *!     @value 1..1024
     *!       Reduce the effective key size to the specified number of bits.
     *!   @endint
     *!
     *! @seealso
     *!   @[set_encrypt_key], @[crypt]
     */
    PIKEFUN object set_decrypt_key(string(0..255) key, void|int ekb)
      optflags OPT_SIDE_EFFECT;
      rawtype tFunc(tStr8 tOr(tInt, tVoid), tObjImpl_NETTLE_CIPHER_STATE);
    {
      NO_WIDE_STRING(key);
      if (!ekb) {
	if (args > 1) pop_n_elems(args - 1);
	push_int(key->len * 8);
	args = 2;
      }
      apply_current(f_ARCTWO_State_inherited_set_decrypt_key_fun_num, args);
    }
  }
  /*! @endclass State
   */
}

/*! @endclass ARCTWO
 */

static void
pike_arcfour_set_key(void *ctx,
		     ptrdiff_t length, const char *key,
		     int UNUSED(force))
{
  if (length < ARCFOUR_MIN_KEY_SIZE || length > ARCFOUR_MAX_KEY_SIZE)
    Pike_error("ARCFOUR: Bad keysize for ARCFOUR.\n");

  arcfour_set_key(ctx, length, (const uint8_t *)key);
}

#define pike_arcfour_set_encrypt_key pike_arcfour_set_key
#define pike_arcfour_set_decrypt_key pike_arcfour_set_key
#define arcfour_encrypt arcfour_crypt
#define arcfour_decrypt arcfour_crypt
#define ARCFOUR_BLOCK_SIZE 1

#cmod_define CIPHER_MODE	STREAM_MODE
#cmod_define PIKE_NAME ARCFOUR
#cmod_define NETTLE_NAME arcfour
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#ifdef HAVE_NETTLE_BLOWFISH_DECRYPT

static void
pike_blowfish_set_key(void *ctx,
		      ptrdiff_t length, const char *key,
		      int UNUSED(force))
{
  if (length < BLOWFISH_MIN_KEY_SIZE || length > BLOWFISH_MAX_KEY_SIZE)
    Pike_error("BLOWFISH: Bad keysize for BLOWFISH.\n");
  if (!blowfish_set_key(ctx, length, (const uint8_t *)key))
    Pike_error("BLOWFISH: Key is weak (and force flag is currently ignored).\n");
}
#define pike_blowfish_set_encrypt_key pike_blowfish_set_key
#define pike_blowfish_set_decrypt_key pike_blowfish_set_key

#cmod_define CIPHER_MODE	BLOCK_MODE
#cmod_define PIKE_NAME BLOWFISH
#cmod_define NETTLE_NAME blowfish
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#endif	/* HAVE_NETTLE_BLOWFISH_DECRYPT */

#if !defined(CAMELLIA_KEY_SIZE) && defined(CAMELLIA128_KEY_SIZE)
/* Nettle 3.0.
 *
 * Emulate the previous API where the Camellia variants were joined.
 */

#define CAMELLIA_KEY_SIZE	CAMELLIA256_KEY_SIZE

struct camellia_ctx
{
  union {
    struct camellia128_ctx ctx128;
    struct camellia192_ctx ctx192;
    struct camellia256_ctx ctx256;
  } u;
  unsigned keylen;
};

static void camellia_set_encrypt_key(void *ctx, unsigned len,
                                     const uint8_t *key)
{
  struct camellia_ctx *camellia_ctx = ctx;

  switch(len) {
  case CAMELLIA128_KEY_SIZE:
    camellia128_set_encrypt_key(&camellia_ctx->u.ctx128, key);
    break;
  case CAMELLIA192_KEY_SIZE:
    camellia192_set_encrypt_key(&camellia_ctx->u.ctx192, key);
    break;
  case CAMELLIA256_KEY_SIZE:
    camellia256_set_encrypt_key(&camellia_ctx->u.ctx256, key);
    break;
  default:
    Pike_fatal("Invalid keylength for Camellia: %d\n", len);
    break;
  }
  camellia_ctx->keylen = len;
}

static void camellia_set_decrypt_key(void *ctx, unsigned len,
                                     const uint8_t *key)
{
  struct camellia_ctx *camellia_ctx = ctx;

  switch(len) {
  case CAMELLIA128_KEY_SIZE:
    camellia128_set_decrypt_key(&camellia_ctx->u.ctx128, key);
    break;
  case CAMELLIA192_KEY_SIZE:
    camellia192_set_decrypt_key(&camellia_ctx->u.ctx192, key);
    break;
  case CAMELLIA256_KEY_SIZE:
    camellia256_set_decrypt_key(&camellia_ctx->u.ctx256, key);
    break;
  default:
    Pike_fatal("Invalid keylength for Camellia: %d\n", len);
    break;
  }
  camellia_ctx->keylen = len;
}

static void camellia_crypt(struct camellia_ctx *ctx, size_t length,
			   uint8_t *dst, const uint8_t *src)
{
  switch(ctx->keylen) {
  case CAMELLIA128_KEY_SIZE:
    camellia128_crypt(&ctx->u.ctx128, length, dst, src);
    break;
  case CAMELLIA192_KEY_SIZE:
    camellia192_crypt(&ctx->u.ctx192, length, dst, src);
    break;
  case 0:
  case CAMELLIA256_KEY_SIZE:
    camellia256_crypt(&ctx->u.ctx256, length, dst, src);
    break;
  default:
    Pike_fatal("Invalid keylength for Camellia: %d\n", ctx->keylen);
    break;
  }
}

#endif

#ifdef CAMELLIA_KEY_SIZE

#ifndef CAMELLIA128_KEY_SIZE
#define CAMELLIA128_KEY_SIZE	16
#endif
#ifndef CAMELLIA192_KEY_SIZE
#define CAMELLIA192_KEY_SIZE	24
#endif
#ifndef CAMELLIA256_KEY_SIZE
#define CAMELLIA256_KEY_SIZE	32
#endif

static void
pike_camellia_set_encrypt_key(void *ctx,
			      ptrdiff_t length, const char *key,
			      int UNUSED(force))
{
  if (length != CAMELLIA128_KEY_SIZE &&
      length != CAMELLIA256_KEY_SIZE &&
      length != CAMELLIA192_KEY_SIZE)
    Pike_error("CAMELLIA: Bad keysize for CAMELLIA.\n");
  camellia_set_encrypt_key(ctx, length, (const uint8_t *)key);
}

static void
pike_camellia_set_decrypt_key(void *ctx,
			      ptrdiff_t length, const char *key,
                              int UNUSED(force))
{
  if (length != CAMELLIA128_KEY_SIZE &&
      length != CAMELLIA256_KEY_SIZE &&
      length != CAMELLIA192_KEY_SIZE)
    Pike_error("CAMELLIA: Bad keysize for CAMELLIA.\n");
  camellia_set_decrypt_key(ctx, length, (const uint8_t *)key);
}

#define camellia_encrypt camellia_crypt
#define camellia_decrypt camellia_crypt

#cmod_define CIPHER_MODE	BLOCK16_MODE
#cmod_define PIKE_NAME CAMELLIA
#cmod_define NETTLE_NAME camellia
#cmod_define NETTLE_MIN_VERSION 2.1
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#endif	/* CAMELLIA_KEY_SIZE */

static void
pike_cast128_set_key(void *ctx,
		     ptrdiff_t length, const char *key,
		     int UNUSED(force))
{
#ifdef CAST5_MIN_KEY_SIZE
  if (length < CAST5_MIN_KEY_SIZE || length > CAST5_MAX_KEY_SIZE)
    Pike_error("CAST128_info: Bad keysize for CAST128.\n");

  cast5_set_key(ctx, length, (const uint8_t *)key);
#else
  if (length < CAST128_MIN_KEY_SIZE || length > CAST128_MAX_KEY_SIZE)
    Pike_error("CAST128_info: Bad keysize for CAST128.\n");

  cast128_set_key(ctx, length, (const uint8_t *)key);
#endif
}
#define pike_cast128_set_encrypt_key pike_cast128_set_key
#define pike_cast128_set_decrypt_key pike_cast128_set_key

#cmod_define CIPHER_MODE	BLOCK_MODE
#cmod_define PIKE_NAME CAST128
#cmod_define NETTLE_NAME cast128
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#ifdef HAVE_NETTLE_CHACHA_H

static void
pike_chacha_set_key(void *ctx,
		    ptrdiff_t length, const char *key,
		    int UNUSED(force))
{
  if (length != CHACHA_KEY_SIZE)
    Pike_error("CHACHA: Bad keysize for CHACHA.\n");

  chacha_set_key(ctx, (const uint8_t *)key);
}

#define pike_chacha_set_encrypt_key pike_chacha_set_key
#define pike_chacha_set_decrypt_key pike_chacha_set_key
#define chacha_encrypt chacha_crypt
#define chacha_decrypt chacha_crypt

/*! @class CHACHA
 *!
 *! Implementation of the CHACHA stream cipher.
 *!
 *! @note
 *!   Note that this class is not available in all versions of Nettle.
 *!
 */
PIKECLASS CHACHA
{
  /*! @decl inherit BlockCipher
   */
  INHERIT BlockCipher;

  static const struct pike_cipher pike_chacha =
    _PIKE_CIPHER(chacha, CHACHA);

  INIT
    {
      struct Nettle_Cipher_struct *cipher;
      ASSIGN_CURRENT_STORAGE(cipher, struct Nettle_Cipher_struct,
			     BLOCKCIPHER_CIPHER_INHERIT + 1,
			     Nettle_Cipher_program);
      cipher->meta = &pike_chacha;
    }

  /*! @class State
   *!
   *! State for CHACHA encyption.
   *!
   */
  PIKECLASS State
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit Cipher::State
     */

    EXTRA
    {
      /* Perform an inherit of the Cipher.State class (if any) that our parent
       * may contain via its inherit of Cipher via BlockCipher.
       */
      lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
    }

    CVAR struct chacha_ctx chacha;

    /*! @decl string(0..255) crypt(string(0..255) data)
     *!
     *! Encrypts or decrypts data, using the current key. Neither the
     *! input nor output data is automatically memory scrubbed,
     *! unless @[String.secure] has been called on them.
     *!
     *! @param data
     *!   Usually an integral number of blocks, except for the last
     *!   segement in a run. The decoder must get partial blocks
     *!   at the same places as the encoder, otherwise they will get
     *!   out of sync.
     *!
     *! @returns
     *!   The encrypted or decrypted data.
     */
    PIKEFUN string(0..255) crypt (string(0..255) data)
      optflags OPT_EXTERNAL_DEPEND | OPT_SIDE_EFFECT;
    {
      struct pike_string *s;

      NO_WIDE_STRING(data);

      /* NB: Differs from default in that the block size
       *     isn't enforced.
       *
       * To simplify the code we also skip the indirection
       * via the Cipher class and its State.
       */

      s = begin_shared_string(data->len);
      chacha_crypt(&THIS->chacha, data->len, (uint8_t *)s->str,
		   (const uint8_t *)data->str);
      s = end_shared_string(s);
      push_string(s);
    }

    /*! @decl object set_iv(string(0..255) iv)
     *!
     *! Set the initialization vector (aka nonce) and reset
     *! the block counter to zero.
     *!
     *! @param iv
     *!   An 8-byte long string which is only to be used
     *!   once for every key.
     *!
     *! @note
     *!   This function MUST be called in addition to
     *!   @[set_encrypt_key()] or @[set_decrypt_key()].
     *!
     *! @note
     *!   The same @[iv] should NEVER be reused with the same key!
     */
    PIKEFUN object set_iv(string(0..255) iv)
      rawtype tFunc(tStr8, tObjImpl_NETTLE_CIPHER_STATE);
    {
      NO_WIDE_STRING(iv);
      if (iv->len != CHACHA_NONCE_SIZE)
        Pike_error("CHACHA IV needs to be %d bytes.\n", CHACHA_NONCE_SIZE);
      iv->flags |= STRING_CLEAR_ON_EXIT;
      chacha_set_nonce(&THIS->chacha, STR0(iv));
      push_object(this_object());
    }

    INIT
    {
      struct Nettle_Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Nettle_Cipher_State_struct, 1,
			     Nettle_Cipher_State_program);
      state->ctx = &THIS->chacha;
    }
  }
  /*! @endclass State
   */

}

/*! @endclass CHACHA
 */

#endif /* HAVE_NETTLE_CHACHA_H */

static void
pike_des_set_key(void *c,
		 ptrdiff_t length, const char *key,
		 int force)
{
  struct des_ctx *ctx = (struct des_ctx *) c;
  if (length != 8)
    Pike_error("DES_INFO: Bad keysize for DES.\n");

  if (!des_set_key(ctx, (const uint8_t *)key))
  {
#ifndef DES_WEAK_KEY
    /* Nettle 2.1 and later. */
    if (!force)
      Pike_error("DES_INFO: Key is weak.\n");
#else
    /* Nettle 2.0 and earlier. */
    switch (ctx->status)
    {
    case DES_WEAK_KEY:
      if (force)
	/* Use key anyway */
	ctx->status = DES_OK;
      else
	Pike_error("DES_INFO: Key is weak.\n");
      break;

    case DES_BAD_PARITY:
      Pike_error("DES_INFO: Key has bad parity.\n");
    default:
      Pike_error("DES_INFO: Unexpected error, please send a bug report.\n");
    }
#endif
  }
}

#define pike_des_set_encrypt_key pike_des_set_key
#define pike_des_set_decrypt_key pike_des_set_key

/*! @class DES
 *!
 *! Implementation of the Data Encryption Standard (DES) crypto algorithm.
 *!
 */
PIKECLASS DES
{
  /*! @decl inherit BlockCipher
   */
  INHERIT BlockCipher;

  INIT
    {
      static const struct pike_cipher pike_des = _PIKE_CIPHER(des, DES);
      /* FIXME: Ought to traverse the inherit graph for
       *        the current program.
       */
      struct Nettle_Cipher_struct *cipher;
      ASSIGN_CURRENT_STORAGE(cipher, struct Nettle_Cipher_struct,
			     BLOCKCIPHER_CIPHER_INHERIT + 1,
			     Nettle_Cipher_program);
      cipher->meta = &pike_des;
    }

  /*! @decl string(0..255) fix_parity(string(0..255) key)
   *! Sets the last bit in every byte in @[key] to reflect the parity.
   *! If a seven byte key is used, it will be expanded into eight
   *! bytes. If a key longer than eight characters is used, it will
   *! be truncated to eight characters.
   */
  PIKEFUN string(0..255) fix_parity(string(0..255) key)
  {
    uint8_t buf[8];

    NO_WIDE_STRING(key);

    if(key->len < 7)
      Pike_error("Key must be at least 7 characters.\n");

    if(key->len == 7) {
      buf[0] = key->str[0]&254;
      buf[1] = (key->str[0]&1)<<7 | (key->str[1]>>1 & 126);
      buf[2] = (key->str[1]&3)<<6 | (key->str[2]>>2 & 62);
      buf[3] = (key->str[2]&7)<<5 | (key->str[3]>>3 & 30);
      buf[4] = (key->str[3]&15)<<4 | (key->str[4]>>4 & 14);
      buf[5] = (key->str[4]&31)<<3 | (key->str[5]>>5 & 6);
      buf[6] = (key->str[5]&63)<<2 | (key->str[6]>>6 & 2);
      buf[7] = (key->str[6]&127)<<1;
    }
    else
      memcpy(buf, key->str, 8);

    des_fix_parity(8, buf, buf);
    RETURN make_shared_binary_string((char *)buf, 8);
  }

  /*! @class State
   *!
   *! State for DES encyption
   */
  PIKECLASS State
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    DOCSTART() @decl inherit Cipher::State
    DOCEND()

    EXTRA
    {
      /* Perform an inherit of the Cipher.State class (if any) that our parent
       * may contain via its inherit of Cipher via BlockCipher.
       */
      lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
    }

    CVAR struct des_ctx des;

    INIT
    {
      struct Nettle_Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Nettle_Cipher_State_struct, 1,
			     Nettle_Cipher_State_program);
      state->ctx = &THIS->des;
    }

    PIKEFUN string(0..255) make_key()
    {
      struct Nettle_Cipher_struct *info = GET_INFO();
      struct Nettle_Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Nettle_Cipher_State_struct, 1,
			     Nettle_Cipher_State_program);
      assert(info);

#ifndef DES_WEAK_KEY
      /* NB: This loop temporarily leaks strings on the stack,
       *     but we don't care, as it is a low probability,
       *     and they will be cleaned up on return.
       */
      do {
        push_random_string(info->meta->key_size);
	f_Nettle_DES_fix_parity(1);
      } while( !des_set_key(state->ctx,
                            (const uint8_t *)Pike_sp[-1].u.string->str) );
#else
      push_random_string(info->meta->key_size);
      f_Nettle_DES_fix_parity(1);

      info->meta->set_encrypt_key(state->ctx, Pike_sp[-1].u.string->len,
				  Pike_sp[-1].u.string->str, 0);
#endif

      Pike_sp[-1].u.string->flags |= STRING_CLEAR_ON_EXIT;
      state->crypt = info->meta->encrypt;
      state->key_size = Pike_sp[-1].u.string->len;
    }

    /*! @decl string(0..255) fix_parity(string(0..255) key)
     *! Sets the last bit in every byte in @[key] to reflect the parity.
     *! If a seven byte key is used, it will be expanded into eight
     *! bytes. If a key longer than eight characters is used, it will
     *! be truncated to eight characters.
     */
    PIKEFUN string(0..255) fix_parity(string(0..255) key)
    {
      apply_external(1, f_Nettle_DES_fix_parity_fun_num, args);
    }
  }
  /*! @endclass State */

}
/*! @endclass DES */

DEFAULT_CMOD_STORAGE void f_Nettle_DES3_fix_parity(INT32);

static void
pike_des3_set_key(void *c,
		  ptrdiff_t length, const char *key,
		  int force)
{
  struct des3_ctx *ctx = (struct des3_ctx *) c;
#ifdef DES_WEAK_KEY
  int i;
#endif
  char nkotb[24];

  switch( length ) {
  case 7+7:
    push_string(make_shared_binary_string(key, length));
    push_static_text("1234567");
    f_add(2);
    f_Nettle_DES3_fix_parity(1);

    memcpy(nkotb, Pike_sp[-1].u.string->str, 8+8);
    pop_stack();

    key = nkotb;
    length = 8+8;
    /* fallthrough */
  case 8+8:
    push_string(make_shared_binary_string(key, length));
    push_string(make_shared_binary_string(key, length));
    push_int(0);
    push_int(7);
    o_range();
    f_add(2);

    memcpy(nkotb, Pike_sp[-1].u.string->str, 8+8+8);
    pop_stack();

    key = nkotb;
    length = 8+8+8;
    break;

  case 7+7+7:
    push_string(make_shared_binary_string(key, length));
    f_Nettle_DES3_fix_parity(1);
    memcpy(nkotb, Pike_sp[-1].u.string->str, 8+8+8);
    pop_stack();

    key = nkotb;
    length = 8+8+8;
    break;

  case 8+8+8:
    break;

  default:
    Pike_error("DES3_INFO: Bad keysize for DES3.\n");
    break;
  }

#ifndef DES_WEAK_KEY
  if( !des3_set_key(ctx, (const uint8_t *)key) && !force )
    Pike_error("DES3_INFO: Key is weak.\n");
#else
  /* The hack of resetting ctx->status to use a weak key doesn't
   * currently work with nettle's des3_set_key function. So we set the
   * individual keys by ourself. */
  for (i = 0; i<3; i++, key += DES_KEY_SIZE)
    if (!des_set_key(&ctx->des[i], (const uint8_t *)key))
    {
      /* Nettle 2.0 and earlier. */
      switch (ctx->des[i].status)
      {
      case DES_WEAK_KEY:
	if (force)
	  /* Use key anyway */
	  ctx->des[i].status = DES_OK;
	else
	  Pike_error("DES3_INFO: Key is weak.\n");
	break;

      case DES_BAD_PARITY:
	Pike_error("DES3_INFO: Key has bad parity.\n");
      default:
	Pike_error("DES3_INFO: Unexpected error, please send a bug report.\n");
      }
    }
#endif
}
#define pike_des3_set_encrypt_key pike_des3_set_key
#define pike_des3_set_decrypt_key pike_des3_set_key


/*! @class DES3
 *!
 *! Implementation of the DES3 cipher algorithm.
 *!
 */
PIKECLASS DES3
{
  /*! @decl inherit BlockCipher
   */
  INHERIT BlockCipher;

  INIT
    {
      static const struct pike_cipher pike_des3 = _PIKE_CIPHER(des3, DES3);
      /* FIXME: Ought to traverse the inherit graph for
       *        the current program.
       */
      struct Nettle_Cipher_struct *cipher;
      ASSIGN_CURRENT_STORAGE(cipher, struct Nettle_Cipher_struct,
			     BLOCKCIPHER_CIPHER_INHERIT + 1,
			     Nettle_Cipher_program);
      cipher->meta = &pike_des3;
    }

  /*! @decl string(0..255) fix_parity(string(0..255) key)
   *! Sets the last bit in every byte in @[key] to reflect the parity.
   *! If a 21 byte key is used, it will be expanded into 24
   *! bytes. If a key longer than 24 characters is used, it will
   *! be truncated to 24 characters.
   */
  PIKEFUN string(0..255) fix_parity(string(0..255) key)
  {
    INT32 i;
    struct array *arr;

    NO_WIDE_STRING(key);

    if(key->len < 24 && key->len != 21)
      Pike_error("Key must be 21 or >=24 characters.\n");

    /* Split the string */
    if(key->len==21)
      push_int(7);
    else
      push_int(8);
    f_divide(2);
    arr = Pike_sp[-1].u.array;
    add_ref(arr);
    pop_stack();

    /* fix_parity for every subkey */
    for(i=0; i<3; i++) {
      push_int(0);
      array_index(&Pike_sp[-1], arr, i);
      f_Nettle_DES_fix_parity(1);
    }
    free_array(arr);

    /* Join the subkeys */
    f_add(3);
  }

  /*! @class State
   *!
   *! State for DES3 encyption
   */
  PIKECLASS State
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    DOCSTART() @decl inherit Cipher::State
    DOCEND()

    EXTRA
    {
      /* Perform an inherit of the Cipher.State class (if any) that our parent
       * may contain via its inherit of Cipher via BlockCipher.
       */
      lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
    }

    CVAR struct des3_ctx des3;

    INIT
    {
      struct Nettle_Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Nettle_Cipher_State_struct, 1,
			     Nettle_Cipher_State_program);
      state->ctx = &THIS->des3;
    }

    PIKEFUN string(0..255) make_key()
    {
      struct Nettle_Cipher_struct *info = GET_INFO();
      struct Nettle_Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Nettle_Cipher_State_struct, 1,
			     Nettle_Cipher_State_program);
      assert(info);

#ifndef DES_WEAK_KEY
      /* NB: This loop temporarily leaks strings on the stack,
       *     but we don't care, as it is a low probability,
       *     and they will be cleaned up on return.
       */
      do {
        push_random_string(info->meta->key_size);
	f_Nettle_DES3_fix_parity(1);
      } while( !des3_set_key(state->ctx,
                             (const uint8_t *)Pike_sp[-1].u.string->str) );
#else
      push_random_string(info->meta->key_size);
      f_Nettle_DES3_fix_parity(1);

      info->meta->set_encrypt_key(state->ctx, Pike_sp[-1].u.string->len,
				  Pike_sp[-1].u.string->str, 0);
#endif

      Pike_sp[-1].u.string->flags |= STRING_CLEAR_ON_EXIT;
      state->crypt = info->meta->encrypt;
      state->key_size = Pike_sp[-1].u.string->len;
    }
  }
  /*! @endclass State */

}

/*! @endclass DES3 */

#ifdef HAVE_NETTLE_SALSA20_CRYPT

static void
pike_salsa20_set_key(void *ctx,
                     ptrdiff_t length, const char *key,
                     int UNUSED(force))
{
  if ((length != SALSA20_MIN_KEY_SIZE) && (length != SALSA20_MAX_KEY_SIZE))
    Pike_error("SALSA20: Bad keysize for SALSA20.\n");

  salsa20_set_key(ctx, length, (const uint8_t *)key);
}

#define pike_salsa20_set_encrypt_key pike_salsa20_set_key
#define pike_salsa20_set_decrypt_key pike_salsa20_set_key
#define salsa20_encrypt salsa20_crypt
#define salsa20_decrypt salsa20_crypt

/*! @class SALSA20
 *!
 *! Implementation of the SALSA20 cipher.
 *!
 *! @note
 *!   Requires Nettle 2.5 or later.
 */
PIKECLASS SALSA20
{
  /*! @decl inherit BlockCipher
   */
  INHERIT BlockCipher;

  static const struct pike_cipher pike_salsa20 =
    _PIKE_CIPHER(salsa20, SALSA20);

  INIT
    {
      struct Nettle_Cipher_struct *cipher;
      ASSIGN_CURRENT_STORAGE(cipher, struct Nettle_Cipher_struct,
			     BLOCKCIPHER_CIPHER_INHERIT + 1,
			     Nettle_Cipher_program);
      cipher->meta = &pike_salsa20;
    }

  /*! @class State
   *!
   *! State for SALSA20 encyption.
   *!
   */
  PIKECLASS State
    program_flags PROGRAM_NEEDS_PARENT|PROGRAM_USES_PARENT;
  {
    /*! @decl inherit Cipher::State
     */

    EXTRA
    {
      /* Perform an inherit of the Cipher.State class (if any) that our parent
       * may contain via its inherit of Cipher via BlockCipher.
       */
      lexical_inherit(1, MK_STRING("State"), 0, REPORT_WARNING, NULL);
    }

    CVAR struct salsa20_ctx salsa20;

    /*! @decl object set_iv(string(0..255) iv)
     *!
     *! Set the initialization vector (aka nonce) and reset
     *! the block counter to zero.
     *!
     *! @param iv
     *!   An 8-byte long string which is only to be used
     *!   once for every key.
     *!
     *! @note
     *!   This function MUST be called in addition to
     *!   @[set_encrypt_key()] or @[set_decrypt_key()].
     *!
     *! @note
     *!   The same @[iv] should NEVER be reused with the same key!
     */
    PIKEFUN object set_iv(string(0..255) iv)
      rawtype tFunc(tStr8, tObjImpl_NETTLE_CIPHER_STATE);
    {
      NO_WIDE_STRING(iv);
      if (iv->len != SALSA20_IV_SIZE)
        Pike_error("SALSA20 IV needs to be %d bytes.\n", SALSA20_IV_SIZE);
      iv->flags |= STRING_CLEAR_ON_EXIT;
      salsa20_set_iv(&THIS->salsa20, STR0(iv));
      push_object(this_object());
    }

    INIT
    {
      struct Nettle_Cipher_State_struct *state;
      ASSIGN_CURRENT_STORAGE(state, struct Nettle_Cipher_State_struct, 1,
			     Nettle_Cipher_State_program);
      state->ctx = &THIS->salsa20;
    }
  }
  /*! @endclass State
   */

}

/*! @endclass SALSA20
 */

#ifdef salsa20r12_crypt

#define pike_salsa20r12_set_encrypt_key pike_salsa20_set_encrypt_key
#define pike_salsa20r12_set_decrypt_key pike_salsa20_set_decrypt_key
#define salsa20r12_encrypt salsa20r12_crypt
#define salsa20r12_decrypt salsa20r12_crypt
#define salsa20r12_ctx salsa20_ctx

#define SALSA20R12_BLOCK_SIZE	SALSA20_BLOCK_SIZE
#define SALSA20R12_KEY_SIZE	SALSA20_KEY_SIZE

/*! @class SALSA20R12
 *!
 *! Implementation of the @[SALSA20] cipher reduced to 12 rounds.
 *!
 *! @note
 *!   Requires Nettle 2.7 or later.
 */
PIKECLASS SALSA20R12
{
  /*! @decl inherit SALSA20
   */
  INHERIT SALSA20;

  static const struct pike_cipher pike_salsa20r12 =
    _PIKE_CIPHER(salsa20r12, SALSA20R12);

  INIT
    {
      struct Nettle_Cipher_struct *cipher;
      /* NB: We know that BlockCipher is the first inherit of SALSA20. */
      ASSIGN_CURRENT_STORAGE(cipher, struct Nettle_Cipher_struct,
			     BLOCKCIPHER_CIPHER_INHERIT + 2,
			     Nettle_Cipher_program);
      cipher->meta = &pike_salsa20r12;
    }
}

/*! @endclass SALSA20R12
 */

#endif /* salsa20r12_crypt */

#endif	/* HAVE_NETTLE_SALSA20_CRYPT */

#ifdef HAVE_NETTLE_SERPENT_DECRYPT

static void
pike_serpent_set_key(void *ctx,
		     ptrdiff_t length, const char *key,
		     int UNUSED(force))
{
  if (length < SERPENT_MIN_KEY_SIZE || length > SERPENT_MAX_KEY_SIZE)
    Pike_error("SERPENT: Bad keysize for SERPENT.\n");

  serpent_set_key(ctx, length, (const uint8_t *)key);
}
#define pike_serpent_set_encrypt_key pike_serpent_set_key
#define pike_serpent_set_decrypt_key pike_serpent_set_key

#cmod_define CIPHER_MODE	BLOCK16_MODE
#cmod_define PIKE_NAME SERPENT
#cmod_define NETTLE_NAME serpent
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#endif	/* HAVE_NETTLE_SERPENT_DECRYPT */

#ifdef HAVE_NETTLE_SM4_CRYPT

static void
pike_sm4_set_encrypt_key(void *ctx,
                         ptrdiff_t length, const char *key,
                         int UNUSED(force))
{
  if (length != SM4_KEY_SIZE)
    Pike_error("SM4: Bad keysize for SM4.\n");

  sm4_set_encrypt_key(ctx, (const uint8_t *)key);
}
static void
pike_sm4_set_decrypt_key(void *ctx,
                         ptrdiff_t length, const char *key,
                         int UNUSED(force))
{
  if (length != SM4_KEY_SIZE)
    Pike_error("SM4: Bad keysize for SM4.\n");

  sm4_set_decrypt_key(ctx, (const uint8_t *)key);
}
#define sm4_encrypt sm4_crypt
#define sm4_decrypt sm4_crypt

#cmod_define CIPHER_MODE	BLOCK16_MODE
#cmod_define PIKE_NAME SM4
#cmod_define NETTLE_NAME sm4
#cmod_define NETTLE_MIN_VERSION 3.9
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#endif

static void
pike_twofish_set_key(void *ctx,
		     ptrdiff_t length, const char *key,
		     int UNUSED(force))
{
  if (length < TWOFISH_MIN_KEY_SIZE || length > TWOFISH_MAX_KEY_SIZE)
    Pike_error("TWOFISH: Bad keysize for TWOFISH.\n");

  twofish_set_key(ctx, length, (const uint8_t *)key);
}
#define pike_twofish_set_encrypt_key pike_twofish_set_key
#define pike_twofish_set_decrypt_key pike_twofish_set_key

#define Twofish_BLOCK_SIZE	TWOFISH_BLOCK_SIZE
#define Twofish_KEY_SIZE 	TWOFISH_KEY_SIZE

#cmod_define CIPHER_MODE	BLOCK16_MODE
#cmod_define PIKE_NAME Twofish
#cmod_define NETTLE_NAME twofish
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#ifdef WITH_IDEA

static void
pike_idea_set_encrypt_key(void *ctx_v,
			 ptrdiff_t length, const char *key,
			 int UNUSED(force))
{
  struct idea_ctx *ctx = ctx_v;
  if (length == IDEA_KEY_SIZE)
    idea_expand((unsigned INT16 *)ctx->ctx, (unsigned INT8 *)key);
  else
    Pike_error("IDEA: Bad keysize for IDEA.\n");
}

static void
pike_idea_set_decrypt_key(void *ctx_v,
			 ptrdiff_t length, const char *key,
			 int UNUSED(force))
{
  struct idea_ctx *ctx = ctx_v;
  if (length == IDEA_KEY_SIZE) {
    idea_expand((unsigned INT16 *)ctx->ctx, (unsigned INT8 *)key);
    idea_invert((unsigned INT16 *)ctx->ctx, (unsigned INT16 *)ctx->ctx);
  }
  else
    Pike_error("IDEA: Bad keysize for IDEA.\n");
}

#define idea_encrypt idea_crypt_blocks
#define idea_decrypt idea_crypt_blocks

#cmod_define CIPHER_MODE	BLOCK_MODE
#cmod_define PIKE_NAME IDEA
#cmod_define NETTLE_NAME idea
#cmod_include "cipher.H"
#cmod_undef PIKE_NAME
#cmod_undef NETTLE_NAME

#endif /* WITH_IDEA */

/*! @endmodule Nettle */

void
cipher_init(void)
{
  nul13_string = begin_shared_string(13);
  memset(STR0(nul13_string), 0, 13);
  nul13_string = end_shared_string(nul13_string);
  nul16_string = begin_shared_string(16);
  memset(STR0(nul16_string), 0, 16);
  nul16_string = end_shared_string(nul16_string);

  INIT;
  ADD_INT_CONSTANT("PAD_SSL",       PAD_SSL,       0);
  ADD_INT_CONSTANT("PAD_ISO_10126", PAD_ISO_10126, 0);
  ADD_INT_CONSTANT("PAD_ANSI_X923", PAD_ANSI_X923, 0);
  ADD_INT_CONSTANT("PAD_PKCS7",     PAD_PKCS7,     0);
  ADD_INT_CONSTANT("PAD_ZERO",      PAD_ZERO,      0);
  ADD_INT_CONSTANT("PAD_TLS",       PAD_TLS,       0);
}

void
cipher_exit(void)
{
  EXIT;
  free_string(nul16_string);
  free_string(nul13_string);
}

#endif /* HAVE_LIBNETTLE */

/* cairo.cmod -*- mode: c; encoding: utf-8; -*- */

#include "module.h"
#include "interpret.h"
#include "module_support.h"
#include "threads.h"
#include "pike_cpulib.h"
#include "sprintf.h"
#include "builtin_functions.h"

#include "cairo_config.h"

#ifdef HAVE_CAIRO

#include <cairo/cairo.h>
#ifdef CAIRO_HAS_PDF_SURFACE
#include <cairo/cairo-pdf.h>
#endif
#ifdef CAIRO_HAS_PS_SURFACE
#include <cairo/cairo-ps.h>
#endif
#ifdef CAIRO_HAS_SVG_SURFACE
#include <cairo/cairo-svg.h>
#endif
#ifdef CAIRO_HAS_SCRIPT_SURFACE
#include <cairo/cairo-script.h>
#endif
#ifdef CAIRO_HAS_TEE_SURFACE
#include <cairo/cairo-tee.h>
#endif
#ifdef CAIRO_HAS_XCB_SURFACE
#include <cairo/cairo-xcb.h>
#endif
#ifdef CAIRO_HAS_XLIB_SURFACE
#include <cairo/cairo-xlib.h>
#endif

#include "modules/Image/image.h"

DECLARATIONS

#ifdef DYNAMIC_MODULE
static struct program *image_program = NULL;
static struct program *image_layer_program = NULL;
#else
extern struct program *image_program;
extern struct program *image_layer_program;
#endif

struct strm_func_closure {
  struct object *obj;
  int func_id;
};

static cairo_status_t strm_read_func(void *closure, unsigned char *data,
                                     unsigned int length)
{
  struct strm_func_closure *ctx = closure;
  cairo_status_t ret = CAIRO_STATUS_READ_ERROR;
  push_int(length);
  if (safe_apply_low2(ctx->obj, ctx->func_id, 1, "read") &&
      PIKE_TYPEOF(Pike_sp[-1]) == PIKE_T_STRING &&
      !Pike_sp[-1].u.string->size_shift &&
      Pike_sp[-1].u.string->len == length) {
    memcpy(data, STR0(Pike_sp[-1].u.string), length);
    ret = CAIRO_STATUS_SUCCESS;
  }
  pop_stack();
  return ret;
}

static cairo_status_t strm_write_func(void *closure, const unsigned char *data,
                                      unsigned int length)
{
  struct strm_func_closure *ctx = closure;
  cairo_status_t ret = CAIRO_STATUS_WRITE_ERROR;
  push_string(make_shared_binary_string((const char *)data, length));
  if (safe_apply_low2(ctx->obj, ctx->func_id, 1, "write") &&
      PIKE_TYPEOF(Pike_sp[-1]) == PIKE_T_INT &&
      Pike_sp[-1].u.integer == length)
    ret = CAIRO_STATUS_SUCCESS;
  pop_stack();
  return ret;
}

/*! @module Cairo
 */

/*! @class Error
 *!
 *! Error object used for Cairo errors.
 */
PIKECLASS Error
{
  /*! @decl inherit Error.Generic
   */
  INHERIT generic_error;

  /*! @decl constant is_cairo_error = 1
   *! @decl constant error_type = "cairo_error"
   *!
   *! Object recognition constants.
   */
  EXTRA
  {
    add_string_constant ("error_type", "cairo_error", 0);
    add_integer_constant ("is_cairo_error", 1, 0);
    Pike_compiler->new_program->flags &= ~PROGRAM_LIVE_OBJ;
  }

  /*! @decl int status
   *!
   *! The numeric status code (STATUS_xxx)
   */
  PIKEVAR int status;

  static void check_status(cairo_status_t status)
  {
    if(status != CAIRO_STATUS_SUCCESS) {
      struct object *o = fast_clone_object(Cairo_Error_program);
      GET_CAIRO_ERROR_STORAGE(o)->status = status;
      throw_error_object(o, NULL, 0, "Cairo.Error: %s\n",
                         cairo_status_to_string(status));
    }
  }
}
/*! @endclass */

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 4, 0)
/*! @class Rectangle
 *! A data structure for holding a rectangle.
 */
PIKECLASS Rectangle
{
  /*! @decl float x
   *!   X coordinate of the left side of the rectangle
   *!
   *! @decl float y
   *!   Y coordinate of the top side of the rectangle
   *!
   *! @decl float width
   *!   width of the rectangle
   *!
   *! @decl float height
   *!   height of the rectangle
   */
  PIKEVAR float x;
  PIKEVAR float y;
  PIKEVAR float width;
  PIKEVAR float height;

  static void rectangle_load(cairo_rectangle_t *rectangle, const struct Cairo_Rectangle_struct *r)
  {
    rectangle->x = r->x;
    rectangle->y = r->y;
    rectangle->width = r->width;
    rectangle->height = r->height;
  }

  static void rectangle_store(const cairo_rectangle_t *rectangle, struct Cairo_Rectangle_struct *r)
  {
    r->x = rectangle->x;
    r->y = rectangle->y;
    r->width = rectangle->width;
    r->height = rectangle->height;
  }

  static struct object *rectangle_to_object(const cairo_rectangle_t *rectangle)
  {
    struct object *o = fast_clone_object(Cairo_Rectangle_program);
    struct Cairo_Rectangle_struct *r = GET_CAIRO_RECTANGLE_STORAGE(o);
    rectangle_store(rectangle, r);
    return o;
  }

  static int rectangle_from_object(struct object *o, cairo_rectangle_t *rectangle)
  {
    struct Cairo_Rectangle_struct *r;
    if (!(r = get_storage(o, Cairo_Rectangle_program)))
      return 0;
    rectangle_load(rectangle, r);
    return 1;
  }

  /*! @decl protected void create(float|int x, float|int y,           @
   *!                             float|int width, float|int height)
   *!
   *! @param x
   *!   X coordinate of the left side of the rectangle
   *! @param y
   *!   Y coordinate of the top side of the rectangle
   *! @param width
   *!   width of the rectangle
   *! @param height
   *!   height of the rectangle
   */
  PIKEFUN void create(float|int x, float|int y,
                      float|int width, float|int height)
    flags ID_PROTECTED;
    get_all_args;
  {
    THIS->x = x;
    THIS->y = y;
    THIS->width = width;
    THIS->height = height;
    RETURN;
  }

  /*! @decl protected string _sprintf(int c, mapping flags)
   */
  PIKEFUN string _sprintf(int c, mapping flags)
    flags ID_PROTECTED;
    get_all_args;
  {
     switch(c) {
     default:
       push_undefined();
       break;

     case 't':
       push_static_text("Cairo.Rectangle");
       break;

     case 'O':
       {
         struct string_builder sb;
         init_string_builder(&sb, 0);
         string_builder_sprintf(&sb, "Cairo.Rectangle(%f, %f, %f, %f)",
                                (double)THIS->x, (double)THIS->y,
                                (double)THIS->width, (double)THIS->height);
         RETURN finish_string_builder(&sb);
       }
       break;
     }

     stack_unlink(args);
  }
}
/*! @endclass */
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
/*! @class RectangleInt
 *! A data structure for holding a rectangle with integer coordinates.
 */
PIKECLASS RectangleInt
{
  /*! @decl int x
   *!   X coordinate of the left side of the rectangle
   *!
   *! @decl int y
   *!   Y coordinate of the top side of the rectangle
   *!
   *! @decl int width
   *!   width of the rectangle
   *!
   *! @decl int height
   *!   height of the rectangle
   */
  PIKEVAR int x;
  PIKEVAR int y;
  PIKEVAR int width;
  PIKEVAR int height;

  static void rectangle_int_load(cairo_rectangle_int_t *rectangle_int, const struct Cairo_RectangleInt_struct *r)
  {
    rectangle_int->x = r->x;
    rectangle_int->y = r->y;
    rectangle_int->width = r->width;
    rectangle_int->height = r->height;
  }

  static int rectangle_int_from_object(struct object *o, cairo_rectangle_int_t *rectangle_int)
  {
    struct Cairo_RectangleInt_struct *r;
    if (!(r = get_storage(o, Cairo_RectangleInt_program)))
      return 0;
    rectangle_int_load(rectangle_int, r);
    return 1;
  }

  /*! @decl protected void create(int x, int y,           @
   *!                             int width, int height)
   *!
   *! @param x
   *!   X coordinate of the left side of the rectangle
   *! @param y
   *!   Y coordinate of the top side of the rectangle
   *! @param width
   *!   width of the rectangle
   *! @param height
   *!   height of the rectangle
   */
  PIKEFUN void create(int x, int y,
                      int width, int height)
    flags ID_PROTECTED;
    get_all_args;
  {
    THIS->x = x;
    THIS->y = y;
    THIS->width = width;
    THIS->height = height;
    RETURN;
  }

  /*! @decl protected string _sprintf(int c, mapping flags)
   */
  PIKEFUN string _sprintf(int c, mapping flags)
    flags ID_PROTECTED;
    get_all_args;
  {
     switch(c) {
     default:
       push_undefined();
       break;

     case 't':
       push_static_text("Cairo.RectangleInt");
       break;

     case 'O':
       {
         struct string_builder sb;
         init_string_builder(&sb, 0);
         string_builder_sprintf(&sb, "Cairo.RectangleInt(%d, %d, %d, %d)",
                                (int)THIS->x, (int)THIS->y,
                                (int)THIS->width, (int)THIS->height);
         RETURN finish_string_builder(&sb);
       }
       break;
     }

     stack_unlink(args);
  }
}
/*! @endclass */
#endif

/*! @class Matrix
 *!
 *! Holds an affine transformation, such as a scale, rotation, shear,
 *! or a combination of those.
 */
PIKECLASS Matrix
{
  /*! @decl float xx
   *!   xx component of the affine transformation
   *!
   *! @decl float yx
   *!   yx component of the affine transformation
   *!
   *! @decl float xy
   *!   xy component of the affine transformation
   *!
   *! @decl float yy
   *!   yy component of the affine transformation
   *!
   *! @decl float x0
   *!   X translation component of the affine transformation
   *!
   *! @decl float y0
   *!   Y translation component of the affine transformation
   */
  PIKEVAR float xx;
  PIKEVAR float yx;
  PIKEVAR float xy;
  PIKEVAR float yy;
  PIKEVAR float x0;
  PIKEVAR float y0;

  static void matrix_load(cairo_matrix_t *matrix, const struct Cairo_Matrix_struct *m)
  {
    matrix->xx = m->xx;
    matrix->yx = m->yx;
    matrix->xy = m->xy;
    matrix->yy = m->yy;
    matrix->x0 = m->x0;
    matrix->y0 = m->y0;
  }

  static void matrix_store(const cairo_matrix_t *matrix, struct Cairo_Matrix_struct *m)
  {
    m->xx = matrix->xx;
    m->yx = matrix->yx;
    m->xy = matrix->xy;
    m->yy = matrix->yy;
    m->x0 = matrix->x0;
    m->y0 = matrix->y0;
  }

  static struct object *matrix_to_object(const cairo_matrix_t *matrix)
  {
    struct object *o = fast_clone_object(Cairo_Matrix_program);
    struct Cairo_Matrix_struct *m = GET_CAIRO_MATRIX_STORAGE(o);
    matrix_store(matrix, m);
    return o;
  }

  static int matrix_from_object(struct object *o, cairo_matrix_t *matrix)
  {
    struct Cairo_Matrix_struct *m;
    if (!(m = get_storage(o, Cairo_Matrix_program)))
      return 0;
    matrix_load(matrix, m);
    return 1;
  }

  /*! @decl protected void create(float|int|void xx, float|int|void yx,  @
   *!                             float|int|void xy, float|int|void yy,  @
   *!                             float|int|void x0, float|int|void y0)
   *!
   *! @param xx
   *!   xx component of the affine transformation
   *! @param yx
   *!   yx component of the affine transformation
   *! @param xy
   *!   xy component of the affine transformation
   *! @param yy
   *!   yy component of the affine transformation
   *! @param x0
   *!   X translation component of the affine transformation
   *! @param y0
   *!   Y translation component of the affine transformation
   */
  PIKEFUN void create(float|int|void xx, float|int|void yx, float|int|void xy,
                      float|int|void yy, float|int|void x0, float|int|void y0)
    flags ID_PROTECTED;
    get_all_args;
  {
    THIS->xx = (args < 1 ? 1.0 : xx);
    THIS->yx = yx;
    THIS->xy = xy;
    THIS->yy = (args < 4 ? 1.0 : yy);
    THIS->x0 = x0;
    THIS->y0 = y0;
    RETURN;
  }

  /*! @decl protected string _sprintf(int c, mapping flags)
   */
  PIKEFUN string _sprintf(int c, mapping flags)
    flags ID_PROTECTED;
    get_all_args;
  {
     switch(c) {
     default:
       push_undefined();
       break;

     case 't':
       push_static_text("Cairo.Matrix");
       break;

     case 'O':
       {
         struct string_builder sb;
         init_string_builder(&sb, 0);
         string_builder_sprintf(&sb, "Cairo.Matrix(%f, %f, %f, %f, %f, %f)",
                                (double)THIS->xx, (double)THIS->yx,
                                (double)THIS->xy, (double)THIS->yy,
                                (double)THIS->x0, (double)THIS->y0);
         RETURN finish_string_builder(&sb);
       }
       break;
     }

     stack_unlink(args);
  }

  /*! @decl void translate(float|int tx, float|int ty)
   *!
   *! Applies a translation by tx, ty to the transformation.  The
   *! effect of the new transformation is to first translate the
   *! coordinates by tx and ty, then apply the original transformation
   *! to the coordinates.
   *!
   *! @param tx
   *!   amount to translate in the X direction
   *! @param ty
   *!   amount to translate in the Y direction
   */
  PIKEFUN void translate(float|int tx, float|int ty)
    get_all_args;
  {
    cairo_matrix_t matrix;
    matrix_load(&matrix, THIS);
    cairo_matrix_translate(&matrix, tx, ty);
    matrix_store(&matrix, THIS);
    RETURN;
  }

  /*! @decl void scale(float|int sx, float|int sy)
   *!
   *! Applies scaling by sx, sy to the transformation.  The effect of
   *! the new transformation is to first scale the coordinates by sx
   *! and sy, then apply the original transformation to the
   *! coordinates.
   *!
   *! @param sx
   *!   scale factor in the X direction
   *! @param sy
   *!   scale factor in the Y direction
   */
  PIKEFUN void scale(float|int sx, float|int sy)
    get_all_args;
  {
    cairo_matrix_t matrix;
    matrix_load(&matrix, THIS);
    cairo_matrix_scale(&matrix, sx, sy);
    matrix_store(&matrix, THIS);
    RETURN;
  }

  /*! @decl void rotate(float radians)
   *!
   *! Applies rotation by radians to the transformation.  The effect of
   *! the new transformation is to first rotate the coordinates by
   *! radians, then apply the original transformation to the
   *! coordinates.
   *!
   *! @param radians
   *!   angle of rotation, in radians.  The direction of rotation is
   *!   defined such that positive angles rotate in the direction from
   *!   the positive X axis toward the positive Y axis. With the default
   *!   axis orientation of cairo, positive angles rotate in a clockwise
   *!   direction.
   */
  PIKEFUN void rotate(float radians)
    get_all_args;
  {
    cairo_matrix_t matrix;
    matrix_load(&matrix, THIS);
    cairo_matrix_rotate (&matrix, radians);
    matrix_store(&matrix, THIS);
    RETURN;
  }

  /*! @decl void invert()
   *!
   *! Changes matrix to be the inverse of its original value.  Not all
   *! transformation matrices have inverses; if the matrix collapses
   *! points together (it is degenerate), then it has no inverse and
   *! this function will fail.
   */
  PIKEFUN void invert()
  {
    cairo_matrix_t matrix;
    matrix_load(&matrix, THIS);
    check_status(cairo_matrix_invert(&matrix));
    matrix_store(&matrix, THIS);
    RETURN;
  }

  /*! @decl Matrix `*(Matrix other)
   *!
   *! Multiplies the affine transformations in this and other.  The
   *! effect of the resulting transformation is to first apply the
   *! transformation in this to the coordinates and then apply the
   *! transformation in other to the coordinates.
   *!
   *! @param other
   *!   a Matrix
   */
  PIKEFUN Matrix `*(Matrix other)
    get_all_args;
  {
    cairo_matrix_t a, b, matrix;
    matrix_load(&a, THIS);
    if (!matrix_from_object(other, &b))
      SIMPLE_ARG_TYPE_ERROR("`*", 1, "Cairo.Matrix");
    cairo_matrix_multiply(&matrix, &a, &b);
    RETURN matrix_to_object(&matrix);
  }

  /*! @decl array(float) transform_distance(float|int dx, float|int dy)

   *! Transforms the distance vector (dx, dy).  This is similar to
   *! @[transform_point()] except that the translation components of
   *! the transformation are ignored.  The calculation of the returned
   *! vector is as follows:
   *!
   *! @code
   *! dx_new = xx * dx + xy * dy;
   *! dy_new = yx * dx + yy * dy;
   *! @endcode
   *!
   *! @param dx
   *!   X component of a distance vector
   *! @param dy
   *!   Y component of a distance vector
   *!
   *! @returns
   *!   The transformed distance vector
   *!   @array
   *!     @elem float 0
   *!       X component of the new distance vector
   *!     @elem float 1
   *!       Y component of the new distance vector
   *!   @endarray
   */
  PIKEFUN array(float) transform_distance(float|int dx, float|int dy)
    get_all_args;
  {
    double ddx = dx;
    double ddy = dy;
    cairo_matrix_t matrix;
    matrix_load(&matrix, THIS);
    cairo_matrix_transform_distance(&matrix, &ddx, &ddy);
    pop_n_elems(2);
    push_float(ddx);
    push_float(ddy);
    f_aggregate(2);
  }

  /*! @decl array(float) transform_point(float|int x, float|int y)
   *!
   *! Transforms the point (x, y).  The transformation is given by:
   *!
   *! @code
   *! x_new = xx * x + xy * y + x0;
   *! y_new = yx * x + yy * y + y0;
   *! @endcode
   *!
   *! @param x
   *!   X position
   *! @param y
   *!   Y position
   *!
   *! @returns
   *!   The transformed point
   *!   @array
   *!     @elem float 0
   *!       X position of the new point
   *!     @elem float 1
   *!       Y position of the new point
   *!   @endarray
   */
  PIKEFUN array(float) transform_point(float|int x, float|int y)
    get_all_args;
  {
    double dx = x;
    double dy = y;
    cairo_matrix_t matrix;
    matrix_load(&matrix, THIS);
    cairo_matrix_transform_point(&matrix, &dx, &dy);
    pop_n_elems(2);
    push_float(dx);
    push_float(dy);
    f_aggregate(2);
  }
}
/*! @endclass */

/*! @class Path
 *!
 *! Paths are the most basic drawing tools and are primarily used to
 *! implicitly generate simple masks
 */
PIKECLASS Path
{
  CVAR cairo_path_t *path;

  PIKEFUN void create()
    flags ID_PROTECTED;
  {
    Pike_error("The Path type cannot be instantiated, use Cairo.Context.copy_path()\n");
  }

  /*! @decl protected string _sprintf(int c, mapping flags)
   */
  PIKEFUN string _sprintf(int c, mapping flags)
    flags ID_PROTECTED;
    get_all_args;
  {
     switch(c) {
     default:
       push_undefined();
       break;

     case 't':
       push_static_text("Cairo.Path");
       break;

     case 'O':
     case 's':
       {
         struct string_builder sb;
         ONERROR uwp;
         cairo_path_t *path;
         init_string_builder(&sb, 0);
         SET_ONERROR(uwp, free_string_builder, &sb);
         if (c == 'O')
           string_builder_strcat(&sb, "Cairo.Path(");
         if ((path = THIS->path)) {
           int i;
           cairo_path_data_t *data;
           for (i=0; i < path->num_data; i += path->data[i].header.length) {
             data = &path->data[i];
             if (i) {
               if (c == 'O')
                 string_builder_strcat(&sb, ", ");
               else
                 string_builder_putchar(&sb, '\n');
             }
             switch (data->header.type) {
             case CAIRO_PATH_MOVE_TO:
               string_builder_strcat(&sb, "move_to");
               string_builder_sprintf(&sb, (c == 's'? " %f %f" : "(%f, %f)"),
                                      (double)data[1].point.x,
                                      (double)data[1].point.y);
               break;
             case CAIRO_PATH_LINE_TO:
               string_builder_strcat(&sb, "line_to");
               string_builder_sprintf(&sb, (c == 's'? " %f %f" : "(%f, %f)"),
                                      (double)data[1].point.x,
                                      (double)data[1].point.y);
               break;
             case CAIRO_PATH_CURVE_TO:
               string_builder_strcat(&sb, "curve_to");
               string_builder_sprintf(&sb,
                                      (c == 's'? " %f %f %f %f %f %f" :
                                       "(%f, %f, %f, %f, %f, %f)"),
                                      (double)data[1].point.x,
                                      (double)data[1].point.y,
                                      (double)data[2].point.x,
                                      (double)data[2].point.y,
                                      (double)data[3].point.x,
                                      (double)data[3].point.y);
               break;
             case CAIRO_PATH_CLOSE_PATH:
               string_builder_strcat(&sb, "close_path");
               break;
             }
           }
         }
         if (c == 'O')
           string_builder_putchar(&sb, ')');
         UNSET_ONERROR(uwp);
         push_string(finish_string_builder(&sb));
       }
       break;
     }

     stack_unlink(args);
  }

#ifdef PIKE_NULL_IS_SPECIAL
  INIT {
    THIS->path = NULL;
  }
#endif

  EXIT
    gc_trivial;
  {
    if (THIS->path)
      cairo_path_destroy(THIS->path);
  }

  /*! @class PathIterator
   *!    This is the iterator for the Path.
   */
  PIKECLASS PathIterator
  {
    CVAR int pos;
    CVAR cairo_path_t *path;
    CVAR struct object *obj;

    /*! @decl void create(Path path)
     *!
     *! Creates a new iterator for the Path @[path].
     */
    PIKEFUN void create(Path path)
      flags ID_PROTECTED;
      get_all_args;
    {
      if (path->prog != Cairo_Path_program)
      {
        SIMPLE_ARG_TYPE_ERROR("create",1,"Cairo.Path");
      }
      else
      {
        THIS->path = OBJ2_CAIRO_PATH(path)->path;
        add_ref(THIS->obj = path);
        THIS->pos = -1;
        RETURN;
      }
    }

    /*! @decl int _iterator_index()
     *!
     *! Returns the current index, or @[UNDEFINED] if the iterator
     *! doesn't point to any item.
     *!
     *! The index is the current position in the data set, counting
     *! from @expr{0@} (zero).
     */
    PIKEFUN int _iterator_index()
      flags ID_PROTECTED;
    {
      if (THIS->pos < 0 || THIS->pos >= THIS->path->num_data)
        RETURN UNDEFINED;
      else
        RETURN THIS->pos;
    }

    /*! @decl mixed _iterator_value()
     *!
     *! Returns the current value, or @[UNDEFINED] if the iterator
     *! doesn't point to any item.
     */
    PIKEFUN array(int|array(float)) _iterator_value()
      flags ID_PROTECTED;
    {
      if (THIS->pos < 0 || THIS->pos >= THIS->path->num_data)
        RETURN UNDEFINED;
      else {
        cairo_path_data_t *data = &THIS->path->data[THIS->pos];
        push_int(data->header.type);
        switch (data->header.type) {
        case CAIRO_PATH_MOVE_TO:
        case CAIRO_PATH_LINE_TO:
          push_float(data[1].point.x);
          push_float(data[1].point.y);
          f_aggregate(2);
          break;
        case CAIRO_PATH_CURVE_TO:
          push_float(data[1].point.x);
          push_float(data[1].point.y);
          push_float(data[2].point.x);
          push_float(data[2].point.y);
          push_float(data[3].point.x);
          push_float(data[3].point.y);
          f_aggregate(6);
          break;
        default:
          f_aggregate(0);
          break;
        }
        f_aggregate(2);
      }
    }

    /*! @decl int(0..1) _iterator_next()
     *!
     *! Advance the iterator one step.
     *!
     *! @returns
     *!   Returns @tt{1@} if it succeeded in advancing, and
     *!   @tt{0@} (zero) if it has reached the end of the iterator.
     *!
     *! @seealso
     *!   @[_iterator_index()], @[_iterator_value()]
     */
    PIKEFUN int(0..1) _iterator_next()
      flags ID_PROTECTED;
    {
      if (THIS->pos < 0)
        THIS->pos = 0;
      else if (THIS->pos < THIS->path->num_data)
        THIS->pos += THIS->path->data[THIS->pos].header.length;
      if (THIS->pos < THIS->path->num_data)
        RETURN 1;
      RETURN UNDEFINED;
    }

    INIT
    {
      THIS->pos = -1;
#ifdef PIKE_NULL_IS_SPECIAL
      THIS->path = NULL;
      THIS->obj = NULL;
#endif
    }

    EXIT
      gc_trivial;
    {
      if( THIS->obj )
        free_object(THIS->obj);
    }

  }
  /*! @endclass
  */

  /*! @decl PathIterator _get_iterator(void|int ind)
   *!   Create and initiate a new PathIterator that could be used
   *!   to iterate over this path.
   *!
   *! @returns
   *!   An iterator.
   */
  PIKEFUN PathIterator _get_iterator()
  {
    ref_push_object(Pike_fp->current_object);
    RETURN clone_object(Cairo_Path_PathIterator_program, 1);
  }
}
/*! @endclass */

/*! @class Glyph
 *!
 *! Holds information about a single glyph when drawing or measuring
 *! text.  A font is (in simple terms) a collection of shapes used to
 *! draw text.  A glyph is one of these shapes.  There can be multiple
 *! glyphs for a single character (alternates to be used in different
 *! contexts, for example), or a glyph can be a ligature of multiple
 *! characters.  Cairo doesn't expose any way of converting input text
 *! into glyphs, so in order to use the Cairo interfaces that take
 *! arrays of glyphs, you must directly access the appropriate
 *! underlying font system.
 *!
 *! Note that the offsets given by @[x] and @[y] are not cumulative.
 *! When drawing or measuring text, each glyph is individually
 *! positioned with respect to the overall origin
 */
PIKECLASS Glyph
{
  /*! @decl int(0..) index
   *! glyph index in the font.  The exact interpretation of the glyph
   *! index depends on the font technology being used.
   */
  PIKEVAR int(0..) index;
  /*! @decl float x
   *! the offset in the X direction between the origin used for
   *! drawing or measuring the string and the origin of this glyph.
   */
  PIKEVAR float x;
  /*! @decl float y
   *! the offset in the Y direction between the origin used for
   *! drawing or measuring the string and the origin of this glyph.
   */
  PIKEVAR float y;

  /*! @decl protected void create(int(0..) index, float|int|void x,      @
   *!                                             float|int|void y)
   *!
   *! @param index
   *!   glyph index in the font.  The exact interpretation of the
   *!   glyph index depends on the font technology being used.
   *! @param x
   *!   the offset in the X direction between the origin used for
   *!   drawing or measuring the string and the origin of this glyph.
   *! @param y
   *!   the offset in the Y direction between the origin used for
   *!   drawing or measuring the string and the origin of this glyph.
   */
  PIKEFUN void create(int(0..) index, float|int|void x, float|int|void y)
    flags ID_PROTECTED;
    get_all_args;
  {
    THIS->index = index;
    THIS->x = x;
    THIS->y = y;
    RETURN;
  }

  /*! @decl protected string _sprintf(int c, mapping flags)
   */
  PIKEFUN string _sprintf(int c, mapping flags)
    flags ID_PROTECTED;
    get_all_args;
  {
     switch(c) {
     default:
       push_undefined();
       break;

     case 't':
       push_static_text("Cairo.Glyph");
       break;

     case 'O':
       {
         struct string_builder sb;
         init_string_builder(&sb, 0);
         string_builder_sprintf(&sb, "Cairo.Glyph(%lu, %f, %f)",
                                (unsigned long)THIS->index,
                                (double)THIS->x, (double)THIS->y);
         RETURN finish_string_builder(&sb);
       }
       break;
     }

     stack_unlink(args);
  }

  static struct object *glyph_to_obj(const cairo_glyph_t *glyph)
  {
    struct object *o = fast_clone_object(Cairo_Glyph_program);
    struct Cairo_Glyph_struct *gly = GET_CAIRO_GLYPH_STORAGE(o);
    gly->index = glyph->index;
    gly->x = glyph->x;
    gly->y = glyph->y;
    return o;
  }
}
/*! @endclass */

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 8, 0)
/*! @class TextCluster
 *!
 *! Holds information about a single text cluster.  A text cluster is
 *! a minimal mapping of some glyphs corresponding to some UTF-8 text.
 *!
 *! For a cluster to be valid, both @[num_bytes] and @[num_glyphs]
 *! should be non-negative, and at least one should be non-zero.  Note
 *! that clusters with zero glyphs are not as well supported as normal
 *! clusters.  For example, PDF rendering applications typically
 *! ignore those clusters when PDF text is being selected.
 *!
 *! See @[Context->show_text_glyphs()] for how clusters are used in
 *! advanced text operations.
 */
PIKECLASS TextCluster
{
  /*! @decl int num_bytes
   *! the number of bytes of UTF-8 text covered by cluster
   */
  PIKEVAR int num_bytes;
  /*! @decl int num_glyphs
   *! the number of glyphs covered by cluster
   */
  PIKEVAR int num_glyphs;

  /*! @decl protected void create(int num_bytes, int num_glyphs)
   *!
   *! @param num_bytes
   *!   the number of bytes of UTF-8 text covered by cluster
   *! @param num_glyphs
   *!   the number of glyphs covered by cluster
   */
  PIKEFUN void create(int num_bytes, int num_glyphs)
    flags ID_PROTECTED;
    get_all_args;
  {
    THIS->num_bytes = num_bytes;
    THIS->num_glyphs = num_glyphs;
    RETURN;
  }

  /*! @decl protected string _sprintf(int c, mapping flags)
   */
  PIKEFUN string _sprintf(int c, mapping flags)
    flags ID_PROTECTED;
    get_all_args;
  {
     switch(c) {
     default:
       push_undefined();
       break;

     case 't':
       push_static_text("Cairo.TextCluster");
       break;

     case 'O':
       {
         struct string_builder sb;
         init_string_builder(&sb, 0);
         string_builder_sprintf(&sb, "Cairo.TextCluster(%d, %d)",
                                (int)THIS->num_bytes, (int)THIS->num_glyphs);
         RETURN finish_string_builder(&sb);
       }
       break;
     }

     stack_unlink(args);
  }

  static struct object *text_cluster_to_obj(const cairo_text_cluster_t *cluster)
  {
    struct object *o = fast_clone_object(Cairo_TextCluster_program);
    struct Cairo_TextCluster_struct *clu = GET_CAIRO_TEXTCLUSTER_STORAGE(o);
    clu->num_bytes = cluster->num_bytes;
    clu->num_glyphs = cluster->num_glyphs;
    return o;
  }

  static cairo_text_cluster_t *parse_text_clusters_arg(struct array *clusters,
                                                       const char *func,
                                                       int args, int argno)
  {
    INT32 i;
    cairo_text_cluster_t *cclusters =
      xalloc(clusters->size * sizeof(cairo_text_cluster_t));
    for (i=0; i<clusters->size; i++) {
      struct svalue *sv = &ITEM(clusters)[i];
      struct Cairo_TextCluster_struct *c;
      if (TYPEOF(*sv) == T_OBJECT &&
          (c = get_storage(sv->u.object, Cairo_TextCluster_program)) != NULL) {
        cclusters[i].num_bytes = c->num_bytes;
        cclusters[i].num_glyphs = c->num_glyphs;
      } else {
        free(cclusters);
        SIMPLE_ARG_TYPE_ERROR(func, argno, "array(Cairo.TextCluster)");
      }
    }
    return cclusters;
  }
}
/*! @endclass */
#endif

/*! @class TextExtents
 *! Stores the extents of a single glyph or a string of glyphs in
 *! user-space coordinates.  Because text extents are in user-space
 *! coordinates, they are mostly, but not entirely, independent of the
 *! current transformation matrix.  If you call
 *! @[Context->scale(2.0, 2.0)], text will be drawn twice as big, but
 *! the reported text extents will not be doubled.  They will change
 *! slightly due to hinting (so you can't assume that metrics are
 *! independent of the transformation matrix), but otherwise will
 *! remain unchanged.
 */
PIKECLASS TextExtents
{
  /*! @decl float x_bearing
   *! the horizontal distance from the origin to the leftmost part of
   *! the glyphs as drawn.  Positive if the glyphs lie entirely to the
   *! right of the origin.
   */
  PIKEVAR float x_bearing;
  /*! @decl float y_bearing
   *! the vertical distance from the origin to the topmost part of the
   *! glyphs as drawn.  Positive only if the glyphs lie completely
   *! below the origin; will usually be negative.
   */
  PIKEVAR float y_bearing;
  /*! @decl float width
   *! width of the glyphs as drawn
   */
  PIKEVAR float width;
  /*! @decl float height
   *! height of the glyphs as drawn
   */
  PIKEVAR float height;
  /*! @decl float x_advance
   *! distance to advance in the X direction after drawing these
   *! glyphs
   */
  PIKEVAR float x_advance;
  /*! @decl float y_advance
   *! distance to advance in the Y direction after drawing these
   *! glyphs.  Will typically be zero except for vertical text layout
   *! as found in East-Asian languages.
   */
  PIKEVAR float y_advance;

  static struct object *text_extents_to_obj(const cairo_text_extents_t *extents)
  {
    struct object *o = fast_clone_object(Cairo_TextExtents_program);
    struct Cairo_TextExtents_struct *ext = GET_CAIRO_TEXTEXTENTS_STORAGE(o);
    ext->x_bearing = extents->x_bearing;
    ext->y_bearing = extents->y_bearing;
    ext->width = extents->width;
    ext->height = extents->height;
    ext->x_advance = extents->x_advance;
    ext->y_advance = extents->y_advance;
    return o;
  }
}
/*! @endclass */

static void push_font_extents(const cairo_font_extents_t *extents)
{
  push_float(extents->ascent);
  push_float(extents->descent);
  push_float(extents->height);
  push_float(extents->max_x_advance);
  push_float(extents->max_y_advance);
  f_aggregate(5);
}

static cairo_glyph_t *parse_glyphs_arg(struct array *glyphs, const char *func,
                                       int args, int argno)
{
  INT32 i;
  cairo_glyph_t *gglyphs = xalloc(glyphs->size * sizeof(cairo_glyph_t));
  for (i=0; i<glyphs->size; i++) {
    struct svalue *sv = &ITEM(glyphs)[i];
    struct array *subarray;
    struct Cairo_Glyph_struct *g;
    if (TYPEOF(*sv) == T_OBJECT &&
        (g = get_storage(sv->u.object, Cairo_Glyph_program)) != NULL) {
      gglyphs[i].index = g->index;
      gglyphs[i].x = g->x;
      gglyphs[i].y = g->y;
    } else if (TYPEOF(*sv) != T_ARRAY || (subarray = sv->u.array)->size != 3 ||
               TYPEOF(ITEM(subarray)[0]) != T_INT ||
               (TYPEOF(ITEM(subarray)[1]) != T_INT && TYPEOF(ITEM(subarray)[1]) != T_FLOAT) ||
               (TYPEOF(ITEM(subarray)[2]) != T_INT && TYPEOF(ITEM(subarray)[2]) != T_FLOAT)) {
      free(gglyphs);
      SIMPLE_ARG_TYPE_ERROR(func, argno, "array(Cairo.Glyph|array(int|float))");
    } else {
      gglyphs[i].index = ITEM(subarray)[0].u.integer;
      gglyphs[i].x = (TYPEOF(ITEM(subarray)[1]) == T_FLOAT?
                      ITEM(subarray)[1].u.float_number :
                      ITEM(subarray)[1].u.integer);
      gglyphs[i].y = (TYPEOF(ITEM(subarray)[2]) == T_FLOAT?
                      ITEM(subarray)[2].u.float_number :
                      ITEM(subarray)[2].u.integer);
    }
  }
  return gglyphs;
}

/*! @class FontOptions
 *! The font options specify how fonts should be rendered.  Most of
 *! the time the font options implied by a surface are just right and
 *! do not need any changes, but for pixel-based targets tweaking font
 *! options may result in superior output on a particular display.
 */
PIKECLASS FontOptions
{
  CVAR cairo_font_options_t *options;

  /*! @decl void create(FontOptions|void original)
   *!
   *! Allocates a new font options object with all options initialized
   *! either to default values, or to values taken from @[original].
   *!
   *! @param original
   *!   If specified, a set of font options to copy
   */
  PIKEFUN void create(FontOptions|void original)
    flags ID_PROTECTED;
    get_all_args;
  {
    if (THIS->options)
      Pike_error("FontOptions already initialized\n");

    if (original) {
      struct Cairo_FontOptions_struct *o;
      if (!(o = get_storage(original, Cairo_FontOptions_program)))
        SIMPLE_ARG_TYPE_ERROR("create", 1, "Cairo.FontOptions");
      THIS->options = cairo_font_options_copy(o->options);
    } else
      THIS->options = cairo_font_options_create();
    check_status(cairo_font_options_status(THIS->options));
    RETURN;
  }

  /*! @decl void merge(FontOptions other)
   *!
   *! Merges non-default options from other into options, replacing
   *! existing values.  This operation can be thought of as somewhat
   *! similar to compositing other onto options with the operation of
   *! @[OPERATOR_OVER].
   *!
   *! @param other
   *!   another @[FontOptions]
   */
  PIKEFUN void merge(FontOptions other)
    get_all_args;
  {
    struct Cairo_FontOptions_struct *o;
    if (!(o = get_storage(other, Cairo_FontOptions_program)))
      SIMPLE_ARG_TYPE_ERROR("merge", 1, "Cairo.FontOptions");
    cairo_font_options_merge(THIS->options, o->options);
    check_status(cairo_font_options_status(THIS->options));
    RETURN;
  }

  PIKEFUN int __hash()
    flags ID_PROTECTED;
  {
    RETURN cairo_font_options_hash(THIS->options);
  }

  /*! @decl protected local int(0..1) `==(mixed x)
   *!
   *! @returns
   *!   Returns @expr{1@} if all fields of the two font options
   *!   objects match and @expr{0@} (zero) otherwise.  Note that this
   *!   function will return @expr{0@} if either object is in error.
   */
  PIKEFUN int `==(mixed x)
    flags ID_PROTECTED;
  {
    struct Cairo_FontOptions_struct *other;
    if (!x || (TYPEOF(*x) != PIKE_T_OBJECT) ||
        !x->u.object || !x->u.object->prog ||
        !(other = get_storage(x->u.object, Cairo_FontOptions_program)))
      RETURN 0;
    RETURN cairo_font_options_equal(THIS->options, other->options);
  }

  /*! @decl void set_antialias(int antialias)
   *!
   *! Sets the antialiasing mode for the font options object.  This
   *! specifies the type of antialiasing to do when rendering text.
   *!
   *! @param antialias
   *!   the new antialiasing mode
  */
  PIKEFUN void set_antialias(int antialias)
    get_all_args;
  {
    cairo_font_options_set_antialias(THIS->options, antialias);
    check_status(cairo_font_options_status(THIS->options));
    RETURN;
  }

  /*! @decl int get_antialias()
   *!
   *! Gets the antialiasing mode for the font options object.
   *!
   *! @returns
   *!   the antialiasing mode
   */
  PIKEFUN int get_antialias()
  {
    RETURN cairo_font_options_get_antialias(THIS->options);
  }

  /*! @decl void set_subpixel_order(int subpixel_order)
   *!
   *! Sets the subpixel order for the font options object.  The
   *! subpixel order specifies the order of color elements within each
   *! pixel on the display device when rendering with an antialiasing
   *! mode of @[ANTIALIAS_SUBPIXEL].
   *!
   *! @param subpixel_order
   *!   the new subpixel order
   */
  PIKEFUN void set_subpixel_order(int subpixel_order)
    get_all_args
  {
    cairo_font_options_set_subpixel_order(THIS->options, subpixel_order);
    check_status(cairo_font_options_status(THIS->options));
    RETURN;
  }

  /*! @decl int get_subpixel_order()
   *!
   *! Gets the subpixel order for the font options object.
   *!
   *! @returns
   *!   the subpixel order for the font options object
   */
  PIKEFUN int get_subpixel_order()
  {
    RETURN cairo_font_options_get_subpixel_order(THIS->options);
  }

  /*! @decl void set_hint_style(int hint_style)
   *!
   *! Sets the hint style for font outlines for the font options
   *! object.  This controls whether to fit font outlines to the pixel
   *! grid, and if so, whether to optimize for fidelity or
   *! contrast.
   *!
   *! @param hint_style
   *!   the new hint style
   */
  PIKEFUN void set_hint_style(int hint_style)
    get_all_args
  {
    cairo_font_options_set_hint_style(THIS->options, hint_style);
    check_status(cairo_font_options_status(THIS->options));
    RETURN;
  }

  /*! @decl int get_hint_style()
   *!
   *! Gets the hint style for font outlines for the font options
   *! object.
   *!
   *! @returns
   *!   the hint style for the font options object
   */
  PIKEFUN int get_hint_style()
  {
    RETURN cairo_font_options_get_hint_style(THIS->options);
  }

  /*! @decl void set_hint_metrics(int hint_metrics)
   *!
   *! Sets the metrics hinting mode for the font options object.  This
   *! controls whether metrics are quantized to integer values in
   *! device units.
   *!
   *! @param hint_metrics
   *!   the new metrics hinting mode
   */
  PIKEFUN void set_hint_metrics(int hint_metrics)
    get_all_args;
  {
    cairo_font_options_set_hint_metrics(THIS->options, hint_metrics);
    check_status(cairo_font_options_status(THIS->options));
    RETURN;
  }

  /*! @decl int get_hint_metrics()
   *!
   *! Gets the metrics hinting mode for the font options object.
   *!
   *! @returns
   *!   the metrics hinting mode for the font options object
   */
  PIKEFUN int get_hint_metrics()
  {
    RETURN cairo_font_options_get_hint_metrics(THIS->options);
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
  /*! @decl string(7bit)|zero get_variations()
   *!
   *! Gets the OpenType font variations for the font options object.
   *! See @[set_variations()] for details about the string format.
   *!
   *! @returns
   *!   the font variations for the font options object.
   */
  PIKEFUN string(7bit)|zero get_variations()
  {
    const char *var = cairo_font_options_get_variations(THIS->options);
    if (var)
      push_text(var);
    else
      push_int(0);
  }

  /*! @decl void set_variations(string(7bit)|zero variations)
   *!
   *! Sets the OpenType font variations for the font options object.
   *! Font variations are specified as a string with a format that is
   *! similar to the CSS font-variation-settings.  The string contains
   *! a comma-separated list of axis assignments, which each
   *! assignment consists of a 4-character axis name and a value,
   *! separated by whitespace and optional equals sign.
   *!
   *! @example
   *! @code
   *! wght=200,wdth=140.5
   *! wght 200 , wdth 140.5
   *! @endcode
   *!
   *! @param variations
   *!   the new font variations, or @expr{0@}
   */
  PIKEFUN void set_variations(string(7bit)|zero variations)
    get_all_args;
  {
    cairo_font_options_set_variations(THIS->options,
                                      (variations?
                                       (const char *)STR0(variations) : NULL));
    check_status(cairo_font_options_status(THIS->options));
    RETURN;
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
  /*! @decl void set_color_mode(int color_mode)
   *!
   *! Sets the color mode for the font options object.  This controls
   *! whether color fonts are to be rendered in color or as
   *! outlines.
   *!
   *! @param color_mode
   *!   the new color mode
   */
  PIKEFUN void set_color_mode(int color_mode)
    get_all_args;
  {
    cairo_font_options_set_color_mode(THIS->options, color_mode);
    check_status(cairo_font_options_status(THIS->options));
    RETURN;
  }

  /*! @decl int get_color_mode()
   *!
   *! Gets the color mode for the font options object.
   *!
   *! @returns
   *!   the color mode for the font options object
   */
  PIKEFUN int get_color_mode()
  {
    RETURN cairo_font_options_get_color_mode(THIS->options);
  }

  /*! @decl void set_color_palette(int(0..) palette_index)
   *!
   *! Sets the OpenType font color palette for the font options
   *! object.  OpenType color fonts with a CPAL table may contain
   *! multiple palettes.  The default color palette index is
   *! @[COLOR_PALETTE_DEFAULT].
   *!
   *! If palette_index is invalid, the default palette is used.
   *!
   *! Individual colors within the palette may be overriden with
   *! @[set_custom_palette_color()].
   *!
   *! @param palette_index
   *!   the palette index in the CPAL table
   */
  PIKEFUN void set_color_palette(int(0..) palette_index)
    get_all_args;
  {
    cairo_font_options_set_color_palette(THIS->options, palette_index);
    check_status(cairo_font_options_status(THIS->options));
    RETURN;
  }

  /*! @decl int(0..) get_color_palette()
   *!
   *! Gets the current OpenType color font palette for the font
   *! options object.
   *!
   *! @returns
   *!   the palette index
   */
  PIKEFUN int(0..) get_color_palette()
  {
    RETURN cairo_font_options_get_color_palette(THIS->options);
  }

  /*! @decl void set_custom_palette_color(int(0..) index, float red,          @
   *!                                     float green, float blue, float alpha)
   *!
   *! Sets a custom palette color for the font options object.  This
   *! overrides the palette color at the specified color index.  This
   *! override is independent of the selected palette index and will
   *! remain in place even if @[set_color_palette()] is called to
   *! change the palette index.
   *!
   *! It is only possible to override color indexes already in the
   *! font palette.
   *!
   *! @param index
   *!   the index of the color to set
   *! @param red
   *!   red component of color
   *! @param green
   *!   green component of color
   *! @param blue
   *!   blue component of color
   *! @param alpha
   *!   alpha component of color
   */
  PIKEFUN void set_custom_palette_color(int(0..) index, float red,
                                        float green, float blue, float alpha)
    get_all_args;
  {
    cairo_font_options_set_custom_palette_color(THIS->options, index, red,
                                                green, blue, alpha);
    check_status(cairo_font_options_status(THIS->options));
    RETURN;
  }

  /*! @decl array(float) get_custom_palette_color(int(0..) index)
   *!
   *! Gets the custom palette color for the color index for the font
   *! options object.
   *!
   *! @param index
   *!   the index of the color to get
   *!
   *! @returns
   *!   An array with the components of the color
   *!   @array
   *!     @elem float 0
   *!       red component of color
   *!     @elem float 1
   *!       green component of color
   *!     @elem float 2
   *!       blue component of color
   *!     @elem float 3
   *!       alpha component of color
   *!   @endarray
   */
  PIKEFUN array(float) get_custom_palette_color(int(0..) index)
    get_all_args;
  {
    double red, green, blue, alpha;
    check_status(cairo_font_options_get_custom_palette_color(THIS->options, index,
                                                             &red, &green, &blue,
                                                             &alpha));
    pop_stack();
    push_float(red);
    push_float(green);
    push_float(blue);
    push_float(alpha);
    f_aggregate(4);
  }
#endif

#ifdef PIKE_NULL_IS_SPECIAL
  INIT {
      THIS->options = NULL;
  }
#endif

  EXIT
    gc_trivial;
  {
    if( THIS->options )
      cairo_font_options_destroy(THIS->options);
  }
}
/*! @endclass */

/*! @class FontFace
 *! @[FontFace] represents a particular font at a particular weight,
 *! slant, and other characteristic but no size, transformation, or
 *! size.
 */
PIKECLASS FontFace
{
  CVAR cairo_font_face_t *font_face;

  /*! @decl protected local int(0..1) `==(mixed x)
   *!
   *! @returns
   *!   Returns @expr{1@} if @[x] is the same @[FontFace],
   *!   and @expr{0@} (zero) otherwise.
   */
  PIKEFUN int(0..1) `==(mixed x)
    flags ID_PROTECTED;
  {
    struct Cairo_FontFace_struct *other;
    if (!x || (TYPEOF(*x) != PIKE_T_OBJECT) ||
        !x->u.object || !x->u.object->prog ||
        !(other = get_storage(x->u.object, Cairo_FontFace_program)))
      RETURN 0;
    RETURN THIS->font_face == other->font_face;
  }

#ifdef PIKE_NULL_IS_SPECIAL
  INIT {
      THIS->font_face = NULL;
  }
#endif

  EXIT
    gc_trivial;
  {
    if( THIS->font_face )
      cairo_font_face_destroy(THIS->font_face);
  }
}
/*! @endclass */

/*! @class ToyFontFace
 *! Font faces used in implementation of the @[Context] "toy" font
 *! API.
 */
PIKECLASS ToyFontFace
{
  /*! @decl inherit FontFace
   */
  INHERIT FontFace;

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 8, 0)
  /*! @decl protected void create(string family, int slant, int weight)
   *!
   *! Creates a font face from a triplet of family, slant, and weight.
   *!
   *! If family is the zero-length string "", the platform-specific
   *! default family is assumed.  The default family then can be
   *! queried using @[get_family()].
   *!
   *! The @[Context->select_font_face()] function uses this to create
   *! font faces. See that function for limitations and other details
   *! of toy font faces.
   *!
   *! @param family
   *!   a font family name
   *! @param slant
   *!   the slant for the font
   *! @param weight
   *!   the weight for the font
   */
  PIKEFUN void create(string family, int slant, int weight)
    flags ID_PROTECTED;
    get_all_args;
  {
    if (THIS->font_face)
      Pike_error("ToyFontFace already initialized\n");

    ref_push_string(family);
    f_string_to_utf8(1);
    THIS->font_face =
      cairo_toy_font_face_create((const char *)STR0(Pike_sp[-1].u.string),
                                 slant, weight);
    pop_stack();
    check_status(cairo_font_face_status(THIS->font_face));
    RETURN;
  }

  /*! @decl string get_family()
   *!
   *! Gets the family name of a toy font.
   *!
   *! @returns
   *!   The family name.
   */
  PIKEFUN string get_family()
  {
    push_text(cairo_toy_font_face_get_family(THIS->font_face));
    f_utf8_to_string(1);
  }

  /*! @decl int get_slant()
   *!
   *! Gets the slant a toy font.
   *!
   *! @returns
   *!   The slant value
   */
  PIKEFUN int get_slant()
  {
    RETURN cairo_toy_font_face_get_slant(THIS->font_face);
  }

  /*! @decl int get_weight()
   *!
   *! Gets the weight a toy font.
   *!
   *! @returns
   *!   The weight value
   */
  PIKEFUN int get_weight()
  {
    RETURN cairo_toy_font_face_get_weight(THIS->font_face);
  }
#endif
}
/*! @endclass */

static struct object *ref_font_face_to_object(cairo_font_face_t *font_face)
{
  struct object *o;
  struct program *p;
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  switch (cairo_font_face_get_type(font_face)) {
  case CAIRO_FONT_TYPE_TOY: p = Cairo_ToyFontFace_program; break;
  default: p = Cairo_FontFace_program; break;
  }
#else
  p = Cairo_FontFace_program;
#endif
  o = fast_clone_object(p);
  GET_CAIRO_FONTFACE_STORAGE(o)->font_face =
    cairo_font_face_reference(font_face);
  return o;
}

/*! @class ScaledFont
 *! @[ScaledFont] represents a realization of a font face at a
 *! particular size and transformation and a certain set of font
 *! options
 */
PIKECLASS ScaledFont
{
  CVAR cairo_scaled_font_t *scaled_font;

  /*! @decl protected local int(0..1) `==(mixed x)
   *!
   *! @returns
   *!   Returns @expr{1@} if @[x] is the same @[ScaledFont],
   *!   and @expr{0@} (zero) otherwise.
   */
  PIKEFUN int(0..1) `==(mixed x)
    flags ID_PROTECTED;
  {
    struct Cairo_ScaledFont_struct *other;
    if (!x || (TYPEOF(*x) != PIKE_T_OBJECT) ||
        !x->u.object || !x->u.object->prog ||
        !(other = get_storage(x->u.object, Cairo_ScaledFont_program)))
      RETURN 0;
    RETURN THIS->scaled_font == other->scaled_font;
  }

  /*! @decl protected void create(FontFace font_face, Matrix font_matrix,  @
   *!                             Matrix ctm, FontOptions options)
   *!
   *! Creates a @[ScaledFont] object from a font face and matrices
   *! that describe the size of the font and the environment in which
   *! it will be used.
   *!
   *! @param font_face
   *!   a @[FontFace]
   *! @param font_matrix
   *!   font space to user space transformation matrix for the font.
   *!   In the simplest case of a N point font, this matrix is just a
   *!   scale by N, but it can also be used to shear the font or
   *!   stretch it unequally along the two axes.  See
   *!   @[Context->set_font_matrix()].
   *! @param ctm
   *!   user to device transformation matrix with which the font will
   *!   be used.
   *! @param options
   *!   options to use when getting metrics for the font and rendering
   *!   with it.
   */
  PIKEFUN void create(FontFace font_face, Matrix font_matrix, Matrix ctm,
                      FontOptions options)
    flags ID_PROTECTED;
    get_all_args;
  {
    struct Cairo_FontFace_struct *ff;
    struct Cairo_Matrix_struct *fm, *ctms;
    struct Cairo_FontOptions_struct *opt;
    cairo_matrix_t fmm, ctmm;

    if (!(ff = get_storage(font_face, Cairo_FontFace_program)))
      SIMPLE_ARG_TYPE_ERROR("create", 1, "Cairo.FontFace");
    if (!(fm = get_storage(font_matrix, Cairo_Matrix_program)))
      SIMPLE_ARG_TYPE_ERROR("create", 2, "Cairo.Matrix");
    if (!(ctms = get_storage(ctm, Cairo_Matrix_program)))
      SIMPLE_ARG_TYPE_ERROR("create", 3, "Cairo.Matrix");
    if (!(opt = get_storage(options, Cairo_FontOptions_program)))
      SIMPLE_ARG_TYPE_ERROR("create", 4, "Cairo.FontOptions");

    matrix_load(&fmm, fm);
    matrix_load(&ctmm, ctms);
    THIS->scaled_font = cairo_scaled_font_create(ff->font_face, &fmm, &ctmm,
                                                 opt->options);
    check_status(cairo_scaled_font_status(THIS->scaled_font));
    RETURN;
  }

  /*! @decl array(float) extents()
   *!
   *! Gets the metrics for a @[ScaledFont].  Values are given in the
   *! current user-space coordinate system.
   *!
   *! Because font metrics are in user-space coordinates, they are
   *! mostly, but not entirely, independent of the current
   *! transformation matrix.  If you call @[Context->scale(2.0, 2.0)],
   *! text will be drawn twice as big, but the reported text extents
   *! will not be doubled.  They will change slightly due to hinting
   *! (so you can't assume that metrics are independent of the
   *! transformation matrix), but otherwise will remain unchanged.
   *!
   *! @returns
   *!   an array which stores the retrieved extents:
   *!   @array
   *!     @elem float 0
   *!       ascent: the distance that the font extends above the
   *!       baseline.  Note that this is not always exactly equal to
   *!       the maximum of the extents of all the glyphs in the font,
   *!       but rather is picked to express the font designer's intent
   *!       as to how the font should align with elements above it.
   *!     @elem float 1
   *!       descent: the distance that the font extends below the
   *!       baseline.  This value is positive for typical fonts that
   *!       include portions below the baseline.  Note that this is
   *!       not always exactly equal to the maximum of the extents of
   *!       all the glyphs in the font, but rather is picked to
   *!       express the font designer's intent as to how the font
   *!       should align with elements below it.
   *!     @elem float 2
   *!       height: the recommended vertical distance between
   *!       baselines when setting consecutive lines of text with the
   *!       font.  This is greater than ascent + descent by a quantity
   *!       known as the line spacing or external leading.  When space
   *!       is at a premium, most fonts can be set with only a
   *!       distance of ascent + descent between lines.
   *!     @elem float 3
   *!       max_x_advance: the maximum distance in the X direction
   *!       that the origin is advanced for any glyph in the font.
   *!     @elem float 4
   *!       max_y_advance: the maximum distance in the Y direction
   *!       that the origin is advanced for any glyph in the font.
   *!       This will be zero for normal fonts used for horizontal
   *!       writing.  (The scripts of East Asia are sometimes written
   *!       vertically.)
   *!   @endarray
   */
  PIKEFUN array(float) extents()
  {
    cairo_font_extents_t extents;
    cairo_scaled_font_extents(THIS->scaled_font, &extents);
    check_status(cairo_scaled_font_status(THIS->scaled_font));
    push_font_extents(&extents);
  }

  /*! @decl TextExtents glyph_extents(array(Glyph|array(int|float)) glyphs)
   *!
   *! Gets the extents for an array of glyphs.  The extents describe a
   *! user-space rectangle that encloses the "inked" portion of the
   *! glyphs, (as they would be drawn by @[Context->show_glyphs()] if
   *! the cairo graphics state were set to the same font_face,
   *! font_matrix, ctm, and font_options as this @[ScaledFont]).
   *! Additionally, the x_advance and y_advance values indicate the
   *! amount by which the current point would be advanced by
   *! @[Context->show_glyphs()].
   *!
   *! Note that whitespace glyphs do not contribute to the size of the
   *! rectangle (@[TextExtents->width] and @[TextExtents->height]).
   *!
   *! @param glyphs
   *!   an array of glyph IDs with X and Y offsets, with each glyph
   *!   being represented either as a @[Glyph] object or as an array
   *!   having the following format:
   *!   @array
   *!     @elem int 0
   *!       glyph index in the font. The exact interpretation of the
   *!       glyph index depends on the font technology being used.
   *!     @elem float|int 1
   *!       the offset in the X direction between the origin used for
   *!       drawing the string and the origin of this glyph
   *!     @elem float|int 2
   *!       the offset in the Y direction between the origin used for
   *!       drawing the string and the origin of this glyph
   *!   @endarray
   *!
   *! @returns
   *!   a @[TextExtents] object which stores the retrieved extents.
   */
  PIKEFUN TextExtents glyph_extents(array(Glyph|array(int|float)) glyphs)
    get_all_args;
  {
    cairo_text_extents_t extents;
    cairo_glyph_t *gglyphs = NULL;
    if (glyphs->size)
      gglyphs = parse_glyphs_arg(glyphs, "glyph_extents", args, 1);
    cairo_scaled_font_glyph_extents(THIS->scaled_font, gglyphs,
                                    glyphs->size, &extents);
    if (gglyphs)
      free(gglyphs);
    check_status(cairo_scaled_font_status(THIS->scaled_font));
    RETURN text_extents_to_obj(&extents);
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  /*! @decl TextExtents text_extents(string text)
   *!
   *! Gets the extents for a string of text.  The extents describe a
   *! user-space rectangle that encloses the "inked" portion of the
   *! text drawn at the origin (0,0) (as it would be drawn by
   *! @[Context->show_text()] if the cairo graphics state were set to
   *! the same font_face, font_matrix, ctm, and font_options as this
   *! @[ScaledFont]).  Additionally, the x_advance and y_advance
   *! values indicate the amount by which the current point would be
   *! advanced by @[Context->show_text()].
   *!
   *! Note that whitespace characters do not directly contribute to
   *! the size of the rectangle (@[TextExtents->width] and
   *! @[TextExtents->height]).  They do contribute indirectly by
   *! changing the position of non-whitespace characters.  In
   *! particular, trailing whitespace characters are likely to not
   *! affect the size of the rectangle, though they will affect the
   *! x_advance and y_advance values.
   *!
   *! @param text
   *!   a string of text
   *!
   *! @returns
   *!   a @[TextExtents] object which stores the retrieved extents.
   */
  PIKEFUN TextExtents text_extents(string text)
    get_all_args;
  {
    cairo_text_extents_t extents;
    const char *utf8;
    f_string_to_utf8(1);
    text = Pike_sp[-1].u.string;
    utf8 = (const char *)STR0(text);
    cairo_scaled_font_text_extents(THIS->scaled_font, utf8, &extents);
    check_status(cairo_scaled_font_status(THIS->scaled_font));
    RETURN text_extents_to_obj(&extents);
  }

  /*! @decl FontFace get_font_face()
   *!
   *! Gets the font face that this scaled font uses.  This might be
   *! the font face passed to @[create()], but this does not hold true
   *! for all possible cases.
   *!
   *! @returns
   *!   The @[FontFace] with which scaled_font was created.
   */
  PIKEFUN FontFace get_font_face()
  {
    cairo_font_face_t *font_face =
      cairo_scaled_font_get_font_face(THIS->scaled_font);
    check_status(cairo_font_face_status(font_face));
    RETURN ref_font_face_to_object(font_face);
  }

  /*! @decl void get_font_options(FontOptions options)
   *!
   *! Stores the font options with which this @[ScaledFont] was
   *! created into @[options].
   *!
   *! @param options
   *!   return value for the font options
   */
  PIKEFUN void get_font_options(FontOptions options)
    get_all_args
  {
    struct Cairo_FontOptions_struct *opt;
    if (!(opt = get_storage(options, Cairo_FontOptions_program)))
      SIMPLE_ARG_TYPE_ERROR("get_font_options", 1, "Cairo.FontOptions");
    cairo_scaled_font_get_font_options(THIS->scaled_font, opt->options);
    check_status(cairo_scaled_font_status(THIS->scaled_font));
    RETURN;
  }

  /*! @decl Matrix get_font_matrix()
   *!
   *! Stores the font matrix with which this @[ScaledFont] was created
   *! into a @[Matrix].
   *!
   *! @returns
   *!   the matrix
   */
  PIKEFUN Matrix get_font_matrix()
  {
    cairo_matrix_t font_matrix;
    cairo_scaled_font_get_font_matrix(THIS->scaled_font, &font_matrix);
    RETURN matrix_to_object(&font_matrix);
  }

  /*! @decl Matrix get_ctm()
   *!
   *! Stores the CTM with which this @[ScaledFont] was created into a
   *! @[Matrix].  Note that the translation offsets (x0, y0) of the
   *! CTM are ignored by @[ScaledFont->create()].  So, the matrix this
   *! function returns always has 0,0 as x0,y0.
   *!
   *! @returns
   *!   the matrix
   */
  PIKEFUN Matrix get_ctm()
  {
    cairo_matrix_t ctm;
    cairo_scaled_font_get_ctm(THIS->scaled_font, &ctm);
    RETURN matrix_to_object(&ctm);
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 8, 0)

  struct glyph_and_cluster_store
  {
    cairo_glyph_t *glyphs;
    cairo_text_cluster_t *clusters;
    int num_glyphs, num_clusters;
    cairo_text_cluster_flags_t cluster_flags;
  };

  static void free_glyph_and_cluster_store(struct glyph_and_cluster_store *s)
  {
    cairo_glyph_free(s->glyphs);
    cairo_text_cluster_free(s->clusters);
  }

  /*! @decl array(array(Glyph)|array(TextCluster)|int)                        @
   *!               text_to_glyphs(float|int x, float|int y, string text)
   *!
   *! Converts text to an array of glyphs, optionally with cluster
   *! mapping, that can be used to render later using @[ScaledFont].
   *!
   *! For details of how clusters, and cluster_flags map UTF-8 text to
   *! the output glyphs see @[Context->show_text_glyphs()].
   *!
   *! The output values can be readily passed to
   *! @[Context->show_text_glyphs()], @[Context->show_glyphs()], or
   *! related functions, assuming that the exact same @[ScaledFont] is
   *! used for the operation.
   *!
   *! @param x
   *!   X position to place first glyph
   *! @param y
   *!   Y position to place first glyph
   *! @param text
   *!   a string of text
   *!
   *! @returns
   *!   An array with three elements
   *!   @array
   *!     @elem array(Glyph) 0
   *!       array of glyphs
   *!     @elem array(TextCluster) 1
   *!       array of cluster mapping information
   *!     @elem int 2
   *!       cluster flags corresponding to the output clusters
   *!   @endarray
   */
  PIKEFUN array(array(Glyph)|array(TextCluster)|int)
    text_to_glyphs(float|int x, float|int y, string text)
    get_all_args;
  {
    struct glyph_and_cluster_store s = { NULL, NULL, 0, 0, 0 };
    ONERROR onerror;
    const char *utf8;
    int utf8_len;
    int i;
    struct array *ret;

    f_string_to_utf8(1);
    text = Pike_sp[-1].u.string;
    utf8 = (const char *)STR0(text);
    utf8_len = text->len;
    SET_ONERROR(onerror, free_glyph_and_cluster_store, &s);
    check_status(cairo_scaled_font_text_to_glyphs(THIS->scaled_font, x, y,
                                                  utf8, utf8_len,
                                                  &s.glyphs, &s.num_glyphs,
                                                  &s.clusters, &s.num_clusters,
                                                  &s.cluster_flags));
    for (i=0; i<s.num_glyphs; i++)
      push_object(glyph_to_obj(&s.glyphs[i]));
    f_aggregate(s.num_glyphs);
    for (i=0; i<s.num_clusters; i++)
      push_object(text_cluster_to_obj(&s.clusters[i]));
    f_aggregate(s.num_clusters);
    push_int(s.cluster_flags);
    CALL_AND_UNSET_ONERROR(onerror);
    f_aggregate(3);
    stack_unlink(3);
  }

  /*! @decl Matrix get_scale_matrix()
   *!
   *! Stores the scale matrix of this @[ScaledFont] into a @[Matrix].
   *! The scale matrix is product of the font matrix and the ctm
   *! associated with the scaled font, and hence is the matrix mapping
   *! from font space to device space.
   *!
   *! @returns
   *!   the matrix
   */
  PIKEFUN Matrix get_scale_matrix()
  {
    cairo_matrix_t scale_matrix;
    cairo_scaled_font_get_scale_matrix(THIS->scaled_font, &scale_matrix);
    RETURN matrix_to_object(&scale_matrix);
  }
#endif

#ifdef PIKE_NULL_IS_SPECIAL
  INIT {
      THIS->scaled_font = NULL;
  }
#endif

  EXIT
    gc_trivial;
  {
    if( THIS->scaled_font )
      cairo_scaled_font_destroy(THIS->scaled_font);
  }
}
/*! @endclass */

static struct object *ref_scaled_font_to_object(cairo_scaled_font_t *scaled_font)
{
  struct object *o;
  struct program *p;
  p = Cairo_ScaledFont_program;
  o = fast_clone_object(p);
  GET_CAIRO_SCALEDFONT_STORAGE(o)->scaled_font =
    cairo_scaled_font_reference(scaled_font);
  return o;
}

static cairo_surface_t *surface_from_object(struct object *o);

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
/*! @class Device
 *! interface to underlying rendering system
 */
PIKECLASS Device
{
  CVAR cairo_device_t *device;

  /*! @decl protected local int(0..1) `==(mixed x)
   *!
   *! @returns
   *!   Returns @expr{1@} if @[x] is the same @[Device],
   *!   and @expr{0@} (zero) otherwise.
   */
  PIKEFUN int(0..1) `==(mixed x)
    flags ID_PROTECTED;
  {
    struct Cairo_Device_struct *other;
    if (!x || (TYPEOF(*x) != PIKE_T_OBJECT) ||
        !x->u.object || !x->u.object->prog ||
        !(other = get_storage(x->u.object, Cairo_Device_program)))
      RETURN 0;
    RETURN THIS->device == other->device;
  }

  /*! @decl void finish()
   *!
   *! This function finishes the device and drops all references to
   *! external resources.  All surfaces, fonts and other objects
   *! created for this device will be finished, too.  Further
   *! operations on the device will not affect the device but will
   *! instead trigger a @[STATUS_DEVICE_FINISHED] error.
   *!
   *! When the reference count of a @[Device] drops to zero, cairo
   *! will call @[finish()] if it hasn't been called already, before
   *! freeing the resources associated with the device.
   *!
   *! This function may acquire devices.
   */
  PIKEFUN void finish()
  {
    cairo_device_finish(THIS->device);
    check_status(cairo_device_status(THIS->device));
  }

  /*! @decl void flush()
   *!
   *! Finish any pending operations for the device and also restore
   *! any temporary modifications cairo has made to the device's
   *! state.  This function must be called before switching from using
   *! the device with Cairo to operating on it directly with native
   *! APIs.  If the device doesn't support direct access, then this
   *! function does nothing.
   *!
   *! This function may acquire devices.
   */
  PIKEFUN void flush()
  {
    cairo_device_flush(THIS->device);
    check_status(cairo_device_status(THIS->device));
  }

  /*! @decl void acquire()
   *!
   *! Acquires the device for the current thread.  This function will
   *! block until no other thread has acquired the device.
   *!
   *! From now on your thread owns the device and no other thread will
   *! be able to acquire it until a matching call to @[release()].  It
   *! is allowed to recursively acquire the device multiple times from
   *! the same thread.
   *!
   *! You must never acquire two different devices at the same time
   *! unless this is explicitly allowed.  Otherwise the possibility of
   *! deadlocks exist.  As various Cairo functions can acquire devices
   *! when called, these functions may also cause deadlocks when you
   *! call them with an acquired device.  So you must not have a
   *! device acquired when calling them.  These functions are marked
   *! in the documentation.
   *!
   *! After a successful call to @[acquire()], a matching call to
   *! @[release()] is required.
   */
  PIKEFUN void acquire()
  {
    check_status(cairo_device_acquire(THIS->device));
  }

  /*! @decl void release()
   *!
   *! Releases a device previously acquired using @[acquire()].  See
   *! that function for details.
   */
  PIKEFUN void release()
  {
    cairo_device_release(THIS->device);
    check_status(cairo_device_status(THIS->device));
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
  /*! @decl float observer_elapsed()
   *!
   *! Returns the total elapsed time of the observation.
   *!
   *! @returns
   *!   the elapsed time, in nanoseconds.
  */
  PIKEFUN float observer_elapsed()
  {
    RETURN cairo_device_observer_elapsed(THIS->device);
  }

  /*! @decl float observer_fill_elapsed()
   *!
   *! Returns the elapsed time of the fill operations.
   *!
   *! @returns
   *!   the elapsed time, in nanoseconds.
   */
  PIKEFUN float observer_fill_elapsed()
  {
    RETURN cairo_device_observer_fill_elapsed(THIS->device);
  }

  /*! @decl float observer_glyphs_elapsed()
   *!
   *! Returns the elapsed time of the glyph operations.
   *!
   *! @returns
   *!   the elapsed time, in nanoseconds.
  */
  PIKEFUN float observer_glyphs_elapsed()
  {
    RETURN cairo_device_observer_glyphs_elapsed(THIS->device);
  }

  /*! @decl float observer_mask_elapsed()
   *!
   *! Returns the elapsed time of the mask operations.
   *!
   *! @returns
   *!   the elapsed time, in nanoseconds
   */
  PIKEFUN float observer_mask_elapsed()
  {
    RETURN cairo_device_observer_mask_elapsed(THIS->device);
  }

  /*! @decl float observer_paint_elapsed()
   *!
   *! Returns the elapsed time of the paint operations.
   *!
   *! @returns
   *!   the elapsed time, in nanoseconds.
   */
  PIKEFUN float observer_paint_elapsed()
  {
    RETURN cairo_device_observer_paint_elapsed(THIS->device);
  }

  /*! @decl void observer_print(Stdio.OutputStreamMixin stream)
   *!
   *! Prints the device log to the given output stream
   *!
   *! @param stream
   *!   the output stream
   */
  PIKEFUN void observer_print(Stdio.OutputStreamMixin stream)
    get_all_args;
  {
    struct strm_func_closure ctx;
    if ((ctx.func_id = find_identifier("write", (ctx.obj = stream)->prog)) >= 0)
      check_status(cairo_device_observer_print(THIS->device,
                                               strm_write_func, &ctx));
    else
      SIMPLE_ARG_TYPE_ERROR("observer_print", 1, "Stdio.OutputStreamMixin");
    RETURN;
  }

  /*! @decl float observer_stroke_elapsed()
   *!
   *! Returns the elapsed time of the stroke operations.
   *!
   *! @returns
   *!   the elapsed time, in nanoseconds.
   */
  PIKEFUN float observer_stroke_elapsed()
  {
    RETURN cairo_device_observer_stroke_elapsed(THIS->device);
  }
#endif

#ifdef PIKE_NULL_IS_SPECIAL
  INIT {
    THIS->device = NULL;
  }
#endif

  EXIT
    gc_trivial;
  {
    if (THIS->device)
      cairo_device_destroy(THIS->device);
  }
}
/*! @endclass */
#endif

#ifdef CAIRO_HAS_SCRIPT_SURFACE
/*! @class ScriptDevice
 *! Rendering to replayable scripts
 */
PIKECLASS ScriptDevice
{
  /*! @decl inherit Device
   */
  INHERIT Device;

  /*! @decl protected void create(string|Stdio.OutputStreamMixin script_file)
   *!
   *! Creates a output device for emitting the script, used when
   *! creating the individual surfaces.
   *!
   *! @param script_file
   *!   the name (path) of the file, or a @[Stdio.OutputStreamMixin],
   *!   to write the script to
   */
  PIKEFUN void create(string|Stdio.OutputStreamMixin script_file)
    flags ID_PROTECTED;
    get_all_args;
  {
    struct strm_func_closure ctx;

    if (THIS->device)
      Pike_error("Device already initialized\n");

    if (PIKE_TYPEOF(*script_file) == PIKE_T_STRING &&
        !script_file->u.string->size_shift)
      THIS->device =
        cairo_script_create((const char *)STR0(script_file->u.string));
    else if (PIKE_TYPEOF(*script_file) == PIKE_T_OBJECT &&
             (ctx.func_id = find_identifier("write", (ctx.obj =
                                                      script_file->u.object)->prog))
             >= 0) {
      THIS->device =
        cairo_script_create_for_stream(strm_write_func, &ctx);
    } else
      SIMPLE_ARG_TYPE_ERROR("create", 1, "string|Stdio.OutputStreamMixin");
    check_status(cairo_device_status(THIS->device));
    RETURN;
  }

  /*! @decl void from_recording_surface(RecordingSurface recording_surface)
   *!
   *! Converts the record operations in @[recording_surface] into a
   *! script.
   *!
   *! @param recording_surface
   *!   the recording surface to replay
   */
  PIKEFUN void from_recording_surface(object/*(Cairo.RecordingSurface)*/ recording_surface)
    get_all_args;
  {
    cairo_surface_t *surf;

    if (!(surf = surface_from_object(recording_surface)))
      SIMPLE_ARG_TYPE_ERROR("from_recording_surface", 1, "Cairo.RecordingSurface");
    check_status(cairo_script_from_recording_surface(THIS->device, surf));
    RETURN;
  }

  /*! @decl int get_mode()
   *!
   *! Queries the script for its current output mode.
   *!
   *! @returns
   *!   the current output mode of the script
   */
  PIKEFUN int get_mode()
  {
    RETURN cairo_script_get_mode(THIS->device);
  }

  /*! @decl void set_mode(int mode)
   *!
   *! Change the output mode of the script
   *!
   *! @param mode
   *!   the new mode
   */
  PIKEFUN void set_mode(int mode)
    get_all_args;
  {
    cairo_script_set_mode(THIS->device, mode);
    check_status(cairo_device_status(THIS->device));
    RETURN;
  }

  /*! @decl void write_comment(string(8bit) comment)
   *!
   *! Emit a string verbatim into the script.
   *!
   *! @param comment
   *!   the string to emit
   */
  PIKEFUN void write_comment(string(8bit) comment)
    get_all_args;
  {
    cairo_script_write_comment(THIS->device, (const char *)STR0(comment),
                               comment->len);
    check_status(cairo_device_status(THIS->device));
    RETURN;
  }
}
/*! @endclass */
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
static struct object *ref_device_to_object(cairo_device_t *device)
{
  struct object *o;
  struct program *p;
  switch (cairo_device_get_type(device)) {
#ifdef CAIRO_HAS_SCRIPT_SURFACE
  case CAIRO_DEVICE_TYPE_SCRIPT: p = Cairo_ScriptDevice_program; break;
#endif
  default: p = Cairo_Device_program; break;
  }
  o = fast_clone_object(p);
  GET_CAIRO_DEVICE_STORAGE(o)->device = cairo_device_reference(device);
  return o;
}
#endif

static struct object *surface_to_object(cairo_surface_t *surf);
static struct object *ref_surface_to_object(cairo_surface_t *surf);

/*! @class Surface
 *! Base class for surfaces
 */
PIKECLASS Surface
{
  CVAR cairo_surface_t *surface;

  /*! @decl protected local int(0..1) `==(mixed x)
   *!
   *! @returns
   *!   Returns @expr{1@} if @[x] is the same @[Surface],
   *!   and @expr{0@} (zero) otherwise.
   */
  PIKEFUN int(0..1) `==(mixed x)
    flags ID_PROTECTED;
  {
    struct Cairo_Surface_struct *other;
    if (!x || (TYPEOF(*x) != PIKE_T_OBJECT) ||
        !x->u.object || !x->u.object->prog ||
        !(other = get_storage(x->u.object, Cairo_Surface_program)))
      RETURN 0;
    RETURN THIS->surface == other->surface;
  }

  /*! @decl Surface create_similar(int content, int width, int height)
   *!
   *! Create a new surface that is as compatible as possible with this
   *! surface.  For example the new surface will have the same device
   *! scale, fallback resolution and font options as this.  Generally,
   *! the new surface will also use the same backend, unless that is
   *! not possible for some reason.
   *!
   *! Initially the surface contents are all 0 (transparent if
   *! contents have transparency, black otherwise.)
   *!
   *! Use @[create_similar_image()] if you need an image surface which
   *! can be painted quickly to the target surface.
   *!
   *! @param content
   *!   the content for the new surface
   *! @param width
   *!   width of the new surface, (in device-space units)
   *! @param height
   *!   height of the new surface (in device-space units)
   *!
   *! @returns
   *!   a newly allocated surface.
   */
  PIKEFUN Surface create_similar(int content, int width, int height)
    get_all_args;
  {
    ONERROR onerr;
    cairo_surface_t *surf = cairo_surface_create_similar(THIS->surface, content,
                                                         width, height);
    SET_ONERROR(onerr, cairo_surface_destroy, surf);
    check_status(cairo_surface_status(surf));
    UNSET_ONERROR(onerr);
    RETURN surface_to_object(surf);
  }

  /*! @decl void finish()
   *!
   *! This function finishes the surface and drops all references to
   *! external resources.  For example, for the Xlib backend it means
   *! that cairo will no longer access the drawable, which can be
   *! freed.  After calling @[finish()] the only valid operations on a
   *! surface are checking status, getting and setting user,
   *! referencing and destroying, and flushing and finishing it.
   *! Further drawing to the surface will not affect the surface but
   *! will instead trigger a @[STATUS_SURFACE_FINISHED] error.
   *!
   *! When the reference count of the @[Surface] decreases to zero,
   *! cairo will call @[finish()] if it hasn't been called already,
   *! before freeing the resources associated with the surface.
   */
  PIKEFUN void finish()
  {
    cairo_surface_finish(THIS->surface);
    check_status(cairo_surface_status(THIS->surface));
  }

 /*! @decl void flush()
  *!
  *! Do any pending drawing for the surface and also restore any
  *! temporary modifications cairo has made to the surface's state.
  *! This function must be called before switching from drawing on the
  *! surface with cairo to drawing on it directly with native APIs, or
  *! accessing its memory outside of Cairo.  If the surface doesn't
  *! support direct access, then this function does nothing.
  */
  PIKEFUN void flush()
  {
    cairo_surface_flush(THIS->surface);
    check_status(cairo_surface_status(THIS->surface));
  }

  /*! @decl void get_font_options(FontOptions options)
   *!
   *! Retrieves the default font rendering options for the surface.
   *! This allows display surfaces to report the correct subpixel
   *! order for rendering on them, print surfaces to disable hinting
   *! of metrics and so forth.  The result can then be used with
   *! @[ScaledFont->create()].
   *!
   *! @param options
   *!   a @[FontOptions] object into which to store the retrieved
   *!   options. All existing values are overwritten
   */
  PIKEFUN void get_font_options(FontOptions options)
    get_all_args;
  {
    struct Cairo_FontOptions_struct *opt;
    if (!(opt = get_storage(options, Cairo_FontOptions_program)))
      SIMPLE_ARG_TYPE_ERROR("get_font_options", 1, "Cairo.FontOptions");
    cairo_surface_get_font_options(THIS->surface, opt->options);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void mark_dirty()
   *!
   *! Tells cairo that drawing has been done to surface using means
   *! other than cairo, and that cairo should reread any cached areas.
   *! Note that you must call @[flush()] before doing such drawing.
   */
  PIKEFUN void mark_dirty()
  {
    cairo_surface_mark_dirty(THIS->surface);
    check_status(cairo_surface_status(THIS->surface));
  }

  /*! @decl void mark_dirty_rectangle(int x, int y, int width, int height)
   *!
   *! Like @[mark_dirty()], but drawing has been done only to the
   *! specified rectangle, so that cairo can retain cached contents
   *! for other parts of the surface.
   *!
   *! Any cached clip set on the surface will be reset by this
   *! function, to make sure that future cairo calls have the clip set
   *! that they expect.
   *!
   *! @param x
   *!   X coordinate of dirty rectangle
   *! @param y
   *!   Y coordinate of dirty rectangle
   *! @param width
   *!   width of dirty rectangle
   *! @param height
   *!   height of dirty rectangle
   */
  PIKEFUN void mark_dirty_rectangle(int x, int y, int width, int height)
    get_all_args;
  {
    cairo_surface_mark_dirty_rectangle(THIS->surface, x, y, width, height);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void set_device_offset(float|int x_offset, float|int y_offset)
   *!
   *! Sets an offset that is added to the device coordinates
   *! determined by the CTM when drawing to surface.  One use case for
   *! this function is when we want to create a @[Surface] that
   *! redirects drawing for a portion of an onscreen surface to an
   *! offscreen surface in a way that is completely invisible to the
   *! user of the cairo API.  Setting a transformation via
   *! @[Context->translate()] isn't sufficient to do this, since
   *! functions like @[Context->device_to_user()] will expose the
   *! hidden offset.
   *!
   *! Note that the offset affects drawing to the surface as well as
   *! using the surface in a source pattern.
   *!
   *! @param x_offset
   *!   the offset in the X direction, in device units
   *! @param y_offset
   *!   the offset in the Y direction, in device units
   */
  PIKEFUN void set_device_offset(float|int x_offset, float|int y_offset)
    get_all_args;
  {
    cairo_surface_set_device_offset(THIS->surface, x_offset, y_offset);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  /*! @decl int get_content()
   *!
   *! This function returns the content type of surface which
   *! indicates whether the surface contains color and/or alpha
   *! information.
   *!
   *! @returns
   *!   The content type of surface .
   */
  PIKEFUN int get_content()
  {
    RETURN cairo_surface_get_content(THIS->surface);
  }

  /*! @decl array(float) get_device_offset()
   *!
   *! This function returns the previous device offset set by
   *! @[set_device_offset()].
   *!
   *! @returns
   *!   The device offset
   *!   @array
   *!     @elem float 0
   *!       the offset in the X direction, in device units
   *!     @elem float 1
   *!       the offset in the Y direction, in device units
   *!   @endarray
   */
  PIKEFUN array(float) get_device_offset()
  {
    double x_offset;
    double y_offset;
    cairo_surface_get_device_offset(THIS->surface, &x_offset, &y_offset);
    push_float(x_offset);
    push_float(y_offset);
    f_aggregate(2);
  }

  /*! @decl void set_fallback_resolution(float|int x_pixels_per_inch,   @
   *!                                    float|int y_pixels_per_inch)
   *!
   *! Set the horizontal and vertical resolution for image fallbacks.
   *!
   *! When certain operations aren't supported natively by a backend,
   *! cairo will fallback by rendering operations to an image and then
   *! overlaying that image onto the output.  For backends that are
   *! natively vector-oriented, this function can be used to set the
   *! resolution used for these image fallbacks, (larger values will
   *! result in more detailed images, but also larger file sizes).
   *!
   *! Some examples of natively vector-oriented backends are the ps,
   *! pdf, and svg backends.
   *!
   *! For backends that are natively raster-oriented, image fallbacks
   *! are still possible, but they are always performed at the native
   *! device resolution.  So this function has no effect on those
   *! backends.
   *!
   *! @note
   *!   The fallback resolution only takes effect at the time of
   *!   completing a page (with @[Context->show_page()] or
   *!   @[Context->copy_page()]) so there is currently no way to have
   *!   more than one fallback resolution in effect on a single page.
   *!
   *! The default fallback resolution is 300 pixels per inch in both dimensions.
   *!
   *! @param x_pixels_per_inch
   *!   horizontal setting for pixels per inch
   *! @param y_pixels_per_inch
   *!   vertical setting for pixels per inch
   */
  PIKEFUN void set_fallback_resolution(float|int x_pixels_per_inch,
                                       float|int y_pixels_per_inch)
    get_all_args;
  {
    cairo_surface_set_fallback_resolution(THIS->surface,
                                          x_pixels_per_inch, y_pixels_per_inch);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 6, 0)
  /*! @decl void copy_page()
   *!
   *! Emits the current page for backends that support multiple pages,
   *! but doesn't clear it, so that the contents of the current page
   *! will be retained for the next page.  Use @[show_page()] if you
   *! want to get an empty page after the emission.
   *!
   *! There is a convenience function for this in @[Context], namely
   *! @[Context->copy_page()].
   */
  PIKEFUN void copy_page()
  {
    cairo_surface_copy_page(THIS->surface);
    check_status(cairo_surface_status(THIS->surface));
  }

  /*! @decl void show_page()
   *!
   *! Emits and clears the current page for backends that support
   *! multiple pages.  Use @[copy_page()] if you don't want to clear
   *! the page.
   *!
   *! There is a convenience function for this in @[Context], namely
   *! @[Context->show_page()].
   */
  PIKEFUN void show_page()
  {
    cairo_surface_show_page(THIS->surface);
    check_status(cairo_surface_status(THIS->surface));
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 8, 0)
  /*! @decl array(float) get_fallback_resolution()
   *!
   *! This function returns the previous fallback resolution set by
   *! @[set_fallback_resolution()], or default fallback resolution if
   *! never set.
   *!
   *! @returns
   *!   The fallback resolution
   *!   @array
   *!     @elem float 0
   *!       horizontal pixels per inch
   *!     @elem float 1
   *!       vertical pixels per inch
   *!   @endarray
   */
  PIKEFUN array(float) get_fallback_resolution()
  {
    double x_pixels_per_inch;
    double y_pixels_per_inch;
    cairo_surface_get_fallback_resolution(THIS->surface, &x_pixels_per_inch,
                                          &y_pixels_per_inch);
    push_float(x_pixels_per_inch);
    push_float(y_pixels_per_inch);
    f_aggregate(2);
  }

  /*! @decl int(0..1) has_show_text_glyphs()
   *!
   *! Returns whether the surface supports sophisticated
   *! @[Context->show_text_glyphs()] operations.  That is, whether it
   *! actually uses the provided text and cluster data to a
   *! @[Context->show_text_glyphs()] call.
   *!
   *! @note
   *!   Even if this function returns @expr{0@}, a
   *!   @[Context->show_text_glyphs()] operation targeted at this
   *!   surface will still succeed.  It just will act like a
   *!   @[Context->show_glyphs()] operation.  Users can use this
   *!   function to avoid computing UTF-8 text and cluster mapping if
   *!   the target surface does not use it.
   *!
   *! @returns
   *!   @expr{1@} if surface supports @[Context->show_text_glyphs()],
   *!   @expr{0@} otherwise
   */
  PIKEFUN int(0..1) has_show_text_glyphs()
  {
    RETURN cairo_surface_has_show_text_glyphs(THIS->surface);
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
  /*! @decl Surface create_for_rectangle(float|int x, float|int y,           @
   *!                                    float|int width, float|int height)
   *!
   *! Create a new surface that is a rectangle within the target
   *! surface.  All operations drawn to this surface are then clipped
   *! and translated onto the target surface.  Nothing drawn via this
   *! sub-surface outside of its bounds is drawn onto the target
   *! surface, making this a useful method for passing constrained
   *! child surfaces to library routines that draw directly onto the
   *! parent surface, i.e. with no further backend allocations, double
   *! buffering or copies.
   *!
   *! The semantics of subsurfaces have not been finalized yet unless
   *! the rectangle is in full device units, is contained within the
   *! extents of the target surface, and the target or subsurface's
   *! device transforms are not changed.
   *!
   *! @param x
   *!   the x-origin of the sub-surface from the top-left of the
   *!   target surface (in device-space units)
   *! @param y
   *!   the y-origin of the sub-surface from the top-left of the
   *!   target surface (in device-space units)
   *! @param width
   *!   width of the sub-surface (in device-space units)
   *! @param height
   *!   height of the sub-surface (in device-space units)
   *!
   *! @returns
   *!   a newly allocated surface.
   */
  PIKEFUN Surface create_for_rectangle(float|int x, float|int y,
                                       float|int width, float|int height)
    get_all_args;
  {
    ONERROR onerr;
    cairo_surface_t *surf =
      cairo_surface_create_for_rectangle(THIS->surface, x, y, width, height);
    SET_ONERROR(onerr, cairo_surface_destroy, surf);
    check_status(cairo_surface_status(surf));
    UNSET_ONERROR(onerr);
    RETURN surface_to_object(surf);
  }

  /*! @decl Device get_device()
   *!
   *! This function returns the device for a surface.  See @[Device].
   *!
   *! @returns
   *!   The device for this surface or @expr{UNDEFINED@} if the
   *!   surface does not have an associated device.
   */
  PIKEFUN Device get_device()
  {
    cairo_device_t *dev = cairo_surface_get_device(THIS->surface);
    if (dev)
      RETURN ref_device_to_object(dev);
    else
      RETURN UNDEFINED;
  }

  /*! @decl void set_mime_data(string(7bit) mime_type, string(8bit)|zero data)
   *!
   *! Attach an image in the format mime_type to surface.  To remove
   *! the data from a surface, call this function with same mime type
   *! and @expr{0@} for data.
   *!
   *! The attached image (or filename) data can later be used by
   *! backends which support it (currently: PDF, PS, SVG and Win32
   *! Printing surfaces) to emit this data instead of making a
   *! snapshot of the surface.  This approach tends to be faster and
   *! requires less memory and disk space.
   *!
   *! The recognized MIME types are the following: @[MIME_TYPE_JPEG],
   *! @[MIME_TYPE_PNG], @[MIME_TYPE_JP2], @[MIME_TYPE_URI],
   *! @[MIME_TYPE_UNIQUE_ID], @[MIME_TYPE_JBIG2],
   *! @[MIME_TYPE_JBIG2_GLOBAL], @[MIME_TYPE_JBIG2_GLOBAL_ID],
   *! @[MIME_TYPE_CCITT_FAX], @[MIME_TYPE_CCITT_FAX_PARAMS].
   *!
   *! See corresponding backend surface docs for details about which
   *! MIME types it can handle.  Caution: the associated MIME data
   *! will be discarded if you draw on the surface afterwards. Use
   *! this function with care.
   *!
   *! Even if a backend supports a MIME type, that does not mean cairo
   *! will always be able to use the attached MIME data.  For example,
   *! if the backend does not natively support the compositing
   *! operation used to apply the MIME data to the backend.  In that
   *! case, the MIME data will be ignored.  Therefore, to apply an
   *! image in all cases, it is best to create an image surface which
   *! contains the decoded image data and then attach the MIME data to
   *! that.  This ensures the image will always be used while still
   *! allowing the MIME data to be used whenever possible.
   *!
   *! @param mime_type
   *!   the MIME type of the image data
   *! @param data
   *!   the image data to attach to the surface
   */
  PIKEFUN void set_mime_data(string(7bit) mime_type, string(8bit)|zero data)
    get_all_args;
  {
    cairo_status_t status;
    if (data) {
      add_ref(data);
      status = cairo_surface_set_mime_data(THIS->surface,
                                           (const char *)STR0(mime_type),
                                           (const unsigned char *)STR0(data),
                                           data->len,
                                           (cairo_destroy_func_t)do_free_string,
                                           data);
      if (status != CAIRO_STATUS_SUCCESS)
        free_string(data);
    } else
      status = cairo_surface_set_mime_data(THIS->surface,
                                           (const char *)STR0(mime_type),
                                           NULL, 0, NULL, NULL);
    check_status(status);
    RETURN;
  }

  /*! @decl string(8bit)|zero get_mime_data(string(7bit) mime_type)
   *!
   *! Return mime data previously attached to surface using the
   *! specified mime type.  If no data has been attached with the
   *! given mime type, @expr{UNDEFINED@} is returned.
   *!
   *! @param mime_type
   *!   the mime type of the image data
   *! @returns
   *!   the image data attached to the surface
   */
  PIKEFUN string(8bit)|zero get_mime_data(string(7bit) mime_type)
    get_all_args;
  {
    const unsigned char *data = NULL;
    unsigned long length = 0;
    cairo_surface_get_mime_data(THIS->surface, (const char *)STR0(mime_type),
                                &data, &length);
    if (data)
      RETURN make_shared_binary_string((const char *)data, length);
    else
      RETURN UNDEFINED;
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
  /*! @decl Surface create_similar_image(int format, int width, int height)
   *!
   *! Create a new image surface that is as compatible as possible for
   *! uploading to and the use in conjunction with this surface.
   *! However, this surface can still be used like any normal image
   *! surface.  Unlike @[create_similar()] the new image surface won't
   *! inherit the device scale from this.
   *!
   *! Initially the surface contents are all 0 (transparent if
   *! contents have transparency, black otherwise.)
   *!
   *! Use @[create_similar()] if you don't need an image surface.
   *!
   *! @param format
   *!   the format for the new surface
   *! @param width
   *!   width of the new surface, (in pixels)
   *! @param height
   *!   height of the new surface (in pixels)
   *!
   *! @returns
   *!   a newly allocated image surface.
   */
  PIKEFUN Surface create_similar_image(int format, int width, int height)
    get_all_args;
  {
    ONERROR onerr;
    cairo_surface_t *surf =
      cairo_surface_create_similar_image(THIS->surface, format, width, height);
    SET_ONERROR(onerr, cairo_surface_destroy, surf);
    check_status(cairo_surface_status(surf));
    UNSET_ONERROR(onerr);
    RETURN surface_to_object(surf);
 }

  /*! @decl int(0..1) supports_mime_type(string(7bit) mime_type)
   *!
   *! Return whether surface supports @[mime_type].
   *!
   *! @param mime_type
   *!   the mime type
   *!
   *! @returns
   *!   @expr{1@} if surface supports @[mime_type], @expr{0@} otherwise
   */
  PIKEFUN int(0..1) supports_mime_type(string(7bit) mime_type)
    get_all_args;
  {
    RETURN cairo_surface_supports_mime_type(THIS->surface,
                                            (const char *)STR0(mime_type));
  }

  /*! @decl Surface map_to_image(RectangleInt|void extents)
   *!
   *! Returns an image surface that is the most efficient mechanism
   *! for modifying the backing store of the target surface.  The
   *! region retrieved may be limited to the extents, or the whole
   *! surface if no extents are given.
   *!
   *! @note
   *!   The use of the original surface as a target or source whilst
   *!   it is mapped is undefined.  The result of mapping the surface
   *!   multiple times is undefined.  Destroying or calling
   *!   @[finish()] on the resulting image surface results in
   *!   undefined behavior.  Changing the device transform of the
   *!   image surface or of surface before the image surface is
   *!   unmapped results in undefined behavior.
   *!
   *! @param extents
   *!   limit the extraction to an rectangular region
   *!
   *! @returns
   *!    a newly allocated image surface.  The caller must use
   *!    @[unmap_image()] to destroy this image surface.
   */
  PIKEFUN Surface map_to_image(RectangleInt|void extents)
    get_all_args;
  {
    ONERROR onerr;
    cairo_surface_t *surf;
    const cairo_rectangle_int_t *rectp = NULL;
    cairo_rectangle_int_t rect;
    if (extents) {
      if (!rectangle_int_from_object(extents, &rect))
        SIMPLE_ARG_TYPE_ERROR("map_to_image", 1, "Cairo.RectangleInt");
      rectp = &rect;
    }
    surf = cairo_surface_map_to_image(THIS->surface, rectp);
    SET_ONERROR(onerr, cairo_surface_destroy, surf);
    check_status(cairo_surface_status(surf));
    UNSET_ONERROR(onerr);
    RETURN surface_to_object(surf);
  }

  /*! @decl void unmap_image(Surface image)
   *!
   *! Unmaps the image surface as returned from @[map_to_image()].
   *!
   *! The content of the image will be uploaded to the target
   *! surface.  Afterwards, the image is destroyed.
   *!
   *! Using an image surface which wasn't returned by
   *! @[map_to_image()] results in undefined behavior.
   *!
   *! @param image
   *!   the currently mapped image
   */
  PIKEFUN void unmap_image(Surface image)
    get_all_args;
  {
    struct Cairo_Surface_struct *image_surf =
      get_storage(image, Cairo_Surface_program);
    if (!image_surf)
      SIMPLE_ARG_TYPE_ERROR("unmap_image", 2, "Cairo.Surface");
    cairo_surface_unmap_image(THIS->surface, image_surf->surface);
    check_status(cairo_surface_status(THIS->surface));
    image_surf->surface = NULL; /* Prevent cairo_surface_destroy() */
    RETURN;
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 14, 0)
  /*! @decl array(float) get_device_scale()
   *!
   *! This function returns the previous device scale set by
   *! @[set_device_scale()].
   *!
   *! @returns
   *!   The device scale
   *!   @array
   *!     @elem float 0
   *!       the scale in the X direction, in device units
   *!     @elem float 1
   *!       the scale in the Y direction, in device units
   *!   @endarray
   */
  PIKEFUN array(float) get_device_scale()
  {
    double x_scale;
    double y_scale;
    cairo_surface_get_device_scale(THIS->surface, &x_scale, &y_scale);
    push_float(x_scale);
    push_float(y_scale);
    f_aggregate(2);
  }

  /*! @decl void set_device_scale(float|int x_scale, float|int y_scale)
   *!
   *! Sets a scale that is multiplied to the device coordinates
   *! determined by the CTM when drawing to this surface.  One common
   *! use for this is to render to very high resolution display
   *! devices at a scale factor, so that code that assumes 1 pixel
   *! will be a certain size will still work.  Setting a
   *! transformation via @[Context->scale()] isn't sufficient to do
   *! this, since functions like @[Context->device_to_user()] will
   *! expose the hidden scale.
   *!
   *! Note that the scale affects drawing to the surface as well as
   *! using the surface in a source pattern.
   *!
   *! @param x_scale
   *!   a scale factor in the X direction
   *! @param y_scale
   *!   a scale factor in the Y direction
   */
  PIKEFUN void set_device_scale(float|int x_scale, float|int y_scale)
    get_all_args;
  {
    cairo_surface_set_device_scale(THIS->surface, x_scale, y_scale);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }
#endif

#ifdef PIKE_NULL_IS_SPECIAL
  INIT {
    THIS->surface = NULL;
  }
#endif

  EXIT
    gc_trivial;
  {
    if (THIS->surface)
      cairo_surface_destroy(THIS->surface);
  }

  static cairo_surface_t *surface_from_object(struct object *o)
  {
    struct Cairo_Surface_struct *s = get_storage(o, Cairo_Surface_program);
    return (s? s->surface : NULL);
  }

  static void copy_pike_image_to_surface(struct image *img,
                                         cairo_surface_t *surface)
  {
    unsigned char *data;
    int stride;
    INT_TYPE y, x;
    rgb_group *rgb = img->img;

    check_status(cairo_surface_status(surface));
    if (cairo_surface_get_type(surface) != CAIRO_SURFACE_TYPE_IMAGE ||
        cairo_image_surface_get_format(surface) != CAIRO_FORMAT_RGB24)
      Pike_error("Wrong type of surface\n");
    if (cairo_image_surface_get_width(surface) < img->xsize ||
        cairo_image_surface_get_height(surface) < img->ysize)
      Pike_error("Surface too small\n");

    cairo_surface_flush(surface);
    data = cairo_image_surface_get_data(surface);
    stride = cairo_image_surface_get_stride(surface);
    for (y=0; y<img->ysize; y++) {
      unsigned INT32 *p = (void *)data;
      for (x=0; x<img->xsize; x++, rgb++)
        *p++ = (((unsigned INT32)rgb->r) << 16) |
          (((unsigned INT32)rgb->g) << 8) |
          (unsigned INT32)rgb->b;
      data += stride;
    }
    cairo_surface_mark_dirty(surface);
  }

  static void copy_pike_image_with_alpha_to_surface(struct image *img,
                                                    struct image *img_alpha,
                                                    cairo_surface_t *surface)
  {
    unsigned char *data;
    int stride;
    INT_TYPE y, x;
    rgb_group *rgb = img->img;
    rgb_group *alpha = img_alpha->img;

    if (img_alpha->xsize != img->xsize || img_alpha->ysize != img->ysize)
      Pike_error("Alpha size differs from image size\n");
    check_status(cairo_surface_status(surface));
    if (cairo_surface_get_type(surface) != CAIRO_SURFACE_TYPE_IMAGE ||
        cairo_image_surface_get_format(surface) != CAIRO_FORMAT_ARGB32)
      Pike_error("Wrong type of surface\n");
    if (cairo_image_surface_get_width(surface) < img->xsize ||
        cairo_image_surface_get_height(surface) < img->ysize)
      Pike_error("Surface too small\n");

    cairo_surface_flush(surface);
    data = cairo_image_surface_get_data(surface);
    stride = cairo_image_surface_get_stride(surface);
    for (y=0; y<img->ysize; y++) {
      unsigned INT32 *p = (void *)data;
      for (x=0; x<img->xsize; x++, rgb++, alpha++) {
        unsigned INT32 a = alpha->r;
        if (alpha->g > a) a = alpha->g;
        if (alpha->b > a) a = alpha->b;
        *p++ = (a << 24) |
          ((((unsigned INT32)rgb->r)*((unsigned INT32)alpha->r)/255) << 16) |
          ((((unsigned INT32)rgb->g)*((unsigned INT32)alpha->g)/255) << 8) |
          (((unsigned INT32)rgb->b)*((unsigned INT32)alpha->b)/255);
      }
      data += stride;
    }
    cairo_surface_mark_dirty(surface);
  }
}
/*! @endclass */

/*! @class ImageSurface
 *! Rendering to memory buffers
 */
PIKECLASS ImageSurface
{
  /*! @decl inherit Surface
   */
  INHERIT Surface;

  /*! @decl variant protected void create(int format, int width, int height)
   *!
   *! Creates an image surface of the specified format and
   *! dimensions. Initially the surface contents are set to 0.
   *! (Specifically, within each pixel, each color or alpha channel
   *! belonging to format will be 0. The contents of bits within a
   *! pixel, but not belonging to the given format are undefined.)
   *!
   *! @param format
   *!   format of pixels in the surface to create
   *! @param width
   *!   width of the surface, in pixels
   *! @param height
   *!   height of the surface, in pixels
   */
  PIKEFUN void create(int format, int width, int height)
    flags ID_PROTECTED|ID_VARIANT;
    get_all_args;
  {
    if (THIS->surface)
      Pike_error("Surface already initialized\n");

    THIS->surface =
      cairo_image_surface_create(format, width, height);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl variant protected void create(Image.Image|Image.Layer|string|Stdio.InputStream image_or_png)
   *!
   *! Creates a new image surface and initializes the contents to the
   *! given @[Image.Image] or @[Image.Layer] or PNG file.
   *!
   *! @param image_or_png
   *!   Either an @[Image.Image] or @[Image.Layer] to copy pixel data
   *!   from, or the filename of a PNG file to load, or a
   *!   @[Stdio.InputStream] to read PNG data from.
   */
  PIKEFUN void create(object(Image.Image)|object(Image.Layer)|string|object(Stdio.InputStream) image_or_png)
    flags ID_PROTECTED|ID_VARIANT;
  {
    struct strm_func_closure ctx;
    struct image *img, *img_alpha;

    if (THIS->surface)
      Pike_error("Surface already initialized\n");

    if (PIKE_TYPEOF(*image_or_png) == PIKE_T_STRING &&
        !image_or_png->u.string->size_shift)
#ifdef CAIRO_HAS_PNG_FUNCTIONS
      THIS->surface =
        cairo_image_surface_create_from_png((const char *)STR0(image_or_png->u.string));
#else
      Pike_error("PNG support not available!\n");
#endif
    else if (PIKE_TYPEOF(*image_or_png) == PIKE_T_OBJECT &&
             program_find_inherit(image_or_png->u.object->prog,
                                  image_layer_program) >= 0) {
      apply(image_or_png->u.object, "image", 0);
      apply(image_or_png->u.object, "alpha", 0);
      img = (PIKE_TYPEOF(Pike_sp[-2]) == PIKE_T_OBJECT?
             get_storage(Pike_sp[-2].u.object, image_program) : NULL);
      img_alpha = (PIKE_TYPEOF(Pike_sp[-1]) == PIKE_T_OBJECT?
                   get_storage(Pike_sp[-1].u.object, image_program) : NULL);
      if (!img)
        Pike_error("No image in Image.Layer\n");
      THIS->surface =
        cairo_image_surface_create((img_alpha? CAIRO_FORMAT_ARGB32 :
                                    CAIRO_FORMAT_RGB24),
                                   img->xsize, img->ysize);
      if (img_alpha)
        copy_pike_image_with_alpha_to_surface(img, img_alpha, THIS->surface);
      else
        copy_pike_image_to_surface(img, THIS->surface);
      pop_n_elems(2);
    } else if (PIKE_TYPEOF(*image_or_png) == PIKE_T_OBJECT &&
             ((img = get_storage(image_or_png->u.object, image_program)))) {
      THIS->surface =
        cairo_image_surface_create(CAIRO_FORMAT_RGB24, img->xsize, img->ysize);
      copy_pike_image_to_surface(img, THIS->surface);
    }
    else if (PIKE_TYPEOF(*image_or_png) == PIKE_T_OBJECT &&
             (ctx.func_id = find_identifier("read", (ctx.obj =
                                                     image_or_png->u.object)->prog))
             >= 0) {
#ifdef CAIRO_HAS_PNG_FUNCTIONS
      THIS->surface =
        cairo_image_surface_create_from_png_stream(strm_read_func, &ctx);
#else
      Pike_error("PNG support not available!\n");
#endif
    } else
      SIMPLE_ARG_TYPE_ERROR("create", 1, "Image.Image|Image.Layer|string|Stdio.InputStream");

    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

#ifdef CAIRO_HAS_PNG_FUNCTIONS
  /*! @decl void write_to_png(string|Stdio.OutputStreamMixin png_file)
   *!
   *! Writes the contents of this @[ImageSurface] as a PNG image.
   *!
   *! @param png_file
   *!   the name of a file to write to, or a
   *!   @[Stdio.OutputStreamMixin] to write the PNG data to
   */
  PIKEFUN void write_to_png(string|object(Stdio.OutputStreamMixin) png_file)
  {
    struct strm_func_closure ctx;
    cairo_status_t status;

    if (PIKE_TYPEOF(*png_file) == PIKE_T_STRING &&
        !png_file->u.string->size_shift)
      status = cairo_surface_write_to_png(THIS->surface, (const char *)STR0(png_file->u.string));
    else if (PIKE_TYPEOF(*png_file) == PIKE_T_OBJECT &&
             (ctx.func_id = find_identifier("write", (ctx.obj =
                                                      png_file->u.object)->prog))
             >= 0) {
      status =
        cairo_surface_write_to_png_stream(THIS->surface, strm_write_func, &ctx);
    } else
      SIMPLE_ARG_TYPE_ERROR("write_to_png", 1, "string|Stdio.OutputStreamMixin");
    check_status(status);
    RETURN;
  }
#endif

  /*! @decl int get_width()
   *!
   *! Get the width of the image surface in pixels.
   *!
   *! @returns
   *!   the width of the surface in pixels.
   */
  PIKEFUN int get_width()
  {
    RETURN cairo_image_surface_get_width(THIS->surface);
  }

  /*! @decl int get_height()
   *!
   *! Get the height of the image surface in pixels.
   *!
   *! @returns
   *!   the height of the surface in pixels.
   */
  PIKEFUN int get_height()
  {
    RETURN cairo_image_surface_get_height(THIS->surface);
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  /*! @decl int get_format()
   *!
   *! Get the format of the surface.
   *!
   *! @returns
   *!   the format of the surface
   */
  PIKEFUN int get_format()
  {
    RETURN cairo_image_surface_get_format(THIS->surface);
  }

  /*! @decl int get_stride()
   *!
   *! Get the stride of the image surface in bytes
   *!
   *! @returns
   *!   the stride of the image surface in bytes (or 0 if surface is
   *!   not an image surface).  The stride is the distance in bytes
   *!   from the beginning of one row of the image data to the
   *!   beginning of the next row.
   */
  PIKEFUN int get_stride()
  {
    RETURN cairo_image_surface_get_stride(THIS->surface);
  }
#endif
}
/*! @endclass */

#ifdef CAIRO_HAS_PDF_SURFACE
/*! @class PDFSurface
 *! Rendering PDF documents
 */
PIKECLASS PDFSurface
{
  /*! @decl inherit Surface
   */
  INHERIT Surface;

  /*! @decl protected void create(string|Stdio.OutputStreamMixin|zero pdf_file, @
   *!                             float|int width_in_points,                  @
   *!                             float|int height_in_points)
   *!
   *! Creates a PDF surface of the specified size in points to be
   *! written to @[pdf_file].
   *!
   *! @param pdf_file
   *!   a filename for the PDF output (must be writable), or a
   *!   @[Stdio.OutputStreamMixin] to write the output to.  @expr{0@}
   *!   may be used to specify no output.  This will generate a PDF
   *!   surface that may be queried and used as a source, without
   *!   generating a temporary file.
   *! @param width_in_points
   *!   width of the surface, in points (1 point == 1/72.0 inch)
   *! @param height_in_points
   *!   height of the surface, in points (1 point == 1/72.0 inch)
   */
  PIKEFUN void create(string|Stdio.OutputStreamMixin|zero pdf_file,
                      float|int width_in_points, float|int height_in_points)
    flags ID_PROTECTED;
    get_all_args;
  {
    struct strm_func_closure ctx;

    if (THIS->surface)
      Pike_error("Surface already initialized\n");

    if (PIKE_TYPEOF(*pdf_file) == PIKE_T_INT && !pdf_file->u.integer)
      THIS->surface =
        cairo_pdf_surface_create(NULL, width_in_points, height_in_points);
    else if (PIKE_TYPEOF(*pdf_file) == PIKE_T_STRING &&
             !pdf_file->u.string->size_shift)
      THIS->surface =
        cairo_pdf_surface_create((const char *)STR0(pdf_file->u.string),
                                 width_in_points, height_in_points);
    else if (PIKE_TYPEOF(*pdf_file) == PIKE_T_OBJECT &&
             (ctx.func_id = find_identifier("write", (ctx.obj =
                                                      pdf_file->u.object)->prog))
             >= 0) {
      THIS->surface =
        cairo_pdf_surface_create_for_stream(strm_write_func, &ctx,
                                            width_in_points, height_in_points);
    } else
      SIMPLE_ARG_TYPE_ERROR("create", 1, "string|Stdio.OutputStreamMixin|zero");

    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void set_size(float|int width_in_points, float|int height_in_points)
   *!
   *! Changes the size of a PDF surface for the current (and
   *! subsequent) pages.
   *!
   *! This function should only be called before any drawing
   *! operations have been performed on the current page.  The
   *! simplest way to do this is to call this function immediately
   *! after creating the surface or immediately after completing a
   *! page with either @[Context->show_page()] or
   *! @[Context->copy_page()].
   *!
   *! @param width_in_points
   *!   new surface width, in points (1 point == 1/72.0 inch)
   *! @param height_in_points
   *!   new surface height, in points (1 point == 1/72.0 inch)
   */
  PIKEFUN void set_size(float|int width_in_points, float|int height_in_points)
    get_all_args;
  {
    cairo_pdf_surface_set_size(THIS->surface, width_in_points, height_in_points);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
  /*! @decl void restrict_to_version(int version)
   *!
   *! Restricts the generated PDF file to @[version].
   *!
   *! This function should only be called before any drawing
   *! operations have been performed on the given surface.  The
   *! simplest way to do this is to call this function immediately
   *! after creating the surface.
   *!
   *! @param version
   *!   PDF version
   */
  PIKEFUN void restrict_to_version(int version)
    get_all_args;
  {
    cairo_pdf_surface_restrict_to_version(THIS->surface, version);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl array(int) get_versions()
   *!
   *! Used to retrieve the list of supported versions. See
   *! @[restrict_to_version()].
   *!
   *! @returns
   *!   supported version list
   */
  PIKEFUN array(int) get_versions()
  {
    cairo_pdf_version_t const *versions;
    int i, num_versions;
    cairo_pdf_get_versions(&versions, &num_versions);
    for (i=0; i<num_versions; i++)
      push_int(versions[i]);
    f_aggregate(num_versions);
  }

  /*! @decl string version_to_string(int version)
   *!
   *! Get the string representation of the given version id.  This
   *! function will return @expr{UNDEFINED@} if version isn't valid.
   *! See @[get_versions()] for a way to get the list of valid version
   *! ids.
   *!
   *! @returns
   *!   the string associated to given version.
   */
  PIKEFUN string version_to_string(int version)
    get_all_args;
  {
    const char *str =  cairo_pdf_version_to_string(version);
    pop_stack();
    if (str)
      push_text(str);
    else
      push_undefined();
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
  /*! @decl int add_outline(int parent_id, string name, string link_attribs, @
   *!                       int flags)
   *!
   *! Add an item to the document outline hierarchy with the given
   *! @[name] that links to the location specified by @[link_attribs].
   *! Link attributes have the same keys and values as the Link Tag,
   *! excluding the "rect" attribute.  The item will be a child of the
   *! item with id @[parent_id].  Use @[PDF_OUTLINE_ROOT] as the
   *! parent id of top level items.
   *!
   *! @param parent_id
   *!   the id of the parent item or @[PDF_OUTLINE_ROOT] if this is a
   *!   top level item.
   *! @param name
   *!   the name of the outline
   *! @param link_attribs
   *!   the link attributes specifying where this outline links to
   *! @param flags
   *!   outline item flags
   */
  PIKEFUN int add_outline(int parent_id, string name, string link_attribs,
                          int flags)
    get_all_args;
  {
    int id;
    ref_push_string(name);
    f_string_to_utf8(1);
    name = Pike_sp[-1].u.string;
    ref_push_string(link_attribs);
    f_string_to_utf8(1);
    link_attribs = Pike_sp[-1].u.string;
    id = cairo_pdf_surface_add_outline(THIS->surface, parent_id,
                                       (const char *)STR0(name),
                                       (const char *)STR0(link_attribs),
                                       flags);
    pop_stack();
    pop_stack();
    check_status(cairo_surface_status(THIS->surface));
    RETURN id;
  }

  /*! @decl void set_metadata(int metadata, string value)
   *!
   *! Set document metadata. The @[PDF_METADATA_CREATE_DATE] and
   *! @[PDF_METADATA_MOD_DATE] values must be in ISO-8601 format:
   *! YYYY-MM-DDThh:mm:ss.  An optional timezone of the form
   *! "[+/-]hh:mm" or "Z" for UTC time can be appended.  All other
   *! metadata values can be any string.
   *!
   *! @example
   *! @code
   *! pdf_surface->set_metadata(Cairo.PDF_METADATA_TITLE, "My Document");
   *! pdf_surface->set_metadata(Cairo.PDF_METADATA_CREATE_DATE, "2015-12-31T23:59+02:00");
   *! @endcode
   *!
   *! @param metadata
   *!   The metadata item to set.
   *! @param value
   *!   metadata value
   */
  PIKEFUN void set_metadata(int metadata, string value)
    get_all_args;
  {
    ref_push_string(value);
    f_string_to_utf8(1);
    value = Pike_sp[-1].u.string;
    cairo_pdf_surface_set_metadata(THIS->surface, metadata,
                                   (const char *)STR0(value));
    pop_stack();
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void set_page_label(string label)
   *!
   *! Set page label for the current page.
   *!
   *! @param label
   *!   The page label.
   */
  PIKEFUN void set_page_label(string label)
    get_all_args;
  {
    ref_push_string(label);
    f_string_to_utf8(1);
    label = Pike_sp[-1].u.string;
    cairo_pdf_surface_set_page_label(THIS->surface, (const char *)STR0(label));
    pop_stack();
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void set_thumbnail_size(int width, int height)
   *!
   *! Set the thumbnail image size for the current and all subsequent
   *! pages.  Setting a width or height of 0 disables thumbnails for
   *! the current and subsequent pages.
   *!
   *! @param width
   *!   Thumbnail width.
   *! @param height
   *!   Thumbnail height
   */
  PIKEFUN void set_thumbnail_size(int width, int height)
    get_all_args;
  {
    cairo_pdf_surface_set_thumbnail_size(THIS->surface, width, height);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
  /*! @decl void set_custom_metadata(string name, string|zero value)
   *!
   *! Set custom document metadata.  @[name] may be any string except
   *! for the following names reserved by PDF: "Title", "Author",
   *! "Subject", "Keywords", "Creator", "Producer", "CreationDate",
   *! "ModDate", "Trapped".
   *!
   *! If @[value] is @expr{0@} or an empty string, the name metadata
   *! will not be set.
   *!
   *! @example
   *! @code
   *! pdf_surface->set_custom_metadata("ISBN", "978-0123456789");
   *! @endcode
   *!
   *! @param name
   *!   The name of the custom metadata item to set.
   *! @param value
   *!   The value of the metadata.
   */
  PIKEFUN void set_custom_metadata(string name, string|zero value)
  {
    ref_push_string(name);
    f_string_to_utf8(1);
    name = Pike_sp[-1].u.string;
    if (value) {
      ref_push_string(value);
      f_string_to_utf8(1);
      value = Pike_sp[-1].u.string;
    }
    cairo_pdf_surface_set_custom_metadata(THIS->surface,
                                          (const char *)STR0(name),
                                          (value? (const char *)STR0(value) :
                                           NULL));
    if (value)
      pop_stack();
    pop_stack();
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }
#endif
}
/*! @endclass */
#endif

#ifdef CAIRO_HAS_PS_SURFACE
/*! @class PSSurface
 *! Rendering PostScript documents
 */
PIKECLASS PSSurface
{
  /*! @decl inherit Surface
   */
  INHERIT Surface;

  /*! @decl protected void create(string|Stdio.OutputStreamMixin|zero ps_file, @
   *!                             float|int width_in_points,                  @
   *!                             float|int height_in_points)
   *!
   *! Creates a PostScript surface of the specified size in points to
   *! be written to @[ps_file].
   *!
   *! @param ps_file
   *!   a filename for the PS output (must be writable), or a
   *!   @[Stdio.OutputStreamMixin] to write the output to.  @expr{0@}
   *!   may be used to specify no output.  This will generate a PS
   *!   surface that may be queried and used as a source, without
   *!   generating a temporary file.
   *! @param width_in_points
   *!   width of the surface, in points (1 point == 1/72.0 inch)
   *! @param height_in_points
   *!   height of the surface, in points (1 point == 1/72.0 inch)
   */
  PIKEFUN void create(string|Stdio.OutputStreamMixin|zero ps_file,
                      float|int width_in_points, float|int height_in_points)
    flags ID_PROTECTED;
    get_all_args;
  {
    struct strm_func_closure ctx;

    if (THIS->surface)
      Pike_error("Surface already initialized\n");

    if (PIKE_TYPEOF(*ps_file) == PIKE_T_INT && !ps_file->u.integer)
      THIS->surface =
        cairo_ps_surface_create(NULL, width_in_points, height_in_points);
    else if (PIKE_TYPEOF(*ps_file) == PIKE_T_STRING &&
             !ps_file->u.string->size_shift)
      THIS->surface =
        cairo_ps_surface_create((const char *)STR0(ps_file->u.string),
                                width_in_points, height_in_points);
    else if (PIKE_TYPEOF(*ps_file) == PIKE_T_OBJECT &&
             (ctx.func_id = find_identifier("write", (ctx.obj =
                                                      ps_file->u.object)->prog))
             >= 0) {
      THIS->surface =
        cairo_ps_surface_create_for_stream(strm_write_func, &ctx,
                                           width_in_points, height_in_points);
    } else
      SIMPLE_ARG_TYPE_ERROR("create", 1, "string|Stdio.OutputStreamMixin|zero");

    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void set_size(float|int width_in_points, float|int height_in_points)
   *!
   *! Changes the size of a PostScript surface for the current (and
   *! subsequent) pages.
   *!
   *! This function should only be called before any drawing
   *! operations have been performed on the current page.  The
   *! simplest way to do this is to call this function immediately
   *! after creating the surface or immediately after completing a
   *! page with either @[Context->show_page()] or
   *! @[Context->copy_page()].
   *!
   *! @param width_in_points
   *!   new surface width, in points (1 point == 1/72.0 inch)
   *! @param height_in_points
   *!   new surface height, in points (1 point == 1/72.0 inch)
   */
  PIKEFUN void set_size(float|int width_in_points, float|int height_in_points)
    get_all_args;
  {
    cairo_ps_surface_set_size(THIS->surface, width_in_points, height_in_points);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void dsc_begin_setup()
   *!
   *! This function indicates that subsequent calls to
   *! @[dsc_comment()] should direct comments to the Setup section of
   *! the PostScript output.
   *!
   *! This function should be called at most once per surface, and
   *! must be called before any call to @[dsc_begin_page_setup()] and
   *! before any drawing is performed to the surface.
   *!
   *! See @[dsc_comment()] for more details.
   */
  PIKEFUN void dsc_begin_setup()
  {
    cairo_ps_surface_dsc_begin_setup(THIS->surface);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void dsc_begin_page_setup()
   *!
   *! This function indicates that subsequent calls to
   *! @[dsc_comment()] should direct comments to the PageSetup section
   *! of the PostScript output.
   *!
   *! This function call is only needed for the first page of a
   *! surface.  It should be called after any call to
   *! @[dsc_begin_setup()] and before any drawing is performed to the
   *! surface.
   *!
   *! See @[dsc_comment()] for more details.
   */
  PIKEFUN void dsc_begin_page_setup()
  {
    cairo_ps_surface_dsc_begin_page_setup(THIS->surface);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void dsc_comment(string comment)
   *!
   *! Emit a comment into the PostScript output for the given surface.
   *!
   *! The comment is expected to conform to the PostScript Language
   *! Document Structuring Conventions (DSC).  Please see that manual
   *! for details on the available comments and their meanings.  In
   *! particular, the %%IncludeFeature comment allows a
   *! device-independent means of controlling printer device features.
   *! So the PostScript Printer Description Files Specification will
   *! also be a useful reference.
   *!
   *! The comment string must begin with a percent character (%) and
   *! the total length of the string (including any initial percent
   *! characters) must not exceed 255 characters.  Violating either of
   *! these conditions will place surface into an error state.  But
   *! beyond these two conditions, this function will not enforce
   *! conformance of the comment with any particular specification.
   *!
   *! The comment string must not contain any newline characters.
   *!
   *! The DSC specifies different sections in which particular
   *! comments can appear.  This function provides for comments to be
   *! emitted within three sections: the header, the Setup section,
   *! and the PageSetup section.  Comments appearing in the first two
   *! sections apply to the entire document while comments in the
   *! BeginPageSetup section apply only to a single page.
   *!
   *! For comments to appear in the header section, this function
   *! should be called after the surface is created, but before a call
   *! to @[dsc_begin_setup()].
   *!
   *! For comments to appear in the Setup section, this function
   *! should be called after a call to @[dsc_begin_setup()] but before
   *! a call to @[dsc_begin_page_setup()].
   *!
   *! For comments to appear in the PageSetup section, this function
   *! should be called after a call to @[dsc_begin_page_setup()].
   *!
   *! Note that it is only necessary to call @[dsc_begin_page_setup()]
   *! for the first page of any surface.  After a call to
   *! @[Context->show_page()] or @[Context->copy_page()] comments are
   *! unambiguously directed to the PageSetup section of the current
   *! page.  But it doesn't hurt to call this function at the
   *! beginning of every page as that consistency may make the calling
   *! code simpler.
   *!
   *! As a final note, cairo automatically generates several comments
   *! on its own.  As such, applications must not manually generate
   *! any of the following comments:
   *!
   *! Header section: %!PS-Adobe-3.0, %%Creator, %%CreationDate,
   *! %%Pages, %%BoundingBox, %%DocumentData, %%LanguageLevel,
   *! %%EndComments.
   *!
   *! Setup section: %%BeginSetup, %%EndSetup
   *!
   *! PageSetup section: %%BeginPageSetup, %%PageBoundingBox,
   *! %%EndPageSetup.
   *!
   *! Other sections: %%BeginProlog, %%EndProlog, %%Page, %%Trailer,
   *! %%EOF
   *!
   *! Here is an example sequence showing how this function might be
   *! used:

   *! @example
   *! @code
   *! Cairo.Surface surface = Cairo.PSSurface(filename, width, height);
   *! ...
   *! surface->dsc_comment("%%Title: My excellent document");
   *! surface->dsc_comment("%%Copyright: Copyright (C) 2006 Cairo Lover")
   *! ...
   *! surface->dsc_begin_setup();
   *! surface->dsc_comment("%%IncludeFeature: *MediaColor White");
   *! ...
   *! surface->dsc_begin_page_setup();
   *! surface->dsc_comment("%%IncludeFeature: *PageSize A3");
   *! surface->dsc_comment("%%IncludeFeature: *InputSlot LargeCapacity");
   *! surface->dsc_comment("%%IncludeFeature: *MediaType Glossy");
   *! surface->dsc_comment("%%IncludeFeature: *MediaColor Blue");
   *! ... draw to first page here ..
   *! cr->show_page();
   *! ...
   *! surface->dsc_comment("%%IncludeFeature: *PageSize A5");
   *! ...
   *! @endcode
   *!
   *! @param comment
   *!   a comment string to be emitted into the PostScript output
   */
  PIKEFUN void dsc_comment(string comment)
    get_all_args;
  {
    ref_push_string(comment);
    f_string_to_utf8(1);
    comment = Pike_sp[-1].u.string;
    cairo_ps_surface_dsc_comment(THIS->surface, (const char *)STR0(comment));
    pop_stack();
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 6, 0)
  /*! @decl void restrict_to_level(int level)
   *!
   *! Restricts the generated PostSript file to @[level].
   *!
   *! This function should only be called before any drawing
   *! operations have been performed on the given surface.  The
   *! simplest way to do this is to call this function immediately
   *! after creating the surface.
   *!
   *! @param level
   *!   PostScript level
   */
  PIKEFUN void restrict_to_level(int level)
    get_all_args;
  {
    cairo_ps_surface_restrict_to_level(THIS->surface, level);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl array(int) get_levels()
   *!
   *! Used to retrieve the list of supported levels.  See
   *! @[restrict_to_level()].
   *!
   *! @returns
   *!   supported level list
   */
  PIKEFUN array(int) get_levels()
  {
    cairo_ps_level_t const *levels;
    int i, num_levels;
    cairo_ps_get_levels(&levels, &num_levels);
    for (i=0; i<num_levels; i++)
      push_int(levels[i]);
    f_aggregate(num_levels);
  }

  /*! @decl string level_to_string(int level)
   *!
   *! Get the string representation of the given level id.  This
   *! function will return @expr{UNDEFINED@} if level id isn't valid.
   *! See @[get_levels()] for a way to get the list of valid level
   *! ids.
   *!
   *! @param level
   *!   a level id
   *!
   *! @returns
   *!   the string associated to given level.
   */
  PIKEFUN string level_to_string(int level)
    get_all_args;
  {
    const char *str = cairo_ps_level_to_string(level);
    pop_stack();
    if (str)
      push_text(str);
    else
      push_undefined();
  }

  /*! @decl void set_eps(int(0..1) eps)
   *!
   *! If @[eps] is @expr{1@}, the PostScript surface will output
   *! Encapsulated PostScript.
   *!
   *! This function should only be called before any drawing
   *! operations have been performed on the current page.  The
   *! simplest way to do this is to call this function immediately
   *! after creating the surface.  An Encapsulated PostScript file
   *! should never contain more than one page.
   *!
   *! @param eps
   *!   @expr{1@} to output EPS format PostScript
   */
  PIKEFUN void set_eps(int(0..1) eps)
    get_all_args;
  {
    cairo_ps_surface_set_eps(THIS->surface, eps);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl int(0..1) get_eps()
   *!
   *! Check whether the PostScript surface will output Encapsulated
   *! PostScript.
   *!
   *! @returns
   *!   @expr{1@} if the surface will output Encapsulated PostScript.
   */
  PIKEFUN int(0..1) get_eps()
  {
    RETURN cairo_ps_surface_get_eps(THIS->surface);
  }
#endif
}
/*! @endclass */
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
/*! @class RecordingSurface
 *! Records all drawing operations
 */
PIKECLASS RecordingSurface
{
  /*! @decl inherit Surface
   */
  INHERIT Surface;

  /*! @decl protected void create(int content, Rectangle|void extents)
   *!
   *! Creates a recording-surface which can be used to record all
   *! drawing operations at the highest level (that is, the level of
   *! @[Context->paint], @[Context->mask], @[Context->stroke],
   *! @[Context->fill] and @[Context->show_text_glyphs]).  The
   *! recording surface can then be "replayed" against any target
   *! surface by using it as a source to drawing operations.
   *!
   *! The recording phase of the recording surface is careful to
   *! snapshot all necessary objects (paths, patterns, etc.), in order
   *! to achieve accurate replay.
   *!
   *! @param content
   *!   the content of the recording surface
   *! @param extents
   *!   the extents to record in pixels, can be omitted to record
   *!   unbounded operations.
   */
  PIKEFUN void create(int content, Rectangle|void extents)
    get_all_args;
  {
    cairo_rectangle_t extents_rect;
    if (!rectangle_from_object(extents, &extents_rect))
      SIMPLE_ARG_TYPE_ERROR("create", 2, "Cairo.Rectangle");

    if (THIS->surface)
      Pike_error("Surface already initialized\n");

    THIS->surface = cairo_recording_surface_create(content, &extents_rect);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl array(float) ink_extents()
   *!
   *! Measures the extents of the operations stored within the
   *! @[RecordingSurface].  This is useful to compute the required
   *! size of an @[ImageSurface] (or equivalent) into which to replay
   *! the full sequence of drawing operations.
   *!
   *! @returns
   *!   An array with the following elements:
   *!   @array
   *!     @elem float 0
   *!       the x-coordinate of the top-left of the ink bounding box
   *!     @elem float 1
   *!       the y-coordinate of the top-left of the ink bounding box
   *!     @elem float 2
   *!       the width of the ink bounding box
   *!     @elem float 3
   *!       the height of the ink bounding box
   *!   @endarray
   */
  PIKEFUN array(float) ink_extents()
  {
    double x0, y0, width, height;
    cairo_recording_surface_ink_extents(THIS->surface, &x0, &y0,
                                        &width, &height);
    check_status(cairo_surface_status(THIS->surface));
    push_float(x0);
    push_float(y0);
    push_float(width);
    push_float(height);
    f_aggregate(4);
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
  /*! @decl Rectangle get_extents()
   *!
   *! Get the extents of the @[RecordingSurface].
   *!
   *! @returns
   *!   A @[Rectangle] if the surface is bounded, otherwise
   *!   @expr{UNDEFINED@}
   */
  PIKEFUN Rectangle get_extents()
  {
    cairo_rectangle_t extents;
    cairo_bool_t r =
      cairo_recording_surface_get_extents(THIS->surface, &extents);
    check_status(cairo_surface_status(THIS->surface));
    if (r)
      RETURN rectangle_to_object(&extents);
    else
      RETURN UNDEFINED;
  }
#endif
}
/*! @endclass */
#endif

#ifdef CAIRO_HAS_SVG_SURFACE
/*! @class SVGSurface
 *! Rendering SVG documents
 */
PIKECLASS SVGSurface
{
  /*! @decl inherit Surface
   */
  INHERIT Surface;

  /*! @decl protected void create(string|Stdio.OutputStreamMixin|zero svg_file, @
   *!                             float|int width_in_points,                  @
   *!                             float|int height_in_points)
   *!
   *! Creates a SVG surface of the specified size in points to be
   *! written to @[svg_file].
   *!
   *! @param svg_file
   *!   a filename for the SVG output (must be writable), or a
   *!   @[Stdio.OutputStreamMixin] to write the output to.  @expr{0@}
   *!   may be used to specify no output.  This will generate a SVG
   *!   surface that may be queried and used as a source, without
   *!   generating a temporary file.
   *! @param width_in_points
   *!   width of the surface, in points (1 point == 1/72.0 inch)
   *! @param height_in_points
   *!   height of the surface, in points (1 point == 1/72.0 inch)
   */
  PIKEFUN void create(string|Stdio.OutputStreamMixin|zero svg_file,
                      float|int width_in_points, float|int height_in_points)
    flags ID_PROTECTED;
    get_all_args;
  {
    struct strm_func_closure ctx;

    if (THIS->surface)
      Pike_error("Surface already initialized\n");

    if (PIKE_TYPEOF(*svg_file) == PIKE_T_INT && !svg_file->u.integer)
      THIS->surface =
        cairo_svg_surface_create(NULL, width_in_points, height_in_points);
    else if (PIKE_TYPEOF(*svg_file) == PIKE_T_STRING &&
        !svg_file->u.string->size_shift)
      THIS->surface =
        cairo_svg_surface_create((const char *)STR0(svg_file->u.string),
                                 width_in_points, height_in_points);
    else if (PIKE_TYPEOF(*svg_file) == PIKE_T_OBJECT &&
             (ctx.func_id = find_identifier("write", (ctx.obj =
                                                      svg_file->u.object)->prog))
             >= 0) {
      THIS->surface =
        cairo_svg_surface_create_for_stream(strm_write_func, &ctx,
                                            width_in_points, height_in_points);
    } else
      SIMPLE_ARG_TYPE_ERROR("create", 1, "string|Stdio.OutputStreamMixin|zero");

    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void restrict_to_version(int version)
   *!
   *! Restricts the generated SVG file to @[version].  See
   *! @[get_versions()] for a list of available version values that
   *! can be used here.
   *!
   *! This function should only be called before any drawing
   *! operations have been performed on the given surface.  The
   *! simplest way to do this is to call this function immediately
   *! after creating the surface.
   *!
   *! @param version
   *!   SVG version
   */
  PIKEFUN void restrict_to_version(int version)
    get_all_args;
  {
    cairo_svg_surface_restrict_to_version(THIS->surface, version);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl array(int) get_versions()
   *!
   *! Used to retrieve the list of supported versions.  See
   *! @[restrict_to_version()].
   *!
   *! @returns
   *!   supported version list
   */
  PIKEFUN array(int) get_versions()
  {
    cairo_svg_version_t const *versions;
    int i, num_versions;

    cairo_svg_get_versions(&versions, &num_versions);
    for (i=0; i<num_versions; i++)
      push_int(versions[i]);
    f_aggregate(num_versions);
  }

  /*! @decl string version_to_string(int version)
   *!
   *! Get the string representation of the given version id.  This
   *! function will return @expr{UNDEFINED@} if @[version] isn't
   *! valid.  See @[get_versions()] for a way to get the list of valid
   *! version ids.
   *!
   *! @param version
   *!   a version id
   *!
   *! @returns
   *!   the string associated to given version.
   */
  PIKEFUN string version_to_string(int version)
  {
    const char *str = cairo_svg_version_to_string(version);
    pop_stack();
    if (str)
      push_text(str);
    else
      push_undefined();
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
  /*! @decl int get_document_unit()
   *!
   *! Get the unit of the SVG surface.
   *!
   *! @returns
   *!   the SVG unit of the SVG surface.
   */
  PIKEFUN int get_document_unit()
  {
    cairo_svg_unit_t unit = cairo_svg_surface_get_document_unit(THIS->surface);
    check_status(cairo_surface_status(THIS->surface));
    RETURN unit;
  }

  /*! @decl void set_document_unit(int unit)
   *!
   *! Use the specified unit for the width and height of the generated
   *! SVG file.
   *!
   *! This function can be called at any time before generating the
   *! SVG file.
   *!
   *! However to minimize the risk of ambiguities it's recommended to
   *! call it before any drawing operations have been performed on the
   *! given surface, to make it clearer what the unit used in the
   *! drawing operations is.
   *!
   *! The simplest way to do this is to call this function immediately
   *! after creating the SVG surface.
   *!
   *! @note
   *!   If this function is never called, the default unit for SVG
   *!   documents generated by cairo will be user unit.
   *!
   *! @param unit
   *!   SVG unit
   */
  PIKEFUN void set_document_unit(int unit)
    get_all_args;
  {
    cairo_svg_surface_set_document_unit(THIS->surface, unit);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }
#endif
}
/*! @endclass */
#endif

#ifdef CAIRO_HAS_SCRIPT_SURFACE
/*! @class ScriptSurface
 *! Rendering to replayable scripts
 */
PIKECLASS ScriptSurface
{
  /*! @decl inherit Surface
   */
  INHERIT Surface;

  /*! @decl variant protected void create(ScriptDevice script, int content, @
   *!                                     float|int width, float|int height)
   *!
   *! Create a new surface that will emit its rendering through @[script]
   *!
   *! @param script
   *!   the script (output device)
   *! @param content
   *!   the content of the surface
   *! @param width
   *!   width in pixels
   *! @param height
   *!   height in pixels
   */
  PIKEFUN void create(ScriptDevice script, int content,
                      float|int width, float|int height)
    flags ID_PROTECTED|ID_VARIANT;
    get_all_args;
  {
    struct Cairo_Device_struct *script_dev;

    if (THIS->surface)
      Pike_error("Surface already initialized\n");

    if ((script_dev = get_storage(script, Cairo_Device_program)))
      THIS->surface = cairo_script_surface_create(script_dev->device,
                                                  content, width, height);
    else
      SIMPLE_ARG_TYPE_ERROR("create", 1, "Cairo.ScriptDevice");
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl variant protected void create(ScriptDevice script, Surface target)
   *!
   *! Create a pxoy surface that will render to target and record the
   *! operations to device.
   *!
   *! @param script
   *!   the script (output device)
   *! @param target
   *!   a target surface to wrap
   */
  PIKEFUN void create(ScriptDevice script, Surface target)
    flags ID_PROTECTED|ID_VARIANT;
    get_all_args;
  {
    struct Cairo_Device_struct *script_dev;
    struct Cairo_Surface_struct *target_surf;

    if (THIS->surface)
      Pike_error("Surface already initialized\n");

    if (!(script_dev = get_storage(script, Cairo_Device_program)))
      SIMPLE_ARG_TYPE_ERROR("create", 1, "Cairo.ScriptDevice");
    if (!(target_surf = get_storage(target, Cairo_Surface_program)))
      SIMPLE_ARG_TYPE_ERROR("create", 2, "Cairo.Surface");
    THIS->surface =
      cairo_script_surface_create_for_target(script_dev->device,
                                             target_surf->surface);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }
}
/*! @endclass */
#endif

#ifdef CAIRO_HAS_TEE_SURFACE
/*! @class TeeSurface
 *! Redirect input to multiple surfaces
 */
PIKECLASS TeeSurface
{
  /*! @decl inherit Surface
   */
  INHERIT Surface;

  /*! @decl protected void create(Surface primary)
   *!
   *! Creates a new "tee" surface.
   *!
   *! The primary surface is used when querying surface options, like
   *! font options and extents.
   *!
   *! Operations performed on the tee surface will be replayed on any
   *! surface added to it.
   *!
   *! @param primary
   *!   the primary @[Surface]
   */
  PIKEFUN void create(Surface primary)
    flags ID_PROTECTED;
    get_all_args;
  {
    struct Cairo_Surface_struct *primary_surface;

    if (THIS->surface)
      Pike_error("Surface already initialized\n");

    if ((primary_surface = get_storage(primary, Cairo_Surface_program)))
      THIS->surface = cairo_tee_surface_create(primary_surface->surface);
    else
      SIMPLE_ARG_TYPE_ERROR("create", 1, "Cairo.Surface");
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl void add(Surface *target)
   *!
   *! Adds a new target surface to the list of replicas of a tee
   *! surface.
   *!
   *! @param target
   *!   the surface to add
   */
  PIKEFUN void add(Surface *target)
    get_all_args;
  {
    struct Cairo_Surface_struct *target_surface;

    if ((target_surface = get_storage(target, Cairo_Surface_program)))
      cairo_tee_surface_add(THIS->surface, target_surface->surface);
    else
      SIMPLE_ARG_TYPE_ERROR("add", 1, "Cairo.Surface");
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }

  /*! @decl Surface index(int(0..) index)
   *!
   *! Retrieves the replica surface at the given index.
   *!
   *! The primary surface used to create the cairo_tee_surface_t is
   *! always set at the zero index.
   *!
   *! @param index
   *!   the index of the replica to retrieve
   *!
   *! @returns
   *!   the surface at the given index
   */
  PIKEFUN Surface index(int(0..) index)
    get_all_args;
  {
    cairo_surface_t *surf = cairo_tee_surface_index(THIS->surface, index);
    check_status(cairo_surface_status(surf));
    RETURN ref_surface_to_object(surf);
  }

  /*! @decl void remove(Surface target)
   *!
   *! Removes the given surface from the list of replicas of a tee
   *! surface.
   *!
   *! @param target
   *!   the surface to remove
   */
  PIKEFUN void remove(Surface target)
    get_all_args;
  {
    struct Cairo_Surface_struct *target_surface;

    if ((target_surface = get_storage(target, Cairo_Surface_program)))
      cairo_tee_surface_remove(THIS->surface, target_surface->surface);
    else
      SIMPLE_ARG_TYPE_ERROR("remove", 1, "Cairo.Surface");
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }
}
/*! @endclass */
#endif

#ifdef CAIRO_HAS_XCB_SURFACE
/*! @class XCBSurface
 *! X Window System rendering using the XCB library
 */
PIKECLASS XCBSurface
{
  /*! @decl inherit Surface
   */
  INHERIT Surface;

  PIKEFUN void create()
    flags ID_PROTECTED;
  {
    Pike_error("Not supported\n");
  }

  /*! @decl void set_size(int width, int height)
   *!
   *! Informs cairo of the new size of the XCB drawable underlying the
   *! surface.  For a surface created for a window (rather than a
   *! pixmap), this function must be called each time the size of the
   *! window changes.  (For a subwindow, you are normally resizing the
   *! window yourself, but for a toplevel window, it is necessary to
   *! listen for ConfigureNotify events.)
   *!
   *! A pixmap can never change size, so it is never necessary to call
   *! this function on a surface created for a pixmap.
   *!
   *! If @[flush()] wasn't called, some pending operations might be
   *! discarded.
   *!
   *! @param width
   *!   the new width of the surface
   *! @param height
   *!   the new height of the surface
   */
  PIKEFUN void set_size(int width, int height)
    get_all_args;
  {
    cairo_xcb_surface_set_size(THIS->surface, width, height);
    check_status(cairo_surface_status(THIS->surface));
    RETURN;
  }
}
/*! @endclass */
#endif

#ifdef CAIRO_HAS_XLIB_SURFACE
/*! @class XlibSurface
 *! X Window System rendering using XLib
 */
PIKECLASS XlibSurface
{
  /*! @decl inherit Surface
   */
  INHERIT Surface;

  PIKEFUN void create()
    flags ID_PROTECTED;
  {
    Pike_error("Not supported\n");
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  /*! @decl int get_width()
   *!
   *! Get the width of the X Drawable underlying the surface in
   *! pixels.
   *!
   *! @returns
   *!   the width of the surface in pixels.
   */
  PIKEFUN int get_width()
  {
    RETURN cairo_xlib_surface_get_width(THIS->surface);
  }

  /*! @decl int get_height()
   *!
   *! Get the height of the X Drawable underlying the surface in
   *! pixels.
   *!
   *! @returns
   *!   the height of the surface in pixels.
   */
  PIKEFUN int get_height()
  {
    RETURN cairo_xlib_surface_get_height(THIS->surface);
  }

  /*! @decl int get_depth()
   *!
   *! Get the number of bits used to represent each pixel value.
   *!
   *! @returns
   *!   the depth of the surface in bits.
   */
  PIKEFUN int get_depth()
  {
    RETURN cairo_xlib_surface_get_depth(THIS->surface);
  }
#endif
}
/*! @endclass */
#endif

static struct object *surface_to_object(cairo_surface_t *surf)
{
  struct object *o;
  struct program *p;
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  switch (cairo_surface_get_type(surf)) {
  case CAIRO_SURFACE_TYPE_IMAGE: p = Cairo_ImageSurface_program; break;
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
  case CAIRO_SURFACE_TYPE_RECORDING: p = Cairo_RecordingSurface_program; break;
#endif
#ifdef CAIRO_HAS_PDF_SURFACE
  case CAIRO_SURFACE_TYPE_PDF: p = Cairo_PDFSurface_program; break;
#endif
#ifdef CAIRO_HAS_PS_SURFACE
  case CAIRO_SURFACE_TYPE_PS: p = Cairo_PSSurface_program; break;
#endif
#ifdef CAIRO_HAS_SVG_SURFACE
  case CAIRO_SURFACE_TYPE_SVG: p = Cairo_SVGSurface_program; break;
#endif
#ifdef CAIRO_HAS_SCRIPT_SURFACE
  case CAIRO_SURFACE_TYPE_SCRIPT: p = Cairo_ScriptSurface_program; break;
#endif
#ifdef CAIRO_HAS_TEE_SURFACE
  case CAIRO_SURFACE_TYPE_TEE: p = Cairo_TeeSurface_program; break;
#endif
#ifdef CAIRO_HAS_XCB_SURFACE
  case CAIRO_SURFACE_TYPE_XCB: p = Cairo_XCBSurface_program; break;
#endif
#ifdef CAIRO_HAS_XLIB_SURFACE
  case CAIRO_SURFACE_TYPE_XLIB: p = Cairo_XlibSurface_program; break;
#endif
  default: p = Cairo_Surface_program; break;
  }
#else
  p = Cairo_Surface_program;
#endif
  o = fast_clone_object(p);
  GET_CAIRO_SURFACE_STORAGE(o)->surface = surf;
  return o;
}

static struct object *ref_surface_to_object(cairo_surface_t *surf)
{
  return surface_to_object(cairo_surface_reference(surf));
}

/*! @class Pattern
 *!
 *! The paint with which cairo draws.  The primary use of patterns is
 *! as the source for all cairo drawing operations, although they can
 *! also be used as masks, that is, as the brush too.
 */
PIKECLASS Pattern
{
  CVAR cairo_pattern_t *pattern;

  /*! @decl protected local int(0..1) `==(mixed x)
   *!
   *! @returns
   *!   Returns @expr{1@} if @[x] is the same @[Pattern],
   *!   and @expr{0@} (zero) otherwise.
   */
  PIKEFUN int(0..1) `==(mixed x)
    flags ID_PROTECTED;
  {
    struct Cairo_Pattern_struct *other;
    if (!x || (TYPEOF(*x) != PIKE_T_OBJECT) ||
        !x->u.object || !x->u.object->prog ||
        !(other = get_storage(x->u.object, Cairo_Pattern_program)))
      RETURN 0;
    RETURN THIS->pattern == other->pattern;
  }

  /*! @decl void set_extend(int extend)
   *!
   *! Sets the mode to be used for drawing outside the area of a
   *! pattern.
   *!
   *! The default extend mode is @[EXTEND_NONE] for surface patterns
   *! and @[EXTEND_PAD] for gradient patterns.
   *!
   *! @param extend
   *!   how the area outside of the pattern will be drawn
   */
  PIKEFUN void set_extend(int extend)
    get_all_args;
  {
    cairo_pattern_set_extend(THIS->pattern, extend);
    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

  /*! @decl int get_extend()
   *!
   *! Gets the current extend mode for a pattern.
   *!
   *! @returns
   *!   the current extend strategy used for drawing the pattern.
   */
  PIKEFUN int get_extend()
  {
    RETURN cairo_pattern_get_extend(THIS->pattern);
  }

  /*! @decl void set_filter(int filter)
   *!
   *!
   *! Sets the filter to be used for resizing when using this
   *! pattern.
   *!
   *! Note that you might want to control filtering even when you do
   *! not have an explicit Pattern object, (for example when using
   *! @[Context->set_source_surface()]).  In these cases, it is
   *! convenient to use @[Context->get_source()] to get access to the
   *! pattern that cairo creates implicitly. For example:
   *!
   *! @code
   *! cr->set_source_surface(image, x, y);
   *! cr->get_source()->set_filter(Cairo.FILTER_NEAREST);
   *! @endcode
   *!
   *! @param filter
   *!   the filter to use for resizing the pattern
   */
  PIKEFUN void set_filter(int filter)
    get_all_args;
  {
    cairo_pattern_set_filter(THIS->pattern, filter);
    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

  /*! @decl int get_filter()
   *!
   *! Gets the current filter for a pattern.
   *!
   *! @returns
   *!   the current filter used for resizing the pattern.
   */
  PIKEFUN int get_filter()
  {
    RETURN cairo_pattern_get_filter(THIS->pattern);
  }

  /*! @decl void set_matrix(Matrix matrix)
   *!
   *! Sets the pattern's transformation matrix to matrix.  This matrix
   *! is a transformation from user space to pattern space.
   *!
   *! When a pattern is first created it always has the identity
   *! matrix for its transformation matrix, which means that pattern
   *! space is initially identical to user space.
   *!
   *! Important: Please note that the direction of this transformation
   *! matrix is from user space to pattern space.  This means that if
   *! you imagine the flow from a pattern to user space (and on to
   *! device space), then coordinates in that flow will be transformed
   *! by the inverse of the pattern matrix.
   *!
   *! Also, please note the discussion of the user-space locking
   *! semantics of @[Context->set_source()].
   *!
   *! @param matrix
   *!   a matrix
   */
  PIKEFUN void set_matrix(Matrix matrix)
  {
    cairo_matrix_t m;
    if (!matrix_from_object(matrix, &m))
      SIMPLE_ARG_TYPE_ERROR("set_matrix", 1, "Cairo.Matrix");
    cairo_pattern_set_matrix(THIS->pattern, &m);
    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

  /*! @decl Matrix get_matrix()
   *!
   *! Stores the pattern's transformation matrix into a @[Matrix].
   *!
   *! @returns
   *!   the matrix
   */
  PIKEFUN Matrix get_matrix()
  {
    cairo_matrix_t m;
    cairo_pattern_get_matrix(THIS->pattern, &m);
    RETURN matrix_to_object(&m);
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
  /*! @decl void set_dither(int dither)
   *!
   *! Set the dithering mode of the rasterizer used for drawing
   *! shapes.  This value is a hint, and a particular backend may or
   *! may not support a particular value.  At the current time, only
   *! pixman is supported.
   *!
   *! @param dither
   *!   the new dithering mode
   */
  PIKEFUN void set_dither(int dither)
    get_all_args;
  {
    cairo_pattern_set_dither(THIS->pattern, dither);
    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

  /*! @decl int get_dither()
   *!
   *! Gets the current dithering mode, as set by @[set_dither()].
   *!
   *! @returns
   *!   the current dithering mode.
   */
  PIKEFUN int get_dither()
  {
    RETURN cairo_pattern_get_dither(THIS->pattern);
  }
#endif

#ifdef PIKE_NULL_IS_SPECIAL
  INIT {
    THIS->pattern = NULL;
  }
#endif

  EXIT
    gc_trivial;
  {
    if (THIS->pattern)
      cairo_pattern_destroy(THIS->pattern);
  }
}
/*! @endclass */

/*! @class SolidPattern
 *! A solid (uniform) color.  It may be opaque or translucent.
 */
PIKECLASS SolidPattern
{
  /*! @decl inherit Pattern
   */
  INHERIT Pattern;

  /*! @decl protected void create(float red, float green, float blue, float|void alpha)
   *!
   *! Creates a new @[Pattern] corresponding to an opaque or
   *! translucent color.  The color components are floating point
   *! numbers in the range 0 to 1.  If the values passed in are
   *! outside that range, they will be clamped.
   *!
   *! @param red
   *!   red component of the color
   *! @param green
   *!   green component of the color
   *! @param blue
   *!   blue component of the color
   *! @param alpha
   *!  alpha component of the color.  If omitted the pattern will be opaque.
   */
  PIKEFUN void create( float red, float green, float blue, float|void alpha)
    flags ID_PROTECTED;
    get_all_args;
  {
    if (THIS->pattern)
      Pike_error("Pattern already initialized\n");

    THIS->pattern =
      (args > 3?
       cairo_pattern_create_rgba(red, green, blue, alpha) :
       cairo_pattern_create_rgb(red, green, blue));

    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 4, 0)
  /*! @decl array(float) get_rgba()
   *!
   *! Gets the solid color for a solid color pattern.
   *!
   *! Note that the color and alpha values are not premultiplied.
   *!
   *! @returns
   *!   An array with the components of the color
   *!   @array
   *!     @elem float 0
   *!       red component of color
   *!     @elem float 1
   *!       green component of color
   *!     @elem float 2
   *!       blue component of color
   *!     @elem float 3
   *!       alpha component of color
   *!   @endarray
   */
  PIKEFUN array(float) get_rgba()
  {
    double red, green, blue, alpha;
    check_status(cairo_pattern_get_rgba(THIS->pattern,
                                        &red, &green, &blue, &alpha));
    push_float(red);
    push_float(green);
    push_float(blue);
    push_float(alpha);
    f_aggregate(4);
  }
#endif
}
/*! @endclass */

/*! @class SurfacePattern
 *! A pattern based on a surface (an image).
 */
PIKECLASS SurfacePattern
{
  /*! @decl inherit Pattern
   */
  INHERIT Pattern;

  /*! @decl protected void create(Surface target)
   *!
   *! Create a new @[Pattern] for the given surface.
   *!
   *! @param surface
   *!   the surface
   */
  PIKEFUN void create(Surface target)
    flags ID_PROTECTED;
    get_all_args;
  {
    struct Cairo_Surface_struct *surface;

    if (THIS->pattern)
      Pike_error("Pattern already initialized\n");

    if ((surface = get_storage(target, Cairo_Surface_program))) {
      THIS->pattern = cairo_pattern_create_for_surface(surface->surface);
      check_status(cairo_pattern_status(THIS->pattern));
    } else
      SIMPLE_ARG_TYPE_ERROR("create", 1, "Cairo.Surface");

    RETURN;
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 4, 0)
  /*! @decl Surface get_surface()
   *!

   *! Gets the surface of a @[SurfacePattern].
   *!
   *! @returns
   *!   surface of pattern
   */
  PIKEFUN Surface get_surface()
  {
    cairo_surface_t *surface;
    check_status(cairo_pattern_get_surface(THIS->pattern, &surface));
    RETURN ref_surface_to_object(surface);
  }
#endif
}
/*! @endclass */

/*! @class Gradient
 *! A gradient.
 */
PIKECLASS Gradient
{
  /*! @decl inherit Pattern
   */
  INHERIT Pattern;

  /*! @decl void add_color_stop_rgb(float offset, float red, float green, float blue)
   *!
   *! Adds an opaque color stop to a gradient pattern.  The offset
   *! specifies the location along the gradient's control vector.  For
   *! example, a linear gradient's control vector is from (x0,y0) to
   *! (x1,y1) while a radial gradient's control vector is from any
   *! point on the start circle to the corresponding point on the end
   *! circle.
   *!
   *! The color is specified in the same way as in
   *! @[Context->set_source_rgb()].
   *!
   *! If two (or more) stops are specified with identical offset
   *! values, they will be sorted according to the order in which the
   *! stops are added, (stops added earlier will compare less than
   *! stops added later).  This can be useful for reliably making
   *! sharp color transitions instead of the typical blend.
   *!
   *! @param offset
   *!   an offset in the range [0.0 .. 1.0]
   *! @param red
   *!   red component of color
   *! @param green
   *!   green component of color
   *! @param blue
   *!   blue component of color
   */
  PIKEFUN void add_color_stop_rgb(float offset, float red, float green, float blue)
    get_all_args;
  {
    cairo_pattern_add_color_stop_rgb(THIS->pattern, offset, red, green, blue);
    RETURN;
  }

  /*! @decl void add_color_stop_rgba(float offset, float red, float green,  @
   *!                                float blue, float alpha)
   *!
   *! Adds a translucent color stop to a gradient pattern.  The offset
   *! specifies the location along the gradient's control vector. For
   *! example, a linear gradient's control vector is from (x0,y0) to
   *! (x1,y1) while a radial gradient's control vector is from any
   *! point on the start circle to the corresponding point on the end
   *! circle.
   *!
   *! The color is specified in the same way as in
   *! @[Context->set_source_rgba()].
   *!
   *! If two (or more) stops are specified with identical offset
   *! values, they will be sorted according to the order in which the
   *! stops are added, (stops added earlier will compare less than
   *! stops added later).  This can be useful for reliably making
   *! sharp color transitions instead of the typical blend.
   *!
   *! @param offset
   *!   an offset in the range [0.0 .. 1.0]
   *! @param red
   *!   red component of color
   *! @param green
   *!   green component of color
   *! @param blue
   *!   blue component of color
   *! @param alpha
   *!   alpha component of color
   */
  PIKEFUN void add_color_stop_rgba(float offset, float red, float green, float blue, float alpha)
    get_all_args;
  {
    cairo_pattern_add_color_stop_rgba(THIS->pattern, offset,
                                      red, green, blue, alpha);
    RETURN;
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 4, 0)
  /*! @decl int get_color_stop_count()
   *!
   *! Gets the number of color stops specified in the gradient
   *! pattern.
   *!
   *! @returns
   *!   the number of color stops
   */
  PIKEFUN int get_color_stop_count()
  {
    int count;
    check_status(cairo_pattern_get_color_stop_count(THIS->pattern, &count));
    RETURN count;
  }

  /*! @decl array(float) get_color_stop_rgba(int index)
   *!
   *! Gets the color and offset information at the given index for a
   *! gradient pattern.  Values of index range from 0 to n-1 where n
   *! is the number returned by @[get_color_stop_count()].
   *!
   *! Note that the color and alpha values are not premultiplied.
   *!
   *! @param index
   *!   index of the stop to return data for
   *!
   *! @returns
   *!   @array
   *!     @elem float 0
   *!       the offset of the stop
   *!     @elem float 1
   *!       red component of color
   *!     @elem float 2
   *!       green component of color
   *!     @elem float 3
   *!       blue component of color
   *!     @elem float 4
   *!       alpha component of color
   *!   @endarray
   */
  PIKEFUN array(float) get_color_stop_rgba(int index)
    get_all_args;
  {
    double offset, red, green, blue, alpha;
    check_status(cairo_pattern_get_color_stop_rgba(THIS->pattern, index,
                                                   &offset, &red, &green,
                                                   &blue, &alpha));
    pop_stack();
    push_float(offset);
    push_float(red);
    push_float(green);
    push_float(blue);
    push_float(alpha);
    f_aggregate(5);
  }
#endif
}
/*! @endclass */

/*! @class LinearGradient
 *! A linear gradient.
 */
PIKECLASS LinearGradient
{
  /*! @decl inherit Gradient
   */
  INHERIT Gradient;

  /*! @decl protected void create(float|int x0, float|int y0, float|int x1, float|int y1)
   *!
   *! Create a new @[LinearGradient] along the line defined by (x0,
   *! y0) and (x1, y1).  Before using the gradient pattern, a number
   *! of color stops should be defined using @[add_color_stop_rgb()]
   *! or @[add_color_stop_rgba()].
   *!
   *! @note
   *! The coordinates here are in pattern space.  For a new pattern,
   *! pattern space is identical to user space, but the relationship
   *! between the spaces can be changed with @[set_matrix()].
   *!
   *! @param x0
   *!   x coordinate of the start point
   *! @param y0
   *!   y coordinate of the start point
   *! @param x1
   *!   x coordinate of the end point
   *! @param y1
   *!   y coordinate of the end point
   */
  PIKEFUN void create(float|int x0, float|int y0, float|int x1, float|int y1)
    flags ID_PROTECTED;
    get_all_args;
  {
    if (THIS->pattern)
      Pike_error("Pattern already initialized\n");

    THIS->pattern = cairo_pattern_create_linear(x0, y0, x1, y1);

    RETURN;
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 4, 0)
  /*! @decl array(float) get_linear_points()
   *!
   *! Gets the gradient endpoints for a linear gradient.
   *!
   *! @returns
   *!   @array
   *!     @elem float 0
   *!       the x coordinate of the first point
   *!     @elem float 1
   *!       the y coordinate of the first point
   *!     @elem float 2
   *!       the x coordinate of the second point
   *!     @elem float 3
   *!       the y coordinate of the second point
   *!   @endarray
   */
  PIKEFUN array(float) get_linear_points()
  {
    double x0, y0, x1, y1;
    check_status(cairo_pattern_get_linear_points(THIS->pattern,
                                                 &x0, &y0, &x1, &y1));
    push_float(x0);
    push_float(y0);
    push_float(x1);
    push_float(y1);
    f_aggregate(4);
  }
#endif
}
/*! @endclass */

/*! @class RadialGradient
 *! A radial gradient.
 */
PIKECLASS RadialGradient
{
  /*! @decl inherit Gradient
   */
  INHERIT Gradient;

  /*! @decl protected void create(float|int cx0, float|int cy0,      @
   *!                             float|int radius0, float|int cx1,  @
   *!                             float|int cy1, float|int radius1)
   *!
   *! Creates a new @[RadialGradient] between the two circles defined
   *! by (cx0, cy0, radius0) and (cx1, cy1, radius1).  Before using
   *! the gradient pattern, a number of color stops should be defined
   *! using @[add_color_stop_rgb()] or @[add_color_stop_rgba()].
   *!
   *! @note
   *! The coordinates here are in pattern space.  For a new pattern,
   *! pattern space is identical to user space, but the relationship
   *! between the spaces can be changed with @[set_matrix()].
   *!
   *! @param cx0
   *!   x coordinate for the center of the start circle
   *! @param cy0
   *!   y coordinate for the center of the start circle
   *! @param radius0
   *!   radius of the start circle
   *! @param cx1
   *!   x coordinate for the center of the end circle
   *! @param cy1
   *!   y coordinate for the center of the end circle
   *! @param radius1
   *!   radius of the end circle
   */
  PIKEFUN void create(float|int cx0, float|int cy0, float|int radius0,
                      float|int cx1, float|int cy1, float|int radius1)
    flags ID_PROTECTED;
    get_all_args;
  {
    if (THIS->pattern)
      Pike_error("Pattern already initialized\n");

    THIS->pattern = cairo_pattern_create_radial(cx0, cy0, radius0,
                                                cx1, cy1, radius1);

    RETURN;
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 4, 0)
  /*! @decl array(float) get_radial_circles()
   *!
   *! Gets the gradient endpoint circles for a radial gradient, each
   *! specified as a center coordinate and a radius.
   *!
   *! @returns
   *!   @array
   *!     @elem float 0
   *!        the x coordinate of the center of the first circle
   *!     @elem float 1
   *!        the y coordinate of the center of the first circle
   *!     @elem float 2
   *!        the radius of the first circle
   *!     @elem float 3
   *!        the x coordinate of the center of the second circle
   *!     @elem float 4
   *!        the y coordinate of the center of the second circle
   *!     @elem float 5
   *!        the radius of the second circle
   *!   @endarray
   */
  PIKEFUN array(float) get_radial_circles()
  {
    double x0, y0, r0, x1, y1, r1;
    check_status(cairo_pattern_get_radial_circles(THIS->pattern,
                                                  &x0, &y0, &r0, &x1, &y1, &r1));
    push_float(x0);
    push_float(y0);
    push_float(r0);
    push_float(x1);
    push_float(y1);
    push_float(r1);
    f_aggregate(6);
  }
#endif
}
/*! @endclass */

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
/*! @class MeshPattern
 *!
 *! Mesh patterns are tensor-product patch meshes (type 7 shadings in
 *! PDF). Mesh patterns may also be used to create other types of
 *! shadings that are special cases of tensor-product patch meshes
 *! such as Coons patch meshes (type 6 shading in PDF) and
 *! Gouraud-shaded triangle meshes (type 4 and 5 shadings in PDF).
 *!
 *! Mesh patterns consist of one or more tensor-product patches, which
 *! should be defined before using the mesh pattern.  Using a mesh
 *! pattern with a partially defined patch as source or mask will put
 *! the context in an error status with a status of
 *! @[STATUS_INVALID_MESH_CONSTRUCTION].
 *!
 *! A tensor-product patch is defined by 4 Bézier curves (side 0, 1,
 *! 2, 3) and by 4 additional control points (P0, P1, P2, P3) that
 *! provide further control over the patch and complete the definition
 *! of the tensor-product patch.  The corner C0 is the first point of
 *! the patch.
 *!
 *! Degenerate sides are permitted so straight lines may be used.  A
 *! zero length line on one side may be used to create 3 sided
 *! patches.
 *!
 *! @pre{
 *!
 *!          C1     Side 1       C2
 *!           +---------------+
 *!           |               |
 *!           |  P1       P2  |
 *!           |               |
 *!    Side 0 |               | Side 2
 *!           |               |
 *!           |               |
 *!           |  P0       P3  |
 *!           |               |
 *!           +---------------+
 *!         C0     Side 3        C3
 *! @}
 *!
 *! Each patch is constructed by first calling @[begin_patch()], then
 *! @[move_to()] to specify the first point in the patch (C0).  Then
 *! the sides are specified with calls to @[curve_to()] and
 *! @[line_to()].
 *!
 *! The four additional control points (P0, P1, P2, P3) in a patch can
 *! be specified with @[set_control_point()].
 *!
 *! At each corner of the patch (C0, C1, C2, C3) a color may be
 *! specified with @[set_corner_color_rgb()] or
 *! @[set_corner_color_rgba()].  Any corner whose color is not
 *! explicitly specified defaults to transparent black.
 *!
 *! A Coons patch is a special case of the tensor-product patch where
 *! the control points are implicitly defined by the sides of the
 *! patch.  The default value for any control point not specified is
 *! the implicit value for a Coons patch, i.e. if no control points
 *! are specified the patch is a Coons patch.
 *!
 *! A triangle is a special case of the tensor-product patch where the
 *! control points are implicitly defined by the sides of the patch,
 *! all the sides are lines and one of them has length 0, i.e. if the
 *! patch is specified using just 3 lines, it is a triangle.  If the
 *! corners connected by the 0-length side have the same color, the
 *! patch is a Gouraud-shaded triangle.
 *!
 *! Calling @[end_patch()] completes the current patch.  If less than
 *! 4 sides have been defined, the first missing side is defined as a
 *! line from the current point to the first point of the patch (C0)
 *! and the other sides are degenerate lines from C0 to C0.  The
 *! corners between the added sides will all be coincident with C0 of
 *! the patch and their color will be set to be the same as the color
 *! of C0.
 *!
 *! Additional patches may be added with additional calls to
 *! @[begin_patch()]/@[end_patch()].
 */
PIKECLASS MeshPattern
{
  /*! @decl inherit Pattern
   */
  INHERIT Pattern;

  /*! @decl protected void create()
   *!
   *! Create a new mesh pattern.
   */
  PIKEFUN void create()
    flags ID_PROTECTED;
  {
    if (THIS->pattern)
      Pike_error("Pattern already initialized\n");

    THIS->pattern = cairo_pattern_create_mesh();

    RETURN;
  }

  /*! @decl void begin_patch()
   *!
   *! Begin a patch in a mesh pattern.
   *!
   *! After calling this function, the patch shape should be defined
   *! with @[move_to()], @[line_to()] and @[curve_to()].
   *!
   *! After defining the patch, @[end_patch()] must be called before
   *! using pattern as a source or mask.
   *!
   *! @note
   *! If pattern already has a current patch, it will be put into an
   *! error status with a status of
   *! @[STATUS_INVALID_MESH_CONSTRUCTION].
   */
  PIKEFUN void begin_patch()
  {
    cairo_mesh_pattern_begin_patch(THIS->pattern);
    check_status(cairo_pattern_status(THIS->pattern));
  }

  /*! @decl void end_patch()
   *!
   *! Indicates the end of the current patch in a mesh pattern.
   *!
   *! If the current patch has less than 4 sides, it is closed with a
   *! straight line from the current point to the first point of the
   *! patch as if @[line_to()] was used.
   *!
   *! @note
   *! If pattern has no current patch or the current patch has no
   *! current point, pattern will be put into an error status with a
   *! status of @[STATUS_INVALID_MESH_CONSTRUCTION].
   */
  PIKEFUN void end_patch()
  {
    cairo_mesh_pattern_end_patch(THIS->pattern);
    check_status(cairo_pattern_status(THIS->pattern));
  }

  /*! @decl void move_to(float|int x, float|int y)
   *!
   *! Define the first point of the current patch in a mesh pattern.
   *!
   *! After this call the current point will be (x, y).
   *!
   *! @note
   *! If pattern has no current patch or the current patch already has
   *! at least one side, pattern will be put into an error status with a
   *! status of @[STATUS_INVALID_MESH_CONSTRUCTION].
   *!
   *! @param x
   *!   the X coordinate of the new position
   *! @param y
   *!   the Y coordinate of the new position
   */
  PIKEFUN void move_to(float|int x, float|int y)
    get_all_args;
  {
    cairo_mesh_pattern_move_to(THIS->pattern, x, y);
    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

  /*! @decl void line_to(float|int x, float|int y)
   *!
   *! Adds a line to the current patch from the current point to
   *! position (x, y) in pattern-space coordinates.
   *!
   *! If there is no current point before the call to @[line_to()] this
   *! function will behave as @[move_to(x, y)].
   *!
   *! After this call the current point will be (x, y).
   *!
   *! @note
   *! If pattern has no current patch or the current patch already has
   *! 4 sides, pattern will be put into an error status with a status
   *! of @[STATUS_INVALID_MESH_CONSTRUCTION].
   *!
   *! @param x
   *!   the X coordinate of the end of the new line
   *! @param y
   *!   the Y coordinate of the end of the new line
   */
  PIKEFUN void line_to(float|int x, float|int y)
    get_all_args;
  {
    cairo_mesh_pattern_line_to(THIS->pattern, x, y);
    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

  /*! @decl void curve_to(float|int x1, float|int y1, float|int x2,  @
   *!                     float|int y2, float|int x3, float|int y3)
   *!
   *! Adds a cubic Bézier spline to the current patch from the current
   *! point to position (x3, y3) in pattern-space coordinates, using
   *! (x1, y1) and (x2, y2) as the control points.
   *!
   *! If the current patch has no current point before the call to
   *! @[curve_to()], this function will behave as if preceded by a call
   *! to @[move_to(x1, y1)].
   *!
   *! After this call the current point will be (x3, y3).
   *!
   *! @note
   *! If pattern has no current patch or the current patch already has
   *! 4 sides, pattern will be put into an error status with a status
   *! of @[STATUS_INVALID_MESH_CONSTRUCTION].
   *!
   *! @param x1
   *!   the X coordinate of the first control point
   *! @param y1
   *!   the Y coordinate of the first control point
   *! @param x2
   *!   the X coordinate of the second control point
   *! @param y2
   *!   the Y coordinate of the second control point
   *! @param x3
   *!   the X coordinate of the end of the curve
   *! @param y3
   *!   the Y coordinate of the end of the curve
   */
  PIKEFUN void curve_to(float|int x1, float|int y1, float|int x2,
                        float|int y2, float|int x3, float|int y3)
    get_all_args;
  {
    cairo_mesh_pattern_curve_to(THIS->pattern, x1, y1, x2, y2, x3, y3);
    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

  /*! @decl void set_control_point(int(0..3) point_num, float|int x, float|int y)
   *!
   *! Set an internal control point of the current patch.
   *!
   *! Valid values for point_num are from 0 to 3 and identify the
   *! control points as explained in @[MeshPattern].
   *!
   *! @note
   *! If point_num is not valid, pattern will be put into an error
   *! status with a status of @[STATUS_INVALID_INDEX].  If pattern has
   *! no current patch, pattern will be put into an error status with
   *! a status of @[STATUS_INVALID_MESH_CONSTRUCTION].
   *!
   *! @param point_num
   *!   the control point to set the position for
   *! @param x
   *!   the X coordinate of the control point
   *! @param y
   *!   the Y coordinate of the control point
   */
  PIKEFUN void set_control_point(int(0..3) point_num, float|int x, float|int y)
    get_all_args;
  {
    cairo_mesh_pattern_set_control_point(THIS->pattern, point_num, x, y);
    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

  /*! @decl void set_corner_color_rgb(int(0..3) corner_num,               @
   *!                                 float red, float green,float blue)
   *!
   *! Sets the color of a corner of the current patch in a mesh
   *! pattern.
   *!
   *! The color is specified in the same way as in
   *! @[Context->set_source_rgb()].
   *!
   *! Valid values for corner_num are from 0 to 3 and identify the
   *! corners as explained in @[MeshPattern].
   *!
   *! @note
   *! If corner_num is not valid, pattern will be put into an error
   *! status with a status of @[STATUS_INVALID_INDEX].  If pattern has
   *! no current patch, pattern will be put into an error status with
   *! a status of @[STATUS_INVALID_MESH_CONSTRUCTION].
   *!
   *! @param corner_num
   *!   the corner to set the color for
   *! @param red
   *!   red component of color
   *! @param green
   *!   green component of color
   *! @param blue
   *!   blue component of color
   */
  PIKEFUN void set_corner_color_rgb(int(0..3) corner_num,
                                    float red, float green,float blue)
    get_all_args;
  {
    cairo_mesh_pattern_set_corner_color_rgb(THIS->pattern, corner_num,
                                            red, green, blue);
    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

  /*! @decl void set_corner_color_rgba(int(0..3) corner_num, float red,      @
   *!                                  float green, float blue, float alpha)
   *!
   *! Sets the color of a corner of the current patch in a mesh
   *! pattern.
   *!
   *! The color is specified in the same way as in
   *! @[Context->set_source_rgba()].
   *!
   *! Valid values for corner_num are from 0 to 3 and identify the
   *! corners as explained in @[MeshPattern].
   *!
   *! @note
   *! If corner_num is not valid, pattern will be put into an error
   *! status with a status of @[STATUS_INVALID_INDEX].  If pattern has
   *! no current patch, pattern will be put into an error status with
   *! a status of @[STATUS_INVALID_MESH_CONSTRUCTION].
   *!
   *! @param corner_num
   *!   the corner to set the color for
   *! @param red
   *!   red component of color
   *! @param green
   *!   green component of color
   *! @param blue
   *!   blue component of color
   *! @param alpha
   *!   alpha component of color
   */
  PIKEFUN void set_corner_color_rgba(int(0..3) corner_num, float red,
                                     float green, float blue, float alpha)
    get_all_args;
  {
    cairo_mesh_pattern_set_corner_color_rgba(THIS->pattern, corner_num,
                                             red, green, blue, alpha);
    check_status(cairo_pattern_status(THIS->pattern));
    RETURN;
  }

  /*! @decl int(0..) get_patch_count()
   *!
   *! Gets the number of patches specified in this mesh pattern.
   *!
   *! The number only includes patches which have been finished by
   *! calling @[end_patch()].  For example it will be 0 during the
   *! definition of the first patch.
   *!
   *! @returns
   *!   the number patches
   */
  PIKEFUN int(0..) get_patch_count()
  {
    unsigned int count;
    check_status(cairo_mesh_pattern_get_patch_count(THIS->pattern, &count));
    RETURN count;
  }

  /*! @decl Path get_path(int(0..) patch_num)
   *!
   *! Gets path defining the patch patch_num for a mesh pattern.
   *!
   *! patch_num can range from 0 to n-1 where n is the number returned
   *! by @[get_patch_count()].
   *!
   *! @param patch_num
   *!   the patch number to return data for
   *!
   *! @returns
   *!   the path defining the patch
   */
  PIKEFUN Path get_path(int(0..) patch_num)
    get_all_args;
  {
    struct object *o = fast_clone_object(Cairo_Path_program);
    struct Cairo_Path_struct *p = GET_CAIRO_PATH_STORAGE(o);
    p->path = cairo_mesh_pattern_get_path(THIS->pattern, patch_num);
    push_object(o);
    check_status(p->path->status);
    stack_unlink(1);
  }

  /*! @decl array(float) get_control_point(int(0..) patch_num,    @
   *!                                      int(0..3) point_num)
   *!
   *! Gets the control point point_num of patch patch_num for a mesh
   *! pattern.
   *!
   *! patch_num can range from 0 to n-1 where n is the number returned
   *! by @[get_patch_count()].
   *!
   *! Valid values for point_num are from 0 to 3 and identify the
   *! control points as explained in @[MeshPattern].
   *!
   *! @param patch_num
   *!   the patch number to return data for
   *! @param point_num
   *!   the control point number to return data for
   *!
   *! @returns
   *!   the coordinates of the control point
   *!   @array
   *!     @elem float 0
   *!       the x coordinate of the control point
   *!     @elem float 1
   *!       the y coordinate of the control point
   *!   @endarray
   */
  PIKEFUN array(float) get_control_point(int(0..) patch_num,
                                         int(0..3) point_num)
    get_all_args;
  {
    double x, y;
    check_status(cairo_mesh_pattern_get_control_point(THIS->pattern, patch_num,
                                                      point_num, &x, &y));
    pop_n_elems(2);
    push_float(x);
    push_float(y);
    f_aggregate(2);
  }

  /*! @decl array(float) get_corner_color_rgba(int(0..) patch_num,    @
   *!                                          int(0..3) corner_num)
   *!
   *! Gets the color information in corner corner_num of patch
   *! patch_num for a mesh pattern.
   *!
   *! patch_num can range from 0 to n-1 where n is the number returned
   *! by @[get_patch_count()].
   *!
   *! Valid values for corner_num are from 0 to 3 and identify the
   *! corners as explained in @[MeshPattern].
   *!
   *! Note that the color and alpha values are not premultiplied.
   *!
   *! @param patch_num
   *!   the patch number to return data for
   *! @param corner_num
   *!   the corner number to return data for
   *!
   *! @returns
   *!   the color information of the corner
   *!   @array
   *!     @elem float 0
   *!       red component of color
   *!     @elem float 1
   *!       green component of color
   *!     @elem float 2
   *!       blue component of color
   *!     @elem float 3
   *!       alpha component of color
   *!   @endarray
   */
  PIKEFUN array(float) get_corner_color_rgba(int(0..) patch_num,
                                             int(0..3) corner_num)
    get_all_args;
  {
    double red, green, blue, alpha;
    check_status(cairo_mesh_pattern_get_corner_color_rgba(THIS->pattern,
                                                          patch_num, corner_num,
                                                          &red, &green, &blue,
                                                          &alpha));
    pop_n_elems(2);
    push_float(red);
    push_float(green);
    push_float(blue);
    push_float(alpha);
    f_aggregate(4);
  }
}
/*! @endclass */
#endif

static struct object *pattern_to_object(cairo_pattern_t *pat)
{
  struct object *o;
  struct program *p;
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  switch (cairo_pattern_get_type(pat)) {
  case CAIRO_PATTERN_TYPE_SOLID: p = Cairo_SolidPattern_program; break;
  case CAIRO_PATTERN_TYPE_SURFACE: p = Cairo_SurfacePattern_program; break;
  case CAIRO_PATTERN_TYPE_LINEAR: p = Cairo_LinearGradient_program; break;
  case CAIRO_PATTERN_TYPE_RADIAL: p = Cairo_RadialGradient_program; break;
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
  case CAIRO_PATTERN_TYPE_MESH: p = Cairo_MeshPattern_program; break;
#endif
  default: p = Cairo_Pattern_program; break;
  }
#else
  p = Cairo_Pattern_program;
#endif
  o = fast_clone_object(p);
  GET_CAIRO_PATTERN_STORAGE(o)->pattern = pat;
  return o;
}

static struct object *ref_pattern_to_object(cairo_pattern_t *pat)
{
  return pattern_to_object(cairo_pattern_reference(pat));
}

/*! @class Context
 *! The cairo drawing context
 */
PIKECLASS Context
{
  CVAR cairo_t *cr;

  /*! @decl protected void create(Surface target)
   *!
   *! Creates a new context with all graphics state parameters set to
   *! default values and with target as a target surface.
   *!
   *! @param target
   *!   target surface for the context
   */
  PIKEFUN void create( object(Surface)|object(Val.Pointer) target )
    flags ID_PROTECTED;
    get_all_args;
  {
    struct Cairo_Surface_struct *surface;

    if (THIS->cr)
      Pike_error("Context already initialized\n");

    if ((surface = get_storage(target, Cairo_Surface_program))) {
      THIS->cr = cairo_create(surface->surface);
      check_status(cairo_status(THIS->cr));
    } else {
      cairo_t *cr = get_pointer_from_pointer_object(target);
      if (!cr)
        Pike_error("No valid pointer provided\n");
      THIS->cr = cairo_reference(cr);
    }

    RETURN;
  }

  /*! @decl void save()
   *!
   *! Makes a copy of the current state and saves it on an internal
   *! stack of saved states.  When @[restore()] is called, the context
   *! will be restored to the saved state.  Multiple calls to save()
   *! and restore() can be nested; each call to restore() restores the
   *! state from the matching paired save().
   */
  PIKEFUN void save()
  {
    cairo_save(THIS->cr);
  }

  /*! @decl void restore()
   *!
   *! Restores to the state saved by a preceding call to @[save()] and
   *! removes that state from the stack of saved states.
   */
  PIKEFUN void restore()
  {
    cairo_restore(THIS->cr);
  }

  /*! @decl Surface get_target()
   *!
   *! Gets the target surface for the cairo context
   *!
   *! @returns
   *!   the target surface.
   */
  PIKEFUN Surface get_target()
  {
    cairo_surface_t *surf = cairo_get_target(THIS->cr);
    check_status(cairo_surface_status(surf));
    RETURN ref_surface_to_object(surf);
  }

  /*! @decl void set_source_rgb(float red, float green, float blue)
   *!
   *! Sets the source pattern to an opaque color. This opaque color
   *! will then be used for any subsequent drawing operation until a
   *! new source pattern is set.
   *!
   *! The color components are floating point numbers in the range 0 to 1.
   *! If the values passed in are outside that range, they will be clamped.
   *!
   *! The default source pattern is opaque black, (that is, it is equivalent
   *! to set_source_rgb(0.0, 0.0, 0.0)).
   *!
   *! @param red
   *!   red component of color
   *! @param green
   *!   green component of color
   *! @param blue
   *!   blue component of color
   */
  PIKEFUN void set_source_rgb(float red, float green, float blue)
    get_all_args;
  {
    cairo_set_source_rgb(THIS->cr, red, green, blue);
    RETURN;
  }

  /*! @decl void set_source_rgba(float red, float green, float blue, float alpha)
   *!
   *! Sets the source pattern to a translucent color. This color will
   *! then be used for any subsequent drawing operation until a new
   *! source pattern is set.
   *!
   *! The color and alpha components are floating point numbers in the
   *! range 0 to 1. If the values passed in are outside that range,
   *! they will be clamped.
   *!
   *! Note that the color and alpha values are not premultiplied.
   *!
   *! The default source pattern is opaque black, (that is, it is
   *! equivalent to set_source_rgba(0.0, 0.0, 0.0, 1.0)).
   *!
   *! @param red
   *!   red component of color
   *! @param green
   *!   green component of color
   *! @param blue
   *!   blue component of color
   *! @param alpha
   *!   alpha component of color
   */
  PIKEFUN void set_source_rgba(float red, float green, float blue, float alpha)
    get_all_args;
  {
    cairo_set_source_rgba(THIS->cr, red, green, blue, alpha);
    RETURN;
  }

  /*! @decl void set_source(Pattern source)
   *!
   *! Sets the source pattern to @[source].  This pattern will then be
   *! used for any subsequent drawing operation until a new source
   *! pattern is set.
   *!
   *! @note
   *! The pattern's transformation matrix will be locked to the user
   *! space in effect at the time of set_source(). This means that
   *! further modifications of the current transformation matrix will
   *! not affect the source pattern. See @[Pattern->set_matrix()].
   *!
   *! The default source pattern is a solid pattern that is opaque
   *! black, (that is, it is equivalent to set_source_rgb(0.0, 0.0,
   *! 0.0)).
   *!
   *! @param source
   *!   a Pattern to be used as the source for subsequent drawing
   *!   operations.
   */
  PIKEFUN void set_source(Pattern source)
    get_all_args;
  {
    struct Cairo_Pattern_struct *pattern;
    if (!(pattern = get_storage(source, Cairo_Pattern_program)))
      SIMPLE_ARG_TYPE_ERROR("set_source", 1, "Cairo.Pattern");
    cairo_set_source(THIS->cr, pattern->pattern);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void set_source_surface(Surface surface, float|int x, float|int y)
   *!
   *! This is a convenience function for creating a pattern from
   *! surface and setting it as the source with @[set_source()].
   *!
   *! The x and y parameters give the user-space coordinate at which
   *! the surface origin should appear.  (The surface origin is its
   *! upper-left corner before any transformation has been applied.)
   *! The x and y parameters are negated and then set as translation
   *! values in the pattern matrix.
   *!
   *! Other than the initial translation pattern matrix, as described
   *! above, all other pattern attributes, (such as its extend mode),
   *! are set to the default values as in @[Pattern->create()].  The
   *! resulting pattern can be queried with @[get_source()] so that
   *! these attributes can be modified if desired, (eg. to create a
   *! repeating pattern with @[Pattern->set_extend()]).
   *!
   *! @param surface
   *!   a surface to be used to set the source pattern
   *! @param x
   *!   User-space X coordinate for surface origin
   *! @param y
   *!   User-space Y coordinate for surface origin
   */
  PIKEFUN void set_source_surface(Surface surface, float|int x, float|int y)
    get_all_args;
  {
    struct Cairo_Surface_struct *surf;
    if (!(surf = get_storage(surface, Cairo_Surface_program)))
      SIMPLE_ARG_TYPE_ERROR("set_source_surface", 1, "Cairo.Surface");
    cairo_set_source_surface(THIS->cr, surf->surface, x, y);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl Pattern get_source()
   *!
   *! Gets the current source pattern.
   *!
   *! @returns
   *!  the current source pattern.
   */
  PIKEFUN Pattern get_source()
  {
    cairo_pattern_t *pat = cairo_get_source(THIS->cr);
    check_status(cairo_pattern_status(pat));
    RETURN ref_pattern_to_object(pat);
  }

  /*! @decl void set_antialias(int antialias)
   *!
   *! Set the antialiasing mode of the rasterizer used for drawing
   *! shapes.  This value is a hint, and a particular backend may or
   *! may not support a particular value.  At the current time, no
   *! backend supports @[ANTIALIAS_SUBPIXEL] when drawing shapes.
   *!
   *! Note that this option does not affect text rendering, instead
   *! see @[FontOptions->set_antialias()].
   *!
   *! @param antialias
   *!   the new antialiasing mode
   */
  PIKEFUN void set_antialias(int antialias)
    get_all_args;
  {
    cairo_set_antialias(THIS->cr, antialias);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl int get_antialias()
   *!
   *! Gets the current shape antialiasing mode, as set by
   *! @[set_antialias()].
   *!
   *! @returns
   *!   the current shape antialiasing mode.
   */
  PIKEFUN int get_antialias()
  {
    RETURN cairo_get_antialias(THIS->cr);
  }

  /*! @decl void set_dash(array(float|int) dashes, float|int offset)
   *!
   *! Sets the dash pattern to be used by @[stroke()].  A dash pattern
   *! is specified by @[dashes], an array of positive values.  Each
   *! value provides the length of alternate "on" and "off" portions
   *! of the stroke.  The offset specifies an offset into the pattern
   *! at which the stroke begins.
   *!
   *! Each "on" segment will have caps applied as if the segment were
   *! a separate sub-path.  In particular, it is valid to use an "on"
   *! length of 0.0 with @[LINE_CAP_ROUND] or @[LINE_CAP_SQUARE] in
   *! order to distributed dots or squares along a path.
   *!
   *! @note
   *! The length values are in user-space units as evaluated at the
   *! time of stroking. This is not necessarily the same as the user
   *! space at the time of set_dash().
   *!
   *! If dashes is empty dashing is disabled.
   *!
   *! If dashes contains a single value a symmetric pattern is assumed
   *! with alternating on and off portions of the size specified by
   *! the value.
   *!
   *! @param dashes
   *!   an array specifying alternate lengths of on and off stroke portions
   *! @param offset
   *!   an offset into the dash pattern at which the stroke should start
   */
  PIKEFUN void set_dash(array(float|int) dashes, float|int offset)
    get_all_args;
  {
    double *double_dashes = NULL;
    if (dashes->size) {
      INT32 i;
      double_dashes = xalloc(dashes->size * sizeof(double));
      for (i=0; i<dashes->size; i++) {
        struct svalue *sv = &ITEM(dashes)[i];
        if (TYPEOF(*sv) == T_FLOAT)
          double_dashes[i] = sv->u.float_number;
        else if (TYPEOF(*sv) == T_INT)
          double_dashes[i] = sv->u.integer;
        else {
          free(double_dashes);
          SIMPLE_ARG_TYPE_ERROR("set_dash", 1, "array(float|int)");
        }
      }
    }
    cairo_set_dash(THIS->cr, double_dashes, dashes->size, offset);
    if (double_dashes)
      free(double_dashes);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void set_fill_rule(int fill_rule)

   *! Set the current fill rule within the cairo context.  The fill
   *! rule is used to determine which regions are inside or outside a
   *! complex (potentially self-intersecting) path.  The current fill
   *! rule affects both @[fill()] and @[clip()].
   *!
   *! The default fill rule is @[FILL_RULE_WINDING].
   *!
   *! @param fill_rule
   *!   a fill rule
   */
  PIKEFUN void set_fill_rule(int fill_rule)
    get_all_args;
  {
    cairo_set_fill_rule(THIS->cr, fill_rule);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl int get_fill_rule()
   *!
   *! Gets the current fill rule, as set by @[set_fill_rule()].
   *!
   *! @returns
   *!   the current fill rule.
   */
  PIKEFUN int get_fill_rule()
  {
    RETURN cairo_get_fill_rule(THIS->cr);
  }

  /*! @decl void set_line_cap(int line_cap)
   *!
   *! Sets the current line cap style within the cairo context.
   *!
   *! As with the other stroke parameters, the current line cap style
   *! is examined by @[stroke()], and @[stroke_extents()], but does
   *! not have any effect during path construction.
   *!
   *! The default line cap style is @[LINE_CAP_BUTT].
   *!
   *! @param line_cap
   *!   a line cap style
   */
  PIKEFUN void set_line_cap(int line_cap)
    get_all_args;
  {
    cairo_set_line_cap(THIS->cr, line_cap);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl int get_line_cap()
   *!
   *! Gets the current line cap style, as set by @[set_line_cap()].
   *!
   *! @returns
   *!   the current line cap style.
   */
  PIKEFUN int get_line_cap()
  {
    RETURN cairo_get_line_cap(THIS->cr);
  }

  /*! @decl void set_line_join(int line_join)
   *!
   *! Sets the current line join style within the cairo context.
   *!
   *! As with the other stroke parameters, the current line join style
   *! is examined by @[stroke()], and @[stroke_extents()], but does
   *! not have any effect during path construction.
   *!
   *! The default line join style is @[LINE_JOIN_MITER].
   *!
   *! @param line_join
   *!   a line join style
   */
  PIKEFUN void set_line_join(int line_join)
    get_all_args;
  {
    cairo_set_line_join(THIS->cr, line_join);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl int get_line_join()
   *!
   *! Gets the current line join style, as set by @[set_line_join()].
   *!
   *! @returns
   *!   the current line join style.
   */
  PIKEFUN int get_line_join()
  {
    RETURN cairo_get_line_join(THIS->cr);
  }

  /*! @decl void set_line_width(float|int width)
   *!
   *! Sets the current line width. The line width value specifies the
   *! diameter of a pen that is circular in user space.
   *!
   *! As with the other stroke parameters, the current line width is
   *! examined by @[stroke()], and @[stroke_extents()], but does not
   *! have any effect during path construction.
   *!
   *! The default line width value is 2.0.
   *!
   *! @param width
   *!   a line width
   */
  PIKEFUN void set_line_width(float|int width)
    get_all_args;
  {
    cairo_set_line_width(THIS->cr, width);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl float get_line_width()
   *!
   *! This function returns the current line width value exactly as
   *! set by @[set_line_width()].  Note that the value is unchanged
   *! even if the CTM has changed between the calls to
   *! set_line_width() and get_line_width().
   *!
   *! @returns
   *!   the current line width.
   */
  PIKEFUN float get_line_width()
  {
    RETURN cairo_get_line_width(THIS->cr);
  }

  /*! @decl void set_miter_limit(float|int limit)
   *!
   *! Sets the current miter limit within the cairo context.
   *!
   *! If the current line join style is set to @[LINE_JOIN_MITER] (see
   *! @[set_line_join()]), the miter limit is used to determine
   *! whether the lines should be joined with a bevel instead of a
   *! miter.  Cairo divides the length of the miter by the line width.
   *! If the result is greater than the miter limit, the style is
   *! converted to a bevel.
   *!
   *! As with the other stroke parameters, the current line miter
   *! limit is examined by @[stroke()], and @[stroke_extents()], but
   *! does not have any effect during path construction.
   *!
   *! The default miter limit value is 10.0, which will convert joins
   *! with interior angles less than 11 degrees to bevels instead of
   *! miters.  For reference, a miter limit of 2.0 makes the miter
   *! cutoff at 60 degrees, and a miter limit of 1.414 makes the
   *! cutoff at 90 degrees.
   *!
   *! A miter limit for a desired angle can be computed as: miter
   *! limit = 1/sin(angle/2)
   *!
   *! @param limit
   *!   miter limit to set
   */
  PIKEFUN void set_miter_limit(float|int limit)
    get_all_args;
  {
    cairo_set_miter_limit(THIS->cr, limit);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl float get_miter_limit()
   *!
   *! Gets the current miter limit, as set by @[set_miter_limit()].
   *!
   *! @returns
   *!   the current miter limit.
   */
  PIKEFUN float get_miter_limit()
  {
    RETURN cairo_get_miter_limit(THIS->cr);
  }


  /*! @decl void set_operator(int op)
   *!
   *! Sets the compositing operator to be used for all drawing
   *! operations.
   *!
   *! The default operator is @[OPERATOR_OVER].
   *!
   *! @param op
   *!   a compositing operator
   */
  PIKEFUN void set_operator(int op)
    get_all_args;
  {
    cairo_set_operator(THIS->cr, op);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl int get_operator()
   *!
   *! Gets the current compositing operator for a cairo context.
   *!
   *! @returns
   *!   the current compositing operator.
   */
  PIKEFUN int get_operator()
  {
    RETURN cairo_get_operator(THIS->cr);
  }

  /*! @decl void set_tolerance(float|int tolerance)
   *!
   *! Sets the tolerance used when converting paths into trapezoids.
   *! Curved segments of the path will be subdivided until the maximum
   *! deviation between the original path and the polygonal
   *! approximation is less than tolerance.  The default value is 0.1.
   *! A larger value will give better performance, a smaller value,
   *! better appearance.  (Reducing the value from the default value
   *! of 0.1 is unlikely to improve appearance significantly.)  The
   *! accuracy of paths within Cairo is limited by the precision of
   *! its internal arithmetic, and the prescribed tolerance is
   *! restricted to the smallest representable internal value.
   *!
   *! @param tolerance
   *!   the tolerance, in device units (typically pixels)
   */
  PIKEFUN void set_tolerance(float|int tolerance)
    get_all_args;
  {
    cairo_set_tolerance(THIS->cr, tolerance);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl float get_tolerance()
   *!
   *! Gets the current tolerance value, as set by @[set_tolerance()].
   *!
   *! @returns
   *!   the current tolerance value.
   */
  PIKEFUN float get_tolerance()
  {
    RETURN cairo_get_tolerance(THIS->cr);
  }

  /*! @decl void clip()
   *!
   *! Establishes a new clip region by intersecting the current clip
   *! region with the current path as it would be filled by @[fill()]
   *! and according to the current fill rule (see @[set_fill_rule()]).
   *!
   *! After clip(), the current path will be cleared from the cairo
   *! context.
   *!
   *! The current clip region affects all drawing operations by
   *! effectively masking out any changes to the surface that are
   *! outside the current clip region.
   *!
   *! Calling clip() can only make the clip region smaller, never
   *! larger.  But the current clip is part of the graphics state, so
   *! a temporary restriction of the clip region can be achieved by
   *! calling clip() within a @[save()]/@[restore()] pair.  The only
   *! other means of increasing the size of the clip region is
   *! @[reset_clip()].
   */
  PIKEFUN void clip()
  {
    cairo_clip(THIS->cr);
  }

  /*! @decl void clip_preserve()
   *!
   *! Establishes a new clip region by intersecting the current clip
   *! region with the current path as it would be filled by @[fill()]
   *! and according to the current fill rule (see @[set_fill_rule()]).
   *!
   *! Unlike @[clip()], clip_preserve() preserves the path within the
   *! cairo context.
   *!
   *! The current clip region affects all drawing operations by
   *! effectively masking out any changes to the surface that are
   *! outside the current clip region.
   *!
   *! Calling clip_preserve() can only make the clip region smaller,
   *! never larger.  But the current clip is part of the graphics
   *! state, so a temporary restriction of the clip region can be
   *! achieved by calling clip_preserve() within a
   *! @[save()]/@[restore()] pair. The only other means of increasing
   *! the size of the clip region is @[reset_clip()].
   */
  PIKEFUN void clip_preserve()
  {
    cairo_clip_preserve(THIS->cr);
  }

  /*! @decl void reset_clip()
   *!
   *! Reset the current clip region to its original, unrestricted
   *! state.  That is, set the clip region to an infinitely large
   *! shape containing the target surface.  Equivalently, if infinity
   *! is too hard to grasp, one can imagine the clip region being
   *! reset to the exact bounds of the target surface.
   *!
   *! Note that code meant to be reusable should not call reset_clip()
   *! as it will cause results unexpected by higher-level code which
   *! calls @[clip()].  Consider using @[save()] and @[restore()]
   *! around @[clip()] as a more robust means of temporarily
   *! restricting the clip region.
   */
  PIKEFUN void reset_clip()
  {
    cairo_reset_clip(THIS->cr);
  }

  /*! @decl void fill()
   *!
   *! A drawing operator that fills the current path according to the
   *! current fill rule, (each sub-path is implicitly closed before
   *! being filled).  After fill(), the current path will be cleared
   *! from the cairo context.
   *!
   *! @seealso
   *!   @[set_fill_rule()] and @[fill_preserve()].
   */
  PIKEFUN void fill()
  {
    cairo_fill(THIS->cr);
  }

  /*! @decl void fill_preserve()
   *!
   *! A drawing operator that fills the current path according to the
   *! current fill rule, (each sub-path is implicitly closed before
   *! being filled).  Unlike @[fill()], fill_preserve() preserves the
   *! path within the cairo context.
   *!
   *! @seealso
   *!   @[set_fill_rule()] and @[fill()].
   */
  PIKEFUN void fill_preserve()
  {
    cairo_fill_preserve(THIS->cr);
  }

  /*! @decl array(float) fill_extents()
   *!
   *! Computes a bounding box in user coordinates covering the area
   *! that would be affected, (the "inked" area), by a @[fill()]
   *! operation given the current path and fill parameters.  If the
   *! current path is empty, returns an empty rectangle ({0, 0, 0,
   *! 0}).  Surface dimensions and clipping are not taken into
   *! account.
   *!
   *! Contrast with @[path_extents()], which is similar, but returns
   *! non-zero extents for some paths with no inked area, (such as a
   *! simple line segment).
   *!
   *! Note that fill_extents() must necessarily do more work to
   *! compute the precise inked areas in light of the fill rule, so
   *! @[path_extents()] may be more desirable for sake of performance
   *! if the non-inked path extents are desired.
   *!
   *! @returns
   *!   an array with coordinates for the left, top, right, and bottom,
   *!   respectively, of the resulting extents
   *!
   *! @seealso
   *!   @[fill()], @[set_fill_rule()] and @[fill_preserve()].
   */
  PIKEFUN array(float) fill_extents()
  {
    double x1, y1, x2, y2;
    cairo_fill_extents(THIS->cr, &x1, &y1, &x2, &y2);
    push_float(x1);
    push_float(y1);
    push_float(x2);
    push_float(y2);
    f_aggregate(4);
  }

  /*! @decl int(0..1) in_fill(float|int x, float|int y)
   *!
   *! Tests whether the given point is inside the area that would be
   *! affected by a @[fill()] operation given the current path and
   *! filling parameters.  Surface dimensions and clipping are not
   *! taken into account.
   *!
   *! @param x
   *!   X coordinate of the point to test
   *! @param y
   *!   Y coordinate of the point to test
   *!
   *! @returns
   *!   A non-zero value if the point is inside, or zero if outside.
   *!
   *! @seealso
   *!   @[fill()], @[set_fill_rule()] and @[fill_preserve()].
   */
  PIKEFUN int(0..1) in_fill(float|int x, float|int y)
    get_all_args;
  {
    RETURN cairo_in_fill(THIS->cr, x, y);
  }

  /*! @decl void mask(Pattern pattern)
   *!
   *! A drawing operator that paints the current source using the
   *! alpha channel of pattern as a mask.  (Opaque areas of pattern
   *! are painted with the source, transparent areas are not painted.)
   *!
   *! @param pattern
   *!   a @[Pattern]
   */
  PIKEFUN void mask(Pattern pattern)
    get_all_args;
  {
    struct Cairo_Pattern_struct *pat;
    if (!(pat = get_storage(pattern, Cairo_Pattern_program)))
      SIMPLE_ARG_TYPE_ERROR("mask", 1, "Cairo.Pattern");
    cairo_mask(THIS->cr, pat->pattern);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void mask_surface(Surface surface, float|int surface_x, float|int surface_y)
   *!
   *! A drawing operator that paints the current source using the
   *! alpha channel of surface as a mask.  (Opaque areas of surface
   *! are painted with the source, transparent areas are not painted.)
   *!
   *! @param surface
   *!   a @[Surface]
   *! @param surface_x
   *!   X coordinate at which to place the origin of surface
   *! @param surface_y
   *!   Y coordinate at which to place the origin of surface
   */
  PIKEFUN void mask_surface(Surface surface, float|int surface_x, float|int surface_y)
    get_all_args;
  {
    struct Cairo_Surface_struct *surf;
    if (!(surf = get_storage(surface, Cairo_Surface_program)))
      SIMPLE_ARG_TYPE_ERROR("mask_surface", 1, "Cairo.Surface");
    cairo_mask_surface(THIS->cr, surf->surface, surface_x, surface_y);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void paint()
   *!
   *! A drawing operator that paints the current source everywhere
   *! within the current clip region.
   */
  PIKEFUN void paint()
  {
    cairo_paint(THIS->cr);
  }

  /*! @decl void paint_with_alpha(float alpha)
   *!
   *! A drawing operator that paints the current source everywhere
   *! within the current clip region using a mask of constant alpha
   *! value alpha . The effect is similar to @[paint()], but the
   *! drawing is faded out using the alpha value.
   *!
   *! @param alpha
   *!   alpha value, between 0 (transparent) and 1 (opaque)
   */
  PIKEFUN void paint_with_alpha(float alpha)
    get_all_args;
  {
    cairo_paint_with_alpha(THIS->cr, alpha);
  }

  /*! @decl void stroke()
   *!
   *! A drawing operator that strokes the current path according to
   *! the current line width, line join, line cap, and dash
   *! settings. After stroke(), the current path will be cleared from
   *! the context.
   *!
   *! @seealso
   *!   @[set_line_width()], @[set_line_join()], @[set_line_cap()],
   *!   @[set_dash()], and @[stroke_preserve()].
   */
  PIKEFUN void stroke()
  {
    cairo_stroke(THIS->cr);
  }

  /*! @decl void stroke_preserve()
   *!
   *! A drawing operator that strokes the current path according to
   *! the current line width, line join, line cap, and dash
   *! settings. Unlike @[stroke()], stroke_preserve() preserves the
   *! path within the cairo context.
   *!
   *! @seealso
   *!   @[set_line_width()], @[set_line_join(]), @[set_line_cap()],
   *!   @[set_dash()], and @[stroke_preserve()].
   */
  PIKEFUN void stroke_preserve()
  {
    cairo_stroke_preserve(THIS->cr);
  }


  /*! @decl array(float) stroke_extents()
   *!
   *! Computes a bounding box in user coordinates covering the area
   *! that would be affected, (the "inked" area), by a @[stroke()]
   *! operation given the current path and stroke parameters.  If the
   *! current path is empty, returns an empty rectangle ({0, 0, 0,
   *! 0}).  Surface dimensions and clipping are not taken into
   *! account.
   *!
   *! Note that if the line width is set to exactly zero, then
   *! stroke_extents() will return an empty rectangle.  Contrast with
   *! @[path_extents()] which can be used to compute the non-empty
   *! bounds as the line width approaches zero.
   *!
   *! Note that stroke_extents() must necessarily do more work to
   *! compute the precise inked areas in light of the stroke
   *! parameters, so @[path_extents()] may be more desirable for sake
   *! of performance if non-inked path extents are desired.
   *!
   *! @returns
   *!   an array with coordinates for the left, top, right, and bottom,
   *!   respectively, of the resulting extents
   *!
   *! @seealso
   *!   @[stroke()], @[set_line_width()], @[set_line_join()],
   *!   @[set_line_cap()], @[set_dash()], and @[stroke_preserve()].
   */
  PIKEFUN array(float) stroke_extents()
  {
    double x1, y1, x2, y2;
    cairo_stroke_extents(THIS->cr, &x1, &y1, &x2, &y2);
    push_float(x1);
    push_float(y1);
    push_float(x2);
    push_float(y2);
    f_aggregate(4);
  }

  /*! @decl int(0..1) in_stroke(float|int x, float|int y)
   *!
   *! Tests whether the given point is inside the area that would be
   *! affected by a @[stroke()] operation given the current path and
   *! stroking parameters.  Surface dimensions and clipping are not
   *! taken into account.
   *!
   *! @param x
   *!   X coordinate of the point to test
   *! @param y
   *!   Y coordinate of the point to test
   *!
   *! @returns
   *!   A non-zero value if the point is inside, or zero if outside.
   *!
   *! @seealso
   *!   @[stroke()], @[set_line_width()], @[set_line_join()],
   *!   @[set_line_cap()], @[set_dash()], and @[stroke_preserve()].
  */
  PIKEFUN int(0..1) in_stroke(float|int x, float|int y)
    get_all_args;
  {
    RETURN cairo_in_stroke(THIS->cr, x, y);
  }

  /*! @decl void copy_page()
   *!
   *! Emits the current page for backends that support multiple pages,
   *! but doesn't clear it, so, the contents of the current page will
   *! be retained for the next page too.  Use @[show_page()] if you
   *! want to get an empty page after the emission.
   *!
   *! This is a convenience function that simply calls
   *! @[Surface->copy_page()] on the context's target.
   */
  PIKEFUN void copy_page()
  {
    cairo_copy_page(THIS->cr);
    check_status(cairo_status(THIS->cr));
  }

  /*! @decl void show_page()
   *!
   *! Emits and clears the current page for backends that support
   *! multiple pages.  Use @[copy_page()] if you don't want to clear
   *! the page.
   *!
   *! This is a convenience function that simply calls
   *! @[Surface->show_page()] on the context's target.
   */
  PIKEFUN void show_page()
  {
    cairo_show_page(THIS->cr);
    check_status(cairo_status(THIS->cr));
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  /*! @decl void push_group()
   *!
   *! Temporarily redirects drawing to an intermediate surface known
   *! as a group.  The redirection lasts until the group is completed
   *! by a call to @[pop_group()] or @[pop_group_to_source()].  These
   *! calls provide the result of any drawing to the group as a
   *! pattern, (either as an explicit object, or set as the source
   *! pattern).
   *!
   *! This group functionality can be convenient for performing
   *! intermediate compositing.  One common use of a group is to
   *! render objects as opaque within the group, (so that they occlude
   *! each other), and then blend the result with translucence onto
   *! the destination.
   *!
   *! Groups can be nested arbitrarily deep by making balanced calls
   *! to push_group()/pop_group(). Each call pushes/pops the new
   *! target group onto/from a stack.
   *!
   *! The push_group() function calls @[save()] so that any changes to
   *! the graphics state will not be visible outside the group, (the
   *! pop_group functions call @[restore()]).
   *!
   *! By default the intermediate group will have a content type of
   *! @[CONTENT_COLOR_ALPHA].  Other content types can be chosen for
   *! the group by using @[push_group_with_content()] instead.
   */
  PIKEFUN void push_group()
  {
    cairo_push_group(THIS->cr);
  }

  /*! @decl void push_group_with_content(int content)
   *!
   *! Temporarily redirects drawing to an intermediate surface known
   *! as a group.  The redirection lasts until the group is completed
   *! by a call to @[pop_group()] or @[pop_group_to_source()].  These
   *! calls provide the result of any drawing to the group as a
   *! pattern, (either as an explicit object, or set as the source
   *! pattern).
   *!
   *! The group will have a content type of @[content].  The ability to
   *! control this content type is the only distinction between this
   *! function and @[push_group()] which you should see for a more
   *! detailed description of group rendering.
   *!
   *! @param content
   *!   the type of group that will be created
   */
  PIKEFUN void push_group_with_content(int content)
    get_all_args;
  {
    cairo_push_group_with_content(THIS->cr, content);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl Pattern pop_group()
   *!
   *! Terminates the redirection begun by a call to @[push_group()] or
   *! @[push_group_with_content()] and returns a new pattern
   *! containing the results of all drawing operations performed to
   *! the group.
   *!
   *! The pop_group() function calls @[restore()], (balancing a call
   *! to @[save()] by the push_group function), so that any changes
   *! to the graphics state will not be visible outside the group.
   *!
   *! @returns
   *!   a newly created (surface) pattern containing the results of
   *!   all drawing operations performed to the group.
   */
  PIKEFUN Pattern pop_group()
  {
    cairo_pattern_t *pat = cairo_pop_group(THIS->cr);
    push_object(pattern_to_object(pat));
    check_status(cairo_pattern_status(pat));
  }

  /*! @decl void pop_group_to_source()
   *!
   *! Terminates the redirection begun by a call to @[push_group()] or
   *! @[push_group_with_content()] and installs the resulting pattern
   *! as the source pattern in the given cairo context.

   *! The pop_group() function calls @[restore()], (balancing a call
   *! to @[save()] by the push_group function), so that any changes
   *! to the graphics state will not be visible outside the group.
   */
  PIKEFUN void pop_group_to_source()
  {
    cairo_pop_group_to_source(THIS->cr);
  }

  /*! @decl Surface get_group_target()
   *!
   *! Gets the current destination surface for the context.  This is
   *! either the original target surface or the target surface for the
   *! current group as started by the most recent call to
   *! @[push_group()] or @[push_group_with_content()].
   *!
   *! @returns
   *!   the target surface.
   */
  PIKEFUN Surface get_group_target()
  {
    cairo_surface_t *surf = cairo_get_group_target(THIS->cr);
    check_status(cairo_surface_status(surf));
    RETURN ref_surface_to_object(surf);
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 4, 0)
  /*! @decl int get_dash_count()
   *!
   *! This function returns the length of the dash array (0 if dashing
   *! is not currently in effect).
   *!
   *! @returns
   *!   the length of the dash array, or 0 if no dash array set.
   *!
   *! @seealso
   *!   @[set_dash()] and @[get_dash()].
   */
  PIKEFUN int get_dash_count()
  {
    RETURN cairo_get_dash_count(THIS->cr);
  }

  /*! @decl array(array(float)|float) get_dash()
   *!
   *! Gets the current dash array.
   *!
   *! @returns
   *!   an array with two elements, the first is the dash array,
   *!   and the second is the current dash offset
   */
  PIKEFUN array(array(float)|float) get_dash()
  {
    int count = cairo_get_dash_count(THIS->cr);
    double offset, *dashes = NULL;
    if (count)
      dashes = xalloc(count * sizeof(double));
    cairo_get_dash(THIS->cr, dashes, &offset);
    if (dashes) {
      int i;
      for (i=0; i<count; i++)
        push_float(dashes[i]);
      free(dashes);
      f_aggregate(count);
    } else
      f_aggregate(0);
    push_float(offset);
    f_aggregate(2);
  }

  /*! @decl array(float) clip_extents()
   *!
   *! Computes a bounding box in user coordinates covering the area
   *! inside the current clip.
   *!
   *! @returns
   *!   an array with coordinates for the left, top, right, and bottom,
   *!   respectively, of the resulting extents
   */
  PIKEFUN array(float) clip_extents()
  {
    double x1, y1, x2, y2;
    cairo_clip_extents(THIS->cr, &x1, &y1, &x2, &y2);
    push_float(x1);
    push_float(y1);
    push_float(x2);
    push_float(y2);
    f_aggregate(4);
  }

  /*! @decl array(Rectangle) copy_clip_rectangle_list()
   *!
   *! Gets the current clip region as a list of rectangles in user
   *! coordinates.
   *!
   *! @returns
   *!   the current clip region as an array of rectangles in user
   *!   coordinates.
   */
  PIKEFUN array(Rectangle) copy_clip_rectangle_list()
  {
    cairo_rectangle_list_t *rects = cairo_copy_clip_rectangle_list(THIS->cr);
    cairo_status_t status = rects->status;
    if (status != CAIRO_STATUS_SUCCESS) {
      cairo_rectangle_list_destroy(rects);
      check_status(status);
    } else {
      int i;
      for (i=0; i<rects->num_rectangles; i++)
        push_object(rectangle_to_object(&rects->rectangles[i]));
      f_aggregate(rects->num_rectangles);
      cairo_rectangle_list_destroy(rects);
    }
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
  /*! @decl int(0..1) in_clip(float|int x, float|int y)
   *!
   *! Tests whether the given point is inside the area that would be
   *! visible through the current clip, i.e. the area that would be
   *! filled by a @[paint()] operation.
   *!
   *! @seealso
   *!    @[clip()], and @[clip_preserve()].
   *!
   *! @param x
   *!   X coordinate of the point to test
   *! @param y
   *!   Y coordinate of the point to test
   *!
   *! @returns
   *!   A non-zero value if the point is inside, or zero if outside.
   */
  PIKEFUN int(0..1) in_clip(float|int x, float|int y)
    get_all_args;
  {
    RETURN cairo_in_clip(THIS->cr, x, y);
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
  /*! @decl void set_hairline(int(0..1) set_hairline)
   *!
   *! Sets lines within the cairo context to be hairlines.  Hairlines
   *! are logically zero-width lines that are drawn at the thinnest
   *! renderable width possible in the current context.
   *!
   *! On surfaces with native hairline support, the native hairline
   *! functionality will be used. Surfaces that support hairlines
   *! include:
   *!
   *! pdf/ps: Encoded as 0-width line.
   *! win32_printing: Rendered with PS_COSMETIC pen.
   *! svg: Encoded as 1px non-scaling-stroke.
   *! script: Encoded with set-hairline function.
   *!
   *! Cairo will always render hairlines at 1 device unit wide, even
   *! if an anisotropic scaling was applied to the stroke width.  In
   *! the wild, handling of this situation is not well-defined.  Some
   *! PDF, PS, and SVG renderers match Cairo's output, but some very
   *! popular implementations (Acrobat, Chrome, rsvg) will scale the
   *! hairline unevenly.  As such, best practice is to reset any
   *! anisotropic scaling before calling @[stroke()].
   *!
   *! @param set_hairline
   *!   whether or not to set hairline mode
   */
  PIKEFUN void set_hairline(int(0..1) set_hairline)
    get_all_args;
  {
    cairo_set_hairline(THIS->cr, set_hairline);
    RETURN;
  }

  /*! @decl int(0..1) get_hairline()
   *!
   *! Returns whether or not hairline mode is set, as set by
   *! @[set_hairline()].
   *!
   *! @returns
   *!   whether hairline mode is set.
   */
  PIKEFUN int(0..1) get_hairline()
  {
    RETURN cairo_get_hairline(THIS->cr);
  }
#endif

  /*! @decl Path copy_path()
   *!
   *! Creates a copy of the current path and returns it to the user as
   *! a @[Path].
   *!
   *! @returns
   *!   the copy of the current path.
   */
  PIKEFUN Path copy_path()
  {
    struct object *o = fast_clone_object(Cairo_Path_program);
    struct Cairo_Path_struct *p = GET_CAIRO_PATH_STORAGE(o);
    p->path = cairo_copy_path(THIS->cr);
    push_object(o);
    check_status(p->path->status);
  }

  /*! @decl Path copy_path_flat()
   *!
   *! Gets a flattened copy of the current path and returns it to the
   *! user as a @[Path].
   *!
   *! This function is like @[copy_path()] except that any curves in
   *! the path will be approximated with piecewise-linear
   *! approximations, (accurate to within the current tolerance
   *! value).
   *!
   *! @returns
   *!   the copy of the current path.
   */
  PIKEFUN Path copy_path_flat()
  {
    struct object *o = fast_clone_object(Cairo_Path_program);
    struct Cairo_Path_struct *p = GET_CAIRO_PATH_STORAGE(o);
    p->path = cairo_copy_path_flat(THIS->cr);
    push_object(o);
    check_status(p->path->status);
  }

  /*! @decl void append_path(Path path)
   *!
   *! Append the path onto the current path.  The path may be either
   *! the return value from one of @[copy_path()] or
   *! @[copy_path_flat()] or it may be constructed manually.
   *!
   *! @param path
   *!   path to be appended
   */
  PIKEFUN void append_path(Path path)
    get_all_args;
  {
    cairo_append_path(THIS->cr, GET_CAIRO_PATH_STORAGE(path)->path);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl array(float) get_current_point()
   *!
   *! Gets the current point of the current path, which is
   *! conceptually the final point reached by the path so far.

   *! The current point is returned in the user-space coordinate
   *! system.  If there is no defined current point or if the context
   *! is in an error status, both returned coordinates will be 0.0.
   *! It is possible to check this in advance with @[has_current_point()].
   *!
   *! @returns
   *!   an array with the current x and y coordinates
   */
  PIKEFUN array(float) get_current_point()
  {
    double x, y;
    cairo_get_current_point (THIS->cr, &x, &y);
    push_float(x);
    push_float(y);
    f_aggregate(2);
  }

  /*! @decl void new_path()
   *!
   *! Clears the current path.  After this call there will be no path
   *! and no current point.
   */
  PIKEFUN void new_path()
  {
    cairo_new_path(THIS->cr);
  }

  /*! @decl void close_path()
   *!
   *! Adds a line segment to the path from the current point to the
   *! beginning of the current sub-path, (the most recent point passed
   *! to move_to()), and closes this sub-path. After this call the
   *! current point will be at the joined endpoint of the sub-path.
   *!
   *! The behavior of close_path() is distinct from simply calling
   *! line_to() with the equivalent coordinate in the case of
   *! stroking.  When a closed sub-path is stroked, there are no caps
   *! on the ends of the sub-path.  Instead, there is a line join
   *! connecting the final and initial segments of the sub-path.
   *!
   *!
   *! If there is no current point before the call to close_path(),
   *! this function will have no effect.
   */
  PIKEFUN void close_path()
  {
    cairo_close_path(THIS->cr);
  }

  /*! @decl void arc(float|int xc, float|int yc, float|int radius, float angle1, float angle2)
   *!
   *! Adds a circular arc of the given radius to the current path. The
   *! arc is centered at (xc, yc), begins at angle1 and proceeds in
   *! the direction of increasing angles to end at angle2.  If angle2
   *! is less than angle1 it will be progressively increased by 2*M_PI
   *! until it is greater than angle1.
   *!
   *! If there is a current point, an initial line segment will be
   *! added to the path to connect the current point to the beginning
   *! of the arc. If this initial line is undesired, it can be avoided
   *! by calling @[new_sub_path()] before calling arc().
   *!
   *! Angles are measured in radians.  An angle of 0.0 is in the
   *! direction of the positive X axis (in user space).  An angle of
   *! M_PI/2.0 radians (90 degrees) is in the direction of the
   *! positive Y axis (in user space).  Angles increase in the
   *! direction from the positive X axis toward the positive Y axis.
   *! So with the default transformation matrix, angles increase in a
   *! clockwise direction.
   *!
   *! This function gives the arc in the direction of increasing
   *! angles; see @[arc_negative()] to get the arc in the direction
   *! of decreasing angles.
   *!
   *! @param xc
   *!   X position of the center of the arc
   *! @param yc
   *!   Y position of the center of the arc
   *! @param radius
   *!   the radius of the arc
   *! @param angle1
   *!   the start angle, in radians
   *! @param angle2
   *!   the end angle, in radians
   */
  PIKEFUN void arc(float|int xc, float|int yc, float|int radius, float angle1, float angle2)
    get_all_args;
  {
    cairo_arc(THIS->cr, xc, yc, radius, angle1, angle2);
    RETURN;
  }

  /*! @decl void arc_negative(float|int xc, float|int yc, float|int radius, float angle1, float angle2)
   *!
   *! Adds a circular arc of the given radius to the current path. The
   *! arc is centered at (xc, yc), begins at angle1 and proceeds in
   *! the direction of decreasing angles to end at angle2.  If angle2
   *! is greater than angle1 it will be progressively decreased by
   *! 2*M_PI until it is less than angle1.
   *!
   *! See @[arc()] for more details.  This function differs only in
   *! the direction of the arc between the two angles.
   *!
   *! @param xc
   *!   X position of the center of the arc
   *! @param yc
   *!   Y position of the center of the arc
   *! @param radius
   *!   the radius of the arc
   *! @param angle1
   *!   the start angle, in radians
   *! @param angle2
   *!   the end angle, in radians
   */
  PIKEFUN void arc_negative(float|int xc, float|int yc, float|int radius, float angle1, float angle2)
    get_all_args;
  {
    cairo_arc_negative(THIS->cr, xc, yc, radius, angle1, angle2);
    RETURN;
  }

  /*! @decl void curve_to(float|int x1, float|int y1, float|int x2, float|int y2, float|int x3, float|int y3)
   *!
   *! Adds a cubic Bézier spline to the path from the current point to
   *! position (x3, y3) in user-space coordinates, using (x1, y1) and
   *! (x2, y2) as the control points.  After this call the current
   *! point will be (x3, y3).
   *!
   *! If there is no current point before the call to curve_to() this
   *! function will behave as if preceded by a call to move_to(x1, y1).
   *!
   *! @param x1
   *!   the X coordinate of the first control point
   *! @param y1
   *!   the Y coordinate of the first control point
   *! @param x2
   *!   the X coordinate of the second control point
   *! @param y2
   *!   the Y coordinate of the second control point
   *! @param x3
   *!   the X coordinate of the end of the curve
   *! @param y3
   *!   the Y coordinate of the end of the curve
   */
  PIKEFUN void curve_to(float|int x1, float|int y1, float|int x2, float|int y2, float|int x3, float|int y3)
    get_all_args;
  {
    cairo_curve_to(THIS->cr, x1, y1, x2, y2, x3, y3);
    RETURN;
  }

  /*! @decl void line_to(float|int x, float|int y)
   *!
   *! Adds a line to the path from the current point to position (x, y)
   *! in user-space coordinates. After this call the current point
   *! will be (x, y).
   *!
   *! If there is no current point before the call to line_to() this
   *! function will behave as move_to(x, y).
   *!
   *! @param x
   *!   the X coordinate of the end of the new line
   *! @param y
   *!   the Y coordinate of the end of the new line
   */
  PIKEFUN void line_to(float|int x, float|int y)
    get_all_args;
  {
    cairo_line_to(THIS->cr, x, y);
    RETURN;
  }

  /*! @decl void move_to(float|int x, float|int y)
   *!
   *! Begin a new sub-path. After this call the current point will be
   *! (x, y).
   *!
   *! @param x
   *!   the X coordinate of the new position
   *! @param y
   *!   the Y coordinate of the new position
   */
  PIKEFUN void move_to(float|int x, float|int y)
    get_all_args;
  {
    cairo_move_to(THIS->cr, x, y);
    RETURN;
  }

  /*! @decl void rectangle(float|int x, float|int y, float|int width, float|int height)
   *!
   *! Adds a closed sub-path rectangle of the given size to the
   *! current path at position (x, y) in user-space coordinates.
   *!
   *! @param x
   *!   the X coordinate of the top left corner of the rectangle
   *! @param y
   *!   the Y coordinate to the top left corner of the rectangle
   *! @param width
   *!   the width of the rectangle
   *! @param height
   *!   the height of the rectangle
   */
  PIKEFUN void rectangle(float|int x, float|int y, float|int width, float|int height)
    get_all_args;
  {
    cairo_rectangle(THIS->cr, x, y, width, height);
    RETURN;
  }

  /*! @decl void glyph_path(array(Glyph|array(int|float)) glyphs)
   *!
   *! Adds closed paths for the glyphs to the current path.  The
   *! generated path if filled, achieves an effect similar to that of
   *! @[show_glyphs()].
   *!
   *! @param glyphs
   *!   array of glyphs to show, with each glyph being represented
   *!   either as a @[Glyph] object or as an array of the following
   *!   format:
   *!   @array
   *!     @elem int 0
   *!       glyph index in the font. The exact interpretation of the
   *!       glyph index depends on the font technology being used.
   *!     @elem float|int 1
   *!       the offset in the X direction between the origin used for
   *!       drawing the string and the origin of this glyph
   *!     @elem float|int 2
   *!       the offset in the Y direction between the origin used for
   *!       drawing the string and the origin of this glyph
   *!   @endarray
   */
  PIKEFUN void glyph_path(array(Glyph|array(int|float)) glyphs)
    get_all_args;
  {
    cairo_glyph_t *gglyphs = NULL;
    if (glyphs->size)
      gglyphs = parse_glyphs_arg(glyphs, "glyph_path", args, 1);
    cairo_glyph_path(THIS->cr, gglyphs, glyphs->size);
    if (gglyphs)
      free(gglyphs);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void text_path(string|zero text)
   *!
   *! Adds closed paths for text to the current path.  The generated
   *! path if filled, achieves an effect similar to that of
   *! @[show_text()].
   *!
   *! Text conversion and positioning is done similar to @[show_text()].
   *!
   *! Like show_text(), After this call the current point is moved to
   *! the origin of where the next glyph would be placed in this same
   *! progression.  That is, the current point will be at the origin
   *! of the final glyph offset by its advance values.  This allows
   *! for chaining multiple calls to to text_path() without having to
   *! set current point in between.
   *!
   *! @param text
   *!   a string of text, or 0
   */
  PIKEFUN void text_path(string|zero text)
    get_all_args;
  {
    const char *utf8 = NULL;
    if (text) {
      f_string_to_utf8(1);
      text = Pike_sp[-1].u.string;
      utf8 = (const char *)STR0(text);
    }
    cairo_text_path(THIS->cr, utf8);
    RETURN;
  }

  /*! @decl void rel_curve_to(float|int dx1, float|int dy1, float|int dx2, float|int dy2, float|int dx3, float|int dy3)
   *!
   *! Relative-coordinate version of @[curve_to()].  All offsets are
   *! relative to the current point.  Adds a cubic Bézier spline to
   *! the path from the current point to a point offset from the
   *! current point by (dx3, dy3), using points offset by (dx1, dy1)
   *! and (dx2, dy2) as the control points.  After this call the
   *! current point will be offset by (dx3, dy3).
   *!
   *! Given a current point of (x, y), rel_curve_to(dx1, dy1, dx2,
   *! dy2, dx3, dy3) is logically equivalent to curve_to(x+dx1, y+dy1,
   *! x+dx2, y+dy2, x+dx3, y+dy3).
   *!
   *! It is an error to call this function with no current
   *! point.
   *!
   *! @param dx1
   *!   the X offset to the first control point
   *! @param dy1
   *!   the Y offset to the first control point
   *! @param dx2
   *!   the X offset to the second control point
   *! @param dy2
   *!   the Y offset to the second control point
   *! @param dx3
   *!   the X offset to the end of the curve
   *! @param dy3
   *!   the Y offset to the end of the curve
   */
  PIKEFUN void rel_curve_to(float|int dx1, float|int dy1, float|int dx2, float|int dy2, float|int dx3, float|int dy3)
    get_all_args;
  {
    cairo_rel_curve_to(THIS->cr, dx1, dy1, dx2, dy2, dx3, dy3);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void rel_line_to(float|int dx, float|int dy)
   *!
   *! Relative-coordinate version of @[line_to()].  Adds a line to the
   *! path from the current point to a point that is offset from the
   *! current point by (dx, dy) in user space.  After this call the
   *! current point will be offset by (dx, dy).
   *!
   *! Given a current point of (x, y), rel_line_to(dx, dy) is
   *! logically equivalent to line_to(x + dx , y + dy).
   *!
   *! It is an error to call this function with no current
   *! point.
   *!
   *! @param dx
   *!   the X offset to the end of the new line
   *! @param dy
   *!   the Y offset to the end of the new line
   */
  PIKEFUN void rel_line_to(float|int dx, float|int dy)
    get_all_args;
  {
    cairo_rel_line_to(THIS->cr, dx, dy);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void rel_move_to(float|int dx, float|int dy)
   *!
   *! Begin a new sub-path.  After this call the current point will
   *! offset by (x, y).
   *!
   *! Given a current point of (x, y), rel_move_to(dx , dy) is
   *! logically equivalent to move_to(x + dx , y + dy).
   *!
   *! It is an error to call this function with no current
   *! point.
   *!
   *! @param dx
   *!   the X offset
   *! @param dy
   *!   the Y offset
   */
  PIKEFUN void rel_move_to(float|int dx, float|int dy)
    get_all_args;
  {
    cairo_rel_move_to(THIS->cr, dx, dy);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  /*! @decl void new_sub_path()
   *!
   *! Begin a new sub-path.  Note that the existing path is not
   *! affected.  After this call there will be no current point.
   *!
   *! In many cases, this call is not needed since new sub-paths are
   *! frequently started with @[move_to()].
   *!
   *! A call to new_sub_path() is particularly useful when beginning a
   *! new sub-path with one of the arc() calls. This makes things
   *! easier as it is no longer necessary to manually compute the
   *! arc's initial coordinates for a call to move_to().
   */
  PIKEFUN void new_sub_path()
  {
    cairo_new_sub_path(THIS->cr);
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 6, 0)
  /*! @decl int(0..1) has_current_point()
   *!
   *! Returns whether a current point is defined on the current
   *! path.
   *!
   *! @seealso
   *!   @[get_current_point()] for details on the current point.
   *!
   *! @returns
   *!   whether a current point is defined.
   */
  PIKEFUN int(0..1) has_current_point()
  {
    RETURN cairo_has_current_point(THIS->cr);
  }

  /*! @decl array(float) path_extents()
   *!
   *! Computes a bounding box in user-space coordinates covering the
   *! points on the current path. If the current path is empty,
   *! returns an empty rectangle ({0, 0, 0, 0}).  Stroke parameters,
   *! fill rule, surface dimensions and clipping are not taken into
   *! account.
   *!
   *! Contrast with @[fill_extents()] and @[stroke_extents()] which
   *! return the extents of only the area that would be "inked" by the
   *! corresponding drawing operations.
   *!
   *! @returns
   *!   an array with coordinates for the left, top, right, and bottom,
   *!   respectively, of the resulting extents
   */
  PIKEFUN array(float) path_extents()
  {
    double x1, y1, x2, y2;
    cairo_path_extents(THIS->cr, &x1, &y1, &x2, &y2);
    push_float(x1);
    push_float(y1);
    push_float(x2);
    push_float(y2);
    f_aggregate(4);
  }
#endif

  /*! @decl void translate(float|int tx, float|int ty)
   *!
   *! Modifies the current transformation matrix (CTM) by translating
   *! the user-space origin by (tx, ty). This offset is interpreted as
   *! a user-space coordinate according to the CTM in place before the
   *! new call to @[translate()].  In other words, the translation of
   *! the user-space origin takes place after any existing
   *! transformation.
   *!
   *! @param tx
   *!   amount to translate in the X direction
   *! @param ty
   *!   amount to translate in the Y direction
   */
  PIKEFUN void translate(float|int tx, float|int ty)
    get_all_args;
  {
    cairo_translate(THIS->cr, tx, ty);
    RETURN;
  }

  /*! @decl void scale(float|int sx, float|int sy)
   *!
   *! Modifies the current transformation matrix (CTM) by scaling the
   *! X and Y user-space axes by sx and sy respectively.  The scaling
   *! of the axes takes place after any existing transformation of
   *! user space.
   *!
   *! @param sx
   *!   scale factor for the X dimension
   *! @param sy
   *!   scale factor for the Y dimension
   */
  PIKEFUN void scale(float|int sx, float|int sy)
    get_all_args;
  {
    cairo_scale(THIS->cr, sx, sy);
    RETURN;
  }

  /*! @decl void rotate(float angle)
   *!
   *! Modifies the current transformation matrix (CTM) by rotating the
   *! user-space axes by angle radians.  The rotation of the axes
   *! takes places after any existing transformation of user space.
   *! The rotation direction for positive angles is from the positive
   *! X axis toward the positive Y axis.
   *!
   *! @param angle
   *!   angle (in radians) by which the user-space axes will be rotated
   */
  PIKEFUN void rotate(float angle)
    get_all_args;
  {
    cairo_rotate(THIS->cr, angle);
    RETURN;
  }

  /*! @decl void transform(Matrix matrix)
   *!
   *! Modifies the current transformation matrix (CTM) by applying
   *! matrix as an additional transformation.  The new transformation
   *! of user space takes place after any existing transformation.
   *!
   *! @param matrix
   *!   a transformation to be applied to the user-space axes
   */
  PIKEFUN void transform(Matrix matrix)
    get_all_args;
  {
    cairo_matrix_t m;
    if (!matrix_from_object(matrix, &m))
      SIMPLE_ARG_TYPE_ERROR("transform", 1, "Cairo.Matrix");
    cairo_transform(THIS->cr, &m);
    RETURN;
  }

  /*! @decl void set_matrix(Matrix matrix)
   *!
   *! Modifies the current transformation matrix (CTM) by setting it
   *! equal to matrix.
   *!
   *! @param matrix
   *!   a transformation matrix from user space to device space
   */
  PIKEFUN void set_matrix(Matrix matrix)
    get_all_args;
  {
    cairo_matrix_t m;
    if (!matrix_from_object(matrix, &m))
      SIMPLE_ARG_TYPE_ERROR("set_matrix", 1, "Cairo.Matrix");
    cairo_set_matrix(THIS->cr, &m);
    RETURN;
  }

  /*! @decl Matrix get_matrix()
   *!
   *! Returns the current transformation matrix (CTM).
   *!
   *! @returns
   *!   the matrix
   */
  PIKEFUN Matrix get_matrix()
  {
    cairo_matrix_t matrix;
    cairo_get_matrix(THIS->cr, &matrix);
    RETURN matrix_to_object(&matrix);
  }

  /*! @decl void identity_matrix()
   *!
   *! Resets the current transformation matrix (CTM) by setting it
   *! equal to the identity matrix.  That is, the user-space and
   *! device-space axes will be aligned and one user-space unit will
   *! transform to one device-space unit.
   */
  PIKEFUN void identity_matrix()
  {
    cairo_identity_matrix(THIS->cr);
  }

  /*! @decl array(float) user_to_device(float|int x, float|int y)
   *!
   *! Transform a coordinate from user space to device space by
   *! multiplying the given point by the current transformation matrix
   *! (CTM).
   '!
   *! @param x
   *!   X value of coordinate
   *! @param y
   *!   Y value of coordinate
   *!
   *! @returns
   *!   The transformed point
   *!   @array
   *!     @elem float 0
   *!       X position of the new point
   *!     @elem float 1
   *!       Y position of the new point
   *!   @endarray
   */
  PIKEFUN array(float) user_to_device(float|int x, float|int y)
    get_all_args;
  {
    double dx = x;
    double dy = y;
    cairo_user_to_device(THIS->cr, &dx, &dy);
    pop_n_elems(2);
    push_float(dx);
    push_float(dy);
    f_aggregate(2);
  }

  /*! @decl array(float) user_to_device_distance(float|int dx, float|int dy)
   *!
   *! Transform a distance vector from user space to device space.
   *! This function is similar to @[user_to_device()] except that the
   *! translation components of the CTM will be ignored when
   *! transforming (dx, dy).
   *!
   *! @param dx
   *!   X component of a distance vector
   *! @param dy
   *!   Y component of a distance vector
   *!
   *! @returns
   *!   The transformed distance vector
   *!   @array
   *!     @elem float 0
   *!       X component of the new distance vector
   *!     @elem float 1
   *!       Y component of the new distance vector
   *!   @endarray
   */
  PIKEFUN array(float) user_to_device_distance(float|int dx, float|int dy)
    get_all_args;
  {
    double ddx = dx;
    double ddy = dy;
    cairo_user_to_device_distance(THIS->cr, &ddx, &ddy);
    pop_n_elems(2);
    push_float(ddx);
    push_float(ddy);
    f_aggregate(2);
  }

  /*! @decl array(float) device_to_user(float|int x, float|int y)
   *!
   *! Transform a coordinate from device space to user space by
   *! multiplying the given point by the inverse of the current
   *! transformation matrix (CTM).
   *!
   *! @param x
   *!   X value of coordinate
   *! @param y
   *!   Y value of coordinate
   *!
   *! @returns
   *!   The transformed point
   *!   @array
   *!     @elem float 0
   *!       X position of the new point
   *!     @elem float 1
   *!       Y position of the new point
   *!   @endarray
   */
  PIKEFUN array(float) device_to_user(float|int x, float|int y)
    get_all_args;
  {
    double dx = x;
    double dy = y;
    cairo_device_to_user(THIS->cr, &dx, &dy);
    pop_n_elems(2);
    push_float(dx);
    push_float(dy);
    f_aggregate(2);
  }

  /*! @decl array(float) device_to_user_distance(float|int dx, float|int dy)
   *!
   *! Transform a distance vector from device space to user space.
   *! This function is similar to @[device_to_user()] except that the
   *! translation components of the inverse CTM will be ignored when
   *! transforming (dx, dy).
   *!
   *! @param dx
   *!   X component of a distance vector (in/out parameter)
   *! @param dy
   *!   Y component of a distance vector (in/out parameter)
   *!
   *! @returns
   *!   The transformed distance vector
   *!   @array
   *!     @elem float 0
   *!       X component of the new distance vector
   *!     @elem float 1
   *!       Y component of the new distance vector
   *!   @endarray
   */
  PIKEFUN array(float) device_to_user_distance(float|int dx, float|int dy)
    get_all_args;
  {
    double ddx = dx;
    double ddy = dy;
    cairo_device_to_user_distance(THIS->cr, &ddx, &ddy);
    pop_n_elems(2);
    push_float(ddx);
    push_float(ddy);
    f_aggregate(2);
  }

  /*! @decl void select_font_face(string family, int slant, int weight)
   *!
   *! @note
   *! The select_font_face() function call is part of what the cairo
   *! designers call the "toy" text API.  It is convenient for short
   *! demos and simple programs, but it is not expected to be adequate
   *! for serious text-using applications.
   *!
   *! Selects a family and style of font from a simplified description
   *! as a family name, slant and weight.  Cairo provides no operation
   *! to list available family names on the system (this is a "toy",
   *! remember), but the standard CSS2 generic family names, ("serif",
   *! "sans-serif", "cursive", "fantasy", "monospace"), are likely to
   *! work as expected.
   *!
   *! If family starts with the string "@@cairo:", or if no native font
   *! backends are compiled in, cairo will use an internal font
   *! family.  The internal font family recognizes many modifiers in
   *! the family string, most notably, it recognizes the string
   *! "monospace".  That is, the family name "@@cairo:monospace" will
   *! use the monospace version of the internal font family.
   *!
   *! For "real" font selection, see the font-backend-specific
   *! font_face_create functions for the font backend you are using.
   *! The resulting font face could then be used with
   *! @[scaled_font_create()] and @[set_scaled_font()].
   *!
   *! If text is drawn without a call to select_font_face(), (nor
   *! @[set_font_face()] nor @[set_scaled_font()]), the default family
   *! is platform-specific, but is essentially "sans-serif".  Default
   *! slant is @[FONT_SLANT_NORMAL], and default weight is
   *! @[FONT_WEIGHT_NORMAL].
   *!
   *! This function is equivalent to a call to
   *! @[toy_font_face_create()] followed by @[set_font_face()].
   *!
   *! @param family
   *!   a font family name
   *! @param slant
   *!   the slant for the font
   *! @param weight
   *!   the weight for the font
   */
  PIKEFUN void select_font_face(string family, int slant, int weight)
    get_all_args;
  {
    pop_n_elems(2);
    f_string_to_utf8(1);
    family = Pike_sp[-1].u.string;
    cairo_select_font_face(THIS->cr, (const char *)STR0(family), slant, weight);
    check_status(cairo_status(THIS->cr));
    pop_stack();
  }

  /*! @decl void set_font_size(float|int size)
   *!
   *! Sets the current font matrix to a scale by a factor of size,
   *! replacing any font matrix previously set with set_font_size() or
   *! @[set_font_matrix()].  This results in a font size of size user
   *! space units.  (More precisely, this matrix will result in the
   *! font's em-square being a size by size square in user space.)
   *!
   *! If text is drawn without a call to set_font_size(), (nor
   *! @[set_font_matrix()] nor @[set_scaled_font()]), the default font
   *! size is 10.0.
   *!
   *! @param size
   *!   the new font size, in user space units
   */
  PIKEFUN void set_font_size(float|int size)
    get_all_args;
  {
    cairo_set_font_size(THIS->cr, size);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void set_font_matrix(Matrix matrix)
   *!
   *! Sets the current font matrix to matrix.  The font matrix gives a
   *! transformation from the design space of the font (in this space,
   *! the em-square is 1 unit by 1 unit) to user space.  Normally, a
   *! simple scale is used (see @[set_font_size()]), but a more
   *! complex font matrix can be used to shear the font or stretch it
   *! unequally along the two axes
   *!
   *! @param matrix
   *!   a @[Matrix] describing a transform to be applied to the current
   *!   font.
   */
  PIKEFUN void set_font_matrix(Matrix matrix)
    get_all_args;
  {
    cairo_matrix_t m;
    if (!matrix_from_object(matrix, &m))
      SIMPLE_ARG_TYPE_ERROR("set_font_matrix", 1, "Cairo.Matrix");
    cairo_set_font_matrix(THIS->cr, &m);
    RETURN;
  }

  /*! @decl Matrix get_font_matrix()
   *!
   *! Returns the current font matrix.  See @[set_font_matrix()].
   *!
   *! @returns
   *!   the matrix
   */
  PIKEFUN Matrix get_font_matrix()
  {
    cairo_matrix_t matrix;
    cairo_get_font_matrix(THIS->cr, &matrix);
    RETURN matrix_to_object(&matrix);
  }

  /*! @decl void set_font_options(FontOptions options)
   *!
   *! Sets a set of custom font rendering options for the @[Context].
   *! Rendering options are derived by merging these options with the
   *! options derived from underlying surface; if the value in options
   *! has a default value (like @[ANTIALIAS_DEFAULT]), then the value
   *! from the surface is used.
   *!
   *! @param options
   *!   font options to use
   */
  PIKEFUN void set_font_options(FontOptions options)
    get_all_args
  {
    struct Cairo_FontOptions_struct *opt;
    if (!(opt = get_storage(options, Cairo_FontOptions_program)))
      SIMPLE_ARG_TYPE_ERROR("set_font_options", 1, "Cairo.FontOptions");
    cairo_set_font_options(THIS->cr, opt->options);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void get_font_options(FontOptions options)
   *!
   *! Retrieves font rendering options set via
   *! @[set_font_options()]. Note that the returned options do not
   *! include any options derived from the underlying surface; they
   *! are literally the options passed to @[set_font_options()].
   *!
   *! @param options
   *!   a @[FontOptions] object into which to store the retrieved
   *!   options.  All existing values are overwritten
   */
  PIKEFUN void get_font_options(FontOptions options)
    get_all_args
  {
    struct Cairo_FontOptions_struct *opt;
    if (!(opt = get_storage(options, Cairo_FontOptions_program)))
      SIMPLE_ARG_TYPE_ERROR("get_font_options", 1, "Cairo.FontOptions");
    cairo_get_font_options(THIS->cr, opt->options);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void set_font_face(FontFace|zero font_face)
   *!
   *! Replaces the current @[FontFace] object in the @[Context] with
   *! font_face.
   *!
   *! @param font_face
   *!   a @[FontFace], or @expr{0@} to restore to the default font
   */
  PIKEFUN void set_font_face(FontFace|zero font_face)
    get_all_args;
  {
    cairo_font_face_t *fff = NULL;
    if (font_face) {
      struct Cairo_FontFace_struct *ff;
      if (!(ff = get_storage(font_face, Cairo_FontFace_program)))
        SIMPLE_ARG_TYPE_ERROR("set_font_face", 1, "Cairo.FontFace");
      fff = ff->font_face;
    }
    cairo_set_font_face(THIS->cr, fff);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl FontFace get_font_face()
   *!
   *! Gets the current font face for a @[Context].
   *!
   *! @returns
   *!   the current font face
   */
  PIKEFUN FontFace get_font_face()
  {
    cairo_font_face_t *font_face = cairo_get_font_face(THIS->cr);
    check_status(cairo_font_face_status(font_face));
    RETURN ref_font_face_to_object(font_face);
  }

  /*! @decl void show_text(string|zero text)
   *!
   *! A drawing operator that generates the shape from a string of
   *! characters, rendered according to the current font_face,
   *! font_size (font_matrix), and font_options.
   *!
   *! This function first computes a set of glyphs for the string of
   *! text.  The first glyph is placed so that its origin is at the
   *! current point.  The origin of each subsequent glyph is offset
   *! from that of the previous glyph by the advance values of the
   *! previous glyph.
   *!
   *! After this call the current point is moved to the origin of
   *! where the next glyph would be placed in this same progression.
   *! That is, the current point will be at the origin of the final
   *! glyph offset by its advance values.  This allows for easy
   *! display of a single logical string with multiple calls to
   *! @[show_text()].
   *!
   *! @note
   *! The @[show_text()] function call is part of what the cairo
   *! designers call the "toy" text API.  It is convenient for short
   *! demos and simple programs, but it is not expected to be adequate
   *! for serious text-using applications.  See @[show_glyphs()] for
   *! the "real" text display API in cairo.
   *!
   *! @param text
   *!   a string of text, or @expr{0@}
   */
  PIKEFUN void show_text(string|zero text)
    get_all_args;
  {
    const char *utf8 = NULL;
    if (text) {
      f_string_to_utf8(1);
      text = Pike_sp[-1].u.string;
      utf8 = (const char *)STR0(text);
    }
    cairo_show_text(THIS->cr, utf8);
    RETURN;
  }

  /*! @decl void show_glyphs(array(Glyph|array(int|float)) glyphs)
   *!
   *! A drawing operator that generates the shape from an array of
   *! glyphs, rendered according to the current font face, font size
   *! (font matrix), and font options.
   *!
   *! @param glyphs
   *!   array of glyphs to show, with each glyph being represented
   *!   either as a @[Glypg] object or as an array of the following
   *!   format:
   *!   @array
   *!     @elem int 0
   *!       glyph index in the font. The exact interpretation of the
   *!       glyph index depends on the font technology being used.
   *!     @elem float|int 1
   *!       the offset in the X direction between the origin used for
   *!       drawing the string and the origin of this glyph
   *!     @elem float|int 2
   *!       the offset in the Y direction between the origin used for
   *!       drawing the string and the origin of this glyph
   *!   @endarray
   */
  PIKEFUN void show_glyphs(array(Glyph|array(int|float)) glyphs)
    get_all_args;
  {
    cairo_glyph_t *gglyphs = NULL;
    if (glyphs->size)
      gglyphs = parse_glyphs_arg(glyphs, "show_glyphs", args, 1);
    cairo_show_glyphs(THIS->cr, gglyphs, glyphs->size);
    if (gglyphs)
      free(gglyphs);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl array(float) font_extents()
   *!
   *! Gets the font extents for the currently selected font.
   *!
   *! @returns
   *!   an array which stores the retrieved extents:
   *!   @array
   *!     @elem float 0
   *!       ascent: the distance that the font extends above the
   *!       baseline.  Note that this is not always exactly equal to
   *!       the maximum of the extents of all the glyphs in the font,
   *!       but rather is picked to express the font designer's intent
   *!       as to how the font should align with elements above it.
   *!     @elem float 1
   *!       descent: the distance that the font extends below the
   *!       baseline.  This value is positive for typical fonts that
   *!       include portions below the baseline.  Note that this is
   *!       not always exactly equal to the maximum of the extents of
   *!       all the glyphs in the font, but rather is picked to
   *!       express the font designer's intent as to how the font
   *!       should align with elements below it.
   *!     @elem float 2
   *!       height: the recommended vertical distance between
   *!       baselines when setting consecutive lines of text with the
   *!       font.  This is greater than ascent + descent by a quantity
   *!       known as the line spacing or external leading.  When space
   *!       is at a premium, most fonts can be set with only a
   *!       distance of ascent + descent between lines.
   *!     @elem float 3
   *!       max_x_advance: the maximum distance in the X direction
   *!       that the origin is advanced for any glyph in the font.
   *!     @elem float 4
   *!       max_y_advance: the maximum distance in the Y direction
   *!       that the origin is advanced for any glyph in the font.
   *!       This will be zero for normal fonts used for horizontal
   *!       writing.  (The scripts of East Asia are sometimes written
   *!       vertically.)
   *!   @endarray
   */
  PIKEFUN array(float) font_extents()
  {
    cairo_font_extents_t extents;
    cairo_font_extents(THIS->cr, &extents);
    check_status(cairo_status(THIS->cr));
    push_font_extents(&extents);
  }

  /*! @decl TextExtents text_extents(string|zero text)
   *!
   *! Gets the extents for a string of text.  The extents describe a
   *! user-space rectangle that encloses the "inked" portion of the
   *! text, (as it would be drawn by @[show_text()]).  Additionally,
   *! the x_advance and y_advance values indicate the amount by which
   *! the current point would be advanced by @[show_text()].
   *!
   *! Note that whitespace characters do not directly contribute to
   *! the size of the rectangle (@[TextExtents->width] and
   *! @[TextExtents->height]).  They do contribute indirectly by
   *! changing the position of non-whitespace characters.  In
   *! particular, trailing whitespace characters are likely to not
   *! affect the size of the rectangle, though they will affect the
   *! x_advance and y_advance values.
   *!
   *! @param text
   *!   a string of text, or @expr{0@}
   *!
   *! @returns
   *!   a @[TextExtents] object which stores the results.
   */
  PIKEFUN TextExtents text_extents(string|zero text)
    get_all_args;
  {
    cairo_text_extents_t extents;
    const char *utf8 = NULL;
    if (text) {
      f_string_to_utf8(1);
      text = Pike_sp[-1].u.string;
      utf8 = (const char *)STR0(text);
    }
    cairo_text_extents(THIS->cr, utf8, &extents);
    check_status(cairo_status(THIS->cr));
    RETURN text_extents_to_obj(&extents);
  }

  /*! @decl TextExtents glyph_extents(array(Glyph|array(int|float)) glyphs)
   *!
   *! Gets the extents for an array of glyphs.  The extents describe a
   *! user-space rectangle that encloses the "inked" portion of the
   *! glyphs, (as they would be drawn by @[show_glyphs()].
   *! Additionally, the x_advance and y_advance values indicate the
   *! amount by which the current point would be advanced by
   *! @[show_glyphs()].
   *!
   *! Note that whitespace glyphs do not contribute to the size of the
   *! rectangle (@[TextExtents->width] and @[TextExtents->height]).
   *!
   *! @param glyphs
   *!   an array of glyph IDs with X and Y offsets, with each glyph
   *!   being represented either as a @[Glyph] object or as an array
   *!   having the following format:
   *!   @array
   *!     @elem int 0
   *!       glyph index in the font. The exact interpretation of the
   *!       glyph index depends on the font technology being used.
   *!     @elem float|int 1
   *!       the offset in the X direction between the origin used for
   *!       drawing the string and the origin of this glyph
   *!     @elem float|int 2
   *!       the offset in the Y direction between the origin used for
   *!       drawing the string and the origin of this glyph
   *!   @endarray
   *!
   *! @returns
   *!   a @[TextExtents] object which stores the results.
   */
  PIKEFUN TextExtents glyph_extents(array(Glyph|array(int|float)) glyphs)
    get_all_args;
  {
    cairo_text_extents_t extents;
    cairo_glyph_t *gglyphs = NULL;
    if (glyphs->size)
      gglyphs = parse_glyphs_arg(glyphs, "glyph_extents", args, 1);
    cairo_glyph_extents(THIS->cr, gglyphs, glyphs->size, &extents);
    if (gglyphs)
      free(gglyphs);
    check_status(cairo_status(THIS->cr));
    RETURN text_extents_to_obj(&extents);
  }

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  /*! @decl void set_scaled_font(ScaledFont scaled_font)
   *!
   *! Replaces the current font face, font matrix, and font options in
   *! the @[Context] with those of the @[ScaledFont].  Except for some
   *! translation, the current CTM of the @[Context] should be the
   *! same as that of the @[ScaledFont], which can be accessed using
   *! @[ScaledFont->get_ctm()].
   *!
   *! @param scaled_font
   *!   a @[ScaledFont]
   */
  PIKEFUN void set_scaled_font(ScaledFont scaled_font)
    get_all_args;
  {
    struct Cairo_ScaledFont_struct *sf;
    if (!(sf = get_storage(scaled_font, Cairo_ScaledFont_program)))
      SIMPLE_ARG_TYPE_ERROR("set_scaled_font", 1, "Cairo.ScaledFont");
    cairo_set_scaled_font(THIS->cr, sf->scaled_font);
    check_status(cairo_status(THIS->cr));
    RETURN;
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 4, 0)
  /*! @decl ScaledFont get_scaled_font()
   *!
   *! Gets the current scaled font for a @[Context].
   *!
   *! @returns
   *!   the current scaled font.
   */
  PIKEFUN ScaledFont get_scaled_font()
  {
    cairo_scaled_font_t *scaled_font = cairo_get_scaled_font(THIS->cr);
    check_status(cairo_scaled_font_status(scaled_font));
    RETURN ref_scaled_font_to_object(scaled_font);
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 8, 0)
  /*! @decl void show_text_glyphs(string text,                              @
   *!                             array(Glyph|array(int|float)) glyphs,     @
   *!                             array(TextCluster) clusters,              @
   *!                             int cluster_flags)
   *!
   *! This operation has rendering effects similar to @[show_glyphs()]
   *! but, if the target surface supports it, uses the provided text
   *! and cluster mapping to embed the text for the glyphs shown in
   *! the output.  If the target does not support the extended
   *! attributes, this function acts like the basic @[show_glyphs()]
   *! as if it had been passed @[glyphs].
   *!
   *! The mapping between text and glyphs is provided by an array of
   *! clusters.  Each cluster covers a number of text bytes and
   *! glyphs, and neighboring clusters cover neighboring areas of text
   *! and glyphs.  The clusters should collectively cover text and
   *! glyphs in entirety.
   *!
   *! The first cluster always covers bytes from the beginning of
   *! text.  If @[cluster_flags] do not have the flag
   *! @[TEXT_CLUSTER_FLAG_BACKWARD] set, the first cluster also
   *! covers the beginning of @[glyphs], otherwise it covers the end of
   *! the @[glyphs] array and following clusters move backward.
   *!
   *! See @[TextCluster] for constraints on valid clusters.
   *!
   *! @param text
   *!   a string of text
   *! @param glyphs
   *!   array of glyphs to show
   *! @param clusters
   *!   array of cluster mapping information
   *! @param cluster_flags
   *!   cluster mapping flags
   */
  PIKEFUN void show_text_glyphs(string text,
                                array(Glyph|array(int|float)) glyphs,
                                array(TextCluster) clusters, int cluster_flags)
    get_all_args;
  {
    const char *utf8;
    int utf8_len;
    cairo_glyph_t *gglyphs = NULL;
    cairo_text_cluster_t *cclusters = NULL;
    ONERROR onerror_glyph;
    ONERROR onerror_cluster;
    if (glyphs->size)
      gglyphs = parse_glyphs_arg(glyphs, "show_text_glyphs", args, 2);
    SET_ONERROR(onerror_glyph, free, gglyphs);
    if (clusters->size)
      cclusters = parse_text_clusters_arg(clusters, "show_text_glyphs", args, 3);
    SET_ONERROR(onerror_cluster, free, cclusters);
    ref_push_string(text);
    f_string_to_utf8(1);
    text = Pike_sp[-1].u.string;
    utf8 = (const char *)STR0(text);
    utf8_len = text->len;
    cairo_show_text_glyphs(THIS->cr, utf8, utf8_len,
                           gglyphs, glyphs->size,
                           cclusters, clusters->size, cluster_flags);
    CALL_AND_UNSET_ONERROR(onerror_cluster);
    CALL_AND_UNSET_ONERROR(onerror_glyph);
    pop_stack();
    check_status(cairo_status(THIS->cr));
    RETURN;
  }
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
  /*! @decl void tag_begin(string tag_name, string|void attributes)
   *!
   *! Marks the beginning of the @[tag_name] structure.  Call
   *! @[ddtag_end()] with the same @[tag_name] to mark the end of the
   *! structure.
   *!
   *! The attributes string is of the form "key1=value2 key2=value2
   *! ...".  Values may be boolean (true/false or 1/0), integer,
   *! float, string, or an array.
   *!
   *! String values are enclosed in single quotes ('). Single quotes
   *! and backslashes inside the string should be escaped with a
   *! backslash.
   *!
   *! Boolean values may be set to true by only specifying the key.
   *! eg the attribute string "key" is the equivalent to "key=true".
   *!
   *! Arrays are enclosed in '[]'.  eg "rect=[1.2 4.3 2.0 3.0]".
   *!
   *! If no attributes are required, attributes can be an empty string
   *! or omitted.
   *!
   *! @seealso
   *!   @[tag_end()]
   *!
   *! @param tag_name
   *!   tag name
   *! @param attributes
   *!   tag attributes
   */
  PIKEFUN void tag_begin(string tag_name, string|void attributes)
    get_all_args;
  {
    ref_push_string(tag_name);
    f_string_to_utf8(1);
    tag_name = Pike_sp[-1].u.string;
    if (attributes) {
      ref_push_string(attributes);
      f_string_to_utf8(1);
      attributes = Pike_sp[-1].u.string;
    }
    cairo_tag_begin(THIS->cr, (const char *)STR0(tag_name),
                    (attributes? (const char *)STR0(attributes) : NULL));
    if (attributes)
      pop_stack();
    pop_stack();
    check_status(cairo_status(THIS->cr));
    RETURN;
  }

  /*! @decl void tag_end(string tag_name)
   *!
   *! Marks the end of the @[tag_name] structure.
   *!
   *! @seealso
   *!   @[tag_begin()].
   *!
   *! @param tag_name
   *!   tag name
   */
  PIKEFUN void tag_end(string tag_name)
    get_all_args;
  {
    ref_push_string(tag_name);
    f_string_to_utf8(1);
    tag_name = Pike_sp[-1].u.string;
    cairo_tag_end(THIS->cr, (const char *)STR0(tag_name));
    pop_stack();
    check_status(cairo_status(THIS->cr));
    RETURN;
  }
#endif

#ifdef PIKE_NULL_IS_SPECIAL
  INIT {
    THIS->cr = NULL;
  }
#endif

  EXIT
    gc_trivial;
  {
    if (THIS->cr)
      cairo_destroy(THIS->cr);
  }
}
/*! @endclass */

/*! @decl int cairo_version()
 *!
 *! Returns the version of the cairo library encoded in a single integer
 *!
 *! @seealso
 *!   @[cairo_version_string()]
 */
PIKEFUN int cairo_version()
{
  RETURN cairo_version();
}

/*! @decl string cairo_version_string()
 *!
 *! Returns the version of the cairo library as a human-readable string
 *!
 *! @seealso
 *!   @[cairo_version()]
 */
PIKEFUN string cairo_version_string()
{
  push_text(cairo_version_string());
}

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 6, 0)
/*! @decl int stride_for_width(int format, int width)
 *!
 *! This function provides a stride value that will respect all
 *! alignment requirements of the accelerated image-rendering code
 *! within cairo.
 *!
 *! @param format
 *!   A cairo format
 *! @param width
 *!   The desired width of an image surface to be created.
 *!
 *! @returns
 *!  the appropriate stride to use given the desired format and width,
 *!  or -1 if either the format is invalid or the width too large.
 */
PIKEFUN int stride_for_width(int format, int width)
  get_all_args;
{
  RETURN cairo_format_stride_for_width(format, width);
}
#endif

/*! @decl constant int CAIRO_VERSION
 *! @decl constant int CAIRO_VERSION_MAJOR
 *! @decl constant int CAIRO_VERSION_MINOR
 *! @decl constant int CAIRO_VERSION_MICRO
 *! @decl constant string CAIRO_VERSION_STRING
 *!
 *! Compile-time version
 */

/*! @decl constant int STATUS_SUCCESS
 *! no error has occurred
 *!
 *! @decl constant int STATUS_NO_MEMORY
 *! out of memory
 *!
 *! @decl constant int STATUS_INVALID_RESTORE
 *! @[Context->restore()] called without matching @[Context->save()]
 *!
 *! @decl constant int STATUS_INVALID_POP_GROUP
 *! no saved group to pop, i.e. @[Context->pop_group()] without
 *! matching @[Context->push_group()]
 *!
 *! @decl constant int STATUS_NO_CURRENT_POINT
 *! no current point defined
 *!
 *! @decl constant int STATUS_INVALID_MATRIX
 *! invalid matrix (not invertible)
 *!
 *! @decl constant int STATUS_INVALID_STATUS
 *! invalid value for an input status
 *!
 *! @decl constant int STATUS_NULL_POINTER
 *! NULL pointer
 *!
 *! @decl constant int STATUS_INVALID_STRING
 *! input string not valid UTF-8
 *!
 *! @decl constant int STATUS_INVALID_PATH_DATA
 *! input path data not valid
 *!
 *! @decl constant int STATUS_READ_ERROR
 *! error while reading from input stream
 *!
 *! @decl constant int STATUS_WRITE_ERROR
 *! error while writing to output stream
 *!
 *! @decl constant int STATUS_SURFACE_FINISHED
 *! target surface has been finished
 *!
 *! @decl constant int STATUS_SURFACE_TYPE_MISMATCH
 *! the surface type is not appropriate for the operation
 *!
 *! @decl constant int STATUS_PATTERN_TYPE_MISMATCH
 *! the pattern type is not appropriate for the operation
 *!
 *! @decl constant int STATUS_INVALID_CONTENT
 *! invalid value for an input content
 *!
 *! @decl constant int STATUS_INVALID_FORMAT
 *! invalid value for an input format
 *!
 *! @decl constant int STATUS_INVALID_VISUAL
 *! invalid value for an input visual
 *!
 *! @decl constant int STATUS_FILE_NOT_FOUND
 *! file not found
 *!
 *! @decl constant int STATUS_INVALID_DASH
 *! invalid value for a dash setting
 */
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
/*! @decl constant int STATUS_INVALID_DSC_COMMENT
 *! invalid value for a DSC comment
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 4, 0)
/*! @decl constant int STATUS_INVALID_INDEX
 *! invalid index passed to getter
 *!
 *! @decl constant int STATUS_CLIP_NOT_REPRESENTABLE
 *! clip region not representable in desired format
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 6, 0)
/*! @decl constant int STATUS_TEMP_FILE_ERROR
 *! error creating or writing to a temporary file
 *!
 *! @decl constant int STATUS_INVALID_STRIDE
 *! invalid value for stride
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 8, 0)
/*! @decl constant int STATUS_FONT_TYPE_MISMATCH
 *! the font type is not appropriate for the operation
 *!
 *! @decl constant int STATUS_USER_FONT_IMMUTABLE
 *! the user-font is immutable
 *!
 *! @decl constant int STATUS_USER_FONT_ERROR
 *! error occurred in a user-font callback function
 *!
 *! @decl constant int STATUS_NEGATIVE_COUNT
 *! negative number used where it is not allowed
 *!
 *! @decl constant int STATUS_INVALID_CLUSTERS
 *! input clusters do not represent the accompanying text and glyph array
 *!
 *! @decl constant int STATUS_INVALID_SLANT
 *! invalid value for an input slant
 *!
 *! @decl constant int STATUS_INVALID_WEIGHT
 *! invalid value for an input weight
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
/*! @decl constant int STATUS_INVALID_SIZE
 *! invalid value (typically too big) for the size of the input
 *! (surface, pattern, etc.)
 *!
 *! @decl constant int STATUS_USER_FONT_NOT_IMPLEMENTED
 *! user-font method not implemented
 *!
 *! @decl constant int STATUS_DEVICE_TYPE_MISMATCH
 *! the device type is not appropriate for the operation
 *!
 *! @decl constant int STATUS_DEVICE_ERROR
 *! an operation to the device caused an unspecified error
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
/*! @decl constant int STATUS_INVALID_MESH_CONSTRUCTION
 *! a mesh pattern construction operation was used outside of a
 *! @[MeshPattern->begin_patch()]/@[MeshPattern->end_patch()] pair
 *!
 *! @decl constant int STATUS_DEVICE_FINISHED
 *! target device has been finished
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 14, 0)
/*! @decl constant int STATUS_JBIG2_GLOBAL_MISSING
 *! @[MIME_TYPE_JBIG2_GLOBAL_ID] has been used on at least one image
 *! but no image provided @[MIME_TYPE_JBIG2_GLOBAL]
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
/*! @decl constant int STATUS_PNG_ERROR
 *! error occurred in libpng while reading from or writing to a PNG file
 *!
 *! @decl constant int STATUS_FREETYPE_ERROR
 *! error occurred in libfreetype
 *!
 *! @decl constant int STATUS_WIN32_GDI_ERROR
 *! error occurred in the Windows Graphics Device Interface
 *!
 *! @decl constant int STATUS_TAG_ERROR
 *! invalid tag name, attributes, or nesting
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
/*! @decl constant int STATUS_DWRITE_ERROR
 *! error occurred in the Windows Direct Write API
 *!
 *! @decl constant int STATUS_SVG_FONT_ERROR
 *! error occurred in OpenType-SVG font rendering
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
/*! @decl constant int STATUS_LAST_STATUS
 *! this is a special value indicating the number of status values
 *! defined in this enumeration.  When using this value, note that the
 *! version of cairo at run-time may have additional status values
 *! defined than the value of this symbol at compile-time.
 */
#endif

/*! @decl constant int ANTIALIAS_DEFAULT
 *! Use the default antialiasing for the subsystem and target device
 *!
 *! @decl constant int ANTIALIAS_NONE
 *! Use a bilevel alpha mask
 *!
 *! @decl constant int ANTIALIAS_GRAY
 *! Perform single-color antialiasing (using shades of gray for black
 *! text on a white background, for example)
 *!
 *! @decl constant int ANTIALIAS_SUBPIXEL
 *! Perform antialiasing by taking advantage of the order of subpixel
 *! elements on devices such as LCD panels
 */
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
/*! @decl constant int ANTIALIAS_FAST
 *! Hint that the backend should perform some antialiasing but prefer
 *! speed over quality
 *!
 *! @decl constant int ANTIALIAS_GOOD
 *! The backend should balance quality against performance
 *!
 *! @decl constant int ANTIALIAS_BEST
 *! Hint that the backend should render at the highest quality,
 *! sacrificing speed if necessary
 */
#endif

/*! @decl constant int FILL_RULE_WINDING
 *! If the path crosses the ray from left-to-right, counts +1.  If the
 *! path crosses the ray from right to left, counts -1.  (Left and
 *! right are determined from the perspective of looking along the ray
 *! from the starting point.)  If the total count is non-zero, the
 *! point will be filled.
 *!
 *! @decl constant int FILL_RULE_EVEN_ODD
 *! Counts the total number of intersections, without regard to the
 *! orientation of the contour.  If the total number of intersections
 *! is odd, the point will be filled.
 */

/*! @decl constant int LINE_CAP_BUTT
 *! start(stop) the line exactly at the start(end) point
 *!
 *! @decl constant int LINE_CAP_ROUND
 *! use a round ending, the center of the circle is the end point
 *!
 *! @decl constant int LINE_CAP_SQUARE
 *! use squared ending, the center of the square is the end point
 */

/*! @decl constant int LINE_JOIN_MITER
 *! use a sharp (angled) corner, see @[Context->set_miter_limit()]
 *!
 *! @decl constant int LINE_JOIN_ROUND
 *! use a rounded join, the center of the circle is the joint point
 *!
 *! @decl constant int LINE_JOIN_BEVEL
 *! use a cut-off join, the join is cut off at half the line width
 *! from the joint point
 */

/*! @decl constant int OPERATOR_CLEAR
 *! clear destination layer (bounded)
 *!
 *! @decl constant int OPERATOR_SOURCE
 *! replace destination layer (bounded)
 *!
 *! @decl constant int OPERATOR_OVER
 *! draw source layer on top of destination layer (bounded)
 *!
 *! @decl constant int OPERATOR_IN
 *! draw source where there was destination content (unbounded)
 *!
 *! @decl constant int OPERATOR_OUT
 *! draw source where there was no destination content (unbounded)
 *!
 *! @decl constant int OPERATOR_ATOP
 *! draw source on top of destination content and only there
 *!
 *! @decl constant int OPERATOR_DEST
 *! ignore the source
 *!
 *! @decl constant int OPERATOR_DEST_OVER
 *! draw destination on top of source
 *!
 *! @decl constant int OPERATOR_DEST_IN
 *! leave destination only where there was source content (unbounded)
 *!
 *! @decl constant int OPERATOR_DEST_OUT
 *! leave destination only where there was no source content
 *!
 *! @decl constant int OPERATOR_DEST_ATOP
 *! leave destination on top of source content and only there (unbounded)
 *!
 *! @decl constant int OPERATOR_XOR
 *! source and destination are shown where there is only one of them
 *!
 *! @decl constant int OPERATOR_ADD
 *! source and destination layers are accumulated
 *!
 *! @decl constant int OPERATOR_SATURATE
 *! like over, but assuming source and dest are disjoint geometries
 */
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
/*! @decl constant int OPERATOR_MULTIPLY
 *! source and destination layers are multiplied. This causes the
 *! result to be at least as dark as the darker inputs.
 *!
 *! @decl constant int OPERATOR_SCREEN
 *! source and destination are complemented and multiplied. This
 *! causes the result to be at least as light as the lighter
 *! inputs.
 *!
 *! @decl constant int OPERATOR_OVERLAY
 *! multiplies or screens, depending on the lightness of the
 *! destination color.
 *!
 *! @decl constant int OPERATOR_DARKEN
 *! replaces the destination with the source if it is darker,
 *! otherwise keeps the source.
 *!
 *! @decl constant int OPERATOR_LIGHTEN
 *! replaces the destination with the source if it is lighter,
 *! otherwise keeps the source.
 *!
 *! @decl constant int OPERATOR_COLOR_DODGE
 *! brightens the destination color to reflect the source color.
 *!
 *! @decl constant int OPERATOR_COLOR_BURN
 *! darkens the destination color to reflect the source color.
 *!
 *! @decl constant int OPERATOR_HARD_LIGHT
 *! Multiplies or screens, dependent on source color.
 *!
 *! @decl constant int OPERATOR_SOFT_LIGHT
 *! Darkens or lightens, dependent on source color.
 *!
 *! @decl constant int OPERATOR_DIFFERENCE
 *! Takes the difference of the source and destination color.
 *!
 *! @decl constant int OPERATOR_EXCLUSION
 *! Produces an effect similar to difference, but with lower contrast.
 *!
 *! @decl constant int OPERATOR_HSL_HUE
 *! Creates a color with the hue of the source and the saturation and
 *! luminosity of the target.
 *!
 *! @decl constant int OPERATOR_HSL_SATURATION
 *! Creates a color with the saturation of the source and the hue and
 *! luminosity of the target. Painting with this mode onto a gray area
 *! produces no change.
 *!
 *! @decl constant int OPERATOR_HSL_COLOR
 *! Creates a color with the hue and saturation of the source and the
 *! luminosity of the target. This preserves the gray levels of the
 *! target and is useful for coloring monochrome images or tinting
 *! color images.
 *!
 *! @decl constant int OPERATOR_HSL_LUMINOSITY
 *! Creates a color with the luminosity of the source and the hue and
 *! saturation of the target. This produces an inverse effect to
 *! @[OPERATOR_HSL_COLOR].
 */
#endif

/*! @decl constant int PATH_MOVE_TO
 *! A move-to operation
 *!
 *! @decl constant int PATH_LINE_TO
 *! A line-to operation
 *!
 *! @decl constant int PATH_CURVE_TO
 *! A curve-to operation
 *!
 *! @decl constant int PATH_CLOSE_PATH
 *! A close-path operation
 */

/*! @decl constant int EXTEND_NONE
 *! pixels outside of the source pattern are fully transparent
 *!
 *! @decl constant int EXTEND_REPEAT
 *! the pattern is tiled by repeating
 *!
 *! @decl constant int EXTEND_REFLECT
 *! the pattern is tiled by reflecting at the edges
 */
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
/*! @decl constant int EXTEND_PAD
 *! pixels outside of the pattern copy the closest pixel from the source
 */
#endif

/*! @decl constant int FILTER_FAST
 *! A high-performance filter, with quality similar to @[FILTER_NEAREST]
 *!
 *! @decl constant int FILTER_GOOD
 *! A reasonable-performance filter, with quality similar to
 *! @[FILTER_BILINEAR]
 *!
 *! @decl constant int FILTER_BEST
 *! The highest-quality available, performance may not be suitable for
 *! interactive use.
 *!
 *! @decl constant int FILTER_NEAREST
 *! Nearest-neighbor filtering
 *!
 *! @decl constant int FILTER_BILINEAR
 *! Linear interpolation in two dimensions
 *!
 *! @decl constant int FILTER_GAUSSIAN
 *! This filter value is currently unimplemented, and should not be
 *! used in current code.
 */

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
/*! @decl constant int DITHER_NONE
 *! No dithering.
 *!
 *! @decl constant int DITHER_DEFAULT
 *! Default choice at cairo compile time.  Currently @[DITHER_NONE].
 *!
 *! @decl constant int DITHER_FAST
 *! Fastest dithering algorithm supported by the backend
 *!
 *! @decl constant int DITHER_GOOD
 *! An algorithm with smoother dithering than @[DITHER_FAST]
 *!
 *! @decl constant int DITHER_BEST
 *! Best algorithm available in the backend
 */
#endif

/*! @decl constant int FONT_SLANT_NORMAL
 *! Upright font style
 *!
 *! @decl constant int FONT_SLANT_ITALIC
 *! Italic font style
 *!
 *! @decl constant int FONT_SLANT_OBLIQUE
 *! Oblique font style
 */

/*! @decl constant int FONT_WEIGHT_NORMAL
 *! Normal font weight
 *!
 *! @decl constant int FONT_WEIGHT_BOLD
 *! Bold font weight
 */

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 8, 0)
/*! @decl constant int TEXT_CLUSTER_FLAG_BACKWARD
 *!
 *! The clusters in the cluster array map to glyphs in the glyph array
 *! from end to start.
 */
#endif

/*! @decl constant int SUBPIXEL_ORDER_DEFAULT
 *! Use the default subpixel order for for the target device
 *!
 *! @decl constant int SUBPIXEL_ORDER_RGB
 *! Subpixel elements are arranged horizontally with red at the left
 *!
 *! @decl constant int SUBPIXEL_ORDER_BGR
 *! Subpixel elements are arranged horizontally with blue at the left
 *!
 *! @decl constant int SUBPIXEL_ORDER_VRGB
 *! Subpixel elements are arranged vertically with red at the top
 *!
 *! @decl constant int SUBPIXEL_ORDER_VBGR
 *! Subpixel elements are arranged vertically with blue at the top
 */

/*! @decl constant int HINT_STYLE_DEFAULT
 *! Use the default hint style for font backend and target device
 *!
 *! @decl constant int HINT_STYLE_NONE
 *! Do not hint outlines
 *!
 *! @decl constant int HINT_STYLE_SLIGHT
 *! Hint outlines slightly to improve contrast while retaining good
 *! fidelity to the original shapes
 *!
 *! @decl constant int HINT_STYLE_MEDIUM
 *! Hint outlines with medium strength giving a compromise between
 *! fidelity to the original shapes and contrast
 *!
 *! @decl constant int HINT_STYLE_FULL
 *! Hint outlines to maximize contrast
 */

/*! @decl constant int HINT_METRICS_DEFAULT
 *! Hint metrics in the default manner for the font backend and target
 *! device
 *!
 *! @decl constant int HINT_METRICS_OFF
 *! Do not hint font metrics
 *!
 *! @decl constant int HINT_METRICS_ON
 *! Hint font metrics
 */

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
/*! @decl constant int COLOR_MODE_DEFAULT
 *! Use the default color mode for font backend and target device
 *!
 *! @decl constant int COLOR_MODE_NO_COLOR
 *! Disable rendering color glyphs.  Glyphs are always rendered as
 *! outline glyphs.
 *!
 *! @decl constant int COLOR_MODE_COLOR
 *! Enable rendering color glyphs.  If the font contains a color
 *! presentation for a glyph, and when supported by the font backend,
 *! the glyph will be rendered in color.
 */

/*! @decl constant int COLOR_PALETTE_DEFAULT
 *! The default color palette index.
 */
#endif


#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
/*! @decl constant string MIME_TYPE_JP2
 *! The Joint Photographic Experts Group (JPEG) 2000 image coding
 *! standard (ISO/IEC 15444-1).
 *!
 *! @decl constant string MIME_TYPE_JPEG
 *! The Joint Photographic Experts Group (JPEG) image coding standard
 *! (ISO/IEC 10918-1).
 *!
 *! @decl constant string MIME_TYPE_PNG
 *! The Portable Network Graphics image file format (ISO/IEC 15948).
 *!
 *! @decl constant string MIME_TYPE_URI
 *! URI for an image file (unofficial MIME type).
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
/*! @decl constant string MIME_TYPE_UNIQUE_ID
 *! Unique identifier for a surface (cairo specific MIME type).  All
 *! surfaces with the same unique identifier will only be embedded
 *! once.
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 14, 0)
/*! @decl constant string MIME_TYPE_JBIG2
 *! Joint Bi-level Image Experts Group image coding standard (ISO/IEC
 *! 11544).
 *!
 *! @decl constant string MIME_TYPE_JBIG2_GLOBAL
 *! Joint Bi-level Image Experts Group image coding standard (ISO/IEC
 *! 11544) global segment.
 *!
 *! @decl constant string MIME_TYPE_JBIG2_GLOBAL_ID
 *! An unique identifier shared by a JBIG2 global segment and all
 *! JBIG2 images that depend on the global segment.
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
/*! @decl constant string MIME_TYPE_CCITT_FAX
 *! Group 3 or Group 4 CCITT facsimile encoding (International
 *! Telecommunication Union, Recommendations T.4 and T.6.)
 *!
 *! @decl constant string MIME_TYPE_CCITT_FAX_PARAMS
 *! Decode parameters for Group 3 or Group 4 CCITT facsimile
 *! encoding. See CCITT Fax Images.
 *!
 *! @decl constant string MIME_TYPE_EPS
 *! Encapsulated PostScript file. Encapsulated PostScript File Format
 *! Specification
 *!
 *! @decl constant string MIME_TYPE_EPS_PARAMS
 *! Embedding parameters Encapsulated PostScript data. See Embedding
 *! EPS files.
 */
#endif

/*! @decl constant int CONTENT_COLOR
 *! The surface will hold color content only.
 *!
 *! @decl constant int CONTENT_ALPHA
 *! The surface will hold alpha content only.
 *!
 *! @decl constant int CONTENT_COLOR_ALPHA
 *! The surface will hold color and alpha content.
 */

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 9, 8)
/*! @decl constant int FORMAT_INVALID
 *! no such format exists or is supported.
 */
#endif
/*! @decl constant int FORMAT_ARGB32
 *! each pixel is a 32-bit quantity, with alpha in the upper 8 bits,
 *! then red, then green, then blue.  The 32-bit quantities are stored
 *! native-endian.  Pre-multiplied alpha is used.  (That is, 50%
 *! transparent red is 0x80800000, not 0x80ff0000.)
 *!
 *! @decl constant int FORMAT_RGB24
 *! each pixel is a 32-bit quantity, with the upper 8 bits
 *! unused.  Red, Green, and Blue are stored in the remaining 24 bits
 *! in that order.
 *!
 *! @decl constant int FORMAT_A8
 *! each pixel is a 8-bit quantity holding an alpha value.
 *!
 *! @decl constant int FORMAT_A1
 *! each pixel is a 1-bit quantity holding an alpha value.  Pixels are
 *! packed together into 32-bit quantities.  The ordering of the bits
 *! matches the endianness of the platform.  On a big-endian machine,
 *! the first pixel is in the uppermost bit, on a little-endian
 *! machine the first pixel is in the least-significant bit.
 */

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
/*! @decl constant int FORMAT_RGB16_565
 *! each pixel is a 16-bit quantity with red in the upper 5 bits, then
 *! green in the middle 6 bits, and blue in the lower 5 bits.
 */
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
/*! @decl constant int FORMAT_RGB30
 *! like RGB24 but with 10bpc.
 */
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 17, 2)
/*! @decl constant int FORMAT_RGB96F
 *! 3 floats, R, G, B.
 *!
 *! @decl constant int FORMAT_RGBA128F
 *! 4 floats, R, G, B, A.
 */
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
/*! @decl constant string TAG_DEST
 *! Create a destination for a hyperlink.
 *!
 *! @decl constant string TAG_LINK
 *! Create hyperlink.
 */
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
/*! @decl constant string TAG_CONTENT
 *! Create a content tag.
 *!
 *! @decl constant string TAG_CONTENT_REF
 *! Create a content reference tag.
 */
#endif
#endif

#ifdef CAIRO_HAS_PDF_SURFACE
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
/*! @decl constant int PDF_VERSION_1_4
 *! The version 1.4 of the PDF specification.
 *!
 *! @decl constant int PDF_VERSION_1_5
 *! The version 1.5 of the PDF specification.
 */
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
/*! @decl constant int PDF_VERSION_1_6
 *! The version 1.6 of the PDF specification.
 *!
 *! @decl constant int PDF_VERSION_1_7
 *! The version 1.7 of the PDF specification.
 */
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
/*! @decl constant int PDF_OUTLINE_ROOT
 *! The root outline item in @[PDFSurface->add_outline()].
 */

/*! @decl constant int PDF_OUTLINE_FLAG_OPEN
 *! The outline item defaults to open in the PDF viewer
 *!
 *! @decl constant int PDF_OUTLINE_FLAG_BOLD
 *! The outline item is displayed by the viewer in bold text
 *!
 *! @decl constant int PDF_OUTLINE_FLAG_ITALIC
 *! The outline item is displayed by the viewer in italic text
 */

/*! @decl constant int PDF_METADATA_TITLE
 *! The document title
 *!
 *! @decl constant int PDF_METADATA_AUTHOR
 *! The document author
 *!
 *! @decl constant int PDF_METADATA_SUBJECT
 *! The document subject
 *!
 *! @decl constant int PDF_METADATA_KEYWORDS
 *! The document keywords
 *!
 *! @decl constant int PDF_METADATA_CREATOR
 *! The document creator
 *!
 *! @decl constant int PDF_METADATA_CREATE_DATE
 *! The document creation date
 *!
 *! @decl constant int PDF_METADATA_MOD_DATE
 *! The document modification date
 */
#endif
#endif

#ifdef CAIRO_HAS_PS_SURFACE
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 6, 0)
/*! @decl constant int PS_LEVEL_2
 *! The language level 2 of the PostScript specification.
 *!
 *! @decl constant int PS_LEVEL_3
 *! The language level 3 of the PostScript specification.
 */
#endif
#endif

#ifdef CAIRO_HAS_SVG_SURFACE
/*! @decl constant int SVG_VERSION_1_1
 *! The version 1.1 of the SVG specification.
 *!
 *! @decl constant int SVG_VERSION_1_2
 *! The version 1.2 of the SVG specification.
 */

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
/*! @decl constant int SVG_UNIT_USER
 *! User unit, a value in the current coordinate system.  If used in
 *! the root element for the initial coordinate systems it corresponds
 *! to pixels.
 *!
 *! @decl constant int SVG_UNIT_EM
 *! The size of the element's font.
 *!
 *! @decl constant int SVG_UNIT_EX
 *!  The x-height of the element’s font.
 *!
 *! @decl constant int SVG_UNIT_PX
 *!  Pixels (1px = 1/96th of 1in).
 *!
 *! @decl constant int SVG_UNIT_IN
 *!  Inches (1in = 2.54cm = 96px).
 *!
 *! @decl constant int SVG_UNIT_CM
 *!  Centimeters (1cm = 96px/2.54).
 *!
 *! @decl constant int SVG_UNIT_MM
 *!  Millimeters (1mm = 1/10th of 1cm).
 *!
 *! @decl constant int SVG_UNIT_PT
 *!  Points (1pt = 1/72th of 1in).
 *!
 *! @decl constant int SVG_UNIT_PC
 *!  Picas (1pc = 1/6th of 1in).
 *!
 *! @decl constant int SVG_UNIT_PERCENT
 *!  Percent, a value that is some fraction of another reference
 *!  value.
 */
#endif
#endif

#ifdef CAIRO_HAS_SCRIPT_SURFACE
/*! @decl constant int SCRIPT_MODE_ASCII
 *! the output will be in readable text (default).
 *!
 *! @decl constant int SCRIPT_MODE_BINARY
 *! the output will use byte codes.
 */
#endif

/*! @endmodule */

#endif /* HAVE_CAIRO */

PIKE_MODULE_INIT
{
  INIT;

#ifdef HAVE_CAIRO

#ifdef DYNAMIC_MODULE
  image_program = PIKE_MODULE_IMPORT(Image, image_program);
  image_layer_program = PIKE_MODULE_IMPORT(Image, image_layer_program);
  if(!image_program || !image_layer_program)
    Pike_error("Could not load Image module.\n");
#endif

  add_integer_constant("CAIRO_VERSION", CAIRO_VERSION, 0);
  add_integer_constant("CAIRO_VERSION_MAJOR", CAIRO_VERSION_MAJOR, 0);
  add_integer_constant("CAIRO_VERSION_MINOR", CAIRO_VERSION_MINOR, 0);
  add_integer_constant("CAIRO_VERSION_MICRO", CAIRO_VERSION_MICRO, 0);
  add_string_constant("CAIRO_VERSION_STRING", CAIRO_VERSION_STRING, 0);

  add_integer_constant("STATUS_SUCCESS", CAIRO_STATUS_SUCCESS, 0);
  add_integer_constant("STATUS_NO_MEMORY", CAIRO_STATUS_NO_MEMORY, 0);
  add_integer_constant("STATUS_INVALID_RESTORE", CAIRO_STATUS_INVALID_RESTORE, 0);
  add_integer_constant("STATUS_INVALID_POP_GROUP", CAIRO_STATUS_INVALID_POP_GROUP, 0);
  add_integer_constant("STATUS_NO_CURRENT_POINT", CAIRO_STATUS_NO_CURRENT_POINT, 0);
  add_integer_constant("STATUS_INVALID_MATRIX", CAIRO_STATUS_INVALID_MATRIX, 0);
  add_integer_constant("STATUS_INVALID_STATUS", CAIRO_STATUS_INVALID_STATUS, 0);
  add_integer_constant("STATUS_NULL_POINTER", CAIRO_STATUS_NULL_POINTER, 0);
  add_integer_constant("STATUS_INVALID_STRING", CAIRO_STATUS_INVALID_STRING, 0);
  add_integer_constant("STATUS_INVALID_PATH_DATA", CAIRO_STATUS_INVALID_PATH_DATA, 0);
  add_integer_constant("STATUS_READ_ERROR", CAIRO_STATUS_READ_ERROR, 0);
  add_integer_constant("STATUS_WRITE_ERROR", CAIRO_STATUS_WRITE_ERROR, 0);
  add_integer_constant("STATUS_SURFACE_FINISHED", CAIRO_STATUS_SURFACE_FINISHED, 0);
  add_integer_constant("STATUS_SURFACE_TYPE_MISMATCH", CAIRO_STATUS_SURFACE_TYPE_MISMATCH, 0);
  add_integer_constant("STATUS_PATTERN_TYPE_MISMATCH", CAIRO_STATUS_PATTERN_TYPE_MISMATCH, 0);
  add_integer_constant("STATUS_INVALID_CONTENT", CAIRO_STATUS_INVALID_CONTENT, 0);
  add_integer_constant("STATUS_INVALID_FORMAT", CAIRO_STATUS_INVALID_FORMAT, 0);
  add_integer_constant("STATUS_INVALID_VISUAL", CAIRO_STATUS_INVALID_VISUAL, 0);
  add_integer_constant("STATUS_FILE_NOT_FOUND", CAIRO_STATUS_FILE_NOT_FOUND, 0);
  add_integer_constant("STATUS_INVALID_DASH", CAIRO_STATUS_INVALID_DASH, 0);
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  add_integer_constant("STATUS_INVALID_DSC_COMMENT", CAIRO_STATUS_INVALID_DSC_COMMENT, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 4, 0)
  add_integer_constant("STATUS_INVALID_INDEX", CAIRO_STATUS_INVALID_INDEX, 0);
  add_integer_constant("STATUS_CLIP_NOT_REPRESENTABLE", CAIRO_STATUS_CLIP_NOT_REPRESENTABLE, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 6, 0)
  add_integer_constant("STATUS_TEMP_FILE_ERROR", CAIRO_STATUS_TEMP_FILE_ERROR, 0);
  add_integer_constant("STATUS_INVALID_STRIDE", CAIRO_STATUS_INVALID_STRIDE, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 8, 0)
  add_integer_constant("STATUS_FONT_TYPE_MISMATCH", CAIRO_STATUS_FONT_TYPE_MISMATCH, 0);
  add_integer_constant("STATUS_USER_FONT_IMMUTABLE", CAIRO_STATUS_USER_FONT_IMMUTABLE, 0);
  add_integer_constant("STATUS_USER_FONT_ERROR", CAIRO_STATUS_USER_FONT_ERROR, 0);
  add_integer_constant("STATUS_NEGATIVE_COUNT", CAIRO_STATUS_NEGATIVE_COUNT, 0);
  add_integer_constant("STATUS_INVALID_CLUSTERS", CAIRO_STATUS_INVALID_CLUSTERS, 0);
  add_integer_constant("STATUS_INVALID_SLANT", CAIRO_STATUS_INVALID_SLANT, 0);
  add_integer_constant("STATUS_INVALID_WEIGHT", CAIRO_STATUS_INVALID_WEIGHT, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
  add_integer_constant("STATUS_INVALID_SIZE", CAIRO_STATUS_INVALID_SIZE, 0);
  add_integer_constant("STATUS_USER_FONT_NOT_IMPLEMENTED", CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, 0);
  add_integer_constant("STATUS_DEVICE_TYPE_MISMATCH", CAIRO_STATUS_DEVICE_TYPE_MISMATCH, 0);
  add_integer_constant("STATUS_DEVICE_ERROR", CAIRO_STATUS_DEVICE_ERROR, 0);
  add_integer_constant("STATUS_LAST_STATUS", CAIRO_STATUS_LAST_STATUS, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
  add_integer_constant("STATUS_INVALID_MESH_CONSTRUCTION", CAIRO_STATUS_INVALID_MESH_CONSTRUCTION, 0);
  add_integer_constant("STATUS_DEVICE_FINISHED", CAIRO_STATUS_DEVICE_FINISHED, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 14, 0)
  add_integer_constant("STATUS_JBIG2_GLOBAL_MISSING", CAIRO_STATUS_JBIG2_GLOBAL_MISSING, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
  add_integer_constant("STATUS_PNG_ERROR", CAIRO_STATUS_PNG_ERROR, 0);
  add_integer_constant("STATUS_FREETYPE_ERROR", CAIRO_STATUS_FREETYPE_ERROR, 0);
  add_integer_constant("STATUS_WIN32_GDI_ERROR", CAIRO_STATUS_WIN32_GDI_ERROR, 0);
  add_integer_constant("STATUS_TAG_ERROR", CAIRO_STATUS_TAG_ERROR, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
  add_integer_constant("STATUS_DWRITE_ERROR", CAIRO_STATUS_DWRITE_ERROR, 0);
  add_integer_constant("STATUS_SVG_FONT_ERROR", CAIRO_STATUS_SVG_FONT_ERROR, 0);
#endif

  add_integer_constant("ANTIALIAS_DEFAULT", CAIRO_ANTIALIAS_DEFAULT, 0);
  add_integer_constant("ANTIALIAS_NONE", CAIRO_ANTIALIAS_NONE, 0);
  add_integer_constant("ANTIALIAS_GRAY", CAIRO_ANTIALIAS_GRAY, 0);
  add_integer_constant("ANTIALIAS_SUBPIXEL", CAIRO_ANTIALIAS_SUBPIXEL, 0);
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
  add_integer_constant("ANTIALIAS_FAST", CAIRO_ANTIALIAS_FAST, 0);
  add_integer_constant("ANTIALIAS_GOOD", CAIRO_ANTIALIAS_GOOD, 0);
  add_integer_constant("ANTIALIAS_BEST", CAIRO_ANTIALIAS_BEST, 0);
#endif

  add_integer_constant("FILL_RULE_WINDING", CAIRO_FILL_RULE_WINDING, 0);
  add_integer_constant("FILL_RULE_EVEN_ODD", CAIRO_FILL_RULE_EVEN_ODD, 0);

  add_integer_constant("LINE_CAP_BUTT", CAIRO_LINE_CAP_BUTT, 0);
  add_integer_constant("LINE_CAP_ROUND", CAIRO_LINE_CAP_ROUND, 0);
  add_integer_constant("LINE_CAP_SQUARE", CAIRO_LINE_CAP_SQUARE, 0);

  add_integer_constant("LINE_JOIN_MITER", CAIRO_LINE_JOIN_MITER, 0);
  add_integer_constant("LINE_JOIN_ROUND", CAIRO_LINE_JOIN_ROUND, 0);
  add_integer_constant("LINE_JOIN_BEVEL", CAIRO_LINE_JOIN_BEVEL, 0);

  add_integer_constant("OPERATOR_CLEAR", CAIRO_OPERATOR_CLEAR, 0);
  add_integer_constant("OPERATOR_SOURCE", CAIRO_OPERATOR_SOURCE, 0);
  add_integer_constant("OPERATOR_OVER", CAIRO_OPERATOR_OVER, 0);
  add_integer_constant("OPERATOR_IN", CAIRO_OPERATOR_IN, 0);
  add_integer_constant("OPERATOR_OUT", CAIRO_OPERATOR_OUT, 0);
  add_integer_constant("OPERATOR_ATOP", CAIRO_OPERATOR_ATOP, 0);
  add_integer_constant("OPERATOR_DEST", CAIRO_OPERATOR_DEST, 0);
  add_integer_constant("OPERATOR_DEST_OVER", CAIRO_OPERATOR_DEST_OVER, 0);
  add_integer_constant("OPERATOR_DEST_IN", CAIRO_OPERATOR_DEST_IN, 0);
  add_integer_constant("OPERATOR_DEST_OUT", CAIRO_OPERATOR_DEST_OUT, 0);
  add_integer_constant("OPERATOR_DEST_ATOP", CAIRO_OPERATOR_DEST_ATOP, 0);
  add_integer_constant("OPERATOR_XOR", CAIRO_OPERATOR_XOR, 0);
  add_integer_constant("OPERATOR_ADD", CAIRO_OPERATOR_ADD, 0);
  add_integer_constant("OPERATOR_SATURATE", CAIRO_OPERATOR_SATURATE, 0);
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
  add_integer_constant("OPERATOR_MULTIPLY", CAIRO_OPERATOR_MULTIPLY, 0);
  add_integer_constant("OPERATOR_SCREEN", CAIRO_OPERATOR_SCREEN, 0);
  add_integer_constant("OPERATOR_OVERLAY", CAIRO_OPERATOR_OVERLAY, 0);
  add_integer_constant("OPERATOR_DARKEN", CAIRO_OPERATOR_DARKEN, 0);
  add_integer_constant("OPERATOR_LIGHTEN", CAIRO_OPERATOR_LIGHTEN, 0);
  add_integer_constant("OPERATOR_COLOR_DODGE", CAIRO_OPERATOR_COLOR_DODGE, 0);
  add_integer_constant("OPERATOR_COLOR_BURN", CAIRO_OPERATOR_COLOR_BURN, 0);
  add_integer_constant("OPERATOR_HARD_LIGHT", CAIRO_OPERATOR_HARD_LIGHT, 0);
  add_integer_constant("OPERATOR_SOFT_LIGHT", CAIRO_OPERATOR_SOFT_LIGHT, 0);
  add_integer_constant("OPERATOR_DIFFERENCE", CAIRO_OPERATOR_DIFFERENCE, 0);
  add_integer_constant("OPERATOR_EXCLUSION", CAIRO_OPERATOR_EXCLUSION, 0);
  add_integer_constant("OPERATOR_HSL_HUE", CAIRO_OPERATOR_HSL_HUE, 0);
  add_integer_constant("OPERATOR_HSL_SATURATION", CAIRO_OPERATOR_HSL_SATURATION, 0);
  add_integer_constant("OPERATOR_HSL_COLOR", CAIRO_OPERATOR_HSL_COLOR, 0);
  add_integer_constant("OPERATOR_HSL_LUMINOSITY", CAIRO_OPERATOR_HSL_LUMINOSITY, 0);
#endif

  add_integer_constant("PATH_MOVE_TO", CAIRO_PATH_MOVE_TO, 0);
  add_integer_constant("PATH_LINE_TO", CAIRO_PATH_LINE_TO, 0);
  add_integer_constant("PATH_CURVE_TO", CAIRO_PATH_CURVE_TO, 0);
  add_integer_constant("PATH_CLOSE_PATH", CAIRO_PATH_CLOSE_PATH, 0);

  add_integer_constant("EXTEND_NONE", CAIRO_EXTEND_NONE, 0);
  add_integer_constant("EXTEND_REPEAT", CAIRO_EXTEND_REPEAT, 0);
  add_integer_constant("EXTEND_REFLECT", CAIRO_EXTEND_REFLECT, 0);
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  add_integer_constant("EXTEND_PAD", CAIRO_EXTEND_PAD, 0);
#endif

  add_integer_constant("FILTER_FAST", CAIRO_FILTER_FAST, 0);
  add_integer_constant("FILTER_GOOD", CAIRO_FILTER_GOOD, 0);
  add_integer_constant("FILTER_BEST", CAIRO_FILTER_BEST, 0);
  add_integer_constant("FILTER_NEAREST", CAIRO_FILTER_NEAREST, 0);
  add_integer_constant("FILTER_BILINEAR", CAIRO_FILTER_BILINEAR, 0);
  add_integer_constant("FILTER_GAUSSIAN", CAIRO_FILTER_GAUSSIAN, 0);

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
  add_integer_constant("DITHER_NONE", CAIRO_DITHER_NONE, 0);
  add_integer_constant("DITHER_DEFAULT", CAIRO_DITHER_DEFAULT, 0);
  add_integer_constant("DITHER_FAST", CAIRO_DITHER_FAST, 0);
  add_integer_constant("DITHER_GOOD", CAIRO_DITHER_GOOD, 0);
  add_integer_constant("DITHER_BEST", CAIRO_DITHER_BEST, 0);
#endif

  add_integer_constant("FONT_SLANT_NORMAL", CAIRO_FONT_SLANT_NORMAL, 0);
  add_integer_constant("FONT_SLANT_ITALIC", CAIRO_FONT_SLANT_ITALIC, 0);
  add_integer_constant("FONT_SLANT_OBLIQUE", CAIRO_FONT_SLANT_OBLIQUE, 0);

  add_integer_constant("FONT_WEIGHT_NORMAL", CAIRO_FONT_WEIGHT_NORMAL, 0);
  add_integer_constant("FONT_WEIGHT_BOLD", CAIRO_FONT_WEIGHT_BOLD, 0);

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 8, 0)
  add_integer_constant("TEXT_CLUSTER_FLAG_BACKWARD", CAIRO_TEXT_CLUSTER_FLAG_BACKWARD, 0);
#endif

  add_integer_constant("SUBPIXEL_ORDER_DEFAULT", CAIRO_SUBPIXEL_ORDER_DEFAULT, 0);
  add_integer_constant("SUBPIXEL_ORDER_RGB", CAIRO_SUBPIXEL_ORDER_RGB, 0);
  add_integer_constant("SUBPIXEL_ORDER_BGR", CAIRO_SUBPIXEL_ORDER_BGR, 0);
  add_integer_constant("SUBPIXEL_ORDER_VRGB", CAIRO_SUBPIXEL_ORDER_VRGB, 0);
  add_integer_constant("SUBPIXEL_ORDER_VBGR", CAIRO_SUBPIXEL_ORDER_VBGR, 0);

  add_integer_constant("HINT_STYLE_DEFAULT", CAIRO_HINT_STYLE_DEFAULT, 0);
  add_integer_constant("HINT_STYLE_NONE", CAIRO_HINT_STYLE_NONE, 0);
  add_integer_constant("HINT_STYLE_SLIGHT", CAIRO_HINT_STYLE_SLIGHT, 0);
  add_integer_constant("HINT_STYLE_MEDIUM", CAIRO_HINT_STYLE_MEDIUM, 0);
  add_integer_constant("HINT_STYLE_FULL", CAIRO_HINT_STYLE_FULL, 0);

  add_integer_constant("HINT_METRICS_DEFAULT", CAIRO_HINT_METRICS_DEFAULT, 0);
  add_integer_constant("HINT_METRICS_OFF", CAIRO_HINT_METRICS_OFF, 0);
  add_integer_constant("HINT_METRICS_ON", CAIRO_HINT_METRICS_ON, 0);

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
  add_integer_constant("COLOR_MODE_DEFAULT", CAIRO_COLOR_MODE_DEFAULT, 0);
  add_integer_constant("COLOR_MODE_NO_COLOR", CAIRO_COLOR_MODE_NO_COLOR, 0);
  add_integer_constant("COLOR_MODE_COLOR", CAIRO_COLOR_MODE_COLOR, 0);

  add_integer_constant("COLOR_PALETTE_DEFAULT", CAIRO_COLOR_PALETTE_DEFAULT, 0);
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
  add_string_constant("MIME_TYPE_JP2", CAIRO_MIME_TYPE_JP2, 0);
  add_string_constant("MIME_TYPE_JPEG", CAIRO_MIME_TYPE_JPEG, 0);
  add_string_constant("MIME_TYPE_PNG", CAIRO_MIME_TYPE_PNG, 0);
  add_string_constant("MIME_TYPE_URI", CAIRO_MIME_TYPE_URI, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
  add_string_constant("MIME_TYPE_UNIQUE_ID", CAIRO_MIME_TYPE_UNIQUE_ID, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 14, 0)
  add_string_constant("MIME_TYPE_JBIG2", CAIRO_MIME_TYPE_JBIG2, 0);
  add_string_constant("MIME_TYPE_JBIG2_GLOBAL", CAIRO_MIME_TYPE_JBIG2_GLOBAL, 0);
  add_string_constant("MIME_TYPE_JBIG2_GLOBAL_ID", CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
  add_string_constant("MIME_TYPE_CCITT_FAX", CAIRO_MIME_TYPE_CCITT_FAX, 0);
  add_string_constant("MIME_TYPE_CCITT_FAX_PARAMS", CAIRO_MIME_TYPE_CCITT_FAX_PARAMS, 0);
  add_string_constant("MIME_TYPE_EPS", CAIRO_MIME_TYPE_EPS, 0);
  add_string_constant("MIME_TYPE_EPS_PARAMS", CAIRO_MIME_TYPE_EPS_PARAMS, 0);
#endif

  add_integer_constant("CONTENT_COLOR", CAIRO_CONTENT_COLOR, 0);
  add_integer_constant("CONTENT_ALPHA", CAIRO_CONTENT_ALPHA, 0);
  add_integer_constant("CONTENT_COLOR_ALPHA", CAIRO_CONTENT_COLOR_ALPHA, 0);

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 9, 8)
  add_integer_constant("FORMAT_INVALID", CAIRO_FORMAT_INVALID, 0);
#endif
  add_integer_constant("FORMAT_ARGB32", CAIRO_FORMAT_ARGB32, 0);
  add_integer_constant("FORMAT_RGB24", CAIRO_FORMAT_RGB24, 0);
  add_integer_constant("FORMAT_A8", CAIRO_FORMAT_A8, 0);
  add_integer_constant("FORMAT_A1", CAIRO_FORMAT_A1, 0);
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 2, 0)
  add_integer_constant("FORMAT_RGB16_565", CAIRO_FORMAT_RGB16_565, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 12, 0)
  add_integer_constant("FORMAT_RGB30", CAIRO_FORMAT_RGB30, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 17, 2)
  add_integer_constant("FORMAT_RGB96F", CAIRO_FORMAT_RGB96F, 0);
  add_integer_constant("FORMAT_RGBA128F", CAIRO_FORMAT_RGBA128F, 0);
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
  add_string_constant("TAG_DEST", CAIRO_TAG_DEST, 0);
  add_string_constant("TAG_LINK", CAIRO_TAG_LINK, 0);
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
  add_string_constant("TAG_CONTENT", CAIRO_TAG_CONTENT, 0);
  add_string_constant("TAG_CONTENT_REF", CAIRO_TAG_CONTENT_REF, 0);
#endif
#endif

#ifdef CAIRO_HAS_PDF_SURFACE
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 10, 0)
  add_integer_constant("PDF_VERSION_1_4", CAIRO_PDF_VERSION_1_4, 0);
  add_integer_constant("PDF_VERSION_1_5", CAIRO_PDF_VERSION_1_5, 0);
#endif
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 18, 0)
  add_integer_constant("PDF_VERSION_1_6", CAIRO_PDF_VERSION_1_6, 0);
  add_integer_constant("PDF_VERSION_1_7", CAIRO_PDF_VERSION_1_7, 0);
#endif

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
  add_integer_constant("PDF_OUTLINE_ROOT", CAIRO_PDF_OUTLINE_ROOT, 0);

  add_integer_constant("PDF_OUTLINE_FLAG_OPEN", CAIRO_PDF_OUTLINE_FLAG_OPEN, 0);
  add_integer_constant("PDF_OUTLINE_FLAG_BOLD", CAIRO_PDF_OUTLINE_FLAG_BOLD, 0);
  add_integer_constant("PDF_OUTLINE_FLAG_ITALIC", CAIRO_PDF_OUTLINE_FLAG_ITALIC, 0);

  add_integer_constant("PDF_METADATA_TITLE", CAIRO_PDF_METADATA_TITLE, 0);
  add_integer_constant("PDF_METADATA_AUTHOR", CAIRO_PDF_METADATA_AUTHOR, 0);
  add_integer_constant("PDF_METADATA_SUBJECT", CAIRO_PDF_METADATA_SUBJECT, 0);
  add_integer_constant("PDF_METADATA_KEYWORDS", CAIRO_PDF_METADATA_KEYWORDS, 0);
  add_integer_constant("PDF_METADATA_CREATOR", CAIRO_PDF_METADATA_CREATOR, 0);
  add_integer_constant("PDF_METADATA_CREATE_DATE", CAIRO_PDF_METADATA_CREATE_DATE, 0);
  add_integer_constant("PDF_METADATA_MOD_DATE", CAIRO_PDF_METADATA_MOD_DATE, 0);
#endif
#endif

#ifdef CAIRO_HAS_PS_SURFACE
#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 6, 0)
  add_integer_constant("PS_LEVEL_2", CAIRO_PS_LEVEL_2, 0);
  add_integer_constant("PS_LEVEL_3", CAIRO_PS_LEVEL_3, 0);
#endif
#endif

#ifdef CAIRO_HAS_SVG_SURFACE
  add_integer_constant("SVG_VERSION_1_1", CAIRO_SVG_VERSION_1_1, 0);
  add_integer_constant("SVG_VERSION_1_2", CAIRO_SVG_VERSION_1_2, 0);

#if CAIRO_VERSION >= CAIRO_VERSION_ENCODE(1, 16, 0)
  add_integer_constant("SVG_UNIT_USER", CAIRO_SVG_UNIT_USER, 0);
  add_integer_constant("SVG_UNIT_EM", CAIRO_SVG_UNIT_EM, 0);
  add_integer_constant("SVG_UNIT_EX", CAIRO_SVG_UNIT_EX, 0);
  add_integer_constant("SVG_UNIT_PX", CAIRO_SVG_UNIT_PX, 0);
  add_integer_constant("SVG_UNIT_IN", CAIRO_SVG_UNIT_IN, 0);
  add_integer_constant("SVG_UNIT_CM", CAIRO_SVG_UNIT_CM, 0);
  add_integer_constant("SVG_UNIT_MM", CAIRO_SVG_UNIT_MM, 0);
  add_integer_constant("SVG_UNIT_PT", CAIRO_SVG_UNIT_PT, 0);
  add_integer_constant("SVG_UNIT_PC", CAIRO_SVG_UNIT_PC, 0);
  add_integer_constant("SVG_UNIT_PERCENT", CAIRO_SVG_UNIT_PERCENT, 0);
#endif
#endif

#ifdef CAIRO_HAS_SCRIPT_SURFACE
  add_integer_constant("SCRIPT_MODE_ASCII", CAIRO_SCRIPT_MODE_ASCII, 0);
  add_integer_constant("SCRIPT_MODE_BINARY", CAIRO_SCRIPT_MODE_BINARY, 0);
#endif

#endif
}

PIKE_MODULE_EXIT
{
#ifdef HAVE_CAIRO
#endif
  EXIT;
}

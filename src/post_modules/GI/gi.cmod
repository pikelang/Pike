/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/

#include "global.h"
#include "interpret.h"
#include "module_support.h"
#include "builtin_functions.h"
#include "bignum.h"
#include "operators.h"
#include "gimod_config.h"

DECLARATIONS

#ifdef HAVE_GI

#include <girepository.h>

static GQuark object_quark;

/*! @module GI
 */

static void throw_gerror(GError *error)
{
  Pike_error("%s\n", error->message);
}

static void free_glist_full_free(void *p)
{
  g_list_free_full(p, free);
}

static void push_gi_info(GIBaseInfo *info);

/*! @class GObject
 */

PIKECLASS GObject
{
  CVAR GObject *obj;

  INIT
    {
      THIS->obj = NULL;
    }

  EXIT
    {
      if (THIS->obj != NULL) {
        g_object_set_qdata(THIS->obj, object_quark, NULL);
        g_object_unref(THIS->obj);
        THIS->obj = NULL;
      }
    }
}

/*! @endclass
 */

static void push_gi_argument_interface(GIArgument *arg, GIBaseInfo *info)
{
  switch(g_base_info_get_type(info)) {

  case GI_INFO_TYPE_ENUM:
  case GI_INFO_TYPE_FLAGS:
    push_int(arg->v_long);
    break;

  case GI_INFO_TYPE_OBJECT:
    if (!arg->v_pointer) {
      push_int(0);
      break;
    } else {
      struct object *obj = g_object_get_qdata(arg->v_pointer, object_quark);
      if (obj == NULL) {
        push_constant_text("GI.repository.");
        push_text(g_base_info_get_namespace(info));
        push_constant_text(".");
        push_text(g_base_info_get_name(info));
        f_add(4);
        APPLY_MASTER ("resolv", 1);
        if (TYPEOF(Pike_sp[-1]) != T_OBJECT)
          Pike_error("Failed to resolve GI object class.\n");
        apply(Pike_sp[-1].u.object, "Instance", 0);
        stack_pop_keep_top();
        if (TYPEOF(Pike_sp[-1]) != T_OBJECT)
          Pike_error("Failed to instantiate GI object class.\n");
        {
          struct GObject_struct *that =
            (struct GObject_struct *)get_storage ((obj = Pike_sp[-1].u.object),
        					  GObject_program);
          if (that == NULL)
            Pike_error("No storage for GObject!\n");
          g_object_ref ((that->obj = arg->v_pointer));
          g_object_set_qdata(that->obj, object_quark, obj);
        }
      } else
        ref_push_object(obj);
    }
    break;

  default:
    Pike_error("Don't know how to push a base %d\n", g_base_info_get_type(info));
  }
}

static void push_gi_argument(GIArgument *arg, GITypeInfo *info)
{
  switch (g_type_info_get_tag(info)) {
  case GI_TYPE_TAG_VOID:
    push_int(0);
    break;
  case GI_TYPE_TAG_BOOLEAN:
    push_int(arg->v_boolean);
    break;
  case GI_TYPE_TAG_INT8:
    push_int(arg->v_int8);
    break;
  case GI_TYPE_TAG_UINT8:
    push_int(arg->v_uint8);
    break;
  case GI_TYPE_TAG_INT16:
    push_int(arg->v_int16);
    break;
  case GI_TYPE_TAG_UINT16:
    push_int(arg->v_uint16);
    break;
  case GI_TYPE_TAG_INT32:
    push_int(arg->v_int32);
    break;
  case GI_TYPE_TAG_UINT32:
    push_int64(arg->v_uint32);
    break;
  case GI_TYPE_TAG_INT64:
    push_int64(arg->v_int64);
    break;
  case GI_TYPE_TAG_UINT64:
    /* FIXME... */
    push_int64(arg->v_uint64);
    break;

  case GI_TYPE_TAG_UTF8:
    push_text(arg->v_pointer);
    f_utf8_to_string(1);
    break;

  case GI_TYPE_TAG_INTERFACE:
    {
      ONERROR onerror;
      GIBaseInfo *info2;
      info2 = g_type_info_get_interface(info);
      SET_ONERROR(onerror, g_base_info_unref, info2);
      push_gi_argument_interface(arg, info2);
      UNSET_ONERROR(onerror);
      g_base_info_unref(info2);
    }
    break;

  default:
    Pike_error("Don't know how to push a %d\n", g_type_info_get_tag(info));
  }
}

static void get_gi_argument_interface(struct svalue *s, GIArgument *arg,
        			      GIBaseInfo *info)
{
  switch(g_base_info_get_type(info)) {

  case GI_INFO_TYPE_ENUM:
  case GI_INFO_TYPE_FLAGS:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_long = s->u.integer;
    break;

  case GI_INFO_TYPE_OBJECT:
    if (UNSAFE_IS_ZERO(s)) {
      arg->v_pointer = NULL;
      break;
    }
    if (TYPEOF(*s) != T_OBJECT)
      Pike_error("object expected\n");
    else {
      struct GObject_struct *that =
        (struct GObject_struct *)get_storage (s->u.object, GObject_program);
      if (that == NULL)
        Pike_error("argument is not a GObject\n");
      if (that->obj == NULL ||
          !g_type_is_a(G_OBJECT_TYPE(that->obj),
        	       g_registered_type_info_get_g_type(info)))
        Pike_error("Object is not a %s\n",
        	   g_base_info_get_name(info));
      arg->v_pointer = that->obj;
    }
    break;

  default:
    Pike_error("Don't know how to get a base %d\n", g_base_info_get_type(info));
  }
}

static void get_gi_argument_type(struct svalue *s, GIArgument *arg,
        			 GITypeInfo *ti)
{
  switch (g_type_info_get_tag(ti)) {
  case GI_TYPE_TAG_VOID:
    Pike_error("Too many arguments\n");

  case GI_TYPE_TAG_BOOLEAN:
    arg->v_boolean = (UNSAFE_IS_ZERO(s)? FALSE : TRUE);
    break;

  case GI_TYPE_TAG_INT8:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_int8 = s->u.integer;
    break;
  case GI_TYPE_TAG_UINT8:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_uint8 = s->u.integer;
    break;
  case GI_TYPE_TAG_INT16:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_int16 = s->u.integer;
    break;
  case GI_TYPE_TAG_UINT16:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_uint16 = s->u.integer;
    break;
  case GI_TYPE_TAG_INT32:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_int32 = s->u.integer;
    break;
  case GI_TYPE_TAG_UINT32:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_uint32 = s->u.integer;
    break;

  case GI_TYPE_TAG_FLOAT:
    if (TYPEOF(*s) == PIKE_T_INT)
      arg->v_float = s->u.integer;
    else if (TYPEOF(*s) == PIKE_T_FLOAT)
      arg->v_float = s->u.float_number;
    else
      Pike_error("float expected\n");
    break;
  case GI_TYPE_TAG_DOUBLE:
    if (TYPEOF(*s) == PIKE_T_INT)
      arg->v_double = s->u.integer;
    else if (TYPEOF(*s) == PIKE_T_FLOAT)
      arg->v_double = s->u.float_number;
    else
      Pike_error("float expected\n");
    break;

  case GI_TYPE_TAG_UTF8:
    if (TYPEOF(*s) != PIKE_T_STRING)
      Pike_error("Expected string\n");
    ref_push_string(s->u.string);
    f_string_to_utf8(1);
    arg->v_pointer = STR0(Pike_sp[-1].u.string);
    break;

  case GI_TYPE_TAG_ARRAY:
    if (UNSAFE_IS_ZERO(s)) {
      arg->v_pointer = NULL;
      break;
    }
    if (TYPEOF(*s) != PIKE_T_ARRAY)
      Pike_error("array expected\n");
    else {
      ONERROR onerror;
      INT32 i;
      GArray *arr;
      GITypeInfo *itemti = g_type_info_get_param_type(ti, 0);
      SET_ONERROR(onerror, g_base_info_unref, itemti);
      arr = g_array_sized_new(g_type_info_is_zero_terminated(ti),
        		      FALSE, sizeof(gpointer) /*FIXME*/,
        		      s->u.array->size);
      for (i=0; i<s->u.array->size; i++) {
        GIArgument a;
        get_gi_argument_type(&ITEM(s->u.array)[i], &a, itemti);
        g_array_insert_val(arr, i, a);
      }
      UNSET_ONERROR(onerror);
      g_base_info_unref(itemti);
      arg->v_pointer = arr->data;
    }
    break;

  case GI_TYPE_TAG_INTERFACE:
    {
      ONERROR onerror;
      GIBaseInfo *info;
      info = g_type_info_get_interface(ti);
      SET_ONERROR(onerror, g_base_info_unref, info);
      get_gi_argument_interface(s, arg, info);
      UNSET_ONERROR(onerror);
      g_base_info_unref(info);
    }
    break;

  default:
    Pike_error("Don't know how to get a %d\n", g_type_info_get_tag(ti));
  }  
}

static void get_gi_argument(struct svalue *s, GIArgument *arg, GIArgInfo *ai)
{
  GITypeInfo ti;

  g_arg_info_load_type(ai, &ti);
  get_gi_argument_type(s, arg, &ti);
}

/*! @class BaseInfo
 */

PIKECLASS BaseInfo
{
  CVAR GIBaseInfo *info;

  INIT
    {
      THIS->info = NULL;
    }

  EXIT
    {
      if (THIS->info != NULL) {
        g_base_info_unref(THIS->info);
        THIS->info = NULL;
      }
    }

  /*! @decl string get_name()
   */
  PIKEFUN string get_name()
  {
    pop_n_elems(args);
    push_text(g_base_info_get_name(THIS->info));
  }

  /*! @decl string get_namespace()
   */
  PIKEFUN string get_namespace()
  {
    pop_n_elems(args);
    push_text(g_base_info_get_namespace(THIS->info));
  }

  /*! @decl BaseInfo get_container()
   */
  PIKEFUN BaseInfo get_container()
  {
    GIBaseInfo *container = g_base_info_get_container(THIS->info);
    pop_n_elems(args);
    if (container)
      push_gi_info(container);
    else
      push_int(0);
  }

  PIKEFUN string _sprintf (int flag, ...)
    flags ID_STATIC;
  {
    pop_n_elems(args);

    if (flag != 'O' || THIS->info == NULL)
      push_int(0);
    else {
      push_constant_text("%O(%s)");
      push_program(Pike_fp->current_program);
      push_text(g_base_info_get_name(THIS->info));
      f_sprintf(3);
    }
  }
}

/*! @class FunctionInfo
 */

PIKECLASS FunctionInfo
{
  INHERIT BaseInfo;

  /*! @decl mixed invoke(mixed ... args)
   */
  PIKEFUN mixed invoke(mixed ... a)
  {
    ONERROR onerror;
    gboolean ok;
    GError *error = NULL;
    GIArgument retval;
    GITypeInfo *ti;
    struct svalue *mark = Pike_sp-args;
    int i = 0, arg_num, num_out_args = 0, num_args = args;
    GIArgument out_args[8], *in_args =
      (num_args? xalloc(num_args * sizeof(GIArgument)) : NULL);
    GIFunctionInfoFlags flags = g_function_info_get_flags (THIS->info);
    SET_ONERROR(onerror, free, in_args);
    if (flags & GI_FUNCTION_IS_METHOD) {
      if (args < 1 || TYPEOF(*mark) != T_OBJECT)
        Pike_error("Missing object for method call\n");
      else {
        struct GObject_struct *that =
          (struct GObject_struct *)get_storage (mark->u.object,
        					GObject_program);
        if (that == NULL)
          Pike_error("Instance argument is not a GObject\n");
        if (that->obj == NULL ||
            !g_type_is_a(G_OBJECT_TYPE(that->obj),
        		 g_registered_type_info_get_g_type(g_base_info_get_container(THIS->info))))
          Pike_error("Object is not a %s\n",
        	     g_base_info_get_name(g_base_info_get_container(THIS->info)));
        in_args[0].v_pointer = that->obj;
        i++;
      }
    }
    for (arg_num=0; i<num_args; i++, arg_num++) {
      ONERROR onerror2;
      GIArgInfo *ai;
      ai = g_callable_info_get_arg(THIS->info, arg_num);
      if (!ai)
        Pike_error("Too many arguments to function %s\n",
        	   g_base_info_get_name(THIS->info));
      SET_ONERROR(onerror2, g_base_info_unref, ai);
      get_gi_argument(mark+i, &in_args[i], ai);
      if(g_arg_info_get_direction(ai) == GI_DIRECTION_INOUT) {
        if(num_out_args >= 8)
          Pike_error("Too many inout args...\n");
        out_args[num_out_args] = in_args[i];
        in_args[i].v_pointer = &out_args[num_out_args];
        num_out_args++;
      }
      UNSET_ONERROR(onerror2);
      g_base_info_unref(ai);
    }
    ok = g_function_info_invoke(THIS->info, in_args, num_args,
        			out_args, num_out_args, &retval, &error);
    UNSET_ONERROR(onerror);
    free(in_args);
    if(error)
      throw_gerror(error);
    if(!ok)
      Pike_error("Function not invoked\n");
    pop_n_elems(Pike_sp - mark);
    ti = g_callable_info_get_return_type(THIS->info);
    SET_ONERROR(onerror, g_base_info_unref, ti);
    push_gi_argument(&retval, ti);
    UNSET_ONERROR(onerror);
    g_base_info_unref(ti);
  }
}

/*! @class CallbackInfo
 */

PIKECLASS CallbackInfo
{
  INHERIT BaseInfo;
}

/*! @class StructInfo
 */

PIKECLASS StructInfo
{
  INHERIT BaseInfo;
}

/*! @class ValueInfo
 */

PIKECLASS ValueInfo
{
  INHERIT BaseInfo;

  /*! @decl int get_value()
   */
  PIKEFUN int get_value()
  {
    RETURN g_value_info_get_value((GIValueInfo *)THIS->info);
  }
}

/*! @class EnumInfo
 */

PIKECLASS EnumInfo
{
  INHERIT BaseInfo;

  /*! @decl array(ValueInfo) get_values()
   */
  PIKEFUN array(ValueInfo) get_values()
  {
    ONERROR onerror, onerror2;
    struct array *arr;
    gssize i, num;
    num = g_enum_info_get_n_values((GIEnumInfo *)THIS->info);
    arr = allocate_array(num);
    SET_ONERROR(onerror, do_free_array, arr);
    for(i=0; i<num; i++) {
      GIBaseInfo *info;
      info =
        (GIBaseInfo *)g_enum_info_get_value((GIEnumInfo *)THIS->info, i);
      SET_ONERROR(onerror2, g_base_info_unref, info);
      push_gi_info(info);
      UNSET_ONERROR(onerror2);
      g_base_info_unref(info);
      array_set_index_no_free(arr, i, Pike_sp-1);
      pop_stack();
    }
    UNSET_ONERROR(onerror);
    RETURN arr;
  }
}

/*! @class InterfaceInfo
 */

PIKECLASS InterfaceInfo
{
  INHERIT BaseInfo;

  /*! @decl array(FunctionInfo) get_methods()
   */
  PIKEFUN array(FunctionInfo) get_methods()
  {
    ONERROR onerror, onerror2;
    struct array *arr;
    gssize i, num;
    num = g_interface_info_get_n_methods((GIInterfaceInfo *)THIS->info);
    arr = allocate_array(num);
    SET_ONERROR(onerror, do_free_array, arr);
    for(i=0; i<num; i++) {
      GIBaseInfo *info;
      info =
        (GIBaseInfo *)g_interface_info_get_method((GIInterfaceInfo *)THIS->info, i);
      SET_ONERROR(onerror2, g_base_info_unref, info);
      push_gi_info(info);
      UNSET_ONERROR(onerror2);
      g_base_info_unref(info);
      array_set_index_no_free(arr, i, Pike_sp-1);
      pop_stack();
    }
    UNSET_ONERROR(onerror);
    RETURN arr;
  }
}

/*! @class ObjectInfo
 */

PIKECLASS ObjectInfo
{
  INHERIT BaseInfo;

  /*! @decl array(FunctionInfo) get_methods()
   */
  PIKEFUN array(FunctionInfo) get_methods()
  {
    ONERROR onerror, onerror2;
    struct array *arr;
    gssize i, num;
    num = g_object_info_get_n_methods((GIObjectInfo *)THIS->info);
    arr = allocate_array(num);
    SET_ONERROR(onerror, do_free_array, arr);
    for(i=0; i<num; i++) {
      GIBaseInfo *info;
      info =
        (GIBaseInfo *)g_object_info_get_method((GIObjectInfo *)THIS->info, i);
      SET_ONERROR(onerror2, g_base_info_unref, info);
      push_gi_info(info);
      UNSET_ONERROR(onerror2);
      g_base_info_unref(info);
      array_set_index_no_free(arr, i, Pike_sp-1);
      pop_stack();
    }
    UNSET_ONERROR(onerror);
    RETURN arr;
  }

  /*! @decl array(InterfaceInfo) get_interfaces()
   */
  PIKEFUN array(InterfaceInfo) get_interfaces()
  {
    ONERROR onerror, onerror2;
    struct array *arr;
    gssize i, num;
    num = g_object_info_get_n_interfaces((GIObjectInfo *)THIS->info);
    arr = allocate_array(num);
    SET_ONERROR(onerror, do_free_array, arr);
    for(i=0; i<num; i++) {
      GIBaseInfo *info;
      info =
        (GIBaseInfo *)g_object_info_get_interface((GIObjectInfo *)THIS->info, i);
      SET_ONERROR(onerror2, g_base_info_unref, info);
      push_gi_info(info);
      UNSET_ONERROR(onerror2);
      g_base_info_unref(info);
      array_set_index_no_free(arr, i, Pike_sp-1);
      pop_stack();
    }
    UNSET_ONERROR(onerror);
    RETURN arr;
  }

  /*! @decl ObjectInfo get_parent()
   */
  PIKEFUN ObjectInfo get_parent()
  {
    ONERROR onerror;
    GIBaseInfo *info =
      (GIBaseInfo *)g_object_info_get_parent((GIObjectInfo *)THIS->info);
    if (info == NULL) {
      pop_n_elems(args);
      push_int(0);
      return;
    }
    SET_ONERROR(onerror, g_base_info_unref, info);
    pop_n_elems(args);
    push_gi_info(info);
    UNSET_ONERROR(onerror);
    g_base_info_unref(info);
  }
}

/*! @class ConstantInfo
 */

PIKECLASS ConstantInfo
{
  INHERIT BaseInfo;
}

/*! @class UnionInfo
 */

PIKECLASS UnionInfo
{
  INHERIT BaseInfo;
}


static void push_gi_info(GIBaseInfo *info)
{
  struct program *p;
  if (info == NULL)
    Pike_error("Missing info\n");
  switch(g_base_info_get_type(info)) {
  case GI_INFO_TYPE_FUNCTION:
    p = FunctionInfo_program; break;
  case GI_INFO_TYPE_CALLBACK:
    p = CallbackInfo_program; break;
  case GI_INFO_TYPE_STRUCT:
    p = StructInfo_program; break;
  case GI_INFO_TYPE_ENUM:
  case GI_INFO_TYPE_FLAGS:
    p = EnumInfo_program; break;
  case GI_INFO_TYPE_OBJECT:
    p = ObjectInfo_program; break;
  case GI_INFO_TYPE_INTERFACE:
    p = InterfaceInfo_program; break;
  case GI_INFO_TYPE_CONSTANT:
    p = ConstantInfo_program; break;
  case GI_INFO_TYPE_UNION:
    p = UnionInfo_program; break;
  case GI_INFO_TYPE_VALUE:
    p = ValueInfo_program; break;
  default:
    Pike_error("No class for %d\n", g_base_info_get_type(info));
  }
  {
    struct object *o = clone_object(p, 0);
    struct BaseInfo_struct *that =
      (struct BaseInfo_struct *)get_storage (o, BaseInfo_program);
    that->info = g_base_info_ref(info);
    push_object(o);
  }
}

/*! @class Repository
 */

PIKECLASS Repository
{
  CVAR GIRepository *repository;

  INIT
    {
      THIS->repository = NULL;
    }

  /*! @decl array(string) enumerate_versions(strig namespace)
   */
  PIKEFUN array(string) enumerate_versions(string namespace)
  {
    ONERROR onerror;
    int count = 0;
    GList *item, *versions =
      g_irepository_enumerate_versions(THIS->repository,
        			       (gchar *)STR0(namespace));
    if (versions == NULL) {
      pop_n_elems(args);
      push_int(0);
      return;
    }
    SET_ONERROR(onerror, free_glist_full_free, versions);
    pop_n_elems(args);
    for (item = versions; item; item = item->next) {
        char *version = item->data;
        push_text(version);
        f_utf8_to_string(1);
        count++;
    }
    UNSET_ONERROR(onerror);
    free_glist_full_free(versions);
    f_aggregate(count);
  }

  /*! @decl BaseInfo find_by_name(string namespace, string name)
   */
  PIKEFUN BaseInfo find_by_name(string namespace, string name)
  {
    ONERROR onerror;
    GIBaseInfo *info =
      g_irepository_find_by_name(THIS->repository,
        			 (gchar *)STR0(namespace),
        			 (gchar *)STR0(name));
    if (info) {
      SET_ONERROR(onerror, g_base_info_unref, info);
      pop_n_elems(args);
      push_gi_info(info);
      UNSET_ONERROR(onerror);
      g_base_info_unref(info);
    } else {
      pop_n_elems(args);
      push_int(0);
    }
  }

  /*! @decl array(BaseInfo) get_infos(string namespace)
   */
  PIKEFUN array(BaseInfo) get_infos(string namespace)
  {
    ONERROR onerror, onerror2;
    struct array *arr;
    gssize i, num;
    num = g_irepository_get_n_infos(THIS->repository,
        			    (gchar *)STR0(namespace));
    if (num < 0)
      Pike_error("Namespace '%S' not loaded\n", namespace);
    arr = allocate_array(num);
    SET_ONERROR(onerror, do_free_array, arr);
    for(i=0; i<num; i++) {
      GIBaseInfo *info;
      info = g_irepository_get_info(THIS->repository,
        			    (gchar *)STR0(namespace), i);
      SET_ONERROR(onerror2, g_base_info_unref, info);
      push_gi_info(info);
      UNSET_ONERROR(onerror2);
      g_base_info_unref(info);
      array_set_index_no_free(arr, i, Pike_sp-1);
      pop_stack();
    }
    UNSET_ONERROR(onerror);
    RETURN arr;
  }
  
  /*! @decl void require(string namespace, string|void version, int(0..1)|void lazy)
   */
  PIKEFUN void require(string namespace, string|void version, int(0..1)|void lazy)
  {
    GError *error = NULL;
    GTypelib *typelib;

    typelib = g_irepository_require(THIS->repository,
        			    (gchar *)STR0(namespace),
        			    (version? (gchar *)STR0(version) : NULL),
        			    ((lazy != NULL && !UNSAFE_IS_ZERO(lazy))? 
        			     G_IREPOSITORY_LOAD_FLAG_LAZY : 0),
        			    &error);

    if(error)
      throw_gerror(error);

    pop_n_elems(args);  /* Should be "RETURN;", but that is broken... */
  }
}

/*! @endclass
 */

/*! @decl Repository get_default_repository()
 */

PIKEFUN Repository get_default_repository()
{
  static struct object *default_repository = NULL;
  if (default_repository == NULL) {
    struct object *o = clone_object(Repository_program, 0);
    struct Repository_struct *that =
      (struct Repository_struct *)get_storage (o, Repository_program);
    that->repository = g_irepository_get_default();
    default_repository = o;
  }
  ref_push_object(default_repository);
}

/*! @endmodule
 */

#endif

PIKE_MODULE_INIT
{
#ifdef HAVE_GI
  g_type_init();
  object_quark = g_quark_from_static_string("PikeGI::object");
  INIT
#endif
}

PIKE_MODULE_EXIT
{
#ifdef HAVE_GI
  EXIT
#endif
}

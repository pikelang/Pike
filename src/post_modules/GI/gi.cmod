/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/

#include "global.h"
#include "interpret.h"
#include "module_support.h"
#include "builtin_functions.h"
#include "bignum.h"
#include "operators.h"
#include "mapping.h"
#include "gimod_config.h"

DECLARATIONS

#ifdef HAVE_GI

#include <girepository.h>

static GQuark object_quark;
static struct mapping *magic_mapping = NULL;

/*! @module GI
 */

static void throw_gerror(GError *error)
{
  Pike_error("%s\n", error->message);
}

static void free_glist_full_free(void *p)
{
  g_list_free_full(p, free);
}

static void push_gi_info(GIBaseInfo *info);
static GObject *make_gobject_from_props(struct object *info, struct mapping *props);
static void push_gvalue(const GValue *v);
static void set_gvalue_from_svalue(GValue *v, const struct svalue *s);

struct signal_data {
  struct svalue cb;
  struct svalue extra_args;
};

static void free_signal_data(struct signal_data *s, GClosure *gcl)
{
  free_svalue(&s->cb);
  free_svalue(&s->extra_args);
  g_free(s);
}

static void marshaller(GClosure *closure,
		       GValue *return_value,
		       guint n_params,
		       const GValue *param_values,
		       gpointer invocation_hint,
		       gpointer marshal_data)
{
  typedef void (*marshal_func)(gpointer data1,
			       gpointer data2,
			       guint n_params, 
			       const GValue *param_values,
			       GValue *return_value);
  marshal_func callback;
  GCClosure *cc=(GCClosure *)closure;
  gpointer data1, data2;

  if (G_CCLOSURE_SWAP_DATA(closure)) {
    data1=closure->data;
    data2=g_value_peek_pointer(param_values+0);
  } else {
    data1=g_value_peek_pointer(param_values+0);
    data2=closure->data;
  }

  callback=(marshal_func)(marshal_data? marshal_data : cc->callback);
  callback(data1, data2, n_params-1, param_values+1, return_value);
}

struct signal_wrapper_context
{
  struct signal_data *d;
  guint n_params;
  const GValue *param_values;
  GValue *return_value;
};

static void invoke_signal_func(void *arg)
{
  struct signal_wrapper_context *ctx = (struct signal_wrapper_context *)arg;
  struct signal_data *d = ctx->d;
  guint n_params = ctx->n_params;
  const GValue *param_values = ctx->param_values;
  GValue *return_value = ctx->return_value;
  JMP_BUF recovery;
  unsigned int i;
  INT32 args = n_params;
  struct svalue *osp = Pike_sp;

  if (SETJMP(recovery)) {
    pop_n_elems(Pike_sp-osp);
    UNSETJMP(recovery);
    call_handle_error();
    if (return_value && G_VALUE_TYPE(return_value) != 0)
      g_value_unset(return_value);
    return;
  }

  for (i=0; i<n_params; i++) {
    push_gvalue(&(param_values[i]));
  }
  if (TYPEOF(d->extra_args) == PIKE_T_ARRAY) {
    struct array *a = d->extra_args.u.array;
    INT32 asize = a->size;
    check_stack(asize);
    assign_svalues_no_free(Pike_sp, ITEM(a), asize, a->type_field);
    Pike_sp += asize;
    args += asize;
  }
  apply_svalue(&d->cb, args);
  if (return_value && G_VALUE_TYPE(return_value) != 0 )
    set_gvalue_from_svalue(return_value, &Pike_sp[-1]);
  pop_stack();
  UNSETJMP(recovery);
}

static void signal_func_wrapper(struct signal_data *d,
				gpointer go,
				guint n_params,
				const GValue *param_values,
				GValue *return_value)
{
  struct signal_wrapper_context ctx = {
    d, n_params, param_values, return_value
  };
  call_with_interpreter(invoke_signal_func, &ctx);
}


/*! @class GObject
 */

PIKECLASS GObject
{
  CVAR GObject *obj;

  INIT
    {
      THIS->obj = NULL;
    }

  EXIT
    {
      if (THIS->obj != NULL) {
	g_object_set_qdata(THIS->obj, object_quark, NULL);
	g_object_unref(THIS->obj);
	THIS->obj = NULL;
      }
    }

#ifndef tObjImpl_OBJECTINFO
/* Break circular class dependency... */
#define tObjImpl_OBJECTINFO tObj
#endif

  /*! @decl void create(ObjectInfo info, mapping(string:mixed)|void props)
   */
  PIKEFUN void create(ObjectInfo info, mapping(string:mixed)|void props)
  {
    if (THIS->obj != NULL)
      Pike_error("GObject.create called twice!\n");
    if (props != magic_mapping) {
      THIS->obj = make_gobject_from_props(info, props);
      g_object_set_qdata(THIS->obj, object_quark, Pike_fp->current_object);
    }
  }

  /*! @decl int connect(string signal_spec, function callback, mixed ... extra_args)
   */
  PIKEFUN int connect(string signal_spec, function callback, mixed ... extra_args)
  {
    struct signal_data *b;
    GClosure *gc;
    guint sigid;
    GQuark detail = 0;
    gulong id;

    if (signal_spec->size_shift ||
	!g_signal_parse_name((const gchar *)STR0(signal_spec),
			     G_OBJECT_TYPE(THIS->obj),
			     &sigid, &detail, TRUE)) {
      Pike_error("Signal \"%S\" is not defined in the '%s' class ancestry.\n",
		 signal_spec, g_type_name(G_TYPE_FROM_INSTANCE(THIS->obj)));
    }

    b=(struct signal_data *)g_malloc0(sizeof(struct signal_data));
    if (b==NULL)
      SIMPLE_OUT_OF_MEMORY_ERROR("connect",sizeof(struct signal_data));
    assign_svalue_no_free(&b->cb, callback);
    if (extra_args) {
      f_aggregate(args-2);
      assign_svalue_no_free(&b->extra_args, Pike_sp-1);
      pop_stack();
      args = 2;
    } else {
      SET_SVAL(b->extra_args, PIKE_T_INT, NUMBER_NUMBER, integer, 0);
    }

    gc=g_cclosure_new_swap(G_CALLBACK(signal_func_wrapper), b,
			   (GClosureNotify)free_signal_data);
    g_closure_set_marshal(gc, marshaller);

    id = g_signal_connect_closure_by_id(G_OBJECT(THIS->obj), sigid, detail,
					gc, FALSE);
    RETURN id;
  }

  /*! @decl int connect_after(string signal_spec, function callback, mixed ... extra_args)
   */
  PIKEFUN int connect_after(string signal_spec, function callback, mixed ... extra_args)
  {
    struct signal_data *b;
    GClosure *gc;
    guint sigid;
    GQuark detail = 0;
    gulong id;

    if (signal_spec->size_shift ||
	!g_signal_parse_name((const gchar *)STR0(signal_spec),
			     G_OBJECT_TYPE(THIS->obj),
			     &sigid, &detail, TRUE)) {
      Pike_error("Signal \"%S\" is not defined in the '%s' class ancestry.\n",
		 signal_spec, g_type_name(G_TYPE_FROM_INSTANCE(THIS->obj)));
    }

    b=(struct signal_data *)g_malloc0(sizeof(struct signal_data));
    if (b==NULL)
      SIMPLE_OUT_OF_MEMORY_ERROR("connect_after",sizeof(struct signal_data));
    assign_svalue_no_free(&b->cb, callback);
    if (extra_args) {
      f_aggregate(args-2);
      assign_svalue_no_free(&b->extra_args, Pike_sp-1);
      pop_stack();
      args = 2;
    } else {
      SET_SVAL(b->extra_args, PIKE_T_INT, NUMBER_NUMBER, integer, 0);
    }

    gc=g_cclosure_new_swap(G_CALLBACK(signal_func_wrapper), b,
			   (GClosureNotify)free_signal_data);
    g_closure_set_marshal(gc, marshaller);

    id = g_signal_connect_closure_by_id(G_OBJECT(THIS->obj), sigid, detail,
					gc, TRUE);
    RETURN id;
  }
}

/*! @endclass
 */

static void push_wrapper_name_from_info(GIBaseInfo *info)
{
  push_constant_text("GI.repository.");
  push_text(g_base_info_get_namespace(info));
  push_constant_text(".");
  push_text(g_base_info_get_name(info));
  f_add(4);
}

static void push_wrapped_gobject(gpointer gobj, GIBaseInfo *info)
{
  if (!gobj) {
    push_int(0);
  } else {
    struct object *obj = g_object_get_qdata(gobj, object_quark);
    if (obj == NULL) {
      GType rttype = G_OBJECT_TYPE((GObject *)gobj);
      GIBaseInfo *rtinfo = g_irepository_find_by_gtype (NULL, rttype);
      if (rtinfo != NULL) {
	push_wrapper_name_from_info(rtinfo);
	g_base_info_unref(rtinfo);
      }
      else if (info != NULL)
	push_wrapper_name_from_info(info);
      else
	Pike_error("Received an object of an unregistered type!\n");
      APPLY_MASTER ("resolv", 1);
      if (TYPEOF(Pike_sp[-1]) != T_OBJECT)
	Pike_error("Failed to resolve GI object class.\n");
      ref_push_mapping(magic_mapping);
      apply(Pike_sp[-2].u.object, "Instance", 1);
      stack_pop_keep_top();
      if (TYPEOF(Pike_sp[-1]) != T_OBJECT)
	Pike_error("Failed to instantiate GI object class.\n");
      {
	struct GObject_struct *that =
	  (struct GObject_struct *)get_storage ((obj = Pike_sp[-1].u.object),
						GObject_program);
	if (that == NULL)
	  Pike_error("No storage for GObject!\n");
	if (that->obj != NULL)
	  Pike_error("GObject already initialized!\n");
	g_object_ref ((that->obj = gobj));
	g_object_set_qdata(that->obj, object_quark, obj);
      }
    } else
      ref_push_object(obj);
  }
}

static void push_gi_argument_interface(GIArgument *arg, GIBaseInfo *info)
{
  switch(g_base_info_get_type(info)) {

  case GI_INFO_TYPE_ENUM:
  case GI_INFO_TYPE_FLAGS:
    push_int(arg->v_long);
    break;

  case GI_INFO_TYPE_OBJECT:
    push_wrapped_gobject(arg->v_pointer, info);
    break;

  default:
    Pike_error("Don't know how to push a base %d\n", g_base_info_get_type(info));
  }
}

static void push_gi_argument(GIArgument *arg, GITypeInfo *info)
{
  switch (g_type_info_get_tag(info)) {
  case GI_TYPE_TAG_VOID:
    push_int(0);
    break;
  case GI_TYPE_TAG_BOOLEAN:
    push_int(arg->v_boolean);
    break;
  case GI_TYPE_TAG_INT8:
    push_int(arg->v_int8);
    break;
  case GI_TYPE_TAG_UINT8:
    push_int(arg->v_uint8);
    break;
  case GI_TYPE_TAG_INT16:
    push_int(arg->v_int16);
    break;
  case GI_TYPE_TAG_UINT16:
    push_int(arg->v_uint16);
    break;
  case GI_TYPE_TAG_INT32:
    push_int(arg->v_int32);
    break;
  case GI_TYPE_TAG_UINT32:
    push_int64(arg->v_uint32);
    break;
  case GI_TYPE_TAG_INT64:
    push_int64(arg->v_int64);
    break;
  case GI_TYPE_TAG_UINT64:
    /* FIXME... */
    push_int64(arg->v_uint64);
    break;

  case GI_TYPE_TAG_UTF8:
    push_text(arg->v_pointer);
    f_utf8_to_string(1);
    break;

  case GI_TYPE_TAG_INTERFACE:
    {
      ONERROR onerror;
      GIBaseInfo *info2;
      info2 = g_type_info_get_interface(info);
      SET_ONERROR(onerror, g_base_info_unref, info2);
      push_gi_argument_interface(arg, info2);
      UNSET_ONERROR(onerror);
      g_base_info_unref(info2);
    }
    break;

  case GI_TYPE_TAG_GLIST:
  case GI_TYPE_TAG_GSLIST:
    {
      INT32 count = 0;
      GSList *list = arg->v_pointer;
      while(list != NULL) {
	GIArgument item;
	GITypeInfo *item_info = g_type_info_get_param_type(info, 0);
	item.v_pointer = list->data;
	push_gi_argument(&item, item_info);
	count++;
	list = g_slist_next (list);
      }
      f_aggregate(count);
    }
    break;

  default:
    Pike_error("Don't know how to push a %d\n", g_type_info_get_tag(info));
  }
}

static void get_gi_argument_interface(struct svalue *s, GIArgument *arg,
				      GIBaseInfo *info)
{
  switch(g_base_info_get_type(info)) {

  case GI_INFO_TYPE_ENUM:
  case GI_INFO_TYPE_FLAGS:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_long = s->u.integer;
    break;

  case GI_INFO_TYPE_OBJECT:
    if (UNSAFE_IS_ZERO(s)) {
      arg->v_pointer = NULL;
      break;
    }
    if (TYPEOF(*s) != T_OBJECT)
      Pike_error("object expected\n");
    else {
      struct GObject_struct *that =
	(struct GObject_struct *)get_storage (s->u.object, GObject_program);
      if (that == NULL)
	Pike_error("argument is not a GObject\n");
      if (that->obj == NULL ||
	  !g_type_is_a(G_OBJECT_TYPE(that->obj),
		       g_registered_type_info_get_g_type(info)))
	Pike_error("Object is not a %s\n",
		   g_base_info_get_name(info));
      arg->v_pointer = that->obj;
    }
    break;

  default:
    Pike_error("Don't know how to get a base %d\n", g_base_info_get_type(info));
  }
}

static void get_gi_argument_type(struct svalue *s, GIArgument *arg,
				 GITypeInfo *ti)
{
  switch (g_type_info_get_tag(ti)) {
  case GI_TYPE_TAG_VOID:
    Pike_error("Too many arguments\n");

  case GI_TYPE_TAG_BOOLEAN:
    arg->v_boolean = (UNSAFE_IS_ZERO(s)? FALSE : TRUE);
    break;

  case GI_TYPE_TAG_INT8:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_int8 = s->u.integer;
    break;
  case GI_TYPE_TAG_UINT8:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_uint8 = s->u.integer;
    break;
  case GI_TYPE_TAG_INT16:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_int16 = s->u.integer;
    break;
  case GI_TYPE_TAG_UINT16:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_uint16 = s->u.integer;
    break;
  case GI_TYPE_TAG_INT32:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_int32 = s->u.integer;
    break;
  case GI_TYPE_TAG_UINT32:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    arg->v_uint32 = s->u.integer;
    break;

  case GI_TYPE_TAG_FLOAT:
    if (TYPEOF(*s) == PIKE_T_INT)
      arg->v_float = s->u.integer;
    else if (TYPEOF(*s) == PIKE_T_FLOAT)
      arg->v_float = s->u.float_number;
    else
      Pike_error("float expected\n");
    break;
  case GI_TYPE_TAG_DOUBLE:
    if (TYPEOF(*s) == PIKE_T_INT)
      arg->v_double = s->u.integer;
    else if (TYPEOF(*s) == PIKE_T_FLOAT)
      arg->v_double = s->u.float_number;
    else
      Pike_error("float expected\n");
    break;

  case GI_TYPE_TAG_UTF8:
    if (TYPEOF(*s) != PIKE_T_STRING)
      Pike_error("Expected string\n");
    ref_push_string(s->u.string);
    f_string_to_utf8(1);
    arg->v_pointer = STR0(Pike_sp[-1].u.string);
    break;

  case GI_TYPE_TAG_ARRAY:
    if (UNSAFE_IS_ZERO(s)) {
      arg->v_pointer = NULL;
      break;
    }
    if (TYPEOF(*s) != PIKE_T_ARRAY)
      Pike_error("array expected\n");
    else {
      ONERROR onerror;
      INT32 i;
      GArray *arr;
      GITypeInfo *itemti = g_type_info_get_param_type(ti, 0);
      SET_ONERROR(onerror, g_base_info_unref, itemti);
      arr = g_array_sized_new(g_type_info_is_zero_terminated(ti),
			      FALSE, sizeof(gpointer) /*FIXME*/,
			      s->u.array->size);
      for (i=0; i<s->u.array->size; i++) {
	GIArgument a;
	get_gi_argument_type(&ITEM(s->u.array)[i], &a, itemti);
	g_array_insert_val(arr, i, a);
      }
      UNSET_ONERROR(onerror);
      g_base_info_unref(itemti);
      arg->v_pointer = arr->data;
    }
    break;

  case GI_TYPE_TAG_INTERFACE:
    {
      ONERROR onerror;
      GIBaseInfo *info;
      info = g_type_info_get_interface(ti);
      SET_ONERROR(onerror, g_base_info_unref, info);
      get_gi_argument_interface(s, arg, info);
      UNSET_ONERROR(onerror);
      g_base_info_unref(info);
    }
    break;

  default:
    Pike_error("Don't know how to get a %d\n", g_type_info_get_tag(ti));
  }  
}

static void get_gi_argument(struct svalue *s, GIArgument *arg, GIArgInfo *ai)
{
  GITypeInfo ti;

  g_arg_info_load_type(ai, &ti);
  get_gi_argument_type(s, arg, &ti);
}

/*! @class BaseInfo
 */

PIKECLASS BaseInfo
{
  CVAR GIBaseInfo *info;

  INIT
    {
      THIS->info = NULL;
    }

  EXIT
    {
      if (THIS->info != NULL) {
	g_base_info_unref(THIS->info);
	THIS->info = NULL;
      }
    }

  /*! @decl string get_name()
   */
  PIKEFUN string get_name()
  {
    pop_n_elems(args);
    push_text(g_base_info_get_name(THIS->info));
  }

  /*! @decl string get_namespace()
   */
  PIKEFUN string get_namespace()
  {
    pop_n_elems(args);
    push_text(g_base_info_get_namespace(THIS->info));
  }

  /*! @decl BaseInfo get_container()
   */
  PIKEFUN BaseInfo get_container()
  {
    GIBaseInfo *container = g_base_info_get_container(THIS->info);
    pop_n_elems(args);
    if (container)
      push_gi_info(container);
    else
      push_int(0);
  }

  PIKEFUN string _sprintf (int flag, ...)
    flags ID_STATIC;
  {
    pop_n_elems(args);

    if (flag != 'O' || THIS->info == NULL)
      push_int(0);
    else {
      push_constant_text("%O(%s)");
      push_program(Pike_fp->current_program);
      push_text(g_base_info_get_name(THIS->info));
      f_sprintf(3);
    }
  }
}

/*! @class FunctionInfo
 */

PIKECLASS FunctionInfo
{
  INHERIT BaseInfo;

  /*! @decl mixed invoke(mixed ... args)
   */
  PIKEFUN mixed invoke(mixed ... a)
  {
    ONERROR onerror;
    gboolean ok;
    GError *error = NULL;
    GIArgument retval;
    GITypeInfo *ti;
    struct svalue *mark = Pike_sp-args;
    int i = 0, arg_num, num_out_args = 0, num_args = args;
    GIArgument out_args[8], *in_args =
      (num_args? xalloc(num_args * sizeof(GIArgument)) : NULL);
    GIFunctionInfoFlags flags = g_function_info_get_flags (THIS->info);
    SET_ONERROR(onerror, free, in_args);
    if (flags & GI_FUNCTION_IS_METHOD) {
      if (args < 1 || TYPEOF(*mark) != T_OBJECT)
	Pike_error("Missing object for method call\n");
      else {
	struct GObject_struct *that =
	  (struct GObject_struct *)get_storage (mark->u.object,
						GObject_program);
	if (that == NULL)
	  Pike_error("Instance argument is not a GObject\n");
	if (that->obj == NULL ||
	    !g_type_is_a(G_OBJECT_TYPE(that->obj),
			 g_registered_type_info_get_g_type(g_base_info_get_container(THIS->info))))
	  Pike_error("Object is not a %s\n",
		     g_base_info_get_name(g_base_info_get_container(THIS->info)));
	in_args[0].v_pointer = that->obj;
	i++;
      }
    }
    for (arg_num=0; i<num_args; i++, arg_num++) {
      ONERROR onerror2;
      GIArgInfo *ai;
      ai = g_callable_info_get_arg(THIS->info, arg_num);
      if (!ai)
	Pike_error("Too many arguments to function %s\n",
		   g_base_info_get_name(THIS->info));
      SET_ONERROR(onerror2, g_base_info_unref, ai);
      get_gi_argument(mark+i, &in_args[i], ai);
      if(g_arg_info_get_direction(ai) == GI_DIRECTION_INOUT) {
	if(num_out_args >= 8)
	  Pike_error("Too many inout args...\n");
	out_args[num_out_args] = in_args[i];
	in_args[i].v_pointer = &out_args[num_out_args];
	num_out_args++;
      }
      UNSET_ONERROR(onerror2);
      g_base_info_unref(ai);
    }
    ok = g_function_info_invoke(THIS->info, in_args, num_args,
				out_args, num_out_args, &retval, &error);
    UNSET_ONERROR(onerror);
    free(in_args);
    if(error)
      throw_gerror(error);
    if(!ok)
      Pike_error("Function not invoked\n");
    pop_n_elems(Pike_sp - mark);
    ti = g_callable_info_get_return_type(THIS->info);
    SET_ONERROR(onerror, g_base_info_unref, ti);
    push_gi_argument(&retval, ti);
    UNSET_ONERROR(onerror);
    g_base_info_unref(ti);
  }
}

/*! @class CallbackInfo
 */

PIKECLASS CallbackInfo
{
  INHERIT BaseInfo;
}

/*! @class StructInfo
 */

PIKECLASS StructInfo
{
  INHERIT BaseInfo;
}

/*! @class ValueInfo
 */

PIKECLASS ValueInfo
{
  INHERIT BaseInfo;

  /*! @decl int get_value()
   */
  PIKEFUN int get_value()
  {
    RETURN g_value_info_get_value((GIValueInfo *)THIS->info);
  }
}

/*! @class EnumInfo
 */

PIKECLASS EnumInfo
{
  INHERIT BaseInfo;

  /*! @decl array(ValueInfo) get_values()
   */
  PIKEFUN array(ValueInfo) get_values()
  {
    ONERROR onerror, onerror2;
    struct array *arr;
    gssize i, num;
    num = g_enum_info_get_n_values((GIEnumInfo *)THIS->info);
    arr = allocate_array(num);
    SET_ONERROR(onerror, do_free_array, arr);
    for(i=0; i<num; i++) {
      GIBaseInfo *info;
      info =
	(GIBaseInfo *)g_enum_info_get_value((GIEnumInfo *)THIS->info, i);
      SET_ONERROR(onerror2, g_base_info_unref, info);
      push_gi_info(info);
      UNSET_ONERROR(onerror2);
      g_base_info_unref(info);
      array_set_index_no_free(arr, i, Pike_sp-1);
      pop_stack();
    }
    UNSET_ONERROR(onerror);
    RETURN arr;
  }
}

/*! @class InterfaceInfo
 */

PIKECLASS InterfaceInfo
{
  INHERIT BaseInfo;

  /*! @decl array(FunctionInfo) get_methods()
   */
  PIKEFUN array(FunctionInfo) get_methods()
  {
    ONERROR onerror, onerror2;
    struct array *arr;
    gssize i, num;
    num = g_interface_info_get_n_methods((GIInterfaceInfo *)THIS->info);
    arr = allocate_array(num);
    SET_ONERROR(onerror, do_free_array, arr);
    for(i=0; i<num; i++) {
      GIBaseInfo *info;
      info =
	(GIBaseInfo *)g_interface_info_get_method((GIInterfaceInfo *)THIS->info, i);
      SET_ONERROR(onerror2, g_base_info_unref, info);
      push_gi_info(info);
      UNSET_ONERROR(onerror2);
      g_base_info_unref(info);
      array_set_index_no_free(arr, i, Pike_sp-1);
      pop_stack();
    }
    UNSET_ONERROR(onerror);
    RETURN arr;
  }
}

/*! @class ObjectInfo
 */

PIKECLASS ObjectInfo
{
  INHERIT BaseInfo;

  /*! @decl array(FunctionInfo) get_methods()
   */
  PIKEFUN array(FunctionInfo) get_methods()
  {
    ONERROR onerror, onerror2;
    struct array *arr;
    gssize i, num;
    num = g_object_info_get_n_methods((GIObjectInfo *)THIS->info);
    arr = allocate_array(num);
    SET_ONERROR(onerror, do_free_array, arr);
    for(i=0; i<num; i++) {
      GIBaseInfo *info;
      info =
	(GIBaseInfo *)g_object_info_get_method((GIObjectInfo *)THIS->info, i);
      SET_ONERROR(onerror2, g_base_info_unref, info);
      push_gi_info(info);
      UNSET_ONERROR(onerror2);
      g_base_info_unref(info);
      array_set_index_no_free(arr, i, Pike_sp-1);
      pop_stack();
    }
    UNSET_ONERROR(onerror);
    RETURN arr;
  }

  /*! @decl array(InterfaceInfo) get_interfaces()
   */
  PIKEFUN array(InterfaceInfo) get_interfaces()
  {
    ONERROR onerror, onerror2;
    struct array *arr;
    gssize i, num;
    num = g_object_info_get_n_interfaces((GIObjectInfo *)THIS->info);
    arr = allocate_array(num);
    SET_ONERROR(onerror, do_free_array, arr);
    for(i=0; i<num; i++) {
      GIBaseInfo *info;
      info =
	(GIBaseInfo *)g_object_info_get_interface((GIObjectInfo *)THIS->info, i);
      SET_ONERROR(onerror2, g_base_info_unref, info);
      push_gi_info(info);
      UNSET_ONERROR(onerror2);
      g_base_info_unref(info);
      array_set_index_no_free(arr, i, Pike_sp-1);
      pop_stack();
    }
    UNSET_ONERROR(onerror);
    RETURN arr;
  }

  /*! @decl ObjectInfo get_parent()
   */
  PIKEFUN ObjectInfo get_parent()
  {
    ONERROR onerror;
    GIBaseInfo *info =
      (GIBaseInfo *)g_object_info_get_parent((GIObjectInfo *)THIS->info);
    if (info == NULL) {
      pop_n_elems(args);
      push_int(0);
      return;
    }
    SET_ONERROR(onerror, g_base_info_unref, info);
    pop_n_elems(args);
    push_gi_info(info);
    UNSET_ONERROR(onerror);
    g_base_info_unref(info);
  }
}

/*! @class ConstantInfo
 */

PIKECLASS ConstantInfo
{
  INHERIT BaseInfo;
}

/*! @class UnionInfo
 */

PIKECLASS UnionInfo
{
  INHERIT BaseInfo;
}


static void push_gi_info(GIBaseInfo *info)
{
  struct program *p;
  if (info == NULL)
    Pike_error("Missing info\n");
  switch(g_base_info_get_type(info)) {
  case GI_INFO_TYPE_FUNCTION:
    p = FunctionInfo_program; break;
  case GI_INFO_TYPE_CALLBACK:
    p = CallbackInfo_program; break;
  case GI_INFO_TYPE_STRUCT:
    p = StructInfo_program; break;
  case GI_INFO_TYPE_ENUM:
  case GI_INFO_TYPE_FLAGS:
    p = EnumInfo_program; break;
  case GI_INFO_TYPE_OBJECT:
    p = ObjectInfo_program; break;
  case GI_INFO_TYPE_INTERFACE:
    p = InterfaceInfo_program; break;
  case GI_INFO_TYPE_CONSTANT:
    p = ConstantInfo_program; break;
  case GI_INFO_TYPE_UNION:
    p = UnionInfo_program; break;
  case GI_INFO_TYPE_VALUE:
    p = ValueInfo_program; break;
  default:
    Pike_error("No class for %d\n", g_base_info_get_type(info));
  }
  {
    struct object *o = clone_object(p, 0);
    struct BaseInfo_struct *that =
      (struct BaseInfo_struct *)get_storage (o, BaseInfo_program);
    that->info = g_base_info_ref(info);
    push_object(o);
  }
}

static void push_gvalue(const GValue *v)
{
  GType gt = G_VALUE_TYPE(v);
  switch(G_TYPE_FUNDAMENTAL(gt)) {

  case G_TYPE_CHAR:
    push_int(g_value_get_schar(v));
    break;
  case G_TYPE_UCHAR:
    push_int(g_value_get_uchar(v));
    break;

  case G_TYPE_BOOLEAN:
    push_int(g_value_get_boolean(v));
    break;

  case G_TYPE_INT:
    push_int(g_value_get_int(v));
    break;
  case G_TYPE_UINT:
    push_int(g_value_get_uint(v));
    break;
  case G_TYPE_LONG:
    push_int(g_value_get_long(v));
    break;
  case G_TYPE_ULONG:
    push_int(g_value_get_ulong(v));
    break;
  case G_TYPE_INT64:
    push_int64(g_value_get_int64(v));
    break;
  case G_TYPE_UINT64:
    push_int64(g_value_get_uint64(v));
    break;

  case G_TYPE_ENUM:
    push_int(g_value_get_enum(v));
    break;

  case G_TYPE_FLAGS:
    push_int(g_value_get_flags(v));
    break;

  case G_TYPE_FLOAT:
    push_float(g_value_get_float(v));
    break;

  case G_TYPE_DOUBLE:
    push_float(g_value_get_double(v));
    break;

  case G_TYPE_STRING:
    {
      const gchar *s = g_value_get_string(v);
      if (s == NULL)
	push_int(0);
      else {
	push_text(s);
	f_utf8_to_string(1);
      }
      break;
    }

  case G_TYPE_OBJECT:
    push_wrapped_gobject(g_value_get_object(v), NULL);
    break;

  default:
    Pike_error("Don't know how to push a gvalue type %d\n",
	       G_TYPE_FUNDAMENTAL(gt));
  }
}

static void set_gvalue_from_svalue(GValue *v, const struct svalue *s)
{
  GType gt = G_VALUE_TYPE(v);
  switch(G_TYPE_FUNDAMENTAL(gt)) {

  case G_TYPE_CHAR:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    g_value_set_schar(v, s->u.integer);
    break;
  case G_TYPE_UCHAR:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    g_value_set_uchar(v, s->u.integer);
    break;

  case G_TYPE_BOOLEAN:
    g_value_set_boolean(v, !UNSAFE_IS_ZERO(s));
    break;

  case G_TYPE_INT:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    g_value_set_int(v, s->u.integer);
    break;
  case G_TYPE_UINT:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    g_value_set_uint(v, s->u.integer);
    break;
  case G_TYPE_LONG:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    g_value_set_long(v, s->u.integer);
    break;
  case G_TYPE_ULONG:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    g_value_set_ulong(v, s->u.integer);
    break;
  case G_TYPE_INT64:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    g_value_set_int64(v, s->u.integer);
    break;
  case G_TYPE_UINT64:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    g_value_set_uint64(v, s->u.integer);
    break;

  case G_TYPE_ENUM:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    g_value_set_enum(v, s->u.integer);
    break;

  case G_TYPE_FLAGS:
    if (TYPEOF(*s) != PIKE_T_INT)
      Pike_error("int expected\n");
    g_value_set_flags(v, s->u.integer);
    break;

  case G_TYPE_FLOAT:
    if (TYPEOF(*s) == PIKE_T_INT)
      g_value_set_float(v, (gfloat)s->u.integer);
    else if (TYPEOF(*s) == PIKE_T_FLOAT)
      g_value_set_float(v, (gfloat)s->u.float_number);
    else
      Pike_error("float expected\n");
    break;

  case G_TYPE_DOUBLE:
    if (TYPEOF(*s) == PIKE_T_INT)
      g_value_set_double(v, (gdouble)s->u.integer);
    else if (TYPEOF(*s) == PIKE_T_FLOAT)
      g_value_set_double(v, (gdouble)s->u.float_number);
    else
      Pike_error("float expected\n");
    break;

  case G_TYPE_STRING:
    if (UNSAFE_IS_ZERO(s)) {
      g_value_set_string(v, NULL);
      break;
    }
    if (TYPEOF(*s) != PIKE_T_STRING)
      Pike_error("Expected string\n");
    ref_push_string(s->u.string);
    f_string_to_utf8(1);
    g_value_set_string(v, (const gchar *)STR0(Pike_sp[-1].u.string));
    pop_stack();
    break;
    
  default:
    Pike_error("Don't know how to set a gvalue type %d\n",
	       G_TYPE_FUNDAMENTAL(gt));
  }
}

static int build_one_parameter(GObjectClass *class, GParameter *p,
			       const struct svalue *name,
			       const struct svalue *value)
{
  GParamSpec *pspec;
  if (name == NULL || TYPEOF(*name) != PIKE_T_STRING)
    Pike_error("Invalid type for parameter name\n");
  ref_push_string(name->u.string);
  f_string_to_utf8(1);
  p->name = g_strdup((const gchar *)STR0(Pike_sp[-1].u.string));
  pop_stack();
  pspec = g_object_class_find_property(class, p->name);
  if (pspec == NULL)
    Pike_error("GObject %s does not support property %S\n",
	       G_OBJECT_CLASS_NAME(class), name->u.string);
  g_value_init(&p->value, G_PARAM_SPEC_VALUE_TYPE(pspec));
  set_gvalue_from_svalue(&p->value, value);
  return 1;
}

static guint build_parameters_from_mapping(GType gt, struct mapping *m,
					   guint free_space,
					   GParameter *parms)
{
  ONERROR onerror;
  INT32 e;
  struct keypair *k;
  guint count = 0;
  GObjectClass *class = g_type_class_ref(gt);
  if (class == NULL)
    Pike_error("Type class not available!\n");
  SET_ONERROR(onerror, g_type_class_unref, class);
  NEW_MAPPING_LOOP(m->data)
    if (free_space &&
	build_one_parameter(class, parms, &k->ind, &k->val)) {
      --free_space;
      count++;
      parms++;
    }
  UNSET_ONERROR(onerror);
  g_type_class_unref(class);
  return count;
}

struct gparams_list {
  guint nparam;
  GParameter *params;
};

static void low_free_gparams(struct gparams_list *gpl)
{
  guint i;
  guint nparam = gpl->nparam;
  GParameter *params = gpl->params;
  if (params) {
    for (i = 0; i < nparam; i++) {
      g_free((gchar *)params[i].name);
      if (G_VALUE_TYPE(&params[i].value) != G_TYPE_INVALID)
	g_value_unset(&params[i].value);
    }
    g_free(params);
    gpl->params = NULL;
  }
}

static GObject *make_gobject_from_props(struct object *info, struct mapping *props)
{
  ONERROR onerror;
  GIObjectInfo *ginfo;
  struct BaseInfo_struct *that;
  GType gt;
  GObject *obj;
  struct gparams_list params = { 0, NULL };
  if (info == NULL ||
      (that =
       (struct BaseInfo_struct *)get_storage (info, BaseInfo_program))
      == NULL || that->info == NULL)
    Pike_error("ObjectInfo missing\n");
  ginfo = (GIObjectInfo *)that->info;
  gt = g_registered_type_info_get_g_type((GIRegisteredTypeInfo *)ginfo);
  if (gt == G_TYPE_NONE)
    Pike_error("Failed to get GType\n");
  if (props != NULL && m_sizeof(props) > 0) {
    params.nparam = m_sizeof(props);
    params.params = g_new0(GParameter, params.nparam);
    SET_ONERROR(onerror, low_free_gparams, &params);
    params.nparam = build_parameters_from_mapping(gt, props, params.nparam,
						  params.params);
  }
  obj = g_object_newv(gt, params.nparam, params.params);
  if (obj == NULL)
    Pike_error("Failed to create GObject\n");
  if (params.params != NULL) {
    UNSET_ONERROR(onerror);
    low_free_gparams(&params);
  }
  if (G_IS_INITIALLY_UNOWNED(obj))
    g_object_ref_sink(obj);
  return obj;
}


/*! @class Repository
 */

PIKECLASS Repository
{
  CVAR GIRepository *repository;

  INIT
    {
      THIS->repository = NULL;
    }

  /*! @decl array(string) enumerate_versions(strig namespace)
   */
  PIKEFUN array(string) enumerate_versions(string namespace)
  {
    ONERROR onerror;
    int count = 0;
    GList *item, *versions =
      g_irepository_enumerate_versions(THIS->repository,
				       (gchar *)STR0(namespace));
    if (versions == NULL) {
      pop_n_elems(args);
      push_int(0);
      return;
    }
    SET_ONERROR(onerror, free_glist_full_free, versions);
    pop_n_elems(args);
    for (item = versions; item; item = item->next) {
        char *version = item->data;
	push_text(version);
	f_utf8_to_string(1);
	count++;
    }
    UNSET_ONERROR(onerror);
    free_glist_full_free(versions);
    f_aggregate(count);
  }

  /*! @decl BaseInfo find_by_name(string namespace, string name)
   */
  PIKEFUN BaseInfo find_by_name(string namespace, string name)
  {
    ONERROR onerror;
    GIBaseInfo *info =
      g_irepository_find_by_name(THIS->repository,
				 (gchar *)STR0(namespace),
				 (gchar *)STR0(name));
    if (info) {
      SET_ONERROR(onerror, g_base_info_unref, info);
      pop_n_elems(args);
      push_gi_info(info);
      UNSET_ONERROR(onerror);
      g_base_info_unref(info);
    } else {
      pop_n_elems(args);
      push_int(0);
    }
  }

  /*! @decl array(BaseInfo) get_infos(string namespace)
   */
  PIKEFUN array(BaseInfo) get_infos(string namespace)
  {
    ONERROR onerror, onerror2;
    struct array *arr;
    gssize i, num;
    num = g_irepository_get_n_infos(THIS->repository,
				    (gchar *)STR0(namespace));
    if (num < 0)
      Pike_error("Namespace '%S' not loaded\n", namespace);
    arr = allocate_array(num);
    SET_ONERROR(onerror, do_free_array, arr);
    for(i=0; i<num; i++) {
      GIBaseInfo *info;
      info = g_irepository_get_info(THIS->repository,
				    (gchar *)STR0(namespace), i);
      SET_ONERROR(onerror2, g_base_info_unref, info);
      push_gi_info(info);
      UNSET_ONERROR(onerror2);
      g_base_info_unref(info);
      array_set_index_no_free(arr, i, Pike_sp-1);
      pop_stack();
    }
    UNSET_ONERROR(onerror);
    RETURN arr;
  }
  
  /*! @decl void require(string namespace, string|void version, int(0..1)|void lazy)
   */
  PIKEFUN void require(string namespace, string|void version, int(0..1)|void lazy)
  {
    GError *error = NULL;
    GTypelib *typelib;

    typelib = g_irepository_require(THIS->repository,
				    (gchar *)STR0(namespace),
				    (version? (gchar *)STR0(version) : NULL),
				    ((lazy != NULL && !UNSAFE_IS_ZERO(lazy))? 
				     G_IREPOSITORY_LOAD_FLAG_LAZY : 0),
				    &error);

    if(error)
      throw_gerror(error);

    pop_n_elems(args);  /* Should be "RETURN;", but that is broken... */
  }
}

/*! @endclass
 */

/*! @decl Repository get_default_repository()
 */

PIKEFUN Repository get_default_repository()
{
  static struct object *default_repository = NULL;
  if (default_repository == NULL) {
    struct object *o = clone_object(Repository_program, 0);
    struct Repository_struct *that =
      (struct Repository_struct *)get_storage (o, Repository_program);
    that->repository = g_irepository_get_default();
    default_repository = o;
  }
  ref_push_object(default_repository);
}

/*! @endmodule
 */

#endif

PIKE_MODULE_INIT
{
#ifdef HAVE_GI
  g_type_init();
  object_quark = g_quark_from_static_string("PikeGI::object");
  magic_mapping = allocate_mapping(0);
  INIT
#endif
}

PIKE_MODULE_EXIT
{
#ifdef HAVE_GI
  EXIT
  if(magic_mapping) {
    free_mapping(magic_mapping);
    magic_mapping = NULL;
  }
#endif
}

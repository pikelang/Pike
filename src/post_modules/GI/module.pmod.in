#pike __REAL_VERSION__

inherit @module@ : GI;

#if constant(@module@.Repository)

class DynamicImporter {
  static Repository repository = get_default_repository();

  class IntrospectionModule {

    static string namespace;

    class Function(static FunctionInfo info)
    {
      class BoundFunction(static object obj)
      {
        static mixed `()(mixed ... args) { Function::`()(obj, @args); }
        static string _sprintf(int mode) { return Function::_sprintf(mode); }
      }

      static mixed `()(mixed ... args)
      {
        return info->invoke(@args);
      }

      static string _sprintf(int mode)
      {
        return mode == 'O' && sprintf("%O.%s",
        			      IntrospectionModule::this,
        			      info->get_name());
      }
    }

    class Object
    {
      static ObjectInfo info;
      static mapping(string:mixed) attrs = ([]);

      class Instance {
        inherit GObject;

        static string _sprintf(int mode)
        {
          return mode == 'O' && sprintf("%O()", Object::this);
        }
        
        static mixed bind(mixed value)
        {
          if (objectp(value) && object_program(value) == Function)
            return value->BoundFunction(this);
        }

        static array(string) _indices() { return Object::_indices(); }
        static array(string) _values() { return Object::_values(); }
        static mixed `[](string index) { return bind(Object::`[](index)); }
        static mixed `->(string index) { return bind(Object::`->(index)); }
      };

      static string _sprintf(int mode)
      {
        return mode == 'O' && sprintf("%O.%s",
        			      IntrospectionModule::this,
        			      info->get_name());
      }

      static void create(ObjectInfo oi)
      {
        info = oi;
        array(ObjectInfo) methods = info->get_methods();
        attrs += mkmapping(methods->get_name(), map(methods, Function));
      }

      static array(string) _indices() { return indices(attrs); }
      static array(string) _values() { return values(attrs); }
      static mixed `[](string index) { return attrs[index]; }
      static mixed `->(string index) { return attrs[index]; }
    }

    static void create(string namespace_, string|void version)
    {
      namespace = namespace_;
      repository->require(namespace, version);
    }

    static string _sprintf(int mode)
    {
      return mode == 'O' && sprintf("%O.%s", DynamicImporter::this, namespace);
    }

    static mixed wrap(BaseInfo info)
    {
      if (object_program(info) == ObjectInfo)
        return Object([object(ObjectInfo)]info);
      else if (object_program(info) == FunctionInfo)
        return Function([object(FunctionInfo)]info);
      /* FIXME */
      return info;
    }

    static mixed `[](string name)
    {
      BaseInfo info = repository->find_by_name(namespace, name);
      if (!info) return UNDEFINED;
      return wrap(info);
    }

    static array(string) _indices()
    {
      return Array.uniq(repository->get_infos(namespace)->get_name());
    }

    static array(string) _values()
    {
      return rows(this, _indices());
    }
  };

  static mapping(string:mixed) cache = ([]);

  static mixed `[](string namespace)
  {
    if (cache[namespace])
      return cache[namespace];
    if (!repository->enumerate_versions(namespace))
      return UNDEFINED;
    IntrospectionModule m = IntrospectionModule(namespace);
    if (m)
      cache[namespace] = m;
    return m;
  }

  static array(string) _indices() { return indices(cache); }
  static array(string) _values() { return values(cache); }
}

DynamicImporter repository = DynamicImporter();

#endif

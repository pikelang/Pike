/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
*/

#include "global.h"

#include "object.h"
#include "svalue.h"
#include "array.h"
#include "pike_error.h"
#include "interpret.h"
#include "stralloc.h"
#include "program.h"
#include "pike_types.h"
#include "pike_embed.h"

#include "program_id.h"

#include "module_support.h"
#include "sequence.h"
#include "circular_list.h"




/*! @module ADT
 */


DECLARATIONS

/*! @class CircularList
 *! This is an circular list implemented by an array. It has a constant time
 *! complexity for pop and push. It has a limited max size but it can be
 *! increased with the methods @[allocate()] or [set_max_size()].
 *!
 */

PIKECLASS CircularList
{

  CVAR int pos;
  CVAR struct array *a;
  CVAR int size;

#define ASSERT_INITIALIZED()	do {                 \
    if (!THIS->a) {                                  \
      Pike_error("CircularList not initialized.\n"); \
    }                                                \
  } while(0)

  //if there is more than one reference to this array copy it.

  static inline void should_copy(void)
  {
    if (THIS->a->refs > 1)
    {
      struct array *a = THIS->a;
      THIS->a = copy_array(a);
      free_array(a);
    }
  }


  //convert an index in the circular list to the index in the underlaying array
  //add the pos and take modulo of the size
  static inline int circ2array(int index)
    {
      return (index+THIS->pos)%THIS->a->size;
    }

  //convert an index in the underlaying array to the array in the circular list
  static inline int array2circ(int index)
    {
      return (index-THIS->pos)%THIS->a->size;
    }



/*! @decl mixed `[](int index)
 *! Index operator
 *!
 *! @param index
 *!   The index to get the value for, may be negative to index from the end.
 *!
 *! @returns
 *!   The value at the index @[index]
 *!
 *! @throws
 *!   An error if the index is out of range.
 */

  PIKEFUN mixed `[](int index)
    flags ID_PROTECTED;
  {
    struct svalue ind;
    ASSERT_INITIALIZED();
    FIX_AND_CHECK_INDEX(index, THIS->size, 0);
    SET_SVAL(ind, T_INT, NUMBER_NUMBER, integer, circ2array(index));
    simple_array_index_no_free(Pike_sp, THIS->a, &ind);
    Pike_sp++;
  }


/*! @decl mixed `[]=(int index, mixed value)
 *! Index assign operator.
 *! Set the value at the index @[index] to be @[value]
 *!
 *! @param index
 *!   The index to set
 *!
 *! @param value
 *!   The new value
 *!
 *! @returns
 *!   The new value at the index @[index]
 *!
 *! @throws
 *!   An error if the index is out of range.
 */

  PIKEFUN mixed `[]=(int index, mixed value, mixed|void context,
                     int|void access)
    flags ID_PROTECTED;
  {
    struct svalue ind;
    ASSERT_INITIALIZED();
    FIX_AND_CHECK_INDEX(index, THIS->size, 0);
    SET_SVAL(ind, T_INT, NUMBER_NUMBER, integer, circ2array(index));
    should_copy();
    simple_set_index(THIS->a, &ind, value);
    pop_n_elems(args);
  }


/*! @decl CircularList `+(CircularList ... coll)
 *! Addition operator
 *!
 *! Append the content of this CircularList and @@@[coll] and
 *! return the results as a new @[CircularList].
 *!
 *! @param coll
 *!   The lists to append to this list
 *!
 *! @returns
 *!   The result of the append as a new @[CircularList].
 */


  PIKEFUN object `+(object ... coll)
    flags ID_PROTECTED;
  {
    struct array *a;
    struct CircularList_struct *tmpList;
    int start=0;
    int i;
    ptrdiff_t sz = THIS->size;

    ASSERT_INITIALIZED();

    for (i=0; i < args; i++) {
      // FIXME: Ought to work on collection classes too
      if (coll[i].u.object->prog == CircularList_program)
      {
	tmpList = OBJ2_CIRCULARLIST(coll[i].u.object);
	sz += tmpList->size;
      }
      else
      {
	SIMPLE_ARG_TYPE_ERROR("`+",i+1,"ADT.CircularList");
      }
    }

    /* Allocate double the space, so that we can grow. */
    push_array(a = allocate_array_no_init(sz*2, 0));

    a->type_field = 0;

    for (i = -1; i < args; i++) {
      if (i >= 0) {
	tmpList = OBJ2_CIRCULARLIST(coll[i].u.object);
      } else {
	tmpList = THIS;
      }
      a->type_field |= tmpList->a->type_field;

      if (tmpList->pos + tmpList->size > tmpList->a->size) {
	//if the list pass the end of the array do it in two parts
	int tmp = tmpList->a->size - tmpList->pos;

	assign_svalues_no_free(ITEM(a)+start,
			       ITEM(tmpList->a) + tmpList->pos,
			       tmp,
			       tmpList->a->type_field);

	assign_svalues_no_free(ITEM(a)+(tmp+start),
			       ITEM(tmpList->a),
			       tmpList->size-tmp,
			       tmpList->a->type_field);
      } else {
	//just do it direct

	assign_svalues_no_free(ITEM(a)+start,
			       ITEM(tmpList->a) + tmpList->pos,
			       tmpList->size,
			       tmpList->a->type_field);
      }
      start += tmpList->size;
    }

    //put the added array in a CircularList and return it
    {
      struct object *o=clone_object(CircularList_program, 1);
      OBJ2_CIRCULARLIST(o)->size = sz;

      push_object(o);
    }
  }


  /*! @decl int(0..1) _equal(mixed coll)
   *!
   *! @returns
   *!   Returns @tt{true@} if the object @[coll] is a @[CircularList]
   *!   and contains the same values in the same order.
   */


  PIKEFUN int(0..1) _equal(mixed coll)
    flags ID_PROTECTED;
  {
    if (TYPEOF(*coll) == T_OBJECT &&
	coll->u.object->prog == CircularList_program)
    {
      struct CircularList_struct *list = OBJ2_CIRCULARLIST(coll->u.object);
      struct processing curr;
      INT32 e;
      INT32 a_pos = THIS->pos;
      INT32 b_pos = list->pos;
      struct array *a = THIS->a;
      struct array *b = list->a;

      if(a == b) RETURN 1;
      if(THIS->size != list->size) RETURN 0;
      if(!THIS->size) RETURN 1;

#ifdef PIKE_DEBUG
      if(d_flag > 1)
	{
	  array_check_type_field(a);
	  array_check_type_field(b);
	}
#endif

      /* This could be done much better if I KNEW that
       * the type fields didn't contain types that
       * really aren't in the array
       */
      if(!(a->type_field & b->type_field) &&
     !( (a->type_field | b->type_field) & BIT_OBJECT ))
	RETURN 0;

      curr.pointer_a = a;
      curr.pointer_b = b;
      curr.next = 0;


      for(e=0; e<THIS->size; e++)
      {
	if (a_pos >= a->size)
	{
	  a_pos=0;
	}
	if (b_pos >= b->size)
	{
	  b_pos=0;
	}
	if(!low_is_equal(ITEM(a)+a_pos, ITEM(b)+b_pos, &curr))
	  RETURN 0;
	a_pos++;
	b_pos++;
      }
      RETURN 1;
    }
    RETURN 0;
  }

  /*! @decl array _indices()
   *!
   *! @returns
   *!   The indices in this list as an array.
   */

  PIKEFUN array _indices()
    flags ID_PROTECTED;
  {
    ptrdiff_t size = THIS->size;
    struct array *a;

    a=allocate_array_no_init(size,0);
    while(--size>=0)
    {
      ITEM(a)[size].u.integer = (INT_TYPE)size;
    }
    a->type_field = BIT_INT;
    RETURN a;
  }

/*! @decl void _insert_element(int index, mixed value)
 *! Insert an element in the list at the position @[index], the value
 *! at the position @[index] and all above will have their index increased
 *! by one.
 *!
 *! @param index
 *!   The index to insert the value at.
 *!
 *! @param value
 *!   The new value.
 *!
 *! @throws
 *!   An error if the index is out of range.
 *!
 *! @note
 *!  The @[max_size] is increased by one.
 *!
 *! @seealso
 *!   @[_remove_element()]
 */

  PIKEFUN void _insert_element(int index, mixed value)
  {
    int ind;
    ASSERT_INITIALIZED();
    FIX_AND_CHECK_INDEX(index, THIS->size, 1);
    should_copy();
    ind = circ2array(index);
    THIS->a = array_insert(THIS->a, value, ind);
    THIS->size++;
    if (index && (ind <= THIS->pos)) {
      THIS->pos++;
    }
  }

/*! @decl mixed _remove_element(int index)
 *!  Remove the values at index @[index] from the list.
 *!
 *! @param index
 *!   The index to remove.
 *!
 *! @returns
 *!   The removed value.
 *!
 *! @throws
 *!   An error if the index is out of range.
 *!
 *! @note
 *!  The @[max_size] is decreased by one.
 *!
 *! @seealso
 *!   @[_insert_element()]
 */

  PIKEFUN mixed _remove_element(int index)
  {
    ASSERT_INITIALIZED();
    FIX_AND_CHECK_INDEX(index, THIS->size, 0);

    index = circ2array(index);
    push_svalue(THIS->a->item + index);
    should_copy();
    THIS->a = array_remove(THIS->a, index);
    THIS->size--;
    if (index < THIS->pos) {
      THIS->pos--;
    }
  }


/*! @decl int _search(mixed value, void|int start)
 *!   Search the list for a specific value. Return the index of the first
 *!   value that is equal to @[value]. If no value was found @expr{UNDEFINED@}
 *!   is returned instead
 *!
 *! @param value
 *!   The value to find
 *!
 *! @param start
 *!   If a start value is supplied it will start searching at the index
 *!   @[start].
 *!
 *! @returns
 *!   Returns the index of the found value or @expr{-1@}.
 *!
 *! @throws
 *!   An error if the start is out of range.
 */

  PIKEFUN int _search(mixed value, void|int start)
    flags ID_PROTECTED;
  {
    int s;
    int retval;
    if (!THIS->a) RETURN -1;
    if(start)
    {
      if (TYPEOF(*start) != PIKE_T_INT)
      {
	SIMPLE_ARG_TYPE_ERROR("_search",2,"int");
      }
      if(start->u.integer <0 || start->u.integer>=THIS->size) {
	if (THIS->a->size) {
	  Pike_error("Start %"PRINTPIKEINT"d is out of array range 0 - %d.\n",
		     start->u.integer,
		   THIS->size-1);
	} else {
	  Pike_error("Attempt to index the empty array with %"PRINTPIKEINT"d.\n",
		     start->u.integer);
	}
      }
      s = circ2array(start->u.integer);
      retval = array2circ(array_search(THIS->a, value, s));
    }
    else
    {
      retval = array2circ(array_search(THIS->a,value,0));
    }
    if (retval >= THIS->size || retval < 0)
    {
      retval = -1;
    }
    RETURN retval;

  }

/*! @decl int _sizeof()
 *!
 *! @returns
 *!   The number of elements in this list.
 */

  PIKEFUN int _sizeof()
    flags ID_PROTECTED;
  {
    RETURN THIS->size;
  }

  /*! @decl array _values()
   *!
   *! @returns
   *!   The values in this list as an array.
   */

  PIKEFUN array _values()
    flags ID_PROTECTED;
  {
    struct array *a;
    int end;
    int tmp;

    a=allocate_array_no_init(THIS->size, 0);
    if (THIS->size) {
      a->type_field = THIS->a->type_field;
      end = circ2array(THIS->size);

      if (end <= THIS->pos && THIS->size > 0)
      {
        //if the list pass the end of the array do it in two parts
        tmp = THIS->a->size - THIS->pos;

        assign_svalues_no_free(ITEM(a), ITEM(THIS->a) + THIS->pos,
                               tmp, THIS->a->type_field);

        assign_svalues_no_free(ITEM(a)+tmp, ITEM(THIS->a),
                               THIS->size-tmp, THIS->a->type_field);
      }
      else
      {
        //just do it direct

        assign_svalues_no_free(ITEM(a), ITEM(THIS->a) + THIS->pos,
                               THIS->size, THIS->a->type_field);
      }
    }
    RETURN a;
  }


  /*! @decl void add(mixed value, int(0..1)|void force)
   *!   Add a value at the front of the list
   *!
   *! @param value
   *!   The value to add.
   *!
   *! @param force
   *!   Add the value even if the list is full, in which case
   *!   the element at the back of the list will be removed.
   *!
   *! @throws
   *!   An error if the list is full and @[force] is false.
   *!
   *! @note
   *!   @[force] was not supported in Pike 8.0.1800 and earlier.
   *!
   *! @note
   *!   This is the same operation as @[push_front()].
   *!
   *! @seealso
   *!   @[push_back()], @[push_front()]
   */

  PIKEFUN void add(mixed value, int(0..1)|void force)
  {
    struct svalue ind;
    ASSERT_INITIALIZED();
    if (THIS->size == THIS->a->size)
    {
      if (!force || !force->u.integer) {
        Pike_error("The list is full, could not add value, "
                   "please allocate more space or use force.\n");
      }
      if (!THIS->a->size) return;
      THIS->size--;
    }
    should_copy();
    THIS->pos--;
    if (THIS->pos < 0)
    {
      THIS->pos=THIS->a->size-1;
    }
    SET_SVAL(ind, T_INT, NUMBER_NUMBER, integer, THIS->pos);
    simple_set_index(THIS->a, &ind, value);
    THIS->size++;
  }

  /*! @decl void allocate(int elements)
   *! Increase the maxsize of the CircularlList.
   *!
   *! @param elements
   *!       Add this number of new elements to the list.
   *!
   *! @seealso
   *!   @[set_max_size()]
   */

  PIKEFUN void allocate(int(0..) elements)
  {
    INT32 size = THIS->a->size+elements;
    INT32 endpos = THIS->a->size - THIS->pos; //distanse of pos from the end
    ASSERT_INITIALIZED();
    if (elements < 0)
    {
      Pike_error("Allocate expects a value larger than zero.\n");
    }
    if (!elements) return;
    if(THIS->a->refs <= 1 && THIS->a->malloced_size >= size)
    {
      /*       +------------+------------+------------+------------+
       * Orig: |############|............|############| over-alloc |
       *       +------------+------------+------------+------------+
       *                    ^            ^            ^            ^
       *         (pos+nelem)%a->size    pos        a->size   malloced_size
       *
       *       +------------+------------+------------+------------+
       * New:  |############|............|000000000000|############|
       *       +------------+------------+------------+------------+
       *                    ^            ^            ^            ^
       *         (pos+nelem)%a->size pos-elems       pos        a->size
       */
      THIS->a->size = size;
      THIS->a->type_field |= BIT_INT;
      if (THIS->size > 0)
      {
	memmove(ITEM(THIS->a)+(size-endpos),
		ITEM(THIS->a)+(THIS->pos),
		(endpos) * sizeof(struct svalue));
	THIS->pos = size-endpos;
      }
      while(elements) {
	SET_SVAL(ITEM(THIS->a)[THIS->pos - elements], T_INT, NUMBER_NUMBER,
		 integer, 0);
	elements--;
      }
    }
    else
    {
      /*       +------------+------------+------------+
       * Orig: |############|............|############|
       *       +------------+------------+------------+
       *                    ^            ^            ^
       *          (pos+nelem)%a->size   pos        a->size
       *
       *       +------------+------------+------------+------------+
       * New:  |############|############|............|000000000000|
       *       +------------+------------+------------+------------+
       *       ^                         ^                         ^
       *      pos                   (pos+nelem)                 a->size
       */
      struct array *a;
      a=allocate_array_no_init(size,  (THIS->a->size >> 1) + 4);
      a->type_field = THIS->a->type_field | BIT_INT;
      if (THIS->size >0)
      {
        // Copy from pos to orig_size.
	assign_svalues_no_free(ITEM(a),
			       ITEM(THIS->a)+(THIS->pos),
			       endpos,
			       THIS->a->type_field);
        // Copy from start to pos.
	assign_svalues_no_free(ITEM(a)+endpos,
			       ITEM(THIS->a),
                               THIS->pos,
			       THIS->a->type_field);
        endpos = THIS->a->size;
      } else {
        endpos = 0;
      }
      while (endpos < size) {
        SET_SVAL(ITEM(a)[endpos], T_INT, NUMBER_NUMBER, integer, 0);
        endpos++;
      }
      free_array(THIS->a);
      THIS->a=a;
      THIS->pos=0;
    }
  }

/*! @decl array cast(string type)
 *! Cast operator.
 *!
 *! @param type
 *!   Casts to this type.
 *!
 *!   Casts to the following types are supported:
 *!   @string
 *!     @value "array"
 *!       Cast the content of this list to an array.
 *!   @endstring
 *!
 *! @returns
 *!   An array with the contents of this list.
 */

  PIKEFUN array cast(string type)
    flags ID_PROTECTED;
  {
    ASSERT_INITIALIZED();
    pop_n_elems(args); /* type as at least one more reference. */
    if (type == literal_array_string)
    {
      struct array *a;
      int end;
      int tmp;

      a=allocate_array_no_init(THIS->size, 0);
      a->type_field = THIS->a->type_field;
      end = circ2array(THIS->size);

      if (end < THIS->pos)
      {
	//if the list pass the end of the array do it in two parts
	tmp = THIS->a->size - THIS->pos;

	assign_svalues_no_free(ITEM(a), ITEM(THIS->a) + THIS->pos,
			       tmp, THIS->a->type_field);

	assign_svalues_no_free(ITEM(a)+tmp, ITEM(THIS->a),
			       THIS->size-tmp, THIS->a->type_field);
      }
      else
      {
	//just do it direct

	assign_svalues_no_free(ITEM(a), ITEM(THIS->a) + THIS->pos,
			     THIS->size, THIS->a->type_field);
      }
      push_array(a);

    }
    else
      push_undefined();
  }

  /*! @decl void clear()
   *!   Clear the contents of the list.
   *!
   *! @deprecated _m_clear
   */

  PIKEFUN void clear()
  {
    if (THIS->a) {
      int oldsize;
      should_copy();
      oldsize = THIS->a->size;
      THIS->a = resize_array(THIS->a, 0);
      THIS->a = resize_array(THIS->a, oldsize);
    }
    THIS->size =0;
    THIS->pos  =0;
  }

  /*! @decl void _m_clear()
   *!   Clear the contents of the list.
   *!
   *! @seealso
   *!   @[clear()]
   */

  PIKEFUN void _m_clear()
    flags ID_PROTECTED;
  {
    if (THIS->a) {
      int oldsize;
      should_copy();
      oldsize = THIS->a->size;
      THIS->a = resize_array(THIS->a, 0);
      THIS->a = resize_array(THIS->a, oldsize);
    }
    THIS->size =0;
    THIS->pos  =0;
  }

  /*! @decl int delete_value(mixed value)
   *!   Remove the first occurrence of the value @[value] from the list.
   *!
   *! @param value
   *!   The value to remove from the list.
   *!
   *! @returns
   *!   The index of the removed element or -1 if there was no value to
   *!   remove.
   */

  PIKEFUN int delete_value(mixed value)
  {
    if (THIS->a) {
      INT32 index = array_search(THIS->a, value, THIS->pos);
      INT32 pos = array2circ(index);
      if (pos < THIS->size && index > -1)
      {
        should_copy();
        THIS->a = array_remove(THIS->a, index);
        THIS->size--;
        RETURN pos;
      }
    }
    RETURN -1;
  }

  /*! @decl int(0..1) is_empty()
   *!
   *! @returns
   *!   Returns @expr{1@} if the list is empty otherwise @expr{0@}.
   */

  PIKEFUN int(0..1) is_empty()
  {
    RETURN !(THIS->size);
  }

  /*! @decl int max_size()
   *!
   *! @returns
   *!   Returns the maximal size of this list.
   *!
   *! @seealso
   *!   @[set_max_size()]
   */

  PIKEFUN int max_size()
  {
    if (!THIS->a) RETURN 0;
    RETURN THIS->a->size;
  }

  /*! @decl int set_max_size(int(0..) new_size)
   *!
   *! @param new_size
   *!   The new size of the list.
   *!
   *! @returns
   *!   Returns the old maximal size of the list.
   *!
   *! @note
   *!   When reducing in size, elements that no
   *!   longer fit are dropped from the back.
   *!
   *! @seealso
   *!   @[allocate()], @[max_size()]
   */
  PIKEFUN int set_max_size(int(0..) new_size)
  {
    struct array *new_a;
    struct array *old_a = THIS->a;

    ASSERT_INITIALIZED();

    push_int(THIS->a->size);

    if (new_size == THIS->a->size) return;

    new_a = allocate_array_no_init(new_size, 0);
    if (!new_size) {
      /* Empty! */
      THIS->size = 0;
    } else if (!THIS->size) {
      /* Empty! */
      new_a->type_field = BIT_INT;
    } else {
      int end = THIS->size;
      int end_pos;
      if (new_size < old_a->size) {
        new_a->type_field = old_a->type_field;
        if (new_size < end) end = new_size;
      } else {
        new_a->type_field = old_a->type_field | BIT_INT;
      }

      /* Move the old contents to the new array.
       *
       * NB: We cheat by knowing that T_INT is 0,
       *     due to this we do not need to care
       *     about reference counting.
       */

      should_copy();

      end_pos = circ2array(end);
      if (end_pos <= THIS->pos) {
        /* Wrap-around. */
        memcpy(ITEM(new_a), ITEM(old_a) + THIS->pos,
               (old_a->size - THIS->pos) * sizeof(struct svalue));
        memset(ITEM(old_a) + THIS->pos, 0,
               (old_a->size - THIS->pos) * sizeof(struct svalue));
        memcpy(ITEM(new_a) + (old_a->size - THIS->pos), ITEM(old_a),
               end_pos * sizeof(struct svalue));
        memset(ITEM(old_a), 0, end_pos * sizeof(struct svalue));
      } else {
        memcpy(ITEM(new_a), ITEM(old_a) + THIS->pos,
               end * sizeof(struct svalue));
        memset(ITEM(old_a) + THIS->pos, 0, end * sizeof(struct svalue));
      }
      THIS->size = end;
    }
    THIS->pos = 0;

    free_array(THIS->a);
    THIS->a = new_a;
  }

  /*! @decl mixed peek_back()
   *!
   *! @returns
   *!    The value at the back of the list but do not remove it from the list.
   */

 PIKEFUN mixed peek_back()
  {
    struct svalue ind;
    if (THIS->size <= 0)
    {
      Pike_error("Can not peek an empty list.\n");
    }
    SET_SVAL(ind, T_INT, NUMBER_NUMBER, integer, circ2array(THIS->size-1));
    simple_array_index_no_free(Pike_sp, THIS->a, &ind);
    Pike_sp++;
  }

  /*! @decl mixed peek_front()
   *!
   *! @returns
   *!    The value at the front of the list but do not remove it from the list.
   */

  PIKEFUN mixed peek_front()
  {
    struct svalue ind;
    if (THIS->size == 0)
    {
      Pike_error("Can not peek an empty list.\n");
    }
    SET_SVAL(ind, T_INT, NUMBER_NUMBER, integer, THIS->pos);
    simple_array_index_no_free(Pike_sp, THIS->a, &ind);
    Pike_sp++;
  }

  /*! @decl mixed pop_back()
   *!
   *! Remove the value at the back of the list and return it.
   *!
   *! @returns
   *!    The value at the back of the list.
   */

  PIKEFUN mixed pop_back()
  {
    struct svalue ind;
    struct svalue zero;
    if (THIS->size <= 0)
    {
      Pike_error("Can not pop an empty list.\n");
    }

    should_copy();
    THIS->size--;
    SET_SVAL(ind, T_INT, NUMBER_NUMBER, integer, circ2array(THIS->size));
    SET_SVAL(zero, T_INT, NUMBER_NUMBER, integer, 0);
    simple_array_index_no_free(Pike_sp, THIS->a, &ind);
    simple_set_index(THIS->a, &ind, &zero);
    Pike_sp++;
  }


  /*! @decl mixed pop_front()
   *!
   *! Remove the value at the front of the list and return it.
   *!
   *! @returns
   *!    The value at the front of the list.
   */

  PIKEFUN mixed pop_front()
  {
    struct svalue ind;
    struct svalue zero;
    if (THIS->size == 0)
    {
      Pike_error("Can not pop an empty list.\n");
    }

    should_copy();
    SET_SVAL(ind, T_INT, NUMBER_NUMBER, integer, THIS->pos);
    SET_SVAL(zero, T_INT, NUMBER_NUMBER, integer, 0);
    if (++THIS->pos >= THIS->a->size)
    {
      THIS->pos = 0;
    }
    THIS->size--;
    simple_array_index_no_free(Pike_sp, THIS->a, &ind);
    simple_set_index(THIS->a, &ind, &zero);
    Pike_sp++;
  }


  /*! @decl void push_back(mixed value, int(0..1)|void force)
   *!
   *! Add a new value at the end of the list.
   *!
   *! @param value
   *!    The value to add.
   *!
   *! @param force
   *!   Add the value even if the list is full, in which case
   *!   the element at the front of the list will be removed.
   *!
   *! @throws
   *!   An error if the list is full and @[force] is false.
   *!
   *! @note
   *!   @[force] was not supported in Pike 8.0.1800 and earlier.
   *!
   *! @seealso
   *!   @[add()], @[push_front()]
   */

  PIKEFUN void push_back(mixed value, int(0..1)|void force)
  {
    struct svalue ind;
    ASSERT_INITIALIZED();
    if (THIS->size == THIS->a->size)
    {
      if (!force || !force->u.integer) {
        Pike_error("The list is full, could not add value, "
                   "please allocate more memory or use force.\n");
      }
      if (!THIS->a->size) return;
      if (++THIS->pos >= THIS->a->size) {
        THIS->pos -= THIS->a->size;
      }
      THIS->size--;
    }
    should_copy();

    SET_SVAL(ind, T_INT, NUMBER_NUMBER, integer, circ2array(THIS->size));
    THIS->size++;
    simple_set_index(THIS->a, &ind, value);
  }


  /*! @decl void push_front(mixed value, int(0..1)|void force)
   *!
   *! Add a new value at the front of the list.
   *!
   *! @param value
   *!    The value to add.
   *!
   *! @param force
   *!   Add the value even if the list is full, in which case
   *!   the element at the back of the list will be removed.
   *!
   *! @throws
   *!   An error if the list is full and @[force] is false.
   *!
   *! @note
   *!   @[force] was not supported in Pike 8.0.1800 and earlier.
   *!
   *! @note
   *!   This is the same operation as @[add()].
   *!
   *! @seealso
   *!   @[add()], @[push_back()]
   */

  PIKEFUN void push_front(mixed value, int(0..1)|void force)
  {
    struct svalue ind;
    ASSERT_INITIALIZED();
    if (THIS->size == THIS->a->size)
    {
      if (!force || !force->u.integer) {
        Pike_error("The list is full, could not add value, "
                   "please allocate more space or use force.\n");
      }
      if (!THIS->a->size) return;

      THIS->size--;
    }
    should_copy();
    THIS->pos--;
    if (THIS->pos < 0)
    {
      THIS->pos=THIS->a->size-1;
    }
    SET_SVAL(ind, T_INT, NUMBER_NUMBER, integer, THIS->pos);
    simple_set_index(THIS->a, &ind, value);
    THIS->size++;
  }


  /*! @decl void create(array|int arg)
   *!   Creates a new @[CircularList] around the array arg or a new
   *!   @[CircularList] with the maximum size of arg.
   */

  PIKEFUN void create(array|int(0..) arg)
  {
    struct array *old_a = THIS->a;
    if (TYPEOF(*arg) == T_INT)
    {
      if (arg->u.integer < 0) {
        SIMPLE_ARG_TYPE_ERROR("create", 1, "int(0..)");
      }
      THIS->a =allocate_array_no_init(arg->u.integer, 0);
      if (arg->u.integer) {
        THIS->a->type_field = BIT_INT;
      }
    }
    else if (TYPEOF(*arg) == T_ARRAY)
    {
      add_ref(THIS->a=arg->u.array);
      THIS->size=THIS->a->size;
    }
    if (old_a) {
      free_array(old_a);
    }
    pop_stack();
  }


#ifdef PIKE_NULL_IS_SPECIAL
  INIT
  {
    THIS->a=NULL;
    THIS->pos=0;
    THIS->size=0;
  }
#endif

  EXIT
    gc_trivial;
  {
    if( THIS->a )
      free_array(THIS->a);
  }



  /*! @class CircularListIterator
   *!    This is the iterator for the CircularList. It implements the
   *!    IndexIterator and the OutputIterator.
   */

  PIKECLASS CircularListIterator
  {
    CVAR int pos;
    CVAR struct CircularList_struct *list;
    CVAR struct object *obj;


  /*! @decl void create(object list, void|int start)
   *!   Creates a new iterator for the CircularList @[list]. If @[start] is
   *!   supplied it will try to position the iterator at @[start].
   *!
   */

    PIKEFUN void create(object list, void|int start)
    {

      if (list->prog != CircularList_program)
      {
        SIMPLE_ARG_TYPE_ERROR("create",1,"ADT.CircularList");
      }
      else
      {
	THIS->list = OBJ2_CIRCULARLIST(list);
	add_ref(THIS->obj = list);
	if (start) // if there was an start index supplied
	{
	  THIS->pos = start->u.integer - 1;
	  if (THIS->list->a && ((THIS->pos >= THIS->list->size)
				   || (THIS->pos < -1)))
	  {
	      Pike_error("Index %d is out of array range 0 - %d.\n",
			 THIS->pos + 1,
			 THIS->list->size);
          }
          pop_n_elems(2);
	}
	else
	{
          THIS->pos = -1;
          pop_stack();
	}
      }
    }

    /*! @decl int _iterator_index()
     *!
     *! @returns
     *!    The index at the current position.
     */

    PIKEFUN int _iterator_index()
      flags ID_PROTECTED;
    {
      if(!THIS->list ||
	 !THIS->list->a ||
	 (THIS->pos < 0) ||
	 (THIS->pos >= THIS->list->size))
      {
	push_undefined();
      }
      else
      {
      	RETURN THIS->pos;
      }
    }


    /*! @decl mixed _iterator_value()
     *!
     *! @returns
     *!    The value at the current position.
     */

    PIKEFUN mixed _iterator_value()
      flags ID_PROTECTED;
    {
      if(!THIS->list ||
	 !THIS->list->a ||
	 (THIS->pos < 0) ||
	 (THIS->pos >= THIS->list->size))
      {
	push_undefined();
      }
      else
      {
	push_svalue(THIS->list->a->item +
		    (THIS->pos+THIS->list->pos)%THIS->list->a->size);
      }
    }

    PIKEFUN int _iterator_next()
      flags ID_PROTECTED;
    {
      if (!THIS->list || !THIS->list->a) {
	push_undefined();
	return;
      }
      THIS->pos++;
      if (THIS->pos >= THIS->list->size) {
	THIS->pos = -1;
	push_undefined();
      } else {
	push_int(THIS->pos);
      }
    }

    /*! @decl CircularListIterator `+(int steps)
     *!   Move the iterator @[steps] steps forward (negative value on @[steps]
     *!   will cause the iterator to move backwards) and return the result
     *!   as a new iterator.
     *! @returns
     *!    A new iterator positioned @[steps] steps forward.
     */

    PIKEFUN object `+(int steps)
    {
      struct object *o=fast_clone_object(CircularList_CircularListIterator_program);
      struct CircularList_CircularListIterator_struct *new;
      new = OBJ2_CIRCULARLIST_CIRCULARLISTITERATOR(o);
      new[0]=*THIS;
      add_ref(THIS->obj);
      if ((steps < 0) && (new->pos < 0)) {
	new->pos = new->list->size;
      }
      new->pos+=steps;
      if (new->pos < 0)
      {
	new->pos = -1;
      }
      else if (new->pos >= new->list->size)
      {
	new->pos = -1;
      }
      RETURN o;
    }

    /*! @decl CircularListIterator `+=(int steps)
     *!   Move this iterator @[steps] steps forward (negative value on @[steps]
     *!   will cause the iterator to move backwards) and return the result.
     *!
     *! @returns
     *!    This iterator positioned @[steps] steps forward.
     */


    PIKEFUN object `+=(int steps)
    {
      if (steps < 0) {
	if (THIS->pos < 0) {
	  THIS->pos = THIS->list->size;
	}
      }
      THIS->pos+=steps;
      if (THIS->pos < 0)
      {
	THIS->pos = -1;
      }
      else if (THIS->pos >= THIS->list->size)
      {
	THIS->pos = -1;
      }

      REF_RETURN Pike_fp->current_object;
    }



    /*! @decl CircularListIterator `-(int steps)
     *!   Move the iterator @[steps] steps backwards (negative value on
     *!   @[steps] will cause the iterator to move forwards) and return
     *!   the result as a new iterator.
     *! @returns
     *!    A new iterator positioned @[steps] steps backwards.
     */

    PIKEFUN object `-(int steps)
    {
      struct object *o=fast_clone_object(CircularList_CircularListIterator_program);
      struct CircularList_CircularListIterator_struct *new;
      new = OBJ2_CIRCULARLIST_CIRCULARLISTITERATOR(o);
      new[0]=*THIS;
      add_ref(THIS->obj);
      if ((steps > 0) && (new->pos < 0)) {
	new->pos = new->list->size;
      }
      new->pos-=steps;
      if (new->pos < 0)
      {
	new->pos = -1;
      }
      else if (new->pos >= new->list->size)
      {
	new->pos = -1;
      }
      RETURN o;
    }


    /*! @decl int(0..1) has_next(void|int steps)
     *! @returns
     *!    Returns @tt{true@} if it is possible to move @[steps] steps
     *!    forwards, if @[steps] weren't supplied it check if it is
     *!    possible to move one step forward.
     */

    PIKEFUN int(0..1) has_next(void|int steps)
    {
      int pos = THIS->pos;
      if (!THIS->list || !THIS->list->size) {
	RETURN 0;
      }
      if (!steps) {
	RETURN ((pos + 1) < THIS->list->size);
      } else if (steps->u.integer < 0) {
	if (pos < 0) pos = THIS->list->size;
	RETURN ((pos + steps->u.integer) >= 0);
      } else {
	RETURN ((pos + steps->u.integer) < THIS->list->size);
      }
    }


    /*! @decl int(0..1) has_previous(void|int steps)
     *! @returns
     *!    Returns @tt{true@} if it is possible to move @[steps] steps
     *!    backwards, if @[steps] weren't supplied it check if it is
     *!    possible to move one step backward.
     */

    PIKEFUN int(0..1) has_previous(void|int steps)
    {
      int pos = THIS->pos;
      if (!THIS->list || !THIS->list->size) {
	RETURN 0;
      }
      if (!steps) {
	RETURN !!pos;
      } else if (steps->u.integer < 0) {
	RETURN ((pos - steps->u.integer) < THIS->list->size);
      } else {
	if (pos < 0) pos = THIS->list->size;
	RETURN ((pos - steps->u.integer) >= 0);
      }
    }


    /*! @decl int(0..1) _equal(mixed iter)
     *!    Compare this iterator with another iterator.
     *!
     *! @param iter
     *!    The iterator to compare with
     *! @returns
     *!    Returns @tt{true@} if both iterators iterates over the same
     *!    objects and are positioned at the same spot.
     */

    PIKEFUN int(0..1) _equal(mixed iter)
    {
      if (TYPEOF(*iter) == T_OBJECT &&
	  iter->u.object->prog == CircularList_CircularListIterator_program)
      {
	struct CircularList_CircularListIterator_struct *i =
	  OBJ2_CIRCULARLIST_CIRCULARLISTITERATOR(iter->u.object);
	RETURN (THIS->list == i->list && THIS->pos == i->pos);
      }
      else
      {
	RETURN 0;
      }
    }


    /*! @decl int(0..1) `<(mixed iter)
     *!    Less then operator
     *!
     *! @returns
     *!    Returns @tt{true@} if this iterator has a lower index
     *!    then @[iter].
     */

    PIKEFUN int(0..1) `<(mixed iter)
    {
      if (TYPEOF(*iter) == T_OBJECT &&
	  iter->u.object->prog == CircularList_CircularListIterator_program)
      {
	struct CircularList_CircularListIterator_struct *i =
	  OBJ2_CIRCULARLIST_CIRCULARLISTITERATOR(iter->u.object);
	RETURN (THIS->pos < i->pos);
      }
      else
      {
	SIMPLE_ARG_TYPE_ERROR("`<",1,"ADT.CircularList.CircularListIterator");
      }
    }


    /*! @decl int(0..1) `>(mixed iter)
     *!    Greater then operator
     *!
     *! @returns
     *!    Returns @tt{true@} if this iterator has a higher index
     *!    then @[iter].
     */


    PIKEFUN int(0..1) `>(mixed iter)
    {
      if (TYPEOF(*iter) == T_OBJECT &&
	  iter->u.object->prog == CircularList_CircularListIterator_program)
      {
	struct CircularList_CircularListIterator_struct *i =
	  OBJ2_CIRCULARLIST_CIRCULARLISTITERATOR(iter->u.object);
	RETURN (THIS->pos > i->pos);
      }
      else
      {
	SIMPLE_ARG_TYPE_ERROR("`>",1,"ADT.CircularList.CircularListIterator");
      }
    }

    /*! @decl int distance(object iter)
     *!
     *! @param iter
     *!    The iterator to measure the distance to.
     *! @returns
     *!    Returns distance between this iterator and @[iter].
     *! @throws
     *!    An error if the two iterator could not be compared.
     *!
     *! @note
     *!    This operation is only valid if both iterators are
     *!    for the same @[CircularList] object.
     */

    PIKEFUN int distance(object iter)
    {
      struct CircularList_CircularListIterator_struct *i = NULL;
      if ((iter->prog == CircularList_CircularListIterator_program) &&
	  (i = OBJ2_CIRCULARLIST_CIRCULARLISTITERATOR(iter)) &&
	  (i->list == THIS->list)) {
	RETURN (i->pos - THIS->pos);
      }
      else
      {
	SIMPLE_ARG_TYPE_ERROR("`-",1,"ADT.CircularList.CircularListIterator");
      }
    }

    /*! @decl CircularList get_collection()
     *!
     *! @returns
     *!    Returns the CircularList this iterator currently iterates over.
     */


    PIKEFUN object get_collection()
    {
      REF_RETURN THIS->obj;
    }


    /*! @decl mixed set_value(mixed val)
     *!    Set the value at the current position.
     *!
     *! @param val
     *!    The new value
     *! @returns
     *!    Returns the old value
     */


    PIKEFUN mixed set_value(mixed val)
    {
      if (THIS->list &&
	  (THIS->pos >= 0) &&
	  (THIS->pos < THIS->list->size))
      {
	struct svalue ind;
	struct svalue retval;

	//if there is someone else using the array but the list
	if (THIS->list->a->refs > 1)
	{
	  //copy it
	  free_array(THIS->list->a);
	  THIS->list->a = copy_array(THIS->list->a);
	}

	SET_SVAL(ind, T_INT, NUMBER_NUMBER, integer,
		 (THIS->pos+THIS->list->pos)%THIS->list->a->size);
	simple_array_index_no_free(&retval, THIS->list->a, &ind);
	simple_set_index(THIS->list->a, &ind, val);
	push_svalue(&retval);
      }
      else
      {
	push_undefined();
      }
    }

    INIT
    {
      THIS->pos = -1;
#ifdef PIKE_NULL_IS_SPECIAL
      THIS->list = NULL;
      THIS->obj = NULL;
#endif
    }

    EXIT
      gc_trivial;
    {
      if( THIS->obj )
        free_object(THIS->obj);
    }

  }

  //End CircularListIterator
  /*! @endclass
  */

  /*! @decl CircularListIterator _get_iterator(void|int ind)
   *!   Create and initiate a new CircularListIterator that could be used
   *!   to iterate over this list.
   *!
   *! @param ind
   *!   If an @[ind] value is supplied the iterator will be positioned at
   *!   that index.
   *!
   *! @returns
   *!   An iterator.
   */

  PIKEFUN object _get_iterator(void|int ind)
  {
    ref_push_object(Pike_fp->current_object);
    if (ind)
    {
      push_svalue(ind);
    }
    push_object(clone_object(CircularList_CircularListIterator_program,
			     args+1));
  }


  /*! @decl __deprecated__ CircularListIterator first()
   *!   Create and initiate a new CircularListIterator that could be used
   *!   to iterate over this list.
   *!
   *! @returns
   *!   An iterator positioned before the first element of the list.
   *!
   *! @deprecated _get_iterator
   *!   With the Pike 8.1 and later iterator API this is identical
   *!   to @[last()] and @[_get_iterator()].
   *!
   *! @seealso
   *!   @[_get_iterator()], @[last()]
   */

  PIKEFUN object first()
    rawtype tDeprecated(tFunc(tNone, tObj));
  {
    ref_push_object(Pike_fp->current_object);
    push_object(clone_object(CircularList_CircularListIterator_program, 1));
  }


  /*! @decl __deprecated__ CircularListIterator last()
   *!   Create and initiate a new CircularListIterator that could be used
   *!   to iterate over this list.
   *!
   *! @returns
   *!   An iterator positioned after the last element of the list.
   *!
   *! @deprecated _get_iterator
   *!   With the Pike 8.1 and later iterator API this is identical
   *!   to @[first()] and @[_get_iterator()].
   *!
   *! @seealso
   *!   @[_get_iterator()], @[first()]
   */

  PIKEFUN object last()
    rawtype tDeprecated(tFunc(tNone, tObj));
  {
    ref_push_object(Pike_fp->current_object);
    push_object(clone_object(CircularList_CircularListIterator_program, 1));
  }


}


//End of CircularList
/*! @endclass
  */

/*! @endmodule
 */


void pike_init_CircularList_module(void)
{
  INIT;
}

void pike_exit_CircularList_module(void)
{
  EXIT
}


